// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongmusicxml/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Articulations_sql sql.NullBool
var dummy_Articulations_time time.Duration
var dummy_Articulations_sort sort.Float64Slice

// ArticulationsAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model articulationsAPI
type ArticulationsAPI struct {
	gorm.Model

	models.Articulations_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	ArticulationsPointersEncoding ArticulationsPointersEncoding
}

// ArticulationsPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type ArticulationsPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field Accent is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	AccentID sql.NullInt64

	// field Strong_accent is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Strong_accentID sql.NullInt64

	// field Staccato is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	StaccatoID sql.NullInt64

	// field Tenuto is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	TenutoID sql.NullInt64

	// field Detached_legato is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Detached_legatoID sql.NullInt64

	// field Staccatissimo is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	StaccatissimoID sql.NullInt64

	// field Spiccato is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	SpiccatoID sql.NullInt64

	// field Scoop is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	ScoopID sql.NullInt64

	// field Plop is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	PlopID sql.NullInt64

	// field Doit is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	DoitID sql.NullInt64

	// field Falloff is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	FalloffID sql.NullInt64

	// field Breath_mark is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Breath_markID sql.NullInt64

	// field Caesura is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	CaesuraID sql.NullInt64

	// field Stress is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	StressID sql.NullInt64

	// field Unstress is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	UnstressID sql.NullInt64

	// field Soft_accent is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Soft_accentID sql.NullInt64
}

// ArticulationsDB describes a articulations in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model articulationsDB
type ArticulationsDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field articulationsDB.Name
	Name_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	ArticulationsPointersEncoding
}

// ArticulationsDBs arrays articulationsDBs
// swagger:response articulationsDBsResponse
type ArticulationsDBs []ArticulationsDB

// ArticulationsDBResponse provides response
// swagger:response articulationsDBResponse
type ArticulationsDBResponse struct {
	ArticulationsDB
}

// ArticulationsWOP is a Articulations without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type ArticulationsWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`
	// insertion for WOP pointer fields
}

var Articulations_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
}

type BackRepoArticulationsStruct struct {
	// stores ArticulationsDB according to their gorm ID
	Map_ArticulationsDBID_ArticulationsDB map[uint]*ArticulationsDB

	// stores ArticulationsDB ID according to Articulations address
	Map_ArticulationsPtr_ArticulationsDBID map[*models.Articulations]uint

	// stores Articulations according to their gorm ID
	Map_ArticulationsDBID_ArticulationsPtr map[uint]*models.Articulations

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoArticulations *BackRepoArticulationsStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoArticulations.stage
	return
}

func (backRepoArticulations *BackRepoArticulationsStruct) GetDB() *gorm.DB {
	return backRepoArticulations.db
}

// GetArticulationsDBFromArticulationsPtr is a handy function to access the back repo instance from the stage instance
func (backRepoArticulations *BackRepoArticulationsStruct) GetArticulationsDBFromArticulationsPtr(articulations *models.Articulations) (articulationsDB *ArticulationsDB) {
	id := backRepoArticulations.Map_ArticulationsPtr_ArticulationsDBID[articulations]
	articulationsDB = backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB[id]
	return
}

// BackRepoArticulations.CommitPhaseOne commits all staged instances of Articulations to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoArticulations *BackRepoArticulationsStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for articulations := range stage.Articulationss {
		backRepoArticulations.CommitPhaseOneInstance(articulations)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, articulations := range backRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr {
		if _, ok := stage.Articulationss[articulations]; !ok {
			backRepoArticulations.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoArticulations.CommitDeleteInstance commits deletion of Articulations to the BackRepo
func (backRepoArticulations *BackRepoArticulationsStruct) CommitDeleteInstance(id uint) (Error error) {

	articulations := backRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr[id]

	// articulations is not staged anymore, remove articulationsDB
	articulationsDB := backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB[id]
	query := backRepoArticulations.db.Unscoped().Delete(&articulationsDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoArticulations.Map_ArticulationsPtr_ArticulationsDBID, articulations)
	delete(backRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr, id)
	delete(backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB, id)

	return
}

// BackRepoArticulations.CommitPhaseOneInstance commits articulations staged instances of Articulations to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoArticulations *BackRepoArticulationsStruct) CommitPhaseOneInstance(articulations *models.Articulations) (Error error) {

	// check if the articulations is not commited yet
	if _, ok := backRepoArticulations.Map_ArticulationsPtr_ArticulationsDBID[articulations]; ok {
		return
	}

	// initiate articulations
	var articulationsDB ArticulationsDB
	articulationsDB.CopyBasicFieldsFromArticulations(articulations)

	query := backRepoArticulations.db.Create(&articulationsDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoArticulations.Map_ArticulationsPtr_ArticulationsDBID[articulations] = articulationsDB.ID
	backRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr[articulationsDB.ID] = articulations
	backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB[articulationsDB.ID] = &articulationsDB

	return
}

// BackRepoArticulations.CommitPhaseTwo commits all staged instances of Articulations to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoArticulations *BackRepoArticulationsStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, articulations := range backRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr {
		backRepoArticulations.CommitPhaseTwoInstance(backRepo, idx, articulations)
	}

	return
}

// BackRepoArticulations.CommitPhaseTwoInstance commits {{structname }} of models.Articulations to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoArticulations *BackRepoArticulationsStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, articulations *models.Articulations) (Error error) {

	// fetch matching articulationsDB
	if articulationsDB, ok := backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB[idx]; ok {

		articulationsDB.CopyBasicFieldsFromArticulations(articulations)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value articulations.Accent translates to updating the articulations.AccentID
		articulationsDB.AccentID.Valid = true // allow for a 0 value (nil association)
		if articulations.Accent != nil {
			if AccentId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[articulations.Accent]; ok {
				articulationsDB.AccentID.Int64 = int64(AccentId)
				articulationsDB.AccentID.Valid = true
			}
		} else {
			articulationsDB.AccentID.Int64 = 0
			articulationsDB.AccentID.Valid = true
		}

		// commit pointer value articulations.Strong_accent translates to updating the articulations.Strong_accentID
		articulationsDB.Strong_accentID.Valid = true // allow for a 0 value (nil association)
		if articulations.Strong_accent != nil {
			if Strong_accentId, ok := backRepo.BackRepoStrong_accent.Map_Strong_accentPtr_Strong_accentDBID[articulations.Strong_accent]; ok {
				articulationsDB.Strong_accentID.Int64 = int64(Strong_accentId)
				articulationsDB.Strong_accentID.Valid = true
			}
		} else {
			articulationsDB.Strong_accentID.Int64 = 0
			articulationsDB.Strong_accentID.Valid = true
		}

		// commit pointer value articulations.Staccato translates to updating the articulations.StaccatoID
		articulationsDB.StaccatoID.Valid = true // allow for a 0 value (nil association)
		if articulations.Staccato != nil {
			if StaccatoId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[articulations.Staccato]; ok {
				articulationsDB.StaccatoID.Int64 = int64(StaccatoId)
				articulationsDB.StaccatoID.Valid = true
			}
		} else {
			articulationsDB.StaccatoID.Int64 = 0
			articulationsDB.StaccatoID.Valid = true
		}

		// commit pointer value articulations.Tenuto translates to updating the articulations.TenutoID
		articulationsDB.TenutoID.Valid = true // allow for a 0 value (nil association)
		if articulations.Tenuto != nil {
			if TenutoId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[articulations.Tenuto]; ok {
				articulationsDB.TenutoID.Int64 = int64(TenutoId)
				articulationsDB.TenutoID.Valid = true
			}
		} else {
			articulationsDB.TenutoID.Int64 = 0
			articulationsDB.TenutoID.Valid = true
		}

		// commit pointer value articulations.Detached_legato translates to updating the articulations.Detached_legatoID
		articulationsDB.Detached_legatoID.Valid = true // allow for a 0 value (nil association)
		if articulations.Detached_legato != nil {
			if Detached_legatoId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[articulations.Detached_legato]; ok {
				articulationsDB.Detached_legatoID.Int64 = int64(Detached_legatoId)
				articulationsDB.Detached_legatoID.Valid = true
			}
		} else {
			articulationsDB.Detached_legatoID.Int64 = 0
			articulationsDB.Detached_legatoID.Valid = true
		}

		// commit pointer value articulations.Staccatissimo translates to updating the articulations.StaccatissimoID
		articulationsDB.StaccatissimoID.Valid = true // allow for a 0 value (nil association)
		if articulations.Staccatissimo != nil {
			if StaccatissimoId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[articulations.Staccatissimo]; ok {
				articulationsDB.StaccatissimoID.Int64 = int64(StaccatissimoId)
				articulationsDB.StaccatissimoID.Valid = true
			}
		} else {
			articulationsDB.StaccatissimoID.Int64 = 0
			articulationsDB.StaccatissimoID.Valid = true
		}

		// commit pointer value articulations.Spiccato translates to updating the articulations.SpiccatoID
		articulationsDB.SpiccatoID.Valid = true // allow for a 0 value (nil association)
		if articulations.Spiccato != nil {
			if SpiccatoId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[articulations.Spiccato]; ok {
				articulationsDB.SpiccatoID.Int64 = int64(SpiccatoId)
				articulationsDB.SpiccatoID.Valid = true
			}
		} else {
			articulationsDB.SpiccatoID.Int64 = 0
			articulationsDB.SpiccatoID.Valid = true
		}

		// commit pointer value articulations.Scoop translates to updating the articulations.ScoopID
		articulationsDB.ScoopID.Valid = true // allow for a 0 value (nil association)
		if articulations.Scoop != nil {
			if ScoopId, ok := backRepo.BackRepoEmpty_line.Map_Empty_linePtr_Empty_lineDBID[articulations.Scoop]; ok {
				articulationsDB.ScoopID.Int64 = int64(ScoopId)
				articulationsDB.ScoopID.Valid = true
			}
		} else {
			articulationsDB.ScoopID.Int64 = 0
			articulationsDB.ScoopID.Valid = true
		}

		// commit pointer value articulations.Plop translates to updating the articulations.PlopID
		articulationsDB.PlopID.Valid = true // allow for a 0 value (nil association)
		if articulations.Plop != nil {
			if PlopId, ok := backRepo.BackRepoEmpty_line.Map_Empty_linePtr_Empty_lineDBID[articulations.Plop]; ok {
				articulationsDB.PlopID.Int64 = int64(PlopId)
				articulationsDB.PlopID.Valid = true
			}
		} else {
			articulationsDB.PlopID.Int64 = 0
			articulationsDB.PlopID.Valid = true
		}

		// commit pointer value articulations.Doit translates to updating the articulations.DoitID
		articulationsDB.DoitID.Valid = true // allow for a 0 value (nil association)
		if articulations.Doit != nil {
			if DoitId, ok := backRepo.BackRepoEmpty_line.Map_Empty_linePtr_Empty_lineDBID[articulations.Doit]; ok {
				articulationsDB.DoitID.Int64 = int64(DoitId)
				articulationsDB.DoitID.Valid = true
			}
		} else {
			articulationsDB.DoitID.Int64 = 0
			articulationsDB.DoitID.Valid = true
		}

		// commit pointer value articulations.Falloff translates to updating the articulations.FalloffID
		articulationsDB.FalloffID.Valid = true // allow for a 0 value (nil association)
		if articulations.Falloff != nil {
			if FalloffId, ok := backRepo.BackRepoEmpty_line.Map_Empty_linePtr_Empty_lineDBID[articulations.Falloff]; ok {
				articulationsDB.FalloffID.Int64 = int64(FalloffId)
				articulationsDB.FalloffID.Valid = true
			}
		} else {
			articulationsDB.FalloffID.Int64 = 0
			articulationsDB.FalloffID.Valid = true
		}

		// commit pointer value articulations.Breath_mark translates to updating the articulations.Breath_markID
		articulationsDB.Breath_markID.Valid = true // allow for a 0 value (nil association)
		if articulations.Breath_mark != nil {
			if Breath_markId, ok := backRepo.BackRepoBreath_mark.Map_Breath_markPtr_Breath_markDBID[articulations.Breath_mark]; ok {
				articulationsDB.Breath_markID.Int64 = int64(Breath_markId)
				articulationsDB.Breath_markID.Valid = true
			}
		} else {
			articulationsDB.Breath_markID.Int64 = 0
			articulationsDB.Breath_markID.Valid = true
		}

		// commit pointer value articulations.Caesura translates to updating the articulations.CaesuraID
		articulationsDB.CaesuraID.Valid = true // allow for a 0 value (nil association)
		if articulations.Caesura != nil {
			if CaesuraId, ok := backRepo.BackRepoCaesura.Map_CaesuraPtr_CaesuraDBID[articulations.Caesura]; ok {
				articulationsDB.CaesuraID.Int64 = int64(CaesuraId)
				articulationsDB.CaesuraID.Valid = true
			}
		} else {
			articulationsDB.CaesuraID.Int64 = 0
			articulationsDB.CaesuraID.Valid = true
		}

		// commit pointer value articulations.Stress translates to updating the articulations.StressID
		articulationsDB.StressID.Valid = true // allow for a 0 value (nil association)
		if articulations.Stress != nil {
			if StressId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[articulations.Stress]; ok {
				articulationsDB.StressID.Int64 = int64(StressId)
				articulationsDB.StressID.Valid = true
			}
		} else {
			articulationsDB.StressID.Int64 = 0
			articulationsDB.StressID.Valid = true
		}

		// commit pointer value articulations.Unstress translates to updating the articulations.UnstressID
		articulationsDB.UnstressID.Valid = true // allow for a 0 value (nil association)
		if articulations.Unstress != nil {
			if UnstressId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[articulations.Unstress]; ok {
				articulationsDB.UnstressID.Int64 = int64(UnstressId)
				articulationsDB.UnstressID.Valid = true
			}
		} else {
			articulationsDB.UnstressID.Int64 = 0
			articulationsDB.UnstressID.Valid = true
		}

		// commit pointer value articulations.Soft_accent translates to updating the articulations.Soft_accentID
		articulationsDB.Soft_accentID.Valid = true // allow for a 0 value (nil association)
		if articulations.Soft_accent != nil {
			if Soft_accentId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[articulations.Soft_accent]; ok {
				articulationsDB.Soft_accentID.Int64 = int64(Soft_accentId)
				articulationsDB.Soft_accentID.Valid = true
			}
		} else {
			articulationsDB.Soft_accentID.Int64 = 0
			articulationsDB.Soft_accentID.Valid = true
		}

		query := backRepoArticulations.db.Save(&articulationsDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Articulations intance %s", articulations.Name))
		return err
	}

	return
}

// BackRepoArticulations.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoArticulations *BackRepoArticulationsStruct) CheckoutPhaseOne() (Error error) {

	articulationsDBArray := make([]ArticulationsDB, 0)
	query := backRepoArticulations.db.Find(&articulationsDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	articulationsInstancesToBeRemovedFromTheStage := make(map[*models.Articulations]any)
	for key, value := range backRepoArticulations.stage.Articulationss {
		articulationsInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, articulationsDB := range articulationsDBArray {
		backRepoArticulations.CheckoutPhaseOneInstance(&articulationsDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		articulations, ok := backRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr[articulationsDB.ID]
		if ok {
			delete(articulationsInstancesToBeRemovedFromTheStage, articulations)
		}
	}

	// remove from stage and back repo's 3 maps all articulationss that are not in the checkout
	for articulations := range articulationsInstancesToBeRemovedFromTheStage {
		articulations.Unstage(backRepoArticulations.GetStage())

		// remove instance from the back repo 3 maps
		articulationsID := backRepoArticulations.Map_ArticulationsPtr_ArticulationsDBID[articulations]
		delete(backRepoArticulations.Map_ArticulationsPtr_ArticulationsDBID, articulations)
		delete(backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB, articulationsID)
		delete(backRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr, articulationsID)
	}

	return
}

// CheckoutPhaseOneInstance takes a articulationsDB that has been found in the DB, updates the backRepo and stages the
// models version of the articulationsDB
func (backRepoArticulations *BackRepoArticulationsStruct) CheckoutPhaseOneInstance(articulationsDB *ArticulationsDB) (Error error) {

	articulations, ok := backRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr[articulationsDB.ID]
	if !ok {
		articulations = new(models.Articulations)

		backRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr[articulationsDB.ID] = articulations
		backRepoArticulations.Map_ArticulationsPtr_ArticulationsDBID[articulations] = articulationsDB.ID

		// append model store with the new element
		articulations.Name = articulationsDB.Name_Data.String
		articulations.Stage(backRepoArticulations.GetStage())
	}
	articulationsDB.CopyBasicFieldsToArticulations(articulations)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	articulations.Stage(backRepoArticulations.GetStage())

	// preserve pointer to articulationsDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_ArticulationsDBID_ArticulationsDB)[articulationsDB hold variable pointers
	articulationsDB_Data := *articulationsDB
	preservedPtrToArticulations := &articulationsDB_Data
	backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB[articulationsDB.ID] = preservedPtrToArticulations

	return
}

// BackRepoArticulations.CheckoutPhaseTwo Checkouts all staged instances of Articulations to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoArticulations *BackRepoArticulationsStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, articulationsDB := range backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB {
		backRepoArticulations.CheckoutPhaseTwoInstance(backRepo, articulationsDB)
	}
	return
}

// BackRepoArticulations.CheckoutPhaseTwoInstance Checkouts staged instances of Articulations to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoArticulations *BackRepoArticulationsStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, articulationsDB *ArticulationsDB) (Error error) {

	articulations := backRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr[articulationsDB.ID]

	articulationsDB.DecodePointers(backRepo, articulations)

	return
}

func (articulationsDB *ArticulationsDB) DecodePointers(backRepo *BackRepoStruct, articulations *models.Articulations) {

	// insertion point for checkout of pointer encoding
	// Accent field
	articulations.Accent = nil
	if articulationsDB.AccentID.Int64 != 0 {
		articulations.Accent = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(articulationsDB.AccentID.Int64)]
	}
	// Strong_accent field
	articulations.Strong_accent = nil
	if articulationsDB.Strong_accentID.Int64 != 0 {
		articulations.Strong_accent = backRepo.BackRepoStrong_accent.Map_Strong_accentDBID_Strong_accentPtr[uint(articulationsDB.Strong_accentID.Int64)]
	}
	// Staccato field
	articulations.Staccato = nil
	if articulationsDB.StaccatoID.Int64 != 0 {
		articulations.Staccato = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(articulationsDB.StaccatoID.Int64)]
	}
	// Tenuto field
	articulations.Tenuto = nil
	if articulationsDB.TenutoID.Int64 != 0 {
		articulations.Tenuto = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(articulationsDB.TenutoID.Int64)]
	}
	// Detached_legato field
	articulations.Detached_legato = nil
	if articulationsDB.Detached_legatoID.Int64 != 0 {
		articulations.Detached_legato = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(articulationsDB.Detached_legatoID.Int64)]
	}
	// Staccatissimo field
	articulations.Staccatissimo = nil
	if articulationsDB.StaccatissimoID.Int64 != 0 {
		articulations.Staccatissimo = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(articulationsDB.StaccatissimoID.Int64)]
	}
	// Spiccato field
	articulations.Spiccato = nil
	if articulationsDB.SpiccatoID.Int64 != 0 {
		articulations.Spiccato = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(articulationsDB.SpiccatoID.Int64)]
	}
	// Scoop field
	articulations.Scoop = nil
	if articulationsDB.ScoopID.Int64 != 0 {
		articulations.Scoop = backRepo.BackRepoEmpty_line.Map_Empty_lineDBID_Empty_linePtr[uint(articulationsDB.ScoopID.Int64)]
	}
	// Plop field
	articulations.Plop = nil
	if articulationsDB.PlopID.Int64 != 0 {
		articulations.Plop = backRepo.BackRepoEmpty_line.Map_Empty_lineDBID_Empty_linePtr[uint(articulationsDB.PlopID.Int64)]
	}
	// Doit field
	articulations.Doit = nil
	if articulationsDB.DoitID.Int64 != 0 {
		articulations.Doit = backRepo.BackRepoEmpty_line.Map_Empty_lineDBID_Empty_linePtr[uint(articulationsDB.DoitID.Int64)]
	}
	// Falloff field
	articulations.Falloff = nil
	if articulationsDB.FalloffID.Int64 != 0 {
		articulations.Falloff = backRepo.BackRepoEmpty_line.Map_Empty_lineDBID_Empty_linePtr[uint(articulationsDB.FalloffID.Int64)]
	}
	// Breath_mark field
	articulations.Breath_mark = nil
	if articulationsDB.Breath_markID.Int64 != 0 {
		articulations.Breath_mark = backRepo.BackRepoBreath_mark.Map_Breath_markDBID_Breath_markPtr[uint(articulationsDB.Breath_markID.Int64)]
	}
	// Caesura field
	articulations.Caesura = nil
	if articulationsDB.CaesuraID.Int64 != 0 {
		articulations.Caesura = backRepo.BackRepoCaesura.Map_CaesuraDBID_CaesuraPtr[uint(articulationsDB.CaesuraID.Int64)]
	}
	// Stress field
	articulations.Stress = nil
	if articulationsDB.StressID.Int64 != 0 {
		articulations.Stress = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(articulationsDB.StressID.Int64)]
	}
	// Unstress field
	articulations.Unstress = nil
	if articulationsDB.UnstressID.Int64 != 0 {
		articulations.Unstress = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(articulationsDB.UnstressID.Int64)]
	}
	// Soft_accent field
	articulations.Soft_accent = nil
	if articulationsDB.Soft_accentID.Int64 != 0 {
		articulations.Soft_accent = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(articulationsDB.Soft_accentID.Int64)]
	}
	return
}

// CommitArticulations allows commit of a single articulations (if already staged)
func (backRepo *BackRepoStruct) CommitArticulations(articulations *models.Articulations) {
	backRepo.BackRepoArticulations.CommitPhaseOneInstance(articulations)
	if id, ok := backRepo.BackRepoArticulations.Map_ArticulationsPtr_ArticulationsDBID[articulations]; ok {
		backRepo.BackRepoArticulations.CommitPhaseTwoInstance(backRepo, id, articulations)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitArticulations allows checkout of a single articulations (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutArticulations(articulations *models.Articulations) {
	// check if the articulations is staged
	if _, ok := backRepo.BackRepoArticulations.Map_ArticulationsPtr_ArticulationsDBID[articulations]; ok {

		if id, ok := backRepo.BackRepoArticulations.Map_ArticulationsPtr_ArticulationsDBID[articulations]; ok {
			var articulationsDB ArticulationsDB
			articulationsDB.ID = id

			if err := backRepo.BackRepoArticulations.db.First(&articulationsDB, id).Error; err != nil {
				log.Fatalln("CheckoutArticulations : Problem with getting object with id:", id)
			}
			backRepo.BackRepoArticulations.CheckoutPhaseOneInstance(&articulationsDB)
			backRepo.BackRepoArticulations.CheckoutPhaseTwoInstance(backRepo, &articulationsDB)
		}
	}
}

// CopyBasicFieldsFromArticulations
func (articulationsDB *ArticulationsDB) CopyBasicFieldsFromArticulations(articulations *models.Articulations) {
	// insertion point for fields commit

	articulationsDB.Name_Data.String = articulations.Name
	articulationsDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromArticulations_WOP
func (articulationsDB *ArticulationsDB) CopyBasicFieldsFromArticulations_WOP(articulations *models.Articulations_WOP) {
	// insertion point for fields commit

	articulationsDB.Name_Data.String = articulations.Name
	articulationsDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromArticulationsWOP
func (articulationsDB *ArticulationsDB) CopyBasicFieldsFromArticulationsWOP(articulations *ArticulationsWOP) {
	// insertion point for fields commit

	articulationsDB.Name_Data.String = articulations.Name
	articulationsDB.Name_Data.Valid = true
}

// CopyBasicFieldsToArticulations
func (articulationsDB *ArticulationsDB) CopyBasicFieldsToArticulations(articulations *models.Articulations) {
	// insertion point for checkout of basic fields (back repo to stage)
	articulations.Name = articulationsDB.Name_Data.String
}

// CopyBasicFieldsToArticulations_WOP
func (articulationsDB *ArticulationsDB) CopyBasicFieldsToArticulations_WOP(articulations *models.Articulations_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	articulations.Name = articulationsDB.Name_Data.String
}

// CopyBasicFieldsToArticulationsWOP
func (articulationsDB *ArticulationsDB) CopyBasicFieldsToArticulationsWOP(articulations *ArticulationsWOP) {
	articulations.ID = int(articulationsDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	articulations.Name = articulationsDB.Name_Data.String
}

// Backup generates a json file from a slice of all ArticulationsDB instances in the backrepo
func (backRepoArticulations *BackRepoArticulationsStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "ArticulationsDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*ArticulationsDB, 0)
	for _, articulationsDB := range backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB {
		forBackup = append(forBackup, articulationsDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json Articulations ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json Articulations file", err.Error())
	}
}

// Backup generates a json file from a slice of all ArticulationsDB instances in the backrepo
func (backRepoArticulations *BackRepoArticulationsStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*ArticulationsDB, 0)
	for _, articulationsDB := range backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB {
		forBackup = append(forBackup, articulationsDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("Articulations")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&Articulations_Fields, -1)
	for _, articulationsDB := range forBackup {

		var articulationsWOP ArticulationsWOP
		articulationsDB.CopyBasicFieldsToArticulationsWOP(&articulationsWOP)

		row := sh.AddRow()
		row.WriteStruct(&articulationsWOP, -1)
	}
}

// RestoreXL from the "Articulations" sheet all ArticulationsDB instances
func (backRepoArticulations *BackRepoArticulationsStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoArticulationsid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["Articulations"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoArticulations.rowVisitorArticulations)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoArticulations *BackRepoArticulationsStruct) rowVisitorArticulations(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var articulationsWOP ArticulationsWOP
		row.ReadStruct(&articulationsWOP)

		// add the unmarshalled struct to the stage
		articulationsDB := new(ArticulationsDB)
		articulationsDB.CopyBasicFieldsFromArticulationsWOP(&articulationsWOP)

		articulationsDB_ID_atBackupTime := articulationsDB.ID
		articulationsDB.ID = 0
		query := backRepoArticulations.db.Create(articulationsDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB[articulationsDB.ID] = articulationsDB
		BackRepoArticulationsid_atBckpTime_newID[articulationsDB_ID_atBackupTime] = articulationsDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "ArticulationsDB.json" in dirPath that stores an array
// of ArticulationsDB and stores it in the database
// the map BackRepoArticulationsid_atBckpTime_newID is updated accordingly
func (backRepoArticulations *BackRepoArticulationsStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoArticulationsid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "ArticulationsDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json Articulations file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*ArticulationsDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_ArticulationsDBID_ArticulationsDB
	for _, articulationsDB := range forRestore {

		articulationsDB_ID_atBackupTime := articulationsDB.ID
		articulationsDB.ID = 0
		query := backRepoArticulations.db.Create(articulationsDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB[articulationsDB.ID] = articulationsDB
		BackRepoArticulationsid_atBckpTime_newID[articulationsDB_ID_atBackupTime] = articulationsDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json Articulations file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Articulations>id_atBckpTime_newID
// to compute new index
func (backRepoArticulations *BackRepoArticulationsStruct) RestorePhaseTwo() {

	for _, articulationsDB := range backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB {

		// next line of code is to avert unused variable compilation error
		_ = articulationsDB

		// insertion point for reindexing pointers encoding
		// reindexing Accent field
		if articulationsDB.AccentID.Int64 != 0 {
			articulationsDB.AccentID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(articulationsDB.AccentID.Int64)])
			articulationsDB.AccentID.Valid = true
		}

		// reindexing Strong_accent field
		if articulationsDB.Strong_accentID.Int64 != 0 {
			articulationsDB.Strong_accentID.Int64 = int64(BackRepoStrong_accentid_atBckpTime_newID[uint(articulationsDB.Strong_accentID.Int64)])
			articulationsDB.Strong_accentID.Valid = true
		}

		// reindexing Staccato field
		if articulationsDB.StaccatoID.Int64 != 0 {
			articulationsDB.StaccatoID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(articulationsDB.StaccatoID.Int64)])
			articulationsDB.StaccatoID.Valid = true
		}

		// reindexing Tenuto field
		if articulationsDB.TenutoID.Int64 != 0 {
			articulationsDB.TenutoID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(articulationsDB.TenutoID.Int64)])
			articulationsDB.TenutoID.Valid = true
		}

		// reindexing Detached_legato field
		if articulationsDB.Detached_legatoID.Int64 != 0 {
			articulationsDB.Detached_legatoID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(articulationsDB.Detached_legatoID.Int64)])
			articulationsDB.Detached_legatoID.Valid = true
		}

		// reindexing Staccatissimo field
		if articulationsDB.StaccatissimoID.Int64 != 0 {
			articulationsDB.StaccatissimoID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(articulationsDB.StaccatissimoID.Int64)])
			articulationsDB.StaccatissimoID.Valid = true
		}

		// reindexing Spiccato field
		if articulationsDB.SpiccatoID.Int64 != 0 {
			articulationsDB.SpiccatoID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(articulationsDB.SpiccatoID.Int64)])
			articulationsDB.SpiccatoID.Valid = true
		}

		// reindexing Scoop field
		if articulationsDB.ScoopID.Int64 != 0 {
			articulationsDB.ScoopID.Int64 = int64(BackRepoEmpty_lineid_atBckpTime_newID[uint(articulationsDB.ScoopID.Int64)])
			articulationsDB.ScoopID.Valid = true
		}

		// reindexing Plop field
		if articulationsDB.PlopID.Int64 != 0 {
			articulationsDB.PlopID.Int64 = int64(BackRepoEmpty_lineid_atBckpTime_newID[uint(articulationsDB.PlopID.Int64)])
			articulationsDB.PlopID.Valid = true
		}

		// reindexing Doit field
		if articulationsDB.DoitID.Int64 != 0 {
			articulationsDB.DoitID.Int64 = int64(BackRepoEmpty_lineid_atBckpTime_newID[uint(articulationsDB.DoitID.Int64)])
			articulationsDB.DoitID.Valid = true
		}

		// reindexing Falloff field
		if articulationsDB.FalloffID.Int64 != 0 {
			articulationsDB.FalloffID.Int64 = int64(BackRepoEmpty_lineid_atBckpTime_newID[uint(articulationsDB.FalloffID.Int64)])
			articulationsDB.FalloffID.Valid = true
		}

		// reindexing Breath_mark field
		if articulationsDB.Breath_markID.Int64 != 0 {
			articulationsDB.Breath_markID.Int64 = int64(BackRepoBreath_markid_atBckpTime_newID[uint(articulationsDB.Breath_markID.Int64)])
			articulationsDB.Breath_markID.Valid = true
		}

		// reindexing Caesura field
		if articulationsDB.CaesuraID.Int64 != 0 {
			articulationsDB.CaesuraID.Int64 = int64(BackRepoCaesuraid_atBckpTime_newID[uint(articulationsDB.CaesuraID.Int64)])
			articulationsDB.CaesuraID.Valid = true
		}

		// reindexing Stress field
		if articulationsDB.StressID.Int64 != 0 {
			articulationsDB.StressID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(articulationsDB.StressID.Int64)])
			articulationsDB.StressID.Valid = true
		}

		// reindexing Unstress field
		if articulationsDB.UnstressID.Int64 != 0 {
			articulationsDB.UnstressID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(articulationsDB.UnstressID.Int64)])
			articulationsDB.UnstressID.Valid = true
		}

		// reindexing Soft_accent field
		if articulationsDB.Soft_accentID.Int64 != 0 {
			articulationsDB.Soft_accentID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(articulationsDB.Soft_accentID.Int64)])
			articulationsDB.Soft_accentID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoArticulations.db.Model(articulationsDB).Updates(*articulationsDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoArticulations.ResetReversePointers commits all staged instances of Articulations to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoArticulations *BackRepoArticulationsStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, articulations := range backRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr {
		backRepoArticulations.ResetReversePointersInstance(backRepo, idx, articulations)
	}

	return
}

func (backRepoArticulations *BackRepoArticulationsStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, articulations *models.Articulations) (Error error) {

	// fetch matching articulationsDB
	if articulationsDB, ok := backRepoArticulations.Map_ArticulationsDBID_ArticulationsDB[idx]; ok {
		_ = articulationsDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoArticulationsid_atBckpTime_newID map[uint]uint
