// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongmusicxml/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Percussion_sql sql.NullBool
var dummy_Percussion_time time.Duration
var dummy_Percussion_sort sort.Float64Slice

// PercussionAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model percussionAPI
type PercussionAPI struct {
	gorm.Model

	models.Percussion_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	PercussionPointersEncoding PercussionPointersEncoding
}

// PercussionPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type PercussionPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field Glass is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	GlassID sql.NullInt64

	// field Metal is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	MetalID sql.NullInt64

	// field Wood is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	WoodID sql.NullInt64

	// field Pitched is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	PitchedID sql.NullInt64

	// field Membrane is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	MembraneID sql.NullInt64

	// field Effect is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	EffectID sql.NullInt64

	// field Timpani is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	TimpaniID sql.NullInt64

	// field Beater is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	BeaterID sql.NullInt64

	// field Stick is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	StickID sql.NullInt64
}

// PercussionDB describes a percussion in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model percussionDB
type PercussionDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field percussionDB.Name
	Name_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	PercussionPointersEncoding
}

// PercussionDBs arrays percussionDBs
// swagger:response percussionDBsResponse
type PercussionDBs []PercussionDB

// PercussionDBResponse provides response
// swagger:response percussionDBResponse
type PercussionDBResponse struct {
	PercussionDB
}

// PercussionWOP is a Percussion without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type PercussionWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`
	// insertion for WOP pointer fields
}

var Percussion_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
}

type BackRepoPercussionStruct struct {
	// stores PercussionDB according to their gorm ID
	Map_PercussionDBID_PercussionDB map[uint]*PercussionDB

	// stores PercussionDB ID according to Percussion address
	Map_PercussionPtr_PercussionDBID map[*models.Percussion]uint

	// stores Percussion according to their gorm ID
	Map_PercussionDBID_PercussionPtr map[uint]*models.Percussion

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoPercussion *BackRepoPercussionStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoPercussion.stage
	return
}

func (backRepoPercussion *BackRepoPercussionStruct) GetDB() *gorm.DB {
	return backRepoPercussion.db
}

// GetPercussionDBFromPercussionPtr is a handy function to access the back repo instance from the stage instance
func (backRepoPercussion *BackRepoPercussionStruct) GetPercussionDBFromPercussionPtr(percussion *models.Percussion) (percussionDB *PercussionDB) {
	id := backRepoPercussion.Map_PercussionPtr_PercussionDBID[percussion]
	percussionDB = backRepoPercussion.Map_PercussionDBID_PercussionDB[id]
	return
}

// BackRepoPercussion.CommitPhaseOne commits all staged instances of Percussion to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoPercussion *BackRepoPercussionStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for percussion := range stage.Percussions {
		backRepoPercussion.CommitPhaseOneInstance(percussion)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, percussion := range backRepoPercussion.Map_PercussionDBID_PercussionPtr {
		if _, ok := stage.Percussions[percussion]; !ok {
			backRepoPercussion.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoPercussion.CommitDeleteInstance commits deletion of Percussion to the BackRepo
func (backRepoPercussion *BackRepoPercussionStruct) CommitDeleteInstance(id uint) (Error error) {

	percussion := backRepoPercussion.Map_PercussionDBID_PercussionPtr[id]

	// percussion is not staged anymore, remove percussionDB
	percussionDB := backRepoPercussion.Map_PercussionDBID_PercussionDB[id]
	query := backRepoPercussion.db.Unscoped().Delete(&percussionDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoPercussion.Map_PercussionPtr_PercussionDBID, percussion)
	delete(backRepoPercussion.Map_PercussionDBID_PercussionPtr, id)
	delete(backRepoPercussion.Map_PercussionDBID_PercussionDB, id)

	return
}

// BackRepoPercussion.CommitPhaseOneInstance commits percussion staged instances of Percussion to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoPercussion *BackRepoPercussionStruct) CommitPhaseOneInstance(percussion *models.Percussion) (Error error) {

	// check if the percussion is not commited yet
	if _, ok := backRepoPercussion.Map_PercussionPtr_PercussionDBID[percussion]; ok {
		return
	}

	// initiate percussion
	var percussionDB PercussionDB
	percussionDB.CopyBasicFieldsFromPercussion(percussion)

	query := backRepoPercussion.db.Create(&percussionDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoPercussion.Map_PercussionPtr_PercussionDBID[percussion] = percussionDB.ID
	backRepoPercussion.Map_PercussionDBID_PercussionPtr[percussionDB.ID] = percussion
	backRepoPercussion.Map_PercussionDBID_PercussionDB[percussionDB.ID] = &percussionDB

	return
}

// BackRepoPercussion.CommitPhaseTwo commits all staged instances of Percussion to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoPercussion *BackRepoPercussionStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, percussion := range backRepoPercussion.Map_PercussionDBID_PercussionPtr {
		backRepoPercussion.CommitPhaseTwoInstance(backRepo, idx, percussion)
	}

	return
}

// BackRepoPercussion.CommitPhaseTwoInstance commits {{structname }} of models.Percussion to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoPercussion *BackRepoPercussionStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, percussion *models.Percussion) (Error error) {

	// fetch matching percussionDB
	if percussionDB, ok := backRepoPercussion.Map_PercussionDBID_PercussionDB[idx]; ok {

		percussionDB.CopyBasicFieldsFromPercussion(percussion)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value percussion.Glass translates to updating the percussion.GlassID
		percussionDB.GlassID.Valid = true // allow for a 0 value (nil association)
		if percussion.Glass != nil {
			if GlassId, ok := backRepo.BackRepoGlass.Map_GlassPtr_GlassDBID[percussion.Glass]; ok {
				percussionDB.GlassID.Int64 = int64(GlassId)
				percussionDB.GlassID.Valid = true
			}
		} else {
			percussionDB.GlassID.Int64 = 0
			percussionDB.GlassID.Valid = true
		}

		// commit pointer value percussion.Metal translates to updating the percussion.MetalID
		percussionDB.MetalID.Valid = true // allow for a 0 value (nil association)
		if percussion.Metal != nil {
			if MetalId, ok := backRepo.BackRepoMetal.Map_MetalPtr_MetalDBID[percussion.Metal]; ok {
				percussionDB.MetalID.Int64 = int64(MetalId)
				percussionDB.MetalID.Valid = true
			}
		} else {
			percussionDB.MetalID.Int64 = 0
			percussionDB.MetalID.Valid = true
		}

		// commit pointer value percussion.Wood translates to updating the percussion.WoodID
		percussionDB.WoodID.Valid = true // allow for a 0 value (nil association)
		if percussion.Wood != nil {
			if WoodId, ok := backRepo.BackRepoWood.Map_WoodPtr_WoodDBID[percussion.Wood]; ok {
				percussionDB.WoodID.Int64 = int64(WoodId)
				percussionDB.WoodID.Valid = true
			}
		} else {
			percussionDB.WoodID.Int64 = 0
			percussionDB.WoodID.Valid = true
		}

		// commit pointer value percussion.Pitched translates to updating the percussion.PitchedID
		percussionDB.PitchedID.Valid = true // allow for a 0 value (nil association)
		if percussion.Pitched != nil {
			if PitchedId, ok := backRepo.BackRepoPitched.Map_PitchedPtr_PitchedDBID[percussion.Pitched]; ok {
				percussionDB.PitchedID.Int64 = int64(PitchedId)
				percussionDB.PitchedID.Valid = true
			}
		} else {
			percussionDB.PitchedID.Int64 = 0
			percussionDB.PitchedID.Valid = true
		}

		// commit pointer value percussion.Membrane translates to updating the percussion.MembraneID
		percussionDB.MembraneID.Valid = true // allow for a 0 value (nil association)
		if percussion.Membrane != nil {
			if MembraneId, ok := backRepo.BackRepoMembrane.Map_MembranePtr_MembraneDBID[percussion.Membrane]; ok {
				percussionDB.MembraneID.Int64 = int64(MembraneId)
				percussionDB.MembraneID.Valid = true
			}
		} else {
			percussionDB.MembraneID.Int64 = 0
			percussionDB.MembraneID.Valid = true
		}

		// commit pointer value percussion.Effect translates to updating the percussion.EffectID
		percussionDB.EffectID.Valid = true // allow for a 0 value (nil association)
		if percussion.Effect != nil {
			if EffectId, ok := backRepo.BackRepoEffect.Map_EffectPtr_EffectDBID[percussion.Effect]; ok {
				percussionDB.EffectID.Int64 = int64(EffectId)
				percussionDB.EffectID.Valid = true
			}
		} else {
			percussionDB.EffectID.Int64 = 0
			percussionDB.EffectID.Valid = true
		}

		// commit pointer value percussion.Timpani translates to updating the percussion.TimpaniID
		percussionDB.TimpaniID.Valid = true // allow for a 0 value (nil association)
		if percussion.Timpani != nil {
			if TimpaniId, ok := backRepo.BackRepoTimpani.Map_TimpaniPtr_TimpaniDBID[percussion.Timpani]; ok {
				percussionDB.TimpaniID.Int64 = int64(TimpaniId)
				percussionDB.TimpaniID.Valid = true
			}
		} else {
			percussionDB.TimpaniID.Int64 = 0
			percussionDB.TimpaniID.Valid = true
		}

		// commit pointer value percussion.Beater translates to updating the percussion.BeaterID
		percussionDB.BeaterID.Valid = true // allow for a 0 value (nil association)
		if percussion.Beater != nil {
			if BeaterId, ok := backRepo.BackRepoBeater.Map_BeaterPtr_BeaterDBID[percussion.Beater]; ok {
				percussionDB.BeaterID.Int64 = int64(BeaterId)
				percussionDB.BeaterID.Valid = true
			}
		} else {
			percussionDB.BeaterID.Int64 = 0
			percussionDB.BeaterID.Valid = true
		}

		// commit pointer value percussion.Stick translates to updating the percussion.StickID
		percussionDB.StickID.Valid = true // allow for a 0 value (nil association)
		if percussion.Stick != nil {
			if StickId, ok := backRepo.BackRepoStick.Map_StickPtr_StickDBID[percussion.Stick]; ok {
				percussionDB.StickID.Int64 = int64(StickId)
				percussionDB.StickID.Valid = true
			}
		} else {
			percussionDB.StickID.Int64 = 0
			percussionDB.StickID.Valid = true
		}

		query := backRepoPercussion.db.Save(&percussionDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Percussion intance %s", percussion.Name))
		return err
	}

	return
}

// BackRepoPercussion.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoPercussion *BackRepoPercussionStruct) CheckoutPhaseOne() (Error error) {

	percussionDBArray := make([]PercussionDB, 0)
	query := backRepoPercussion.db.Find(&percussionDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	percussionInstancesToBeRemovedFromTheStage := make(map[*models.Percussion]any)
	for key, value := range backRepoPercussion.stage.Percussions {
		percussionInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, percussionDB := range percussionDBArray {
		backRepoPercussion.CheckoutPhaseOneInstance(&percussionDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		percussion, ok := backRepoPercussion.Map_PercussionDBID_PercussionPtr[percussionDB.ID]
		if ok {
			delete(percussionInstancesToBeRemovedFromTheStage, percussion)
		}
	}

	// remove from stage and back repo's 3 maps all percussions that are not in the checkout
	for percussion := range percussionInstancesToBeRemovedFromTheStage {
		percussion.Unstage(backRepoPercussion.GetStage())

		// remove instance from the back repo 3 maps
		percussionID := backRepoPercussion.Map_PercussionPtr_PercussionDBID[percussion]
		delete(backRepoPercussion.Map_PercussionPtr_PercussionDBID, percussion)
		delete(backRepoPercussion.Map_PercussionDBID_PercussionDB, percussionID)
		delete(backRepoPercussion.Map_PercussionDBID_PercussionPtr, percussionID)
	}

	return
}

// CheckoutPhaseOneInstance takes a percussionDB that has been found in the DB, updates the backRepo and stages the
// models version of the percussionDB
func (backRepoPercussion *BackRepoPercussionStruct) CheckoutPhaseOneInstance(percussionDB *PercussionDB) (Error error) {

	percussion, ok := backRepoPercussion.Map_PercussionDBID_PercussionPtr[percussionDB.ID]
	if !ok {
		percussion = new(models.Percussion)

		backRepoPercussion.Map_PercussionDBID_PercussionPtr[percussionDB.ID] = percussion
		backRepoPercussion.Map_PercussionPtr_PercussionDBID[percussion] = percussionDB.ID

		// append model store with the new element
		percussion.Name = percussionDB.Name_Data.String
		percussion.Stage(backRepoPercussion.GetStage())
	}
	percussionDB.CopyBasicFieldsToPercussion(percussion)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	percussion.Stage(backRepoPercussion.GetStage())

	// preserve pointer to percussionDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_PercussionDBID_PercussionDB)[percussionDB hold variable pointers
	percussionDB_Data := *percussionDB
	preservedPtrToPercussion := &percussionDB_Data
	backRepoPercussion.Map_PercussionDBID_PercussionDB[percussionDB.ID] = preservedPtrToPercussion

	return
}

// BackRepoPercussion.CheckoutPhaseTwo Checkouts all staged instances of Percussion to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoPercussion *BackRepoPercussionStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, percussionDB := range backRepoPercussion.Map_PercussionDBID_PercussionDB {
		backRepoPercussion.CheckoutPhaseTwoInstance(backRepo, percussionDB)
	}
	return
}

// BackRepoPercussion.CheckoutPhaseTwoInstance Checkouts staged instances of Percussion to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoPercussion *BackRepoPercussionStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, percussionDB *PercussionDB) (Error error) {

	percussion := backRepoPercussion.Map_PercussionDBID_PercussionPtr[percussionDB.ID]

	percussionDB.DecodePointers(backRepo, percussion)

	return
}

func (percussionDB *PercussionDB) DecodePointers(backRepo *BackRepoStruct, percussion *models.Percussion) {

	// insertion point for checkout of pointer encoding
	// Glass field
	percussion.Glass = nil
	if percussionDB.GlassID.Int64 != 0 {
		percussion.Glass = backRepo.BackRepoGlass.Map_GlassDBID_GlassPtr[uint(percussionDB.GlassID.Int64)]
	}
	// Metal field
	percussion.Metal = nil
	if percussionDB.MetalID.Int64 != 0 {
		percussion.Metal = backRepo.BackRepoMetal.Map_MetalDBID_MetalPtr[uint(percussionDB.MetalID.Int64)]
	}
	// Wood field
	percussion.Wood = nil
	if percussionDB.WoodID.Int64 != 0 {
		percussion.Wood = backRepo.BackRepoWood.Map_WoodDBID_WoodPtr[uint(percussionDB.WoodID.Int64)]
	}
	// Pitched field
	percussion.Pitched = nil
	if percussionDB.PitchedID.Int64 != 0 {
		percussion.Pitched = backRepo.BackRepoPitched.Map_PitchedDBID_PitchedPtr[uint(percussionDB.PitchedID.Int64)]
	}
	// Membrane field
	percussion.Membrane = nil
	if percussionDB.MembraneID.Int64 != 0 {
		percussion.Membrane = backRepo.BackRepoMembrane.Map_MembraneDBID_MembranePtr[uint(percussionDB.MembraneID.Int64)]
	}
	// Effect field
	percussion.Effect = nil
	if percussionDB.EffectID.Int64 != 0 {
		percussion.Effect = backRepo.BackRepoEffect.Map_EffectDBID_EffectPtr[uint(percussionDB.EffectID.Int64)]
	}
	// Timpani field
	percussion.Timpani = nil
	if percussionDB.TimpaniID.Int64 != 0 {
		percussion.Timpani = backRepo.BackRepoTimpani.Map_TimpaniDBID_TimpaniPtr[uint(percussionDB.TimpaniID.Int64)]
	}
	// Beater field
	percussion.Beater = nil
	if percussionDB.BeaterID.Int64 != 0 {
		percussion.Beater = backRepo.BackRepoBeater.Map_BeaterDBID_BeaterPtr[uint(percussionDB.BeaterID.Int64)]
	}
	// Stick field
	percussion.Stick = nil
	if percussionDB.StickID.Int64 != 0 {
		percussion.Stick = backRepo.BackRepoStick.Map_StickDBID_StickPtr[uint(percussionDB.StickID.Int64)]
	}
	return
}

// CommitPercussion allows commit of a single percussion (if already staged)
func (backRepo *BackRepoStruct) CommitPercussion(percussion *models.Percussion) {
	backRepo.BackRepoPercussion.CommitPhaseOneInstance(percussion)
	if id, ok := backRepo.BackRepoPercussion.Map_PercussionPtr_PercussionDBID[percussion]; ok {
		backRepo.BackRepoPercussion.CommitPhaseTwoInstance(backRepo, id, percussion)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitPercussion allows checkout of a single percussion (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutPercussion(percussion *models.Percussion) {
	// check if the percussion is staged
	if _, ok := backRepo.BackRepoPercussion.Map_PercussionPtr_PercussionDBID[percussion]; ok {

		if id, ok := backRepo.BackRepoPercussion.Map_PercussionPtr_PercussionDBID[percussion]; ok {
			var percussionDB PercussionDB
			percussionDB.ID = id

			if err := backRepo.BackRepoPercussion.db.First(&percussionDB, id).Error; err != nil {
				log.Fatalln("CheckoutPercussion : Problem with getting object with id:", id)
			}
			backRepo.BackRepoPercussion.CheckoutPhaseOneInstance(&percussionDB)
			backRepo.BackRepoPercussion.CheckoutPhaseTwoInstance(backRepo, &percussionDB)
		}
	}
}

// CopyBasicFieldsFromPercussion
func (percussionDB *PercussionDB) CopyBasicFieldsFromPercussion(percussion *models.Percussion) {
	// insertion point for fields commit

	percussionDB.Name_Data.String = percussion.Name
	percussionDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromPercussion_WOP
func (percussionDB *PercussionDB) CopyBasicFieldsFromPercussion_WOP(percussion *models.Percussion_WOP) {
	// insertion point for fields commit

	percussionDB.Name_Data.String = percussion.Name
	percussionDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromPercussionWOP
func (percussionDB *PercussionDB) CopyBasicFieldsFromPercussionWOP(percussion *PercussionWOP) {
	// insertion point for fields commit

	percussionDB.Name_Data.String = percussion.Name
	percussionDB.Name_Data.Valid = true
}

// CopyBasicFieldsToPercussion
func (percussionDB *PercussionDB) CopyBasicFieldsToPercussion(percussion *models.Percussion) {
	// insertion point for checkout of basic fields (back repo to stage)
	percussion.Name = percussionDB.Name_Data.String
}

// CopyBasicFieldsToPercussion_WOP
func (percussionDB *PercussionDB) CopyBasicFieldsToPercussion_WOP(percussion *models.Percussion_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	percussion.Name = percussionDB.Name_Data.String
}

// CopyBasicFieldsToPercussionWOP
func (percussionDB *PercussionDB) CopyBasicFieldsToPercussionWOP(percussion *PercussionWOP) {
	percussion.ID = int(percussionDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	percussion.Name = percussionDB.Name_Data.String
}

// Backup generates a json file from a slice of all PercussionDB instances in the backrepo
func (backRepoPercussion *BackRepoPercussionStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "PercussionDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*PercussionDB, 0)
	for _, percussionDB := range backRepoPercussion.Map_PercussionDBID_PercussionDB {
		forBackup = append(forBackup, percussionDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json Percussion ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json Percussion file", err.Error())
	}
}

// Backup generates a json file from a slice of all PercussionDB instances in the backrepo
func (backRepoPercussion *BackRepoPercussionStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*PercussionDB, 0)
	for _, percussionDB := range backRepoPercussion.Map_PercussionDBID_PercussionDB {
		forBackup = append(forBackup, percussionDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("Percussion")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&Percussion_Fields, -1)
	for _, percussionDB := range forBackup {

		var percussionWOP PercussionWOP
		percussionDB.CopyBasicFieldsToPercussionWOP(&percussionWOP)

		row := sh.AddRow()
		row.WriteStruct(&percussionWOP, -1)
	}
}

// RestoreXL from the "Percussion" sheet all PercussionDB instances
func (backRepoPercussion *BackRepoPercussionStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoPercussionid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["Percussion"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoPercussion.rowVisitorPercussion)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoPercussion *BackRepoPercussionStruct) rowVisitorPercussion(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var percussionWOP PercussionWOP
		row.ReadStruct(&percussionWOP)

		// add the unmarshalled struct to the stage
		percussionDB := new(PercussionDB)
		percussionDB.CopyBasicFieldsFromPercussionWOP(&percussionWOP)

		percussionDB_ID_atBackupTime := percussionDB.ID
		percussionDB.ID = 0
		query := backRepoPercussion.db.Create(percussionDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoPercussion.Map_PercussionDBID_PercussionDB[percussionDB.ID] = percussionDB
		BackRepoPercussionid_atBckpTime_newID[percussionDB_ID_atBackupTime] = percussionDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "PercussionDB.json" in dirPath that stores an array
// of PercussionDB and stores it in the database
// the map BackRepoPercussionid_atBckpTime_newID is updated accordingly
func (backRepoPercussion *BackRepoPercussionStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoPercussionid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "PercussionDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json Percussion file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*PercussionDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_PercussionDBID_PercussionDB
	for _, percussionDB := range forRestore {

		percussionDB_ID_atBackupTime := percussionDB.ID
		percussionDB.ID = 0
		query := backRepoPercussion.db.Create(percussionDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoPercussion.Map_PercussionDBID_PercussionDB[percussionDB.ID] = percussionDB
		BackRepoPercussionid_atBckpTime_newID[percussionDB_ID_atBackupTime] = percussionDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json Percussion file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Percussion>id_atBckpTime_newID
// to compute new index
func (backRepoPercussion *BackRepoPercussionStruct) RestorePhaseTwo() {

	for _, percussionDB := range backRepoPercussion.Map_PercussionDBID_PercussionDB {

		// next line of code is to avert unused variable compilation error
		_ = percussionDB

		// insertion point for reindexing pointers encoding
		// reindexing Glass field
		if percussionDB.GlassID.Int64 != 0 {
			percussionDB.GlassID.Int64 = int64(BackRepoGlassid_atBckpTime_newID[uint(percussionDB.GlassID.Int64)])
			percussionDB.GlassID.Valid = true
		}

		// reindexing Metal field
		if percussionDB.MetalID.Int64 != 0 {
			percussionDB.MetalID.Int64 = int64(BackRepoMetalid_atBckpTime_newID[uint(percussionDB.MetalID.Int64)])
			percussionDB.MetalID.Valid = true
		}

		// reindexing Wood field
		if percussionDB.WoodID.Int64 != 0 {
			percussionDB.WoodID.Int64 = int64(BackRepoWoodid_atBckpTime_newID[uint(percussionDB.WoodID.Int64)])
			percussionDB.WoodID.Valid = true
		}

		// reindexing Pitched field
		if percussionDB.PitchedID.Int64 != 0 {
			percussionDB.PitchedID.Int64 = int64(BackRepoPitchedid_atBckpTime_newID[uint(percussionDB.PitchedID.Int64)])
			percussionDB.PitchedID.Valid = true
		}

		// reindexing Membrane field
		if percussionDB.MembraneID.Int64 != 0 {
			percussionDB.MembraneID.Int64 = int64(BackRepoMembraneid_atBckpTime_newID[uint(percussionDB.MembraneID.Int64)])
			percussionDB.MembraneID.Valid = true
		}

		// reindexing Effect field
		if percussionDB.EffectID.Int64 != 0 {
			percussionDB.EffectID.Int64 = int64(BackRepoEffectid_atBckpTime_newID[uint(percussionDB.EffectID.Int64)])
			percussionDB.EffectID.Valid = true
		}

		// reindexing Timpani field
		if percussionDB.TimpaniID.Int64 != 0 {
			percussionDB.TimpaniID.Int64 = int64(BackRepoTimpaniid_atBckpTime_newID[uint(percussionDB.TimpaniID.Int64)])
			percussionDB.TimpaniID.Valid = true
		}

		// reindexing Beater field
		if percussionDB.BeaterID.Int64 != 0 {
			percussionDB.BeaterID.Int64 = int64(BackRepoBeaterid_atBckpTime_newID[uint(percussionDB.BeaterID.Int64)])
			percussionDB.BeaterID.Valid = true
		}

		// reindexing Stick field
		if percussionDB.StickID.Int64 != 0 {
			percussionDB.StickID.Int64 = int64(BackRepoStickid_atBckpTime_newID[uint(percussionDB.StickID.Int64)])
			percussionDB.StickID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoPercussion.db.Model(percussionDB).Updates(*percussionDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoPercussion.ResetReversePointers commits all staged instances of Percussion to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoPercussion *BackRepoPercussionStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, percussion := range backRepoPercussion.Map_PercussionDBID_PercussionPtr {
		backRepoPercussion.ResetReversePointersInstance(backRepo, idx, percussion)
	}

	return
}

func (backRepoPercussion *BackRepoPercussionStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, percussion *models.Percussion) (Error error) {

	// fetch matching percussionDB
	if percussionDB, ok := backRepoPercussion.Map_PercussionDBID_PercussionDB[idx]; ok {
		_ = percussionDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoPercussionid_atBckpTime_newID map[uint]uint
