// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongmusicxml/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Direction_type_sql sql.NullBool
var dummy_Direction_type_time time.Duration
var dummy_Direction_type_sort sort.Float64Slice

// Direction_typeAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model direction_typeAPI
type Direction_typeAPI struct {
	gorm.Model

	models.Direction_type_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	Direction_typePointersEncoding Direction_typePointersEncoding
}

// Direction_typePointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type Direction_typePointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field Segno is a slice of pointers to another Struct (optional or 0..1)
	Segno IntSlice `gorm:"type:TEXT"`

	// field Coda is a slice of pointers to another Struct (optional or 0..1)
	Coda IntSlice `gorm:"type:TEXT"`

	// field Wedge is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	WedgeID sql.NullInt64

	// field Dynamics is a slice of pointers to another Struct (optional or 0..1)
	Dynamics IntSlice `gorm:"type:TEXT"`

	// field Dashes is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	DashesID sql.NullInt64

	// field Bracket is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	BracketID sql.NullInt64

	// field Pedal is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	PedalID sql.NullInt64

	// field Metronome is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	MetronomeID sql.NullInt64

	// field Octave_shift is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Octave_shiftID sql.NullInt64

	// field Harp_pedals is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Harp_pedalsID sql.NullInt64

	// field Damp is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	DampID sql.NullInt64

	// field Damp_all is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Damp_allID sql.NullInt64

	// field Eyeglasses is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	EyeglassesID sql.NullInt64

	// field String_mute is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	String_muteID sql.NullInt64

	// field Scordatura is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	ScordaturaID sql.NullInt64

	// field Image is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	ImageID sql.NullInt64

	// field Principal_voice is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Principal_voiceID sql.NullInt64

	// field Percussion is a slice of pointers to another Struct (optional or 0..1)
	Percussion IntSlice `gorm:"type:TEXT"`

	// field Accordion_registration is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Accordion_registrationID sql.NullInt64

	// field Staff_divide is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Staff_divideID sql.NullInt64
}

// Direction_typeDB describes a direction_type in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model direction_typeDB
type Direction_typeDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field direction_typeDB.Name
	Name_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	Direction_typePointersEncoding
}

// Direction_typeDBs arrays direction_typeDBs
// swagger:response direction_typeDBsResponse
type Direction_typeDBs []Direction_typeDB

// Direction_typeDBResponse provides response
// swagger:response direction_typeDBResponse
type Direction_typeDBResponse struct {
	Direction_typeDB
}

// Direction_typeWOP is a Direction_type without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type Direction_typeWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`
	// insertion for WOP pointer fields
}

var Direction_type_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
}

type BackRepoDirection_typeStruct struct {
	// stores Direction_typeDB according to their gorm ID
	Map_Direction_typeDBID_Direction_typeDB map[uint]*Direction_typeDB

	// stores Direction_typeDB ID according to Direction_type address
	Map_Direction_typePtr_Direction_typeDBID map[*models.Direction_type]uint

	// stores Direction_type according to their gorm ID
	Map_Direction_typeDBID_Direction_typePtr map[uint]*models.Direction_type

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoDirection_type *BackRepoDirection_typeStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoDirection_type.stage
	return
}

func (backRepoDirection_type *BackRepoDirection_typeStruct) GetDB() *gorm.DB {
	return backRepoDirection_type.db
}

// GetDirection_typeDBFromDirection_typePtr is a handy function to access the back repo instance from the stage instance
func (backRepoDirection_type *BackRepoDirection_typeStruct) GetDirection_typeDBFromDirection_typePtr(direction_type *models.Direction_type) (direction_typeDB *Direction_typeDB) {
	id := backRepoDirection_type.Map_Direction_typePtr_Direction_typeDBID[direction_type]
	direction_typeDB = backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB[id]
	return
}

// BackRepoDirection_type.CommitPhaseOne commits all staged instances of Direction_type to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoDirection_type *BackRepoDirection_typeStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for direction_type := range stage.Direction_types {
		backRepoDirection_type.CommitPhaseOneInstance(direction_type)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, direction_type := range backRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr {
		if _, ok := stage.Direction_types[direction_type]; !ok {
			backRepoDirection_type.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoDirection_type.CommitDeleteInstance commits deletion of Direction_type to the BackRepo
func (backRepoDirection_type *BackRepoDirection_typeStruct) CommitDeleteInstance(id uint) (Error error) {

	direction_type := backRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr[id]

	// direction_type is not staged anymore, remove direction_typeDB
	direction_typeDB := backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB[id]
	query := backRepoDirection_type.db.Unscoped().Delete(&direction_typeDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoDirection_type.Map_Direction_typePtr_Direction_typeDBID, direction_type)
	delete(backRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr, id)
	delete(backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB, id)

	return
}

// BackRepoDirection_type.CommitPhaseOneInstance commits direction_type staged instances of Direction_type to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoDirection_type *BackRepoDirection_typeStruct) CommitPhaseOneInstance(direction_type *models.Direction_type) (Error error) {

	// check if the direction_type is not commited yet
	if _, ok := backRepoDirection_type.Map_Direction_typePtr_Direction_typeDBID[direction_type]; ok {
		return
	}

	// initiate direction_type
	var direction_typeDB Direction_typeDB
	direction_typeDB.CopyBasicFieldsFromDirection_type(direction_type)

	query := backRepoDirection_type.db.Create(&direction_typeDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoDirection_type.Map_Direction_typePtr_Direction_typeDBID[direction_type] = direction_typeDB.ID
	backRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr[direction_typeDB.ID] = direction_type
	backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB[direction_typeDB.ID] = &direction_typeDB

	return
}

// BackRepoDirection_type.CommitPhaseTwo commits all staged instances of Direction_type to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDirection_type *BackRepoDirection_typeStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, direction_type := range backRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr {
		backRepoDirection_type.CommitPhaseTwoInstance(backRepo, idx, direction_type)
	}

	return
}

// BackRepoDirection_type.CommitPhaseTwoInstance commits {{structname }} of models.Direction_type to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDirection_type *BackRepoDirection_typeStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, direction_type *models.Direction_type) (Error error) {

	// fetch matching direction_typeDB
	if direction_typeDB, ok := backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB[idx]; ok {

		direction_typeDB.CopyBasicFieldsFromDirection_type(direction_type)

		// insertion point for translating pointers encodings into actual pointers
		// 1. reset
		direction_typeDB.Direction_typePointersEncoding.Segno = make([]int, 0)
		// 2. encode
		for _, segnoAssocEnd := range direction_type.Segno {
			segnoAssocEnd_DB :=
				backRepo.BackRepoSegno.GetSegnoDBFromSegnoPtr(segnoAssocEnd)
			
			// the stage might be inconsistant, meaning that the segnoAssocEnd_DB might
			// be missing from the stage. In this case, the commit operation is robust
			// An alternative would be to crash here to reveal the missing element.
			if segnoAssocEnd_DB == nil {
				continue
			}
			
			direction_typeDB.Direction_typePointersEncoding.Segno =
				append(direction_typeDB.Direction_typePointersEncoding.Segno, int(segnoAssocEnd_DB.ID))
		}

		// 1. reset
		direction_typeDB.Direction_typePointersEncoding.Coda = make([]int, 0)
		// 2. encode
		for _, codaAssocEnd := range direction_type.Coda {
			codaAssocEnd_DB :=
				backRepo.BackRepoCoda.GetCodaDBFromCodaPtr(codaAssocEnd)
			
			// the stage might be inconsistant, meaning that the codaAssocEnd_DB might
			// be missing from the stage. In this case, the commit operation is robust
			// An alternative would be to crash here to reveal the missing element.
			if codaAssocEnd_DB == nil {
				continue
			}
			
			direction_typeDB.Direction_typePointersEncoding.Coda =
				append(direction_typeDB.Direction_typePointersEncoding.Coda, int(codaAssocEnd_DB.ID))
		}

		// commit pointer value direction_type.Wedge translates to updating the direction_type.WedgeID
		direction_typeDB.WedgeID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Wedge != nil {
			if WedgeId, ok := backRepo.BackRepoWedge.Map_WedgePtr_WedgeDBID[direction_type.Wedge]; ok {
				direction_typeDB.WedgeID.Int64 = int64(WedgeId)
				direction_typeDB.WedgeID.Valid = true
			}
		} else {
			direction_typeDB.WedgeID.Int64 = 0
			direction_typeDB.WedgeID.Valid = true
		}

		// 1. reset
		direction_typeDB.Direction_typePointersEncoding.Dynamics = make([]int, 0)
		// 2. encode
		for _, dynamicsAssocEnd := range direction_type.Dynamics {
			dynamicsAssocEnd_DB :=
				backRepo.BackRepoDynamics.GetDynamicsDBFromDynamicsPtr(dynamicsAssocEnd)
			
			// the stage might be inconsistant, meaning that the dynamicsAssocEnd_DB might
			// be missing from the stage. In this case, the commit operation is robust
			// An alternative would be to crash here to reveal the missing element.
			if dynamicsAssocEnd_DB == nil {
				continue
			}
			
			direction_typeDB.Direction_typePointersEncoding.Dynamics =
				append(direction_typeDB.Direction_typePointersEncoding.Dynamics, int(dynamicsAssocEnd_DB.ID))
		}

		// commit pointer value direction_type.Dashes translates to updating the direction_type.DashesID
		direction_typeDB.DashesID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Dashes != nil {
			if DashesId, ok := backRepo.BackRepoDashes.Map_DashesPtr_DashesDBID[direction_type.Dashes]; ok {
				direction_typeDB.DashesID.Int64 = int64(DashesId)
				direction_typeDB.DashesID.Valid = true
			}
		} else {
			direction_typeDB.DashesID.Int64 = 0
			direction_typeDB.DashesID.Valid = true
		}

		// commit pointer value direction_type.Bracket translates to updating the direction_type.BracketID
		direction_typeDB.BracketID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Bracket != nil {
			if BracketId, ok := backRepo.BackRepoBracket.Map_BracketPtr_BracketDBID[direction_type.Bracket]; ok {
				direction_typeDB.BracketID.Int64 = int64(BracketId)
				direction_typeDB.BracketID.Valid = true
			}
		} else {
			direction_typeDB.BracketID.Int64 = 0
			direction_typeDB.BracketID.Valid = true
		}

		// commit pointer value direction_type.Pedal translates to updating the direction_type.PedalID
		direction_typeDB.PedalID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Pedal != nil {
			if PedalId, ok := backRepo.BackRepoPedal.Map_PedalPtr_PedalDBID[direction_type.Pedal]; ok {
				direction_typeDB.PedalID.Int64 = int64(PedalId)
				direction_typeDB.PedalID.Valid = true
			}
		} else {
			direction_typeDB.PedalID.Int64 = 0
			direction_typeDB.PedalID.Valid = true
		}

		// commit pointer value direction_type.Metronome translates to updating the direction_type.MetronomeID
		direction_typeDB.MetronomeID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Metronome != nil {
			if MetronomeId, ok := backRepo.BackRepoMetronome.Map_MetronomePtr_MetronomeDBID[direction_type.Metronome]; ok {
				direction_typeDB.MetronomeID.Int64 = int64(MetronomeId)
				direction_typeDB.MetronomeID.Valid = true
			}
		} else {
			direction_typeDB.MetronomeID.Int64 = 0
			direction_typeDB.MetronomeID.Valid = true
		}

		// commit pointer value direction_type.Octave_shift translates to updating the direction_type.Octave_shiftID
		direction_typeDB.Octave_shiftID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Octave_shift != nil {
			if Octave_shiftId, ok := backRepo.BackRepoOctave_shift.Map_Octave_shiftPtr_Octave_shiftDBID[direction_type.Octave_shift]; ok {
				direction_typeDB.Octave_shiftID.Int64 = int64(Octave_shiftId)
				direction_typeDB.Octave_shiftID.Valid = true
			}
		} else {
			direction_typeDB.Octave_shiftID.Int64 = 0
			direction_typeDB.Octave_shiftID.Valid = true
		}

		// commit pointer value direction_type.Harp_pedals translates to updating the direction_type.Harp_pedalsID
		direction_typeDB.Harp_pedalsID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Harp_pedals != nil {
			if Harp_pedalsId, ok := backRepo.BackRepoHarp_pedals.Map_Harp_pedalsPtr_Harp_pedalsDBID[direction_type.Harp_pedals]; ok {
				direction_typeDB.Harp_pedalsID.Int64 = int64(Harp_pedalsId)
				direction_typeDB.Harp_pedalsID.Valid = true
			}
		} else {
			direction_typeDB.Harp_pedalsID.Int64 = 0
			direction_typeDB.Harp_pedalsID.Valid = true
		}

		// commit pointer value direction_type.Damp translates to updating the direction_type.DampID
		direction_typeDB.DampID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Damp != nil {
			if DampId, ok := backRepo.BackRepoEmpty_print_style_align_id.Map_Empty_print_style_align_idPtr_Empty_print_style_align_idDBID[direction_type.Damp]; ok {
				direction_typeDB.DampID.Int64 = int64(DampId)
				direction_typeDB.DampID.Valid = true
			}
		} else {
			direction_typeDB.DampID.Int64 = 0
			direction_typeDB.DampID.Valid = true
		}

		// commit pointer value direction_type.Damp_all translates to updating the direction_type.Damp_allID
		direction_typeDB.Damp_allID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Damp_all != nil {
			if Damp_allId, ok := backRepo.BackRepoEmpty_print_style_align_id.Map_Empty_print_style_align_idPtr_Empty_print_style_align_idDBID[direction_type.Damp_all]; ok {
				direction_typeDB.Damp_allID.Int64 = int64(Damp_allId)
				direction_typeDB.Damp_allID.Valid = true
			}
		} else {
			direction_typeDB.Damp_allID.Int64 = 0
			direction_typeDB.Damp_allID.Valid = true
		}

		// commit pointer value direction_type.Eyeglasses translates to updating the direction_type.EyeglassesID
		direction_typeDB.EyeglassesID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Eyeglasses != nil {
			if EyeglassesId, ok := backRepo.BackRepoEmpty_print_style_align_id.Map_Empty_print_style_align_idPtr_Empty_print_style_align_idDBID[direction_type.Eyeglasses]; ok {
				direction_typeDB.EyeglassesID.Int64 = int64(EyeglassesId)
				direction_typeDB.EyeglassesID.Valid = true
			}
		} else {
			direction_typeDB.EyeglassesID.Int64 = 0
			direction_typeDB.EyeglassesID.Valid = true
		}

		// commit pointer value direction_type.String_mute translates to updating the direction_type.String_muteID
		direction_typeDB.String_muteID.Valid = true // allow for a 0 value (nil association)
		if direction_type.String_mute != nil {
			if String_muteId, ok := backRepo.BackRepoString_mute.Map_String_mutePtr_String_muteDBID[direction_type.String_mute]; ok {
				direction_typeDB.String_muteID.Int64 = int64(String_muteId)
				direction_typeDB.String_muteID.Valid = true
			}
		} else {
			direction_typeDB.String_muteID.Int64 = 0
			direction_typeDB.String_muteID.Valid = true
		}

		// commit pointer value direction_type.Scordatura translates to updating the direction_type.ScordaturaID
		direction_typeDB.ScordaturaID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Scordatura != nil {
			if ScordaturaId, ok := backRepo.BackRepoScordatura.Map_ScordaturaPtr_ScordaturaDBID[direction_type.Scordatura]; ok {
				direction_typeDB.ScordaturaID.Int64 = int64(ScordaturaId)
				direction_typeDB.ScordaturaID.Valid = true
			}
		} else {
			direction_typeDB.ScordaturaID.Int64 = 0
			direction_typeDB.ScordaturaID.Valid = true
		}

		// commit pointer value direction_type.Image translates to updating the direction_type.ImageID
		direction_typeDB.ImageID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Image != nil {
			if ImageId, ok := backRepo.BackRepoImage.Map_ImagePtr_ImageDBID[direction_type.Image]; ok {
				direction_typeDB.ImageID.Int64 = int64(ImageId)
				direction_typeDB.ImageID.Valid = true
			}
		} else {
			direction_typeDB.ImageID.Int64 = 0
			direction_typeDB.ImageID.Valid = true
		}

		// commit pointer value direction_type.Principal_voice translates to updating the direction_type.Principal_voiceID
		direction_typeDB.Principal_voiceID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Principal_voice != nil {
			if Principal_voiceId, ok := backRepo.BackRepoPrincipal_voice.Map_Principal_voicePtr_Principal_voiceDBID[direction_type.Principal_voice]; ok {
				direction_typeDB.Principal_voiceID.Int64 = int64(Principal_voiceId)
				direction_typeDB.Principal_voiceID.Valid = true
			}
		} else {
			direction_typeDB.Principal_voiceID.Int64 = 0
			direction_typeDB.Principal_voiceID.Valid = true
		}

		// 1. reset
		direction_typeDB.Direction_typePointersEncoding.Percussion = make([]int, 0)
		// 2. encode
		for _, percussionAssocEnd := range direction_type.Percussion {
			percussionAssocEnd_DB :=
				backRepo.BackRepoPercussion.GetPercussionDBFromPercussionPtr(percussionAssocEnd)
			
			// the stage might be inconsistant, meaning that the percussionAssocEnd_DB might
			// be missing from the stage. In this case, the commit operation is robust
			// An alternative would be to crash here to reveal the missing element.
			if percussionAssocEnd_DB == nil {
				continue
			}
			
			direction_typeDB.Direction_typePointersEncoding.Percussion =
				append(direction_typeDB.Direction_typePointersEncoding.Percussion, int(percussionAssocEnd_DB.ID))
		}

		// commit pointer value direction_type.Accordion_registration translates to updating the direction_type.Accordion_registrationID
		direction_typeDB.Accordion_registrationID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Accordion_registration != nil {
			if Accordion_registrationId, ok := backRepo.BackRepoAccordion_registration.Map_Accordion_registrationPtr_Accordion_registrationDBID[direction_type.Accordion_registration]; ok {
				direction_typeDB.Accordion_registrationID.Int64 = int64(Accordion_registrationId)
				direction_typeDB.Accordion_registrationID.Valid = true
			}
		} else {
			direction_typeDB.Accordion_registrationID.Int64 = 0
			direction_typeDB.Accordion_registrationID.Valid = true
		}

		// commit pointer value direction_type.Staff_divide translates to updating the direction_type.Staff_divideID
		direction_typeDB.Staff_divideID.Valid = true // allow for a 0 value (nil association)
		if direction_type.Staff_divide != nil {
			if Staff_divideId, ok := backRepo.BackRepoStaff_divide.Map_Staff_dividePtr_Staff_divideDBID[direction_type.Staff_divide]; ok {
				direction_typeDB.Staff_divideID.Int64 = int64(Staff_divideId)
				direction_typeDB.Staff_divideID.Valid = true
			}
		} else {
			direction_typeDB.Staff_divideID.Int64 = 0
			direction_typeDB.Staff_divideID.Valid = true
		}

		query := backRepoDirection_type.db.Save(&direction_typeDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Direction_type intance %s", direction_type.Name))
		return err
	}

	return
}

// BackRepoDirection_type.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoDirection_type *BackRepoDirection_typeStruct) CheckoutPhaseOne() (Error error) {

	direction_typeDBArray := make([]Direction_typeDB, 0)
	query := backRepoDirection_type.db.Find(&direction_typeDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	direction_typeInstancesToBeRemovedFromTheStage := make(map[*models.Direction_type]any)
	for key, value := range backRepoDirection_type.stage.Direction_types {
		direction_typeInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, direction_typeDB := range direction_typeDBArray {
		backRepoDirection_type.CheckoutPhaseOneInstance(&direction_typeDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		direction_type, ok := backRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr[direction_typeDB.ID]
		if ok {
			delete(direction_typeInstancesToBeRemovedFromTheStage, direction_type)
		}
	}

	// remove from stage and back repo's 3 maps all direction_types that are not in the checkout
	for direction_type := range direction_typeInstancesToBeRemovedFromTheStage {
		direction_type.Unstage(backRepoDirection_type.GetStage())

		// remove instance from the back repo 3 maps
		direction_typeID := backRepoDirection_type.Map_Direction_typePtr_Direction_typeDBID[direction_type]
		delete(backRepoDirection_type.Map_Direction_typePtr_Direction_typeDBID, direction_type)
		delete(backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB, direction_typeID)
		delete(backRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr, direction_typeID)
	}

	return
}

// CheckoutPhaseOneInstance takes a direction_typeDB that has been found in the DB, updates the backRepo and stages the
// models version of the direction_typeDB
func (backRepoDirection_type *BackRepoDirection_typeStruct) CheckoutPhaseOneInstance(direction_typeDB *Direction_typeDB) (Error error) {

	direction_type, ok := backRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr[direction_typeDB.ID]
	if !ok {
		direction_type = new(models.Direction_type)

		backRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr[direction_typeDB.ID] = direction_type
		backRepoDirection_type.Map_Direction_typePtr_Direction_typeDBID[direction_type] = direction_typeDB.ID

		// append model store with the new element
		direction_type.Name = direction_typeDB.Name_Data.String
		direction_type.Stage(backRepoDirection_type.GetStage())
	}
	direction_typeDB.CopyBasicFieldsToDirection_type(direction_type)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	direction_type.Stage(backRepoDirection_type.GetStage())

	// preserve pointer to direction_typeDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_Direction_typeDBID_Direction_typeDB)[direction_typeDB hold variable pointers
	direction_typeDB_Data := *direction_typeDB
	preservedPtrToDirection_type := &direction_typeDB_Data
	backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB[direction_typeDB.ID] = preservedPtrToDirection_type

	return
}

// BackRepoDirection_type.CheckoutPhaseTwo Checkouts all staged instances of Direction_type to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDirection_type *BackRepoDirection_typeStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, direction_typeDB := range backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB {
		backRepoDirection_type.CheckoutPhaseTwoInstance(backRepo, direction_typeDB)
	}
	return
}

// BackRepoDirection_type.CheckoutPhaseTwoInstance Checkouts staged instances of Direction_type to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDirection_type *BackRepoDirection_typeStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, direction_typeDB *Direction_typeDB) (Error error) {

	direction_type := backRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr[direction_typeDB.ID]

	direction_typeDB.DecodePointers(backRepo, direction_type)

	return
}

func (direction_typeDB *Direction_typeDB) DecodePointers(backRepo *BackRepoStruct, direction_type *models.Direction_type) {

	// insertion point for checkout of pointer encoding
	// This loop redeem direction_type.Segno in the stage from the encode in the back repo
	// It parses all SegnoDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	direction_type.Segno = direction_type.Segno[:0]
	for _, _Segnoid := range direction_typeDB.Direction_typePointersEncoding.Segno {
		direction_type.Segno = append(direction_type.Segno, backRepo.BackRepoSegno.Map_SegnoDBID_SegnoPtr[uint(_Segnoid)])
	}

	// This loop redeem direction_type.Coda in the stage from the encode in the back repo
	// It parses all CodaDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	direction_type.Coda = direction_type.Coda[:0]
	for _, _Codaid := range direction_typeDB.Direction_typePointersEncoding.Coda {
		direction_type.Coda = append(direction_type.Coda, backRepo.BackRepoCoda.Map_CodaDBID_CodaPtr[uint(_Codaid)])
	}

	// Wedge field
	direction_type.Wedge = nil
	if direction_typeDB.WedgeID.Int64 != 0 {
		direction_type.Wedge = backRepo.BackRepoWedge.Map_WedgeDBID_WedgePtr[uint(direction_typeDB.WedgeID.Int64)]
	}
	// This loop redeem direction_type.Dynamics in the stage from the encode in the back repo
	// It parses all DynamicsDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	direction_type.Dynamics = direction_type.Dynamics[:0]
	for _, _Dynamicsid := range direction_typeDB.Direction_typePointersEncoding.Dynamics {
		direction_type.Dynamics = append(direction_type.Dynamics, backRepo.BackRepoDynamics.Map_DynamicsDBID_DynamicsPtr[uint(_Dynamicsid)])
	}

	// Dashes field
	direction_type.Dashes = nil
	if direction_typeDB.DashesID.Int64 != 0 {
		direction_type.Dashes = backRepo.BackRepoDashes.Map_DashesDBID_DashesPtr[uint(direction_typeDB.DashesID.Int64)]
	}
	// Bracket field
	direction_type.Bracket = nil
	if direction_typeDB.BracketID.Int64 != 0 {
		direction_type.Bracket = backRepo.BackRepoBracket.Map_BracketDBID_BracketPtr[uint(direction_typeDB.BracketID.Int64)]
	}
	// Pedal field
	direction_type.Pedal = nil
	if direction_typeDB.PedalID.Int64 != 0 {
		direction_type.Pedal = backRepo.BackRepoPedal.Map_PedalDBID_PedalPtr[uint(direction_typeDB.PedalID.Int64)]
	}
	// Metronome field
	direction_type.Metronome = nil
	if direction_typeDB.MetronomeID.Int64 != 0 {
		direction_type.Metronome = backRepo.BackRepoMetronome.Map_MetronomeDBID_MetronomePtr[uint(direction_typeDB.MetronomeID.Int64)]
	}
	// Octave_shift field
	direction_type.Octave_shift = nil
	if direction_typeDB.Octave_shiftID.Int64 != 0 {
		direction_type.Octave_shift = backRepo.BackRepoOctave_shift.Map_Octave_shiftDBID_Octave_shiftPtr[uint(direction_typeDB.Octave_shiftID.Int64)]
	}
	// Harp_pedals field
	direction_type.Harp_pedals = nil
	if direction_typeDB.Harp_pedalsID.Int64 != 0 {
		direction_type.Harp_pedals = backRepo.BackRepoHarp_pedals.Map_Harp_pedalsDBID_Harp_pedalsPtr[uint(direction_typeDB.Harp_pedalsID.Int64)]
	}
	// Damp field
	direction_type.Damp = nil
	if direction_typeDB.DampID.Int64 != 0 {
		direction_type.Damp = backRepo.BackRepoEmpty_print_style_align_id.Map_Empty_print_style_align_idDBID_Empty_print_style_align_idPtr[uint(direction_typeDB.DampID.Int64)]
	}
	// Damp_all field
	direction_type.Damp_all = nil
	if direction_typeDB.Damp_allID.Int64 != 0 {
		direction_type.Damp_all = backRepo.BackRepoEmpty_print_style_align_id.Map_Empty_print_style_align_idDBID_Empty_print_style_align_idPtr[uint(direction_typeDB.Damp_allID.Int64)]
	}
	// Eyeglasses field
	direction_type.Eyeglasses = nil
	if direction_typeDB.EyeglassesID.Int64 != 0 {
		direction_type.Eyeglasses = backRepo.BackRepoEmpty_print_style_align_id.Map_Empty_print_style_align_idDBID_Empty_print_style_align_idPtr[uint(direction_typeDB.EyeglassesID.Int64)]
	}
	// String_mute field
	direction_type.String_mute = nil
	if direction_typeDB.String_muteID.Int64 != 0 {
		direction_type.String_mute = backRepo.BackRepoString_mute.Map_String_muteDBID_String_mutePtr[uint(direction_typeDB.String_muteID.Int64)]
	}
	// Scordatura field
	direction_type.Scordatura = nil
	if direction_typeDB.ScordaturaID.Int64 != 0 {
		direction_type.Scordatura = backRepo.BackRepoScordatura.Map_ScordaturaDBID_ScordaturaPtr[uint(direction_typeDB.ScordaturaID.Int64)]
	}
	// Image field
	direction_type.Image = nil
	if direction_typeDB.ImageID.Int64 != 0 {
		direction_type.Image = backRepo.BackRepoImage.Map_ImageDBID_ImagePtr[uint(direction_typeDB.ImageID.Int64)]
	}
	// Principal_voice field
	direction_type.Principal_voice = nil
	if direction_typeDB.Principal_voiceID.Int64 != 0 {
		direction_type.Principal_voice = backRepo.BackRepoPrincipal_voice.Map_Principal_voiceDBID_Principal_voicePtr[uint(direction_typeDB.Principal_voiceID.Int64)]
	}
	// This loop redeem direction_type.Percussion in the stage from the encode in the back repo
	// It parses all PercussionDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	direction_type.Percussion = direction_type.Percussion[:0]
	for _, _Percussionid := range direction_typeDB.Direction_typePointersEncoding.Percussion {
		direction_type.Percussion = append(direction_type.Percussion, backRepo.BackRepoPercussion.Map_PercussionDBID_PercussionPtr[uint(_Percussionid)])
	}

	// Accordion_registration field
	direction_type.Accordion_registration = nil
	if direction_typeDB.Accordion_registrationID.Int64 != 0 {
		direction_type.Accordion_registration = backRepo.BackRepoAccordion_registration.Map_Accordion_registrationDBID_Accordion_registrationPtr[uint(direction_typeDB.Accordion_registrationID.Int64)]
	}
	// Staff_divide field
	direction_type.Staff_divide = nil
	if direction_typeDB.Staff_divideID.Int64 != 0 {
		direction_type.Staff_divide = backRepo.BackRepoStaff_divide.Map_Staff_divideDBID_Staff_dividePtr[uint(direction_typeDB.Staff_divideID.Int64)]
	}
	return
}

// CommitDirection_type allows commit of a single direction_type (if already staged)
func (backRepo *BackRepoStruct) CommitDirection_type(direction_type *models.Direction_type) {
	backRepo.BackRepoDirection_type.CommitPhaseOneInstance(direction_type)
	if id, ok := backRepo.BackRepoDirection_type.Map_Direction_typePtr_Direction_typeDBID[direction_type]; ok {
		backRepo.BackRepoDirection_type.CommitPhaseTwoInstance(backRepo, id, direction_type)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitDirection_type allows checkout of a single direction_type (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutDirection_type(direction_type *models.Direction_type) {
	// check if the direction_type is staged
	if _, ok := backRepo.BackRepoDirection_type.Map_Direction_typePtr_Direction_typeDBID[direction_type]; ok {

		if id, ok := backRepo.BackRepoDirection_type.Map_Direction_typePtr_Direction_typeDBID[direction_type]; ok {
			var direction_typeDB Direction_typeDB
			direction_typeDB.ID = id

			if err := backRepo.BackRepoDirection_type.db.First(&direction_typeDB, id).Error; err != nil {
				log.Fatalln("CheckoutDirection_type : Problem with getting object with id:", id)
			}
			backRepo.BackRepoDirection_type.CheckoutPhaseOneInstance(&direction_typeDB)
			backRepo.BackRepoDirection_type.CheckoutPhaseTwoInstance(backRepo, &direction_typeDB)
		}
	}
}

// CopyBasicFieldsFromDirection_type
func (direction_typeDB *Direction_typeDB) CopyBasicFieldsFromDirection_type(direction_type *models.Direction_type) {
	// insertion point for fields commit

	direction_typeDB.Name_Data.String = direction_type.Name
	direction_typeDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromDirection_type_WOP
func (direction_typeDB *Direction_typeDB) CopyBasicFieldsFromDirection_type_WOP(direction_type *models.Direction_type_WOP) {
	// insertion point for fields commit

	direction_typeDB.Name_Data.String = direction_type.Name
	direction_typeDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromDirection_typeWOP
func (direction_typeDB *Direction_typeDB) CopyBasicFieldsFromDirection_typeWOP(direction_type *Direction_typeWOP) {
	// insertion point for fields commit

	direction_typeDB.Name_Data.String = direction_type.Name
	direction_typeDB.Name_Data.Valid = true
}

// CopyBasicFieldsToDirection_type
func (direction_typeDB *Direction_typeDB) CopyBasicFieldsToDirection_type(direction_type *models.Direction_type) {
	// insertion point for checkout of basic fields (back repo to stage)
	direction_type.Name = direction_typeDB.Name_Data.String
}

// CopyBasicFieldsToDirection_type_WOP
func (direction_typeDB *Direction_typeDB) CopyBasicFieldsToDirection_type_WOP(direction_type *models.Direction_type_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	direction_type.Name = direction_typeDB.Name_Data.String
}

// CopyBasicFieldsToDirection_typeWOP
func (direction_typeDB *Direction_typeDB) CopyBasicFieldsToDirection_typeWOP(direction_type *Direction_typeWOP) {
	direction_type.ID = int(direction_typeDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	direction_type.Name = direction_typeDB.Name_Data.String
}

// Backup generates a json file from a slice of all Direction_typeDB instances in the backrepo
func (backRepoDirection_type *BackRepoDirection_typeStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "Direction_typeDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*Direction_typeDB, 0)
	for _, direction_typeDB := range backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB {
		forBackup = append(forBackup, direction_typeDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json Direction_type ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json Direction_type file", err.Error())
	}
}

// Backup generates a json file from a slice of all Direction_typeDB instances in the backrepo
func (backRepoDirection_type *BackRepoDirection_typeStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*Direction_typeDB, 0)
	for _, direction_typeDB := range backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB {
		forBackup = append(forBackup, direction_typeDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("Direction_type")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&Direction_type_Fields, -1)
	for _, direction_typeDB := range forBackup {

		var direction_typeWOP Direction_typeWOP
		direction_typeDB.CopyBasicFieldsToDirection_typeWOP(&direction_typeWOP)

		row := sh.AddRow()
		row.WriteStruct(&direction_typeWOP, -1)
	}
}

// RestoreXL from the "Direction_type" sheet all Direction_typeDB instances
func (backRepoDirection_type *BackRepoDirection_typeStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoDirection_typeid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["Direction_type"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoDirection_type.rowVisitorDirection_type)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoDirection_type *BackRepoDirection_typeStruct) rowVisitorDirection_type(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var direction_typeWOP Direction_typeWOP
		row.ReadStruct(&direction_typeWOP)

		// add the unmarshalled struct to the stage
		direction_typeDB := new(Direction_typeDB)
		direction_typeDB.CopyBasicFieldsFromDirection_typeWOP(&direction_typeWOP)

		direction_typeDB_ID_atBackupTime := direction_typeDB.ID
		direction_typeDB.ID = 0
		query := backRepoDirection_type.db.Create(direction_typeDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB[direction_typeDB.ID] = direction_typeDB
		BackRepoDirection_typeid_atBckpTime_newID[direction_typeDB_ID_atBackupTime] = direction_typeDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "Direction_typeDB.json" in dirPath that stores an array
// of Direction_typeDB and stores it in the database
// the map BackRepoDirection_typeid_atBckpTime_newID is updated accordingly
func (backRepoDirection_type *BackRepoDirection_typeStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoDirection_typeid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "Direction_typeDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json Direction_type file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*Direction_typeDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_Direction_typeDBID_Direction_typeDB
	for _, direction_typeDB := range forRestore {

		direction_typeDB_ID_atBackupTime := direction_typeDB.ID
		direction_typeDB.ID = 0
		query := backRepoDirection_type.db.Create(direction_typeDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB[direction_typeDB.ID] = direction_typeDB
		BackRepoDirection_typeid_atBckpTime_newID[direction_typeDB_ID_atBackupTime] = direction_typeDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json Direction_type file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Direction_type>id_atBckpTime_newID
// to compute new index
func (backRepoDirection_type *BackRepoDirection_typeStruct) RestorePhaseTwo() {

	for _, direction_typeDB := range backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB {

		// next line of code is to avert unused variable compilation error
		_ = direction_typeDB

		// insertion point for reindexing pointers encoding
		// reindexing Wedge field
		if direction_typeDB.WedgeID.Int64 != 0 {
			direction_typeDB.WedgeID.Int64 = int64(BackRepoWedgeid_atBckpTime_newID[uint(direction_typeDB.WedgeID.Int64)])
			direction_typeDB.WedgeID.Valid = true
		}

		// reindexing Dashes field
		if direction_typeDB.DashesID.Int64 != 0 {
			direction_typeDB.DashesID.Int64 = int64(BackRepoDashesid_atBckpTime_newID[uint(direction_typeDB.DashesID.Int64)])
			direction_typeDB.DashesID.Valid = true
		}

		// reindexing Bracket field
		if direction_typeDB.BracketID.Int64 != 0 {
			direction_typeDB.BracketID.Int64 = int64(BackRepoBracketid_atBckpTime_newID[uint(direction_typeDB.BracketID.Int64)])
			direction_typeDB.BracketID.Valid = true
		}

		// reindexing Pedal field
		if direction_typeDB.PedalID.Int64 != 0 {
			direction_typeDB.PedalID.Int64 = int64(BackRepoPedalid_atBckpTime_newID[uint(direction_typeDB.PedalID.Int64)])
			direction_typeDB.PedalID.Valid = true
		}

		// reindexing Metronome field
		if direction_typeDB.MetronomeID.Int64 != 0 {
			direction_typeDB.MetronomeID.Int64 = int64(BackRepoMetronomeid_atBckpTime_newID[uint(direction_typeDB.MetronomeID.Int64)])
			direction_typeDB.MetronomeID.Valid = true
		}

		// reindexing Octave_shift field
		if direction_typeDB.Octave_shiftID.Int64 != 0 {
			direction_typeDB.Octave_shiftID.Int64 = int64(BackRepoOctave_shiftid_atBckpTime_newID[uint(direction_typeDB.Octave_shiftID.Int64)])
			direction_typeDB.Octave_shiftID.Valid = true
		}

		// reindexing Harp_pedals field
		if direction_typeDB.Harp_pedalsID.Int64 != 0 {
			direction_typeDB.Harp_pedalsID.Int64 = int64(BackRepoHarp_pedalsid_atBckpTime_newID[uint(direction_typeDB.Harp_pedalsID.Int64)])
			direction_typeDB.Harp_pedalsID.Valid = true
		}

		// reindexing Damp field
		if direction_typeDB.DampID.Int64 != 0 {
			direction_typeDB.DampID.Int64 = int64(BackRepoEmpty_print_style_align_idid_atBckpTime_newID[uint(direction_typeDB.DampID.Int64)])
			direction_typeDB.DampID.Valid = true
		}

		// reindexing Damp_all field
		if direction_typeDB.Damp_allID.Int64 != 0 {
			direction_typeDB.Damp_allID.Int64 = int64(BackRepoEmpty_print_style_align_idid_atBckpTime_newID[uint(direction_typeDB.Damp_allID.Int64)])
			direction_typeDB.Damp_allID.Valid = true
		}

		// reindexing Eyeglasses field
		if direction_typeDB.EyeglassesID.Int64 != 0 {
			direction_typeDB.EyeglassesID.Int64 = int64(BackRepoEmpty_print_style_align_idid_atBckpTime_newID[uint(direction_typeDB.EyeglassesID.Int64)])
			direction_typeDB.EyeglassesID.Valid = true
		}

		// reindexing String_mute field
		if direction_typeDB.String_muteID.Int64 != 0 {
			direction_typeDB.String_muteID.Int64 = int64(BackRepoString_muteid_atBckpTime_newID[uint(direction_typeDB.String_muteID.Int64)])
			direction_typeDB.String_muteID.Valid = true
		}

		// reindexing Scordatura field
		if direction_typeDB.ScordaturaID.Int64 != 0 {
			direction_typeDB.ScordaturaID.Int64 = int64(BackRepoScordaturaid_atBckpTime_newID[uint(direction_typeDB.ScordaturaID.Int64)])
			direction_typeDB.ScordaturaID.Valid = true
		}

		// reindexing Image field
		if direction_typeDB.ImageID.Int64 != 0 {
			direction_typeDB.ImageID.Int64 = int64(BackRepoImageid_atBckpTime_newID[uint(direction_typeDB.ImageID.Int64)])
			direction_typeDB.ImageID.Valid = true
		}

		// reindexing Principal_voice field
		if direction_typeDB.Principal_voiceID.Int64 != 0 {
			direction_typeDB.Principal_voiceID.Int64 = int64(BackRepoPrincipal_voiceid_atBckpTime_newID[uint(direction_typeDB.Principal_voiceID.Int64)])
			direction_typeDB.Principal_voiceID.Valid = true
		}

		// reindexing Accordion_registration field
		if direction_typeDB.Accordion_registrationID.Int64 != 0 {
			direction_typeDB.Accordion_registrationID.Int64 = int64(BackRepoAccordion_registrationid_atBckpTime_newID[uint(direction_typeDB.Accordion_registrationID.Int64)])
			direction_typeDB.Accordion_registrationID.Valid = true
		}

		// reindexing Staff_divide field
		if direction_typeDB.Staff_divideID.Int64 != 0 {
			direction_typeDB.Staff_divideID.Int64 = int64(BackRepoStaff_divideid_atBckpTime_newID[uint(direction_typeDB.Staff_divideID.Int64)])
			direction_typeDB.Staff_divideID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoDirection_type.db.Model(direction_typeDB).Updates(*direction_typeDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoDirection_type.ResetReversePointers commits all staged instances of Direction_type to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDirection_type *BackRepoDirection_typeStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, direction_type := range backRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr {
		backRepoDirection_type.ResetReversePointersInstance(backRepo, idx, direction_type)
	}

	return
}

func (backRepoDirection_type *BackRepoDirection_typeStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, direction_type *models.Direction_type) (Error error) {

	// fetch matching direction_typeDB
	if direction_typeDB, ok := backRepoDirection_type.Map_Direction_typeDBID_Direction_typeDB[idx]; ok {
		_ = direction_typeDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoDirection_typeid_atBckpTime_newID map[uint]uint
