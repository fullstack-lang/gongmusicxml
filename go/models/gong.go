// generated code - do not edit
package models

import (
	"cmp"
	"errors"
	"fmt"
	"math"
	"slices"
	"time"
)

func __Gong__Abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// errUnkownEnum is returns when a value cannot match enum values
var errUnkownEnum = errors.New("unkown enum")

// needed to avoid when fmt package is not needed by generated code
var __dummy__fmt_variable fmt.Scanner

// idem for math package when not need by generated code
var __dummy_math_variable = math.E

// swagger:ignore
type __void any

// needed for creating set of instances in the stage
var __member __void

// GongStructInterface is the interface met by GongStructs
// It allows runtime reflexion of instances (without the hassle of the "reflect" package)
type GongStructInterface interface {
	GetName() (res string)
	// GetID() (res int)
	// GetFields() (res []string)
	// GetFieldStringValue(fieldName string) (res string)
}

// StageStruct enables storage of staged instances
// swagger:ignore
type StageStruct struct {
	path string

	// insertion point for definition of arrays registering instances
	Accidentals           map[*Accidental]any
	Accidentals_mapString map[string]*Accidental

	// insertion point for slice of pointers maps

	OnAfterAccidentalCreateCallback OnAfterCreateInterface[Accidental]
	OnAfterAccidentalUpdateCallback OnAfterUpdateInterface[Accidental]
	OnAfterAccidentalDeleteCallback OnAfterDeleteInterface[Accidental]
	OnAfterAccidentalReadCallback   OnAfterReadInterface[Accidental]

	Accidental_marks           map[*Accidental_mark]any
	Accidental_marks_mapString map[string]*Accidental_mark

	// insertion point for slice of pointers maps

	OnAfterAccidental_markCreateCallback OnAfterCreateInterface[Accidental_mark]
	OnAfterAccidental_markUpdateCallback OnAfterUpdateInterface[Accidental_mark]
	OnAfterAccidental_markDeleteCallback OnAfterDeleteInterface[Accidental_mark]
	OnAfterAccidental_markReadCallback   OnAfterReadInterface[Accidental_mark]

	Accidental_texts           map[*Accidental_text]any
	Accidental_texts_mapString map[string]*Accidental_text

	// insertion point for slice of pointers maps

	OnAfterAccidental_textCreateCallback OnAfterCreateInterface[Accidental_text]
	OnAfterAccidental_textUpdateCallback OnAfterUpdateInterface[Accidental_text]
	OnAfterAccidental_textDeleteCallback OnAfterDeleteInterface[Accidental_text]
	OnAfterAccidental_textReadCallback   OnAfterReadInterface[Accidental_text]

	Accords           map[*Accord]any
	Accords_mapString map[string]*Accord

	// insertion point for slice of pointers maps

	OnAfterAccordCreateCallback OnAfterCreateInterface[Accord]
	OnAfterAccordUpdateCallback OnAfterUpdateInterface[Accord]
	OnAfterAccordDeleteCallback OnAfterDeleteInterface[Accord]
	OnAfterAccordReadCallback   OnAfterReadInterface[Accord]

	Accordion_registrations           map[*Accordion_registration]any
	Accordion_registrations_mapString map[string]*Accordion_registration

	// insertion point for slice of pointers maps

	OnAfterAccordion_registrationCreateCallback OnAfterCreateInterface[Accordion_registration]
	OnAfterAccordion_registrationUpdateCallback OnAfterUpdateInterface[Accordion_registration]
	OnAfterAccordion_registrationDeleteCallback OnAfterDeleteInterface[Accordion_registration]
	OnAfterAccordion_registrationReadCallback   OnAfterReadInterface[Accordion_registration]

	AnyTypes           map[*AnyType]any
	AnyTypes_mapString map[string]*AnyType

	// insertion point for slice of pointers maps

	OnAfterAnyTypeCreateCallback OnAfterCreateInterface[AnyType]
	OnAfterAnyTypeUpdateCallback OnAfterUpdateInterface[AnyType]
	OnAfterAnyTypeDeleteCallback OnAfterDeleteInterface[AnyType]
	OnAfterAnyTypeReadCallback   OnAfterReadInterface[AnyType]

	Appearances           map[*Appearance]any
	Appearances_mapString map[string]*Appearance

	// insertion point for slice of pointers maps
	Appearance_Line_width_reverseMap       map[*Line_width]*Appearance
	Appearance_Note_size_reverseMap        map[*Note_size]*Appearance
	Appearance_Distance_reverseMap         map[*Distance]*Appearance
	Appearance_Glyph_reverseMap            map[*Glyph]*Appearance
	Appearance_Other_appearance_reverseMap map[*Other_appearance]*Appearance

	OnAfterAppearanceCreateCallback OnAfterCreateInterface[Appearance]
	OnAfterAppearanceUpdateCallback OnAfterUpdateInterface[Appearance]
	OnAfterAppearanceDeleteCallback OnAfterDeleteInterface[Appearance]
	OnAfterAppearanceReadCallback   OnAfterReadInterface[Appearance]

	Arpeggiates           map[*Arpeggiate]any
	Arpeggiates_mapString map[string]*Arpeggiate

	// insertion point for slice of pointers maps

	OnAfterArpeggiateCreateCallback OnAfterCreateInterface[Arpeggiate]
	OnAfterArpeggiateUpdateCallback OnAfterUpdateInterface[Arpeggiate]
	OnAfterArpeggiateDeleteCallback OnAfterDeleteInterface[Arpeggiate]
	OnAfterArpeggiateReadCallback   OnAfterReadInterface[Arpeggiate]

	Arrows           map[*Arrow]any
	Arrows_mapString map[string]*Arrow

	// insertion point for slice of pointers maps

	OnAfterArrowCreateCallback OnAfterCreateInterface[Arrow]
	OnAfterArrowUpdateCallback OnAfterUpdateInterface[Arrow]
	OnAfterArrowDeleteCallback OnAfterDeleteInterface[Arrow]
	OnAfterArrowReadCallback   OnAfterReadInterface[Arrow]

	Articulationss           map[*Articulations]any
	Articulationss_mapString map[string]*Articulations

	// insertion point for slice of pointers maps

	OnAfterArticulationsCreateCallback OnAfterCreateInterface[Articulations]
	OnAfterArticulationsUpdateCallback OnAfterUpdateInterface[Articulations]
	OnAfterArticulationsDeleteCallback OnAfterDeleteInterface[Articulations]
	OnAfterArticulationsReadCallback   OnAfterReadInterface[Articulations]

	Assesss           map[*Assess]any
	Assesss_mapString map[string]*Assess

	// insertion point for slice of pointers maps

	OnAfterAssessCreateCallback OnAfterCreateInterface[Assess]
	OnAfterAssessUpdateCallback OnAfterUpdateInterface[Assess]
	OnAfterAssessDeleteCallback OnAfterDeleteInterface[Assess]
	OnAfterAssessReadCallback   OnAfterReadInterface[Assess]

	Attributess           map[*Attributes]any
	Attributess_mapString map[string]*Attributes

	// insertion point for slice of pointers maps
	Attributes_Key_reverseMap           map[*Key]*Attributes
	Attributes_Clef_reverseMap          map[*Clef]*Attributes
	Attributes_Staff_details_reverseMap map[*Staff_details]*Attributes
	Attributes_Measure_style_reverseMap map[*Measure_style]*Attributes
	Attributes_Transpose_reverseMap     map[*Transpose]*Attributes
	Attributes_For_part_reverseMap      map[*For_part]*Attributes

	OnAfterAttributesCreateCallback OnAfterCreateInterface[Attributes]
	OnAfterAttributesUpdateCallback OnAfterUpdateInterface[Attributes]
	OnAfterAttributesDeleteCallback OnAfterDeleteInterface[Attributes]
	OnAfterAttributesReadCallback   OnAfterReadInterface[Attributes]

	Backups           map[*Backup]any
	Backups_mapString map[string]*Backup

	// insertion point for slice of pointers maps

	OnAfterBackupCreateCallback OnAfterCreateInterface[Backup]
	OnAfterBackupUpdateCallback OnAfterUpdateInterface[Backup]
	OnAfterBackupDeleteCallback OnAfterDeleteInterface[Backup]
	OnAfterBackupReadCallback   OnAfterReadInterface[Backup]

	Bar_style_colors           map[*Bar_style_color]any
	Bar_style_colors_mapString map[string]*Bar_style_color

	// insertion point for slice of pointers maps

	OnAfterBar_style_colorCreateCallback OnAfterCreateInterface[Bar_style_color]
	OnAfterBar_style_colorUpdateCallback OnAfterUpdateInterface[Bar_style_color]
	OnAfterBar_style_colorDeleteCallback OnAfterDeleteInterface[Bar_style_color]
	OnAfterBar_style_colorReadCallback   OnAfterReadInterface[Bar_style_color]

	Barlines           map[*Barline]any
	Barlines_mapString map[string]*Barline

	// insertion point for slice of pointers maps

	OnAfterBarlineCreateCallback OnAfterCreateInterface[Barline]
	OnAfterBarlineUpdateCallback OnAfterUpdateInterface[Barline]
	OnAfterBarlineDeleteCallback OnAfterDeleteInterface[Barline]
	OnAfterBarlineReadCallback   OnAfterReadInterface[Barline]

	Barres           map[*Barre]any
	Barres_mapString map[string]*Barre

	// insertion point for slice of pointers maps

	OnAfterBarreCreateCallback OnAfterCreateInterface[Barre]
	OnAfterBarreUpdateCallback OnAfterUpdateInterface[Barre]
	OnAfterBarreDeleteCallback OnAfterDeleteInterface[Barre]
	OnAfterBarreReadCallback   OnAfterReadInterface[Barre]

	Basss           map[*Bass]any
	Basss_mapString map[string]*Bass

	// insertion point for slice of pointers maps

	OnAfterBassCreateCallback OnAfterCreateInterface[Bass]
	OnAfterBassUpdateCallback OnAfterUpdateInterface[Bass]
	OnAfterBassDeleteCallback OnAfterDeleteInterface[Bass]
	OnAfterBassReadCallback   OnAfterReadInterface[Bass]

	Bass_steps           map[*Bass_step]any
	Bass_steps_mapString map[string]*Bass_step

	// insertion point for slice of pointers maps

	OnAfterBass_stepCreateCallback OnAfterCreateInterface[Bass_step]
	OnAfterBass_stepUpdateCallback OnAfterUpdateInterface[Bass_step]
	OnAfterBass_stepDeleteCallback OnAfterDeleteInterface[Bass_step]
	OnAfterBass_stepReadCallback   OnAfterReadInterface[Bass_step]

	Beams           map[*Beam]any
	Beams_mapString map[string]*Beam

	// insertion point for slice of pointers maps

	OnAfterBeamCreateCallback OnAfterCreateInterface[Beam]
	OnAfterBeamUpdateCallback OnAfterUpdateInterface[Beam]
	OnAfterBeamDeleteCallback OnAfterDeleteInterface[Beam]
	OnAfterBeamReadCallback   OnAfterReadInterface[Beam]

	Beat_repeats           map[*Beat_repeat]any
	Beat_repeats_mapString map[string]*Beat_repeat

	// insertion point for slice of pointers maps

	OnAfterBeat_repeatCreateCallback OnAfterCreateInterface[Beat_repeat]
	OnAfterBeat_repeatUpdateCallback OnAfterUpdateInterface[Beat_repeat]
	OnAfterBeat_repeatDeleteCallback OnAfterDeleteInterface[Beat_repeat]
	OnAfterBeat_repeatReadCallback   OnAfterReadInterface[Beat_repeat]

	Beat_unit_tieds           map[*Beat_unit_tied]any
	Beat_unit_tieds_mapString map[string]*Beat_unit_tied

	// insertion point for slice of pointers maps

	OnAfterBeat_unit_tiedCreateCallback OnAfterCreateInterface[Beat_unit_tied]
	OnAfterBeat_unit_tiedUpdateCallback OnAfterUpdateInterface[Beat_unit_tied]
	OnAfterBeat_unit_tiedDeleteCallback OnAfterDeleteInterface[Beat_unit_tied]
	OnAfterBeat_unit_tiedReadCallback   OnAfterReadInterface[Beat_unit_tied]

	Beaters           map[*Beater]any
	Beaters_mapString map[string]*Beater

	// insertion point for slice of pointers maps

	OnAfterBeaterCreateCallback OnAfterCreateInterface[Beater]
	OnAfterBeaterUpdateCallback OnAfterUpdateInterface[Beater]
	OnAfterBeaterDeleteCallback OnAfterDeleteInterface[Beater]
	OnAfterBeaterReadCallback   OnAfterReadInterface[Beater]

	Bends           map[*Bend]any
	Bends_mapString map[string]*Bend

	// insertion point for slice of pointers maps

	OnAfterBendCreateCallback OnAfterCreateInterface[Bend]
	OnAfterBendUpdateCallback OnAfterUpdateInterface[Bend]
	OnAfterBendDeleteCallback OnAfterDeleteInterface[Bend]
	OnAfterBendReadCallback   OnAfterReadInterface[Bend]

	Bookmarks           map[*Bookmark]any
	Bookmarks_mapString map[string]*Bookmark

	// insertion point for slice of pointers maps

	OnAfterBookmarkCreateCallback OnAfterCreateInterface[Bookmark]
	OnAfterBookmarkUpdateCallback OnAfterUpdateInterface[Bookmark]
	OnAfterBookmarkDeleteCallback OnAfterDeleteInterface[Bookmark]
	OnAfterBookmarkReadCallback   OnAfterReadInterface[Bookmark]

	Brackets           map[*Bracket]any
	Brackets_mapString map[string]*Bracket

	// insertion point for slice of pointers maps

	OnAfterBracketCreateCallback OnAfterCreateInterface[Bracket]
	OnAfterBracketUpdateCallback OnAfterUpdateInterface[Bracket]
	OnAfterBracketDeleteCallback OnAfterDeleteInterface[Bracket]
	OnAfterBracketReadCallback   OnAfterReadInterface[Bracket]

	Breath_marks           map[*Breath_mark]any
	Breath_marks_mapString map[string]*Breath_mark

	// insertion point for slice of pointers maps

	OnAfterBreath_markCreateCallback OnAfterCreateInterface[Breath_mark]
	OnAfterBreath_markUpdateCallback OnAfterUpdateInterface[Breath_mark]
	OnAfterBreath_markDeleteCallback OnAfterDeleteInterface[Breath_mark]
	OnAfterBreath_markReadCallback   OnAfterReadInterface[Breath_mark]

	Caesuras           map[*Caesura]any
	Caesuras_mapString map[string]*Caesura

	// insertion point for slice of pointers maps

	OnAfterCaesuraCreateCallback OnAfterCreateInterface[Caesura]
	OnAfterCaesuraUpdateCallback OnAfterUpdateInterface[Caesura]
	OnAfterCaesuraDeleteCallback OnAfterDeleteInterface[Caesura]
	OnAfterCaesuraReadCallback   OnAfterReadInterface[Caesura]

	Cancels           map[*Cancel]any
	Cancels_mapString map[string]*Cancel

	// insertion point for slice of pointers maps

	OnAfterCancelCreateCallback OnAfterCreateInterface[Cancel]
	OnAfterCancelUpdateCallback OnAfterUpdateInterface[Cancel]
	OnAfterCancelDeleteCallback OnAfterDeleteInterface[Cancel]
	OnAfterCancelReadCallback   OnAfterReadInterface[Cancel]

	Clefs           map[*Clef]any
	Clefs_mapString map[string]*Clef

	// insertion point for slice of pointers maps

	OnAfterClefCreateCallback OnAfterCreateInterface[Clef]
	OnAfterClefUpdateCallback OnAfterUpdateInterface[Clef]
	OnAfterClefDeleteCallback OnAfterDeleteInterface[Clef]
	OnAfterClefReadCallback   OnAfterReadInterface[Clef]

	Codas           map[*Coda]any
	Codas_mapString map[string]*Coda

	// insertion point for slice of pointers maps

	OnAfterCodaCreateCallback OnAfterCreateInterface[Coda]
	OnAfterCodaUpdateCallback OnAfterUpdateInterface[Coda]
	OnAfterCodaDeleteCallback OnAfterDeleteInterface[Coda]
	OnAfterCodaReadCallback   OnAfterReadInterface[Coda]

	Credits           map[*Credit]any
	Credits_mapString map[string]*Credit

	// insertion point for slice of pointers maps
	Credit_Link_reverseMap     map[*Link]*Credit
	Credit_Bookmark_reverseMap map[*Bookmark]*Credit

	OnAfterCreditCreateCallback OnAfterCreateInterface[Credit]
	OnAfterCreditUpdateCallback OnAfterUpdateInterface[Credit]
	OnAfterCreditDeleteCallback OnAfterDeleteInterface[Credit]
	OnAfterCreditReadCallback   OnAfterReadInterface[Credit]

	Dashess           map[*Dashes]any
	Dashess_mapString map[string]*Dashes

	// insertion point for slice of pointers maps

	OnAfterDashesCreateCallback OnAfterCreateInterface[Dashes]
	OnAfterDashesUpdateCallback OnAfterUpdateInterface[Dashes]
	OnAfterDashesDeleteCallback OnAfterDeleteInterface[Dashes]
	OnAfterDashesReadCallback   OnAfterReadInterface[Dashes]

	Defaultss           map[*Defaults]any
	Defaultss_mapString map[string]*Defaults

	// insertion point for slice of pointers maps
	Defaults_Lyric_font_reverseMap     map[*Lyric_font]*Defaults
	Defaults_Lyric_language_reverseMap map[*Lyric_language]*Defaults

	OnAfterDefaultsCreateCallback OnAfterCreateInterface[Defaults]
	OnAfterDefaultsUpdateCallback OnAfterUpdateInterface[Defaults]
	OnAfterDefaultsDeleteCallback OnAfterDeleteInterface[Defaults]
	OnAfterDefaultsReadCallback   OnAfterReadInterface[Defaults]

	Degrees           map[*Degree]any
	Degrees_mapString map[string]*Degree

	// insertion point for slice of pointers maps

	OnAfterDegreeCreateCallback OnAfterCreateInterface[Degree]
	OnAfterDegreeUpdateCallback OnAfterUpdateInterface[Degree]
	OnAfterDegreeDeleteCallback OnAfterDeleteInterface[Degree]
	OnAfterDegreeReadCallback   OnAfterReadInterface[Degree]

	Degree_alters           map[*Degree_alter]any
	Degree_alters_mapString map[string]*Degree_alter

	// insertion point for slice of pointers maps

	OnAfterDegree_alterCreateCallback OnAfterCreateInterface[Degree_alter]
	OnAfterDegree_alterUpdateCallback OnAfterUpdateInterface[Degree_alter]
	OnAfterDegree_alterDeleteCallback OnAfterDeleteInterface[Degree_alter]
	OnAfterDegree_alterReadCallback   OnAfterReadInterface[Degree_alter]

	Degree_types           map[*Degree_type]any
	Degree_types_mapString map[string]*Degree_type

	// insertion point for slice of pointers maps

	OnAfterDegree_typeCreateCallback OnAfterCreateInterface[Degree_type]
	OnAfterDegree_typeUpdateCallback OnAfterUpdateInterface[Degree_type]
	OnAfterDegree_typeDeleteCallback OnAfterDeleteInterface[Degree_type]
	OnAfterDegree_typeReadCallback   OnAfterReadInterface[Degree_type]

	Degree_values           map[*Degree_value]any
	Degree_values_mapString map[string]*Degree_value

	// insertion point for slice of pointers maps

	OnAfterDegree_valueCreateCallback OnAfterCreateInterface[Degree_value]
	OnAfterDegree_valueUpdateCallback OnAfterUpdateInterface[Degree_value]
	OnAfterDegree_valueDeleteCallback OnAfterDeleteInterface[Degree_value]
	OnAfterDegree_valueReadCallback   OnAfterReadInterface[Degree_value]

	Directions           map[*Direction]any
	Directions_mapString map[string]*Direction

	// insertion point for slice of pointers maps
	Direction_Direction_type_reverseMap map[*Direction_type]*Direction

	OnAfterDirectionCreateCallback OnAfterCreateInterface[Direction]
	OnAfterDirectionUpdateCallback OnAfterUpdateInterface[Direction]
	OnAfterDirectionDeleteCallback OnAfterDeleteInterface[Direction]
	OnAfterDirectionReadCallback   OnAfterReadInterface[Direction]

	Direction_types           map[*Direction_type]any
	Direction_types_mapString map[string]*Direction_type

	// insertion point for slice of pointers maps
	Direction_type_Segno_reverseMap      map[*Segno]*Direction_type
	Direction_type_Coda_reverseMap       map[*Coda]*Direction_type
	Direction_type_Dynamics_reverseMap   map[*Dynamics]*Direction_type
	Direction_type_Percussion_reverseMap map[*Percussion]*Direction_type

	OnAfterDirection_typeCreateCallback OnAfterCreateInterface[Direction_type]
	OnAfterDirection_typeUpdateCallback OnAfterUpdateInterface[Direction_type]
	OnAfterDirection_typeDeleteCallback OnAfterDeleteInterface[Direction_type]
	OnAfterDirection_typeReadCallback   OnAfterReadInterface[Direction_type]

	Distances           map[*Distance]any
	Distances_mapString map[string]*Distance

	// insertion point for slice of pointers maps

	OnAfterDistanceCreateCallback OnAfterCreateInterface[Distance]
	OnAfterDistanceUpdateCallback OnAfterUpdateInterface[Distance]
	OnAfterDistanceDeleteCallback OnAfterDeleteInterface[Distance]
	OnAfterDistanceReadCallback   OnAfterReadInterface[Distance]

	Doubles           map[*Double]any
	Doubles_mapString map[string]*Double

	// insertion point for slice of pointers maps

	OnAfterDoubleCreateCallback OnAfterCreateInterface[Double]
	OnAfterDoubleUpdateCallback OnAfterUpdateInterface[Double]
	OnAfterDoubleDeleteCallback OnAfterDeleteInterface[Double]
	OnAfterDoubleReadCallback   OnAfterReadInterface[Double]

	Dynamicss           map[*Dynamics]any
	Dynamicss_mapString map[string]*Dynamics

	// insertion point for slice of pointers maps

	OnAfterDynamicsCreateCallback OnAfterCreateInterface[Dynamics]
	OnAfterDynamicsUpdateCallback OnAfterUpdateInterface[Dynamics]
	OnAfterDynamicsDeleteCallback OnAfterDeleteInterface[Dynamics]
	OnAfterDynamicsReadCallback   OnAfterReadInterface[Dynamics]

	Effects           map[*Effect]any
	Effects_mapString map[string]*Effect

	// insertion point for slice of pointers maps

	OnAfterEffectCreateCallback OnAfterCreateInterface[Effect]
	OnAfterEffectUpdateCallback OnAfterUpdateInterface[Effect]
	OnAfterEffectDeleteCallback OnAfterDeleteInterface[Effect]
	OnAfterEffectReadCallback   OnAfterReadInterface[Effect]

	Elisions           map[*Elision]any
	Elisions_mapString map[string]*Elision

	// insertion point for slice of pointers maps

	OnAfterElisionCreateCallback OnAfterCreateInterface[Elision]
	OnAfterElisionUpdateCallback OnAfterUpdateInterface[Elision]
	OnAfterElisionDeleteCallback OnAfterDeleteInterface[Elision]
	OnAfterElisionReadCallback   OnAfterReadInterface[Elision]

	Emptys           map[*Empty]any
	Emptys_mapString map[string]*Empty

	// insertion point for slice of pointers maps

	OnAfterEmptyCreateCallback OnAfterCreateInterface[Empty]
	OnAfterEmptyUpdateCallback OnAfterUpdateInterface[Empty]
	OnAfterEmptyDeleteCallback OnAfterDeleteInterface[Empty]
	OnAfterEmptyReadCallback   OnAfterReadInterface[Empty]

	Empty_fonts           map[*Empty_font]any
	Empty_fonts_mapString map[string]*Empty_font

	// insertion point for slice of pointers maps

	OnAfterEmpty_fontCreateCallback OnAfterCreateInterface[Empty_font]
	OnAfterEmpty_fontUpdateCallback OnAfterUpdateInterface[Empty_font]
	OnAfterEmpty_fontDeleteCallback OnAfterDeleteInterface[Empty_font]
	OnAfterEmpty_fontReadCallback   OnAfterReadInterface[Empty_font]

	Empty_lines           map[*Empty_line]any
	Empty_lines_mapString map[string]*Empty_line

	// insertion point for slice of pointers maps

	OnAfterEmpty_lineCreateCallback OnAfterCreateInterface[Empty_line]
	OnAfterEmpty_lineUpdateCallback OnAfterUpdateInterface[Empty_line]
	OnAfterEmpty_lineDeleteCallback OnAfterDeleteInterface[Empty_line]
	OnAfterEmpty_lineReadCallback   OnAfterReadInterface[Empty_line]

	Empty_placements           map[*Empty_placement]any
	Empty_placements_mapString map[string]*Empty_placement

	// insertion point for slice of pointers maps

	OnAfterEmpty_placementCreateCallback OnAfterCreateInterface[Empty_placement]
	OnAfterEmpty_placementUpdateCallback OnAfterUpdateInterface[Empty_placement]
	OnAfterEmpty_placementDeleteCallback OnAfterDeleteInterface[Empty_placement]
	OnAfterEmpty_placementReadCallback   OnAfterReadInterface[Empty_placement]

	Empty_placement_smufls           map[*Empty_placement_smufl]any
	Empty_placement_smufls_mapString map[string]*Empty_placement_smufl

	// insertion point for slice of pointers maps

	OnAfterEmpty_placement_smuflCreateCallback OnAfterCreateInterface[Empty_placement_smufl]
	OnAfterEmpty_placement_smuflUpdateCallback OnAfterUpdateInterface[Empty_placement_smufl]
	OnAfterEmpty_placement_smuflDeleteCallback OnAfterDeleteInterface[Empty_placement_smufl]
	OnAfterEmpty_placement_smuflReadCallback   OnAfterReadInterface[Empty_placement_smufl]

	Empty_print_object_style_aligns           map[*Empty_print_object_style_align]any
	Empty_print_object_style_aligns_mapString map[string]*Empty_print_object_style_align

	// insertion point for slice of pointers maps

	OnAfterEmpty_print_object_style_alignCreateCallback OnAfterCreateInterface[Empty_print_object_style_align]
	OnAfterEmpty_print_object_style_alignUpdateCallback OnAfterUpdateInterface[Empty_print_object_style_align]
	OnAfterEmpty_print_object_style_alignDeleteCallback OnAfterDeleteInterface[Empty_print_object_style_align]
	OnAfterEmpty_print_object_style_alignReadCallback   OnAfterReadInterface[Empty_print_object_style_align]

	Empty_print_styles           map[*Empty_print_style]any
	Empty_print_styles_mapString map[string]*Empty_print_style

	// insertion point for slice of pointers maps

	OnAfterEmpty_print_styleCreateCallback OnAfterCreateInterface[Empty_print_style]
	OnAfterEmpty_print_styleUpdateCallback OnAfterUpdateInterface[Empty_print_style]
	OnAfterEmpty_print_styleDeleteCallback OnAfterDeleteInterface[Empty_print_style]
	OnAfterEmpty_print_styleReadCallback   OnAfterReadInterface[Empty_print_style]

	Empty_print_style_aligns           map[*Empty_print_style_align]any
	Empty_print_style_aligns_mapString map[string]*Empty_print_style_align

	// insertion point for slice of pointers maps

	OnAfterEmpty_print_style_alignCreateCallback OnAfterCreateInterface[Empty_print_style_align]
	OnAfterEmpty_print_style_alignUpdateCallback OnAfterUpdateInterface[Empty_print_style_align]
	OnAfterEmpty_print_style_alignDeleteCallback OnAfterDeleteInterface[Empty_print_style_align]
	OnAfterEmpty_print_style_alignReadCallback   OnAfterReadInterface[Empty_print_style_align]

	Empty_print_style_align_ids           map[*Empty_print_style_align_id]any
	Empty_print_style_align_ids_mapString map[string]*Empty_print_style_align_id

	// insertion point for slice of pointers maps

	OnAfterEmpty_print_style_align_idCreateCallback OnAfterCreateInterface[Empty_print_style_align_id]
	OnAfterEmpty_print_style_align_idUpdateCallback OnAfterUpdateInterface[Empty_print_style_align_id]
	OnAfterEmpty_print_style_align_idDeleteCallback OnAfterDeleteInterface[Empty_print_style_align_id]
	OnAfterEmpty_print_style_align_idReadCallback   OnAfterReadInterface[Empty_print_style_align_id]

	Empty_trill_sounds           map[*Empty_trill_sound]any
	Empty_trill_sounds_mapString map[string]*Empty_trill_sound

	// insertion point for slice of pointers maps

	OnAfterEmpty_trill_soundCreateCallback OnAfterCreateInterface[Empty_trill_sound]
	OnAfterEmpty_trill_soundUpdateCallback OnAfterUpdateInterface[Empty_trill_sound]
	OnAfterEmpty_trill_soundDeleteCallback OnAfterDeleteInterface[Empty_trill_sound]
	OnAfterEmpty_trill_soundReadCallback   OnAfterReadInterface[Empty_trill_sound]

	Encodings           map[*Encoding]any
	Encodings_mapString map[string]*Encoding

	// insertion point for slice of pointers maps

	OnAfterEncodingCreateCallback OnAfterCreateInterface[Encoding]
	OnAfterEncodingUpdateCallback OnAfterUpdateInterface[Encoding]
	OnAfterEncodingDeleteCallback OnAfterDeleteInterface[Encoding]
	OnAfterEncodingReadCallback   OnAfterReadInterface[Encoding]

	Endings           map[*Ending]any
	Endings_mapString map[string]*Ending

	// insertion point for slice of pointers maps

	OnAfterEndingCreateCallback OnAfterCreateInterface[Ending]
	OnAfterEndingUpdateCallback OnAfterUpdateInterface[Ending]
	OnAfterEndingDeleteCallback OnAfterDeleteInterface[Ending]
	OnAfterEndingReadCallback   OnAfterReadInterface[Ending]

	Extends           map[*Extend]any
	Extends_mapString map[string]*Extend

	// insertion point for slice of pointers maps

	OnAfterExtendCreateCallback OnAfterCreateInterface[Extend]
	OnAfterExtendUpdateCallback OnAfterUpdateInterface[Extend]
	OnAfterExtendDeleteCallback OnAfterDeleteInterface[Extend]
	OnAfterExtendReadCallback   OnAfterReadInterface[Extend]

	Features           map[*Feature]any
	Features_mapString map[string]*Feature

	// insertion point for slice of pointers maps

	OnAfterFeatureCreateCallback OnAfterCreateInterface[Feature]
	OnAfterFeatureUpdateCallback OnAfterUpdateInterface[Feature]
	OnAfterFeatureDeleteCallback OnAfterDeleteInterface[Feature]
	OnAfterFeatureReadCallback   OnAfterReadInterface[Feature]

	Fermatas           map[*Fermata]any
	Fermatas_mapString map[string]*Fermata

	// insertion point for slice of pointers maps

	OnAfterFermataCreateCallback OnAfterCreateInterface[Fermata]
	OnAfterFermataUpdateCallback OnAfterUpdateInterface[Fermata]
	OnAfterFermataDeleteCallback OnAfterDeleteInterface[Fermata]
	OnAfterFermataReadCallback   OnAfterReadInterface[Fermata]

	Figures           map[*Figure]any
	Figures_mapString map[string]*Figure

	// insertion point for slice of pointers maps

	OnAfterFigureCreateCallback OnAfterCreateInterface[Figure]
	OnAfterFigureUpdateCallback OnAfterUpdateInterface[Figure]
	OnAfterFigureDeleteCallback OnAfterDeleteInterface[Figure]
	OnAfterFigureReadCallback   OnAfterReadInterface[Figure]

	Figured_basss           map[*Figured_bass]any
	Figured_basss_mapString map[string]*Figured_bass

	// insertion point for slice of pointers maps
	Figured_bass_Figure_reverseMap map[*Figure]*Figured_bass

	OnAfterFigured_bassCreateCallback OnAfterCreateInterface[Figured_bass]
	OnAfterFigured_bassUpdateCallback OnAfterUpdateInterface[Figured_bass]
	OnAfterFigured_bassDeleteCallback OnAfterDeleteInterface[Figured_bass]
	OnAfterFigured_bassReadCallback   OnAfterReadInterface[Figured_bass]

	Fingerings           map[*Fingering]any
	Fingerings_mapString map[string]*Fingering

	// insertion point for slice of pointers maps

	OnAfterFingeringCreateCallback OnAfterCreateInterface[Fingering]
	OnAfterFingeringUpdateCallback OnAfterUpdateInterface[Fingering]
	OnAfterFingeringDeleteCallback OnAfterDeleteInterface[Fingering]
	OnAfterFingeringReadCallback   OnAfterReadInterface[Fingering]

	First_frets           map[*First_fret]any
	First_frets_mapString map[string]*First_fret

	// insertion point for slice of pointers maps

	OnAfterFirst_fretCreateCallback OnAfterCreateInterface[First_fret]
	OnAfterFirst_fretUpdateCallback OnAfterUpdateInterface[First_fret]
	OnAfterFirst_fretDeleteCallback OnAfterDeleteInterface[First_fret]
	OnAfterFirst_fretReadCallback   OnAfterReadInterface[First_fret]

	Foos           map[*Foo]any
	Foos_mapString map[string]*Foo

	// insertion point for slice of pointers maps

	OnAfterFooCreateCallback OnAfterCreateInterface[Foo]
	OnAfterFooUpdateCallback OnAfterUpdateInterface[Foo]
	OnAfterFooDeleteCallback OnAfterDeleteInterface[Foo]
	OnAfterFooReadCallback   OnAfterReadInterface[Foo]

	For_parts           map[*For_part]any
	For_parts_mapString map[string]*For_part

	// insertion point for slice of pointers maps

	OnAfterFor_partCreateCallback OnAfterCreateInterface[For_part]
	OnAfterFor_partUpdateCallback OnAfterUpdateInterface[For_part]
	OnAfterFor_partDeleteCallback OnAfterDeleteInterface[For_part]
	OnAfterFor_partReadCallback   OnAfterReadInterface[For_part]

	Formatted_symbols           map[*Formatted_symbol]any
	Formatted_symbols_mapString map[string]*Formatted_symbol

	// insertion point for slice of pointers maps

	OnAfterFormatted_symbolCreateCallback OnAfterCreateInterface[Formatted_symbol]
	OnAfterFormatted_symbolUpdateCallback OnAfterUpdateInterface[Formatted_symbol]
	OnAfterFormatted_symbolDeleteCallback OnAfterDeleteInterface[Formatted_symbol]
	OnAfterFormatted_symbolReadCallback   OnAfterReadInterface[Formatted_symbol]

	Formatted_symbol_ids           map[*Formatted_symbol_id]any
	Formatted_symbol_ids_mapString map[string]*Formatted_symbol_id

	// insertion point for slice of pointers maps

	OnAfterFormatted_symbol_idCreateCallback OnAfterCreateInterface[Formatted_symbol_id]
	OnAfterFormatted_symbol_idUpdateCallback OnAfterUpdateInterface[Formatted_symbol_id]
	OnAfterFormatted_symbol_idDeleteCallback OnAfterDeleteInterface[Formatted_symbol_id]
	OnAfterFormatted_symbol_idReadCallback   OnAfterReadInterface[Formatted_symbol_id]

	Forwards           map[*Forward]any
	Forwards_mapString map[string]*Forward

	// insertion point for slice of pointers maps

	OnAfterForwardCreateCallback OnAfterCreateInterface[Forward]
	OnAfterForwardUpdateCallback OnAfterUpdateInterface[Forward]
	OnAfterForwardDeleteCallback OnAfterDeleteInterface[Forward]
	OnAfterForwardReadCallback   OnAfterReadInterface[Forward]

	Frames           map[*Frame]any
	Frames_mapString map[string]*Frame

	// insertion point for slice of pointers maps
	Frame_Frame_note_reverseMap map[*Frame_note]*Frame

	OnAfterFrameCreateCallback OnAfterCreateInterface[Frame]
	OnAfterFrameUpdateCallback OnAfterUpdateInterface[Frame]
	OnAfterFrameDeleteCallback OnAfterDeleteInterface[Frame]
	OnAfterFrameReadCallback   OnAfterReadInterface[Frame]

	Frame_notes           map[*Frame_note]any
	Frame_notes_mapString map[string]*Frame_note

	// insertion point for slice of pointers maps

	OnAfterFrame_noteCreateCallback OnAfterCreateInterface[Frame_note]
	OnAfterFrame_noteUpdateCallback OnAfterUpdateInterface[Frame_note]
	OnAfterFrame_noteDeleteCallback OnAfterDeleteInterface[Frame_note]
	OnAfterFrame_noteReadCallback   OnAfterReadInterface[Frame_note]

	Frets           map[*Fret]any
	Frets_mapString map[string]*Fret

	// insertion point for slice of pointers maps

	OnAfterFretCreateCallback OnAfterCreateInterface[Fret]
	OnAfterFretUpdateCallback OnAfterUpdateInterface[Fret]
	OnAfterFretDeleteCallback OnAfterDeleteInterface[Fret]
	OnAfterFretReadCallback   OnAfterReadInterface[Fret]

	Glasss           map[*Glass]any
	Glasss_mapString map[string]*Glass

	// insertion point for slice of pointers maps

	OnAfterGlassCreateCallback OnAfterCreateInterface[Glass]
	OnAfterGlassUpdateCallback OnAfterUpdateInterface[Glass]
	OnAfterGlassDeleteCallback OnAfterDeleteInterface[Glass]
	OnAfterGlassReadCallback   OnAfterReadInterface[Glass]

	Glissandos           map[*Glissando]any
	Glissandos_mapString map[string]*Glissando

	// insertion point for slice of pointers maps

	OnAfterGlissandoCreateCallback OnAfterCreateInterface[Glissando]
	OnAfterGlissandoUpdateCallback OnAfterUpdateInterface[Glissando]
	OnAfterGlissandoDeleteCallback OnAfterDeleteInterface[Glissando]
	OnAfterGlissandoReadCallback   OnAfterReadInterface[Glissando]

	Glyphs           map[*Glyph]any
	Glyphs_mapString map[string]*Glyph

	// insertion point for slice of pointers maps

	OnAfterGlyphCreateCallback OnAfterCreateInterface[Glyph]
	OnAfterGlyphUpdateCallback OnAfterUpdateInterface[Glyph]
	OnAfterGlyphDeleteCallback OnAfterDeleteInterface[Glyph]
	OnAfterGlyphReadCallback   OnAfterReadInterface[Glyph]

	Graces           map[*Grace]any
	Graces_mapString map[string]*Grace

	// insertion point for slice of pointers maps

	OnAfterGraceCreateCallback OnAfterCreateInterface[Grace]
	OnAfterGraceUpdateCallback OnAfterUpdateInterface[Grace]
	OnAfterGraceDeleteCallback OnAfterDeleteInterface[Grace]
	OnAfterGraceReadCallback   OnAfterReadInterface[Grace]

	Group_barlines           map[*Group_barline]any
	Group_barlines_mapString map[string]*Group_barline

	// insertion point for slice of pointers maps

	OnAfterGroup_barlineCreateCallback OnAfterCreateInterface[Group_barline]
	OnAfterGroup_barlineUpdateCallback OnAfterUpdateInterface[Group_barline]
	OnAfterGroup_barlineDeleteCallback OnAfterDeleteInterface[Group_barline]
	OnAfterGroup_barlineReadCallback   OnAfterReadInterface[Group_barline]

	Group_symbols           map[*Group_symbol]any
	Group_symbols_mapString map[string]*Group_symbol

	// insertion point for slice of pointers maps

	OnAfterGroup_symbolCreateCallback OnAfterCreateInterface[Group_symbol]
	OnAfterGroup_symbolUpdateCallback OnAfterUpdateInterface[Group_symbol]
	OnAfterGroup_symbolDeleteCallback OnAfterDeleteInterface[Group_symbol]
	OnAfterGroup_symbolReadCallback   OnAfterReadInterface[Group_symbol]

	Groupings           map[*Grouping]any
	Groupings_mapString map[string]*Grouping

	// insertion point for slice of pointers maps
	Grouping_Feature_reverseMap map[*Feature]*Grouping

	OnAfterGroupingCreateCallback OnAfterCreateInterface[Grouping]
	OnAfterGroupingUpdateCallback OnAfterUpdateInterface[Grouping]
	OnAfterGroupingDeleteCallback OnAfterDeleteInterface[Grouping]
	OnAfterGroupingReadCallback   OnAfterReadInterface[Grouping]

	Hammer_on_pull_offs           map[*Hammer_on_pull_off]any
	Hammer_on_pull_offs_mapString map[string]*Hammer_on_pull_off

	// insertion point for slice of pointers maps

	OnAfterHammer_on_pull_offCreateCallback OnAfterCreateInterface[Hammer_on_pull_off]
	OnAfterHammer_on_pull_offUpdateCallback OnAfterUpdateInterface[Hammer_on_pull_off]
	OnAfterHammer_on_pull_offDeleteCallback OnAfterDeleteInterface[Hammer_on_pull_off]
	OnAfterHammer_on_pull_offReadCallback   OnAfterReadInterface[Hammer_on_pull_off]

	Handbells           map[*Handbell]any
	Handbells_mapString map[string]*Handbell

	// insertion point for slice of pointers maps

	OnAfterHandbellCreateCallback OnAfterCreateInterface[Handbell]
	OnAfterHandbellUpdateCallback OnAfterUpdateInterface[Handbell]
	OnAfterHandbellDeleteCallback OnAfterDeleteInterface[Handbell]
	OnAfterHandbellReadCallback   OnAfterReadInterface[Handbell]

	Harmon_closeds           map[*Harmon_closed]any
	Harmon_closeds_mapString map[string]*Harmon_closed

	// insertion point for slice of pointers maps

	OnAfterHarmon_closedCreateCallback OnAfterCreateInterface[Harmon_closed]
	OnAfterHarmon_closedUpdateCallback OnAfterUpdateInterface[Harmon_closed]
	OnAfterHarmon_closedDeleteCallback OnAfterDeleteInterface[Harmon_closed]
	OnAfterHarmon_closedReadCallback   OnAfterReadInterface[Harmon_closed]

	Harmon_mutes           map[*Harmon_mute]any
	Harmon_mutes_mapString map[string]*Harmon_mute

	// insertion point for slice of pointers maps

	OnAfterHarmon_muteCreateCallback OnAfterCreateInterface[Harmon_mute]
	OnAfterHarmon_muteUpdateCallback OnAfterUpdateInterface[Harmon_mute]
	OnAfterHarmon_muteDeleteCallback OnAfterDeleteInterface[Harmon_mute]
	OnAfterHarmon_muteReadCallback   OnAfterReadInterface[Harmon_mute]

	Harmonics           map[*Harmonic]any
	Harmonics_mapString map[string]*Harmonic

	// insertion point for slice of pointers maps

	OnAfterHarmonicCreateCallback OnAfterCreateInterface[Harmonic]
	OnAfterHarmonicUpdateCallback OnAfterUpdateInterface[Harmonic]
	OnAfterHarmonicDeleteCallback OnAfterDeleteInterface[Harmonic]
	OnAfterHarmonicReadCallback   OnAfterReadInterface[Harmonic]

	Harmonys           map[*Harmony]any
	Harmonys_mapString map[string]*Harmony

	// insertion point for slice of pointers maps

	OnAfterHarmonyCreateCallback OnAfterCreateInterface[Harmony]
	OnAfterHarmonyUpdateCallback OnAfterUpdateInterface[Harmony]
	OnAfterHarmonyDeleteCallback OnAfterDeleteInterface[Harmony]
	OnAfterHarmonyReadCallback   OnAfterReadInterface[Harmony]

	Harmony_alters           map[*Harmony_alter]any
	Harmony_alters_mapString map[string]*Harmony_alter

	// insertion point for slice of pointers maps

	OnAfterHarmony_alterCreateCallback OnAfterCreateInterface[Harmony_alter]
	OnAfterHarmony_alterUpdateCallback OnAfterUpdateInterface[Harmony_alter]
	OnAfterHarmony_alterDeleteCallback OnAfterDeleteInterface[Harmony_alter]
	OnAfterHarmony_alterReadCallback   OnAfterReadInterface[Harmony_alter]

	Harp_pedalss           map[*Harp_pedals]any
	Harp_pedalss_mapString map[string]*Harp_pedals

	// insertion point for slice of pointers maps
	Harp_pedals_Pedal_tuning_reverseMap map[*Pedal_tuning]*Harp_pedals

	OnAfterHarp_pedalsCreateCallback OnAfterCreateInterface[Harp_pedals]
	OnAfterHarp_pedalsUpdateCallback OnAfterUpdateInterface[Harp_pedals]
	OnAfterHarp_pedalsDeleteCallback OnAfterDeleteInterface[Harp_pedals]
	OnAfterHarp_pedalsReadCallback   OnAfterReadInterface[Harp_pedals]

	Heel_toes           map[*Heel_toe]any
	Heel_toes_mapString map[string]*Heel_toe

	// insertion point for slice of pointers maps

	OnAfterHeel_toeCreateCallback OnAfterCreateInterface[Heel_toe]
	OnAfterHeel_toeUpdateCallback OnAfterUpdateInterface[Heel_toe]
	OnAfterHeel_toeDeleteCallback OnAfterDeleteInterface[Heel_toe]
	OnAfterHeel_toeReadCallback   OnAfterReadInterface[Heel_toe]

	Holes           map[*Hole]any
	Holes_mapString map[string]*Hole

	// insertion point for slice of pointers maps

	OnAfterHoleCreateCallback OnAfterCreateInterface[Hole]
	OnAfterHoleUpdateCallback OnAfterUpdateInterface[Hole]
	OnAfterHoleDeleteCallback OnAfterDeleteInterface[Hole]
	OnAfterHoleReadCallback   OnAfterReadInterface[Hole]

	Hole_closeds           map[*Hole_closed]any
	Hole_closeds_mapString map[string]*Hole_closed

	// insertion point for slice of pointers maps

	OnAfterHole_closedCreateCallback OnAfterCreateInterface[Hole_closed]
	OnAfterHole_closedUpdateCallback OnAfterUpdateInterface[Hole_closed]
	OnAfterHole_closedDeleteCallback OnAfterDeleteInterface[Hole_closed]
	OnAfterHole_closedReadCallback   OnAfterReadInterface[Hole_closed]

	Horizontal_turns           map[*Horizontal_turn]any
	Horizontal_turns_mapString map[string]*Horizontal_turn

	// insertion point for slice of pointers maps

	OnAfterHorizontal_turnCreateCallback OnAfterCreateInterface[Horizontal_turn]
	OnAfterHorizontal_turnUpdateCallback OnAfterUpdateInterface[Horizontal_turn]
	OnAfterHorizontal_turnDeleteCallback OnAfterDeleteInterface[Horizontal_turn]
	OnAfterHorizontal_turnReadCallback   OnAfterReadInterface[Horizontal_turn]

	Identifications           map[*Identification]any
	Identifications_mapString map[string]*Identification

	// insertion point for slice of pointers maps
	Identification_Creator_reverseMap  map[*Typed_text]*Identification
	Identification_Rights_reverseMap   map[*Typed_text]*Identification
	Identification_Relation_reverseMap map[*Typed_text]*Identification

	OnAfterIdentificationCreateCallback OnAfterCreateInterface[Identification]
	OnAfterIdentificationUpdateCallback OnAfterUpdateInterface[Identification]
	OnAfterIdentificationDeleteCallback OnAfterDeleteInterface[Identification]
	OnAfterIdentificationReadCallback   OnAfterReadInterface[Identification]

	Images           map[*Image]any
	Images_mapString map[string]*Image

	// insertion point for slice of pointers maps

	OnAfterImageCreateCallback OnAfterCreateInterface[Image]
	OnAfterImageUpdateCallback OnAfterUpdateInterface[Image]
	OnAfterImageDeleteCallback OnAfterDeleteInterface[Image]
	OnAfterImageReadCallback   OnAfterReadInterface[Image]

	Instruments           map[*Instrument]any
	Instruments_mapString map[string]*Instrument

	// insertion point for slice of pointers maps

	OnAfterInstrumentCreateCallback OnAfterCreateInterface[Instrument]
	OnAfterInstrumentUpdateCallback OnAfterUpdateInterface[Instrument]
	OnAfterInstrumentDeleteCallback OnAfterDeleteInterface[Instrument]
	OnAfterInstrumentReadCallback   OnAfterReadInterface[Instrument]

	Instrument_changes           map[*Instrument_change]any
	Instrument_changes_mapString map[string]*Instrument_change

	// insertion point for slice of pointers maps

	OnAfterInstrument_changeCreateCallback OnAfterCreateInterface[Instrument_change]
	OnAfterInstrument_changeUpdateCallback OnAfterUpdateInterface[Instrument_change]
	OnAfterInstrument_changeDeleteCallback OnAfterDeleteInterface[Instrument_change]
	OnAfterInstrument_changeReadCallback   OnAfterReadInterface[Instrument_change]

	Instrument_links           map[*Instrument_link]any
	Instrument_links_mapString map[string]*Instrument_link

	// insertion point for slice of pointers maps

	OnAfterInstrument_linkCreateCallback OnAfterCreateInterface[Instrument_link]
	OnAfterInstrument_linkUpdateCallback OnAfterUpdateInterface[Instrument_link]
	OnAfterInstrument_linkDeleteCallback OnAfterDeleteInterface[Instrument_link]
	OnAfterInstrument_linkReadCallback   OnAfterReadInterface[Instrument_link]

	Interchangeables           map[*Interchangeable]any
	Interchangeables_mapString map[string]*Interchangeable

	// insertion point for slice of pointers maps

	OnAfterInterchangeableCreateCallback OnAfterCreateInterface[Interchangeable]
	OnAfterInterchangeableUpdateCallback OnAfterUpdateInterface[Interchangeable]
	OnAfterInterchangeableDeleteCallback OnAfterDeleteInterface[Interchangeable]
	OnAfterInterchangeableReadCallback   OnAfterReadInterface[Interchangeable]

	Inversions           map[*Inversion]any
	Inversions_mapString map[string]*Inversion

	// insertion point for slice of pointers maps

	OnAfterInversionCreateCallback OnAfterCreateInterface[Inversion]
	OnAfterInversionUpdateCallback OnAfterUpdateInterface[Inversion]
	OnAfterInversionDeleteCallback OnAfterDeleteInterface[Inversion]
	OnAfterInversionReadCallback   OnAfterReadInterface[Inversion]

	Keys           map[*Key]any
	Keys_mapString map[string]*Key

	// insertion point for slice of pointers maps
	Key_Key_octave_reverseMap map[*Key_octave]*Key

	OnAfterKeyCreateCallback OnAfterCreateInterface[Key]
	OnAfterKeyUpdateCallback OnAfterUpdateInterface[Key]
	OnAfterKeyDeleteCallback OnAfterDeleteInterface[Key]
	OnAfterKeyReadCallback   OnAfterReadInterface[Key]

	Key_accidentals           map[*Key_accidental]any
	Key_accidentals_mapString map[string]*Key_accidental

	// insertion point for slice of pointers maps

	OnAfterKey_accidentalCreateCallback OnAfterCreateInterface[Key_accidental]
	OnAfterKey_accidentalUpdateCallback OnAfterUpdateInterface[Key_accidental]
	OnAfterKey_accidentalDeleteCallback OnAfterDeleteInterface[Key_accidental]
	OnAfterKey_accidentalReadCallback   OnAfterReadInterface[Key_accidental]

	Key_octaves           map[*Key_octave]any
	Key_octaves_mapString map[string]*Key_octave

	// insertion point for slice of pointers maps

	OnAfterKey_octaveCreateCallback OnAfterCreateInterface[Key_octave]
	OnAfterKey_octaveUpdateCallback OnAfterUpdateInterface[Key_octave]
	OnAfterKey_octaveDeleteCallback OnAfterDeleteInterface[Key_octave]
	OnAfterKey_octaveReadCallback   OnAfterReadInterface[Key_octave]

	Kinds           map[*Kind]any
	Kinds_mapString map[string]*Kind

	// insertion point for slice of pointers maps

	OnAfterKindCreateCallback OnAfterCreateInterface[Kind]
	OnAfterKindUpdateCallback OnAfterUpdateInterface[Kind]
	OnAfterKindDeleteCallback OnAfterDeleteInterface[Kind]
	OnAfterKindReadCallback   OnAfterReadInterface[Kind]

	Levels           map[*Level]any
	Levels_mapString map[string]*Level

	// insertion point for slice of pointers maps

	OnAfterLevelCreateCallback OnAfterCreateInterface[Level]
	OnAfterLevelUpdateCallback OnAfterUpdateInterface[Level]
	OnAfterLevelDeleteCallback OnAfterDeleteInterface[Level]
	OnAfterLevelReadCallback   OnAfterReadInterface[Level]

	Line_details           map[*Line_detail]any
	Line_details_mapString map[string]*Line_detail

	// insertion point for slice of pointers maps

	OnAfterLine_detailCreateCallback OnAfterCreateInterface[Line_detail]
	OnAfterLine_detailUpdateCallback OnAfterUpdateInterface[Line_detail]
	OnAfterLine_detailDeleteCallback OnAfterDeleteInterface[Line_detail]
	OnAfterLine_detailReadCallback   OnAfterReadInterface[Line_detail]

	Line_widths           map[*Line_width]any
	Line_widths_mapString map[string]*Line_width

	// insertion point for slice of pointers maps

	OnAfterLine_widthCreateCallback OnAfterCreateInterface[Line_width]
	OnAfterLine_widthUpdateCallback OnAfterUpdateInterface[Line_width]
	OnAfterLine_widthDeleteCallback OnAfterDeleteInterface[Line_width]
	OnAfterLine_widthReadCallback   OnAfterReadInterface[Line_width]

	Links           map[*Link]any
	Links_mapString map[string]*Link

	// insertion point for slice of pointers maps

	OnAfterLinkCreateCallback OnAfterCreateInterface[Link]
	OnAfterLinkUpdateCallback OnAfterUpdateInterface[Link]
	OnAfterLinkDeleteCallback OnAfterDeleteInterface[Link]
	OnAfterLinkReadCallback   OnAfterReadInterface[Link]

	Listens           map[*Listen]any
	Listens_mapString map[string]*Listen

	// insertion point for slice of pointers maps

	OnAfterListenCreateCallback OnAfterCreateInterface[Listen]
	OnAfterListenUpdateCallback OnAfterUpdateInterface[Listen]
	OnAfterListenDeleteCallback OnAfterDeleteInterface[Listen]
	OnAfterListenReadCallback   OnAfterReadInterface[Listen]

	Listenings           map[*Listening]any
	Listenings_mapString map[string]*Listening

	// insertion point for slice of pointers maps

	OnAfterListeningCreateCallback OnAfterCreateInterface[Listening]
	OnAfterListeningUpdateCallback OnAfterUpdateInterface[Listening]
	OnAfterListeningDeleteCallback OnAfterDeleteInterface[Listening]
	OnAfterListeningReadCallback   OnAfterReadInterface[Listening]

	Lyrics           map[*Lyric]any
	Lyrics_mapString map[string]*Lyric

	// insertion point for slice of pointers maps

	OnAfterLyricCreateCallback OnAfterCreateInterface[Lyric]
	OnAfterLyricUpdateCallback OnAfterUpdateInterface[Lyric]
	OnAfterLyricDeleteCallback OnAfterDeleteInterface[Lyric]
	OnAfterLyricReadCallback   OnAfterReadInterface[Lyric]

	Lyric_fonts           map[*Lyric_font]any
	Lyric_fonts_mapString map[string]*Lyric_font

	// insertion point for slice of pointers maps

	OnAfterLyric_fontCreateCallback OnAfterCreateInterface[Lyric_font]
	OnAfterLyric_fontUpdateCallback OnAfterUpdateInterface[Lyric_font]
	OnAfterLyric_fontDeleteCallback OnAfterDeleteInterface[Lyric_font]
	OnAfterLyric_fontReadCallback   OnAfterReadInterface[Lyric_font]

	Lyric_languages           map[*Lyric_language]any
	Lyric_languages_mapString map[string]*Lyric_language

	// insertion point for slice of pointers maps

	OnAfterLyric_languageCreateCallback OnAfterCreateInterface[Lyric_language]
	OnAfterLyric_languageUpdateCallback OnAfterUpdateInterface[Lyric_language]
	OnAfterLyric_languageDeleteCallback OnAfterDeleteInterface[Lyric_language]
	OnAfterLyric_languageReadCallback   OnAfterReadInterface[Lyric_language]

	Measure_layouts           map[*Measure_layout]any
	Measure_layouts_mapString map[string]*Measure_layout

	// insertion point for slice of pointers maps

	OnAfterMeasure_layoutCreateCallback OnAfterCreateInterface[Measure_layout]
	OnAfterMeasure_layoutUpdateCallback OnAfterUpdateInterface[Measure_layout]
	OnAfterMeasure_layoutDeleteCallback OnAfterDeleteInterface[Measure_layout]
	OnAfterMeasure_layoutReadCallback   OnAfterReadInterface[Measure_layout]

	Measure_numberings           map[*Measure_numbering]any
	Measure_numberings_mapString map[string]*Measure_numbering

	// insertion point for slice of pointers maps

	OnAfterMeasure_numberingCreateCallback OnAfterCreateInterface[Measure_numbering]
	OnAfterMeasure_numberingUpdateCallback OnAfterUpdateInterface[Measure_numbering]
	OnAfterMeasure_numberingDeleteCallback OnAfterDeleteInterface[Measure_numbering]
	OnAfterMeasure_numberingReadCallback   OnAfterReadInterface[Measure_numbering]

	Measure_repeats           map[*Measure_repeat]any
	Measure_repeats_mapString map[string]*Measure_repeat

	// insertion point for slice of pointers maps

	OnAfterMeasure_repeatCreateCallback OnAfterCreateInterface[Measure_repeat]
	OnAfterMeasure_repeatUpdateCallback OnAfterUpdateInterface[Measure_repeat]
	OnAfterMeasure_repeatDeleteCallback OnAfterDeleteInterface[Measure_repeat]
	OnAfterMeasure_repeatReadCallback   OnAfterReadInterface[Measure_repeat]

	Measure_styles           map[*Measure_style]any
	Measure_styles_mapString map[string]*Measure_style

	// insertion point for slice of pointers maps

	OnAfterMeasure_styleCreateCallback OnAfterCreateInterface[Measure_style]
	OnAfterMeasure_styleUpdateCallback OnAfterUpdateInterface[Measure_style]
	OnAfterMeasure_styleDeleteCallback OnAfterDeleteInterface[Measure_style]
	OnAfterMeasure_styleReadCallback   OnAfterReadInterface[Measure_style]

	Membranes           map[*Membrane]any
	Membranes_mapString map[string]*Membrane

	// insertion point for slice of pointers maps

	OnAfterMembraneCreateCallback OnAfterCreateInterface[Membrane]
	OnAfterMembraneUpdateCallback OnAfterUpdateInterface[Membrane]
	OnAfterMembraneDeleteCallback OnAfterDeleteInterface[Membrane]
	OnAfterMembraneReadCallback   OnAfterReadInterface[Membrane]

	Metals           map[*Metal]any
	Metals_mapString map[string]*Metal

	// insertion point for slice of pointers maps

	OnAfterMetalCreateCallback OnAfterCreateInterface[Metal]
	OnAfterMetalUpdateCallback OnAfterUpdateInterface[Metal]
	OnAfterMetalDeleteCallback OnAfterDeleteInterface[Metal]
	OnAfterMetalReadCallback   OnAfterReadInterface[Metal]

	Metronomes           map[*Metronome]any
	Metronomes_mapString map[string]*Metronome

	// insertion point for slice of pointers maps

	OnAfterMetronomeCreateCallback OnAfterCreateInterface[Metronome]
	OnAfterMetronomeUpdateCallback OnAfterUpdateInterface[Metronome]
	OnAfterMetronomeDeleteCallback OnAfterDeleteInterface[Metronome]
	OnAfterMetronomeReadCallback   OnAfterReadInterface[Metronome]

	Metronome_beams           map[*Metronome_beam]any
	Metronome_beams_mapString map[string]*Metronome_beam

	// insertion point for slice of pointers maps

	OnAfterMetronome_beamCreateCallback OnAfterCreateInterface[Metronome_beam]
	OnAfterMetronome_beamUpdateCallback OnAfterUpdateInterface[Metronome_beam]
	OnAfterMetronome_beamDeleteCallback OnAfterDeleteInterface[Metronome_beam]
	OnAfterMetronome_beamReadCallback   OnAfterReadInterface[Metronome_beam]

	Metronome_notes           map[*Metronome_note]any
	Metronome_notes_mapString map[string]*Metronome_note

	// insertion point for slice of pointers maps
	Metronome_note_Metronome_dot_reverseMap  map[*Empty]*Metronome_note
	Metronome_note_Metronome_beam_reverseMap map[*Metronome_beam]*Metronome_note

	OnAfterMetronome_noteCreateCallback OnAfterCreateInterface[Metronome_note]
	OnAfterMetronome_noteUpdateCallback OnAfterUpdateInterface[Metronome_note]
	OnAfterMetronome_noteDeleteCallback OnAfterDeleteInterface[Metronome_note]
	OnAfterMetronome_noteReadCallback   OnAfterReadInterface[Metronome_note]

	Metronome_tieds           map[*Metronome_tied]any
	Metronome_tieds_mapString map[string]*Metronome_tied

	// insertion point for slice of pointers maps

	OnAfterMetronome_tiedCreateCallback OnAfterCreateInterface[Metronome_tied]
	OnAfterMetronome_tiedUpdateCallback OnAfterUpdateInterface[Metronome_tied]
	OnAfterMetronome_tiedDeleteCallback OnAfterDeleteInterface[Metronome_tied]
	OnAfterMetronome_tiedReadCallback   OnAfterReadInterface[Metronome_tied]

	Metronome_tuplets           map[*Metronome_tuplet]any
	Metronome_tuplets_mapString map[string]*Metronome_tuplet

	// insertion point for slice of pointers maps

	OnAfterMetronome_tupletCreateCallback OnAfterCreateInterface[Metronome_tuplet]
	OnAfterMetronome_tupletUpdateCallback OnAfterUpdateInterface[Metronome_tuplet]
	OnAfterMetronome_tupletDeleteCallback OnAfterDeleteInterface[Metronome_tuplet]
	OnAfterMetronome_tupletReadCallback   OnAfterReadInterface[Metronome_tuplet]

	Midi_devices           map[*Midi_device]any
	Midi_devices_mapString map[string]*Midi_device

	// insertion point for slice of pointers maps

	OnAfterMidi_deviceCreateCallback OnAfterCreateInterface[Midi_device]
	OnAfterMidi_deviceUpdateCallback OnAfterUpdateInterface[Midi_device]
	OnAfterMidi_deviceDeleteCallback OnAfterDeleteInterface[Midi_device]
	OnAfterMidi_deviceReadCallback   OnAfterReadInterface[Midi_device]

	Midi_instruments           map[*Midi_instrument]any
	Midi_instruments_mapString map[string]*Midi_instrument

	// insertion point for slice of pointers maps

	OnAfterMidi_instrumentCreateCallback OnAfterCreateInterface[Midi_instrument]
	OnAfterMidi_instrumentUpdateCallback OnAfterUpdateInterface[Midi_instrument]
	OnAfterMidi_instrumentDeleteCallback OnAfterDeleteInterface[Midi_instrument]
	OnAfterMidi_instrumentReadCallback   OnAfterReadInterface[Midi_instrument]

	Miscellaneouss           map[*Miscellaneous]any
	Miscellaneouss_mapString map[string]*Miscellaneous

	// insertion point for slice of pointers maps
	Miscellaneous_Miscellaneous_field_reverseMap map[*Miscellaneous_field]*Miscellaneous

	OnAfterMiscellaneousCreateCallback OnAfterCreateInterface[Miscellaneous]
	OnAfterMiscellaneousUpdateCallback OnAfterUpdateInterface[Miscellaneous]
	OnAfterMiscellaneousDeleteCallback OnAfterDeleteInterface[Miscellaneous]
	OnAfterMiscellaneousReadCallback   OnAfterReadInterface[Miscellaneous]

	Miscellaneous_fields           map[*Miscellaneous_field]any
	Miscellaneous_fields_mapString map[string]*Miscellaneous_field

	// insertion point for slice of pointers maps

	OnAfterMiscellaneous_fieldCreateCallback OnAfterCreateInterface[Miscellaneous_field]
	OnAfterMiscellaneous_fieldUpdateCallback OnAfterUpdateInterface[Miscellaneous_field]
	OnAfterMiscellaneous_fieldDeleteCallback OnAfterDeleteInterface[Miscellaneous_field]
	OnAfterMiscellaneous_fieldReadCallback   OnAfterReadInterface[Miscellaneous_field]

	Mordents           map[*Mordent]any
	Mordents_mapString map[string]*Mordent

	// insertion point for slice of pointers maps

	OnAfterMordentCreateCallback OnAfterCreateInterface[Mordent]
	OnAfterMordentUpdateCallback OnAfterUpdateInterface[Mordent]
	OnAfterMordentDeleteCallback OnAfterDeleteInterface[Mordent]
	OnAfterMordentReadCallback   OnAfterReadInterface[Mordent]

	Multiple_rests           map[*Multiple_rest]any
	Multiple_rests_mapString map[string]*Multiple_rest

	// insertion point for slice of pointers maps

	OnAfterMultiple_restCreateCallback OnAfterCreateInterface[Multiple_rest]
	OnAfterMultiple_restUpdateCallback OnAfterUpdateInterface[Multiple_rest]
	OnAfterMultiple_restDeleteCallback OnAfterDeleteInterface[Multiple_rest]
	OnAfterMultiple_restReadCallback   OnAfterReadInterface[Multiple_rest]

	Name_displays           map[*Name_display]any
	Name_displays_mapString map[string]*Name_display

	// insertion point for slice of pointers maps

	OnAfterName_displayCreateCallback OnAfterCreateInterface[Name_display]
	OnAfterName_displayUpdateCallback OnAfterUpdateInterface[Name_display]
	OnAfterName_displayDeleteCallback OnAfterDeleteInterface[Name_display]
	OnAfterName_displayReadCallback   OnAfterReadInterface[Name_display]

	Non_arpeggiates           map[*Non_arpeggiate]any
	Non_arpeggiates_mapString map[string]*Non_arpeggiate

	// insertion point for slice of pointers maps

	OnAfterNon_arpeggiateCreateCallback OnAfterCreateInterface[Non_arpeggiate]
	OnAfterNon_arpeggiateUpdateCallback OnAfterUpdateInterface[Non_arpeggiate]
	OnAfterNon_arpeggiateDeleteCallback OnAfterDeleteInterface[Non_arpeggiate]
	OnAfterNon_arpeggiateReadCallback   OnAfterReadInterface[Non_arpeggiate]

	Notationss           map[*Notations]any
	Notationss_mapString map[string]*Notations

	// insertion point for slice of pointers maps

	OnAfterNotationsCreateCallback OnAfterCreateInterface[Notations]
	OnAfterNotationsUpdateCallback OnAfterUpdateInterface[Notations]
	OnAfterNotationsDeleteCallback OnAfterDeleteInterface[Notations]
	OnAfterNotationsReadCallback   OnAfterReadInterface[Notations]

	Notes           map[*Note]any
	Notes_mapString map[string]*Note

	// insertion point for slice of pointers maps
	Note_Instrument_reverseMap map[*Instrument]*Note
	Note_Dot_reverseMap        map[*Empty_placement]*Note
	Note_Notations_reverseMap  map[*Notations]*Note
	Note_Lyric_reverseMap      map[*Lyric]*Note

	OnAfterNoteCreateCallback OnAfterCreateInterface[Note]
	OnAfterNoteUpdateCallback OnAfterUpdateInterface[Note]
	OnAfterNoteDeleteCallback OnAfterDeleteInterface[Note]
	OnAfterNoteReadCallback   OnAfterReadInterface[Note]

	Note_sizes           map[*Note_size]any
	Note_sizes_mapString map[string]*Note_size

	// insertion point for slice of pointers maps

	OnAfterNote_sizeCreateCallback OnAfterCreateInterface[Note_size]
	OnAfterNote_sizeUpdateCallback OnAfterUpdateInterface[Note_size]
	OnAfterNote_sizeDeleteCallback OnAfterDeleteInterface[Note_size]
	OnAfterNote_sizeReadCallback   OnAfterReadInterface[Note_size]

	Note_types           map[*Note_type]any
	Note_types_mapString map[string]*Note_type

	// insertion point for slice of pointers maps

	OnAfterNote_typeCreateCallback OnAfterCreateInterface[Note_type]
	OnAfterNote_typeUpdateCallback OnAfterUpdateInterface[Note_type]
	OnAfterNote_typeDeleteCallback OnAfterDeleteInterface[Note_type]
	OnAfterNote_typeReadCallback   OnAfterReadInterface[Note_type]

	Noteheads           map[*Notehead]any
	Noteheads_mapString map[string]*Notehead

	// insertion point for slice of pointers maps

	OnAfterNoteheadCreateCallback OnAfterCreateInterface[Notehead]
	OnAfterNoteheadUpdateCallback OnAfterUpdateInterface[Notehead]
	OnAfterNoteheadDeleteCallback OnAfterDeleteInterface[Notehead]
	OnAfterNoteheadReadCallback   OnAfterReadInterface[Notehead]

	Notehead_texts           map[*Notehead_text]any
	Notehead_texts_mapString map[string]*Notehead_text

	// insertion point for slice of pointers maps

	OnAfterNotehead_textCreateCallback OnAfterCreateInterface[Notehead_text]
	OnAfterNotehead_textUpdateCallback OnAfterUpdateInterface[Notehead_text]
	OnAfterNotehead_textDeleteCallback OnAfterDeleteInterface[Notehead_text]
	OnAfterNotehead_textReadCallback   OnAfterReadInterface[Notehead_text]

	Numerals           map[*Numeral]any
	Numerals_mapString map[string]*Numeral

	// insertion point for slice of pointers maps

	OnAfterNumeralCreateCallback OnAfterCreateInterface[Numeral]
	OnAfterNumeralUpdateCallback OnAfterUpdateInterface[Numeral]
	OnAfterNumeralDeleteCallback OnAfterDeleteInterface[Numeral]
	OnAfterNumeralReadCallback   OnAfterReadInterface[Numeral]

	Numeral_keys           map[*Numeral_key]any
	Numeral_keys_mapString map[string]*Numeral_key

	// insertion point for slice of pointers maps

	OnAfterNumeral_keyCreateCallback OnAfterCreateInterface[Numeral_key]
	OnAfterNumeral_keyUpdateCallback OnAfterUpdateInterface[Numeral_key]
	OnAfterNumeral_keyDeleteCallback OnAfterDeleteInterface[Numeral_key]
	OnAfterNumeral_keyReadCallback   OnAfterReadInterface[Numeral_key]

	Numeral_roots           map[*Numeral_root]any
	Numeral_roots_mapString map[string]*Numeral_root

	// insertion point for slice of pointers maps

	OnAfterNumeral_rootCreateCallback OnAfterCreateInterface[Numeral_root]
	OnAfterNumeral_rootUpdateCallback OnAfterUpdateInterface[Numeral_root]
	OnAfterNumeral_rootDeleteCallback OnAfterDeleteInterface[Numeral_root]
	OnAfterNumeral_rootReadCallback   OnAfterReadInterface[Numeral_root]

	Octave_shifts           map[*Octave_shift]any
	Octave_shifts_mapString map[string]*Octave_shift

	// insertion point for slice of pointers maps

	OnAfterOctave_shiftCreateCallback OnAfterCreateInterface[Octave_shift]
	OnAfterOctave_shiftUpdateCallback OnAfterUpdateInterface[Octave_shift]
	OnAfterOctave_shiftDeleteCallback OnAfterDeleteInterface[Octave_shift]
	OnAfterOctave_shiftReadCallback   OnAfterReadInterface[Octave_shift]

	Offsets           map[*Offset]any
	Offsets_mapString map[string]*Offset

	// insertion point for slice of pointers maps

	OnAfterOffsetCreateCallback OnAfterCreateInterface[Offset]
	OnAfterOffsetUpdateCallback OnAfterUpdateInterface[Offset]
	OnAfterOffsetDeleteCallback OnAfterDeleteInterface[Offset]
	OnAfterOffsetReadCallback   OnAfterReadInterface[Offset]

	Opuss           map[*Opus]any
	Opuss_mapString map[string]*Opus

	// insertion point for slice of pointers maps

	OnAfterOpusCreateCallback OnAfterCreateInterface[Opus]
	OnAfterOpusUpdateCallback OnAfterUpdateInterface[Opus]
	OnAfterOpusDeleteCallback OnAfterDeleteInterface[Opus]
	OnAfterOpusReadCallback   OnAfterReadInterface[Opus]

	Ornamentss           map[*Ornaments]any
	Ornamentss_mapString map[string]*Ornaments

	// insertion point for slice of pointers maps
	Ornaments_Accidental_mark_reverseMap map[*Accidental_mark]*Ornaments

	OnAfterOrnamentsCreateCallback OnAfterCreateInterface[Ornaments]
	OnAfterOrnamentsUpdateCallback OnAfterUpdateInterface[Ornaments]
	OnAfterOrnamentsDeleteCallback OnAfterDeleteInterface[Ornaments]
	OnAfterOrnamentsReadCallback   OnAfterReadInterface[Ornaments]

	Other_appearances           map[*Other_appearance]any
	Other_appearances_mapString map[string]*Other_appearance

	// insertion point for slice of pointers maps

	OnAfterOther_appearanceCreateCallback OnAfterCreateInterface[Other_appearance]
	OnAfterOther_appearanceUpdateCallback OnAfterUpdateInterface[Other_appearance]
	OnAfterOther_appearanceDeleteCallback OnAfterDeleteInterface[Other_appearance]
	OnAfterOther_appearanceReadCallback   OnAfterReadInterface[Other_appearance]

	Other_listenings           map[*Other_listening]any
	Other_listenings_mapString map[string]*Other_listening

	// insertion point for slice of pointers maps

	OnAfterOther_listeningCreateCallback OnAfterCreateInterface[Other_listening]
	OnAfterOther_listeningUpdateCallback OnAfterUpdateInterface[Other_listening]
	OnAfterOther_listeningDeleteCallback OnAfterDeleteInterface[Other_listening]
	OnAfterOther_listeningReadCallback   OnAfterReadInterface[Other_listening]

	Other_notations           map[*Other_notation]any
	Other_notations_mapString map[string]*Other_notation

	// insertion point for slice of pointers maps

	OnAfterOther_notationCreateCallback OnAfterCreateInterface[Other_notation]
	OnAfterOther_notationUpdateCallback OnAfterUpdateInterface[Other_notation]
	OnAfterOther_notationDeleteCallback OnAfterDeleteInterface[Other_notation]
	OnAfterOther_notationReadCallback   OnAfterReadInterface[Other_notation]

	Other_plays           map[*Other_play]any
	Other_plays_mapString map[string]*Other_play

	// insertion point for slice of pointers maps

	OnAfterOther_playCreateCallback OnAfterCreateInterface[Other_play]
	OnAfterOther_playUpdateCallback OnAfterUpdateInterface[Other_play]
	OnAfterOther_playDeleteCallback OnAfterDeleteInterface[Other_play]
	OnAfterOther_playReadCallback   OnAfterReadInterface[Other_play]

	Page_layouts           map[*Page_layout]any
	Page_layouts_mapString map[string]*Page_layout

	// insertion point for slice of pointers maps

	OnAfterPage_layoutCreateCallback OnAfterCreateInterface[Page_layout]
	OnAfterPage_layoutUpdateCallback OnAfterUpdateInterface[Page_layout]
	OnAfterPage_layoutDeleteCallback OnAfterDeleteInterface[Page_layout]
	OnAfterPage_layoutReadCallback   OnAfterReadInterface[Page_layout]

	Page_marginss           map[*Page_margins]any
	Page_marginss_mapString map[string]*Page_margins

	// insertion point for slice of pointers maps

	OnAfterPage_marginsCreateCallback OnAfterCreateInterface[Page_margins]
	OnAfterPage_marginsUpdateCallback OnAfterUpdateInterface[Page_margins]
	OnAfterPage_marginsDeleteCallback OnAfterDeleteInterface[Page_margins]
	OnAfterPage_marginsReadCallback   OnAfterReadInterface[Page_margins]

	Part_clefs           map[*Part_clef]any
	Part_clefs_mapString map[string]*Part_clef

	// insertion point for slice of pointers maps

	OnAfterPart_clefCreateCallback OnAfterCreateInterface[Part_clef]
	OnAfterPart_clefUpdateCallback OnAfterUpdateInterface[Part_clef]
	OnAfterPart_clefDeleteCallback OnAfterDeleteInterface[Part_clef]
	OnAfterPart_clefReadCallback   OnAfterReadInterface[Part_clef]

	Part_groups           map[*Part_group]any
	Part_groups_mapString map[string]*Part_group

	// insertion point for slice of pointers maps

	OnAfterPart_groupCreateCallback OnAfterCreateInterface[Part_group]
	OnAfterPart_groupUpdateCallback OnAfterUpdateInterface[Part_group]
	OnAfterPart_groupDeleteCallback OnAfterDeleteInterface[Part_group]
	OnAfterPart_groupReadCallback   OnAfterReadInterface[Part_group]

	Part_links           map[*Part_link]any
	Part_links_mapString map[string]*Part_link

	// insertion point for slice of pointers maps
	Part_link_Instrument_link_reverseMap map[*Instrument_link]*Part_link

	OnAfterPart_linkCreateCallback OnAfterCreateInterface[Part_link]
	OnAfterPart_linkUpdateCallback OnAfterUpdateInterface[Part_link]
	OnAfterPart_linkDeleteCallback OnAfterDeleteInterface[Part_link]
	OnAfterPart_linkReadCallback   OnAfterReadInterface[Part_link]

	Part_lists           map[*Part_list]any
	Part_lists_mapString map[string]*Part_list

	// insertion point for slice of pointers maps

	OnAfterPart_listCreateCallback OnAfterCreateInterface[Part_list]
	OnAfterPart_listUpdateCallback OnAfterUpdateInterface[Part_list]
	OnAfterPart_listDeleteCallback OnAfterDeleteInterface[Part_list]
	OnAfterPart_listReadCallback   OnAfterReadInterface[Part_list]

	Part_symbols           map[*Part_symbol]any
	Part_symbols_mapString map[string]*Part_symbol

	// insertion point for slice of pointers maps

	OnAfterPart_symbolCreateCallback OnAfterCreateInterface[Part_symbol]
	OnAfterPart_symbolUpdateCallback OnAfterUpdateInterface[Part_symbol]
	OnAfterPart_symbolDeleteCallback OnAfterDeleteInterface[Part_symbol]
	OnAfterPart_symbolReadCallback   OnAfterReadInterface[Part_symbol]

	Part_transposes           map[*Part_transpose]any
	Part_transposes_mapString map[string]*Part_transpose

	// insertion point for slice of pointers maps

	OnAfterPart_transposeCreateCallback OnAfterCreateInterface[Part_transpose]
	OnAfterPart_transposeUpdateCallback OnAfterUpdateInterface[Part_transpose]
	OnAfterPart_transposeDeleteCallback OnAfterDeleteInterface[Part_transpose]
	OnAfterPart_transposeReadCallback   OnAfterReadInterface[Part_transpose]

	Pedals           map[*Pedal]any
	Pedals_mapString map[string]*Pedal

	// insertion point for slice of pointers maps

	OnAfterPedalCreateCallback OnAfterCreateInterface[Pedal]
	OnAfterPedalUpdateCallback OnAfterUpdateInterface[Pedal]
	OnAfterPedalDeleteCallback OnAfterDeleteInterface[Pedal]
	OnAfterPedalReadCallback   OnAfterReadInterface[Pedal]

	Pedal_tunings           map[*Pedal_tuning]any
	Pedal_tunings_mapString map[string]*Pedal_tuning

	// insertion point for slice of pointers maps

	OnAfterPedal_tuningCreateCallback OnAfterCreateInterface[Pedal_tuning]
	OnAfterPedal_tuningUpdateCallback OnAfterUpdateInterface[Pedal_tuning]
	OnAfterPedal_tuningDeleteCallback OnAfterDeleteInterface[Pedal_tuning]
	OnAfterPedal_tuningReadCallback   OnAfterReadInterface[Pedal_tuning]

	Percussions           map[*Percussion]any
	Percussions_mapString map[string]*Percussion

	// insertion point for slice of pointers maps

	OnAfterPercussionCreateCallback OnAfterCreateInterface[Percussion]
	OnAfterPercussionUpdateCallback OnAfterUpdateInterface[Percussion]
	OnAfterPercussionDeleteCallback OnAfterDeleteInterface[Percussion]
	OnAfterPercussionReadCallback   OnAfterReadInterface[Percussion]

	Pitchs           map[*Pitch]any
	Pitchs_mapString map[string]*Pitch

	// insertion point for slice of pointers maps

	OnAfterPitchCreateCallback OnAfterCreateInterface[Pitch]
	OnAfterPitchUpdateCallback OnAfterUpdateInterface[Pitch]
	OnAfterPitchDeleteCallback OnAfterDeleteInterface[Pitch]
	OnAfterPitchReadCallback   OnAfterReadInterface[Pitch]

	Pitcheds           map[*Pitched]any
	Pitcheds_mapString map[string]*Pitched

	// insertion point for slice of pointers maps

	OnAfterPitchedCreateCallback OnAfterCreateInterface[Pitched]
	OnAfterPitchedUpdateCallback OnAfterUpdateInterface[Pitched]
	OnAfterPitchedDeleteCallback OnAfterDeleteInterface[Pitched]
	OnAfterPitchedReadCallback   OnAfterReadInterface[Pitched]

	Plays           map[*Play]any
	Plays_mapString map[string]*Play

	// insertion point for slice of pointers maps

	OnAfterPlayCreateCallback OnAfterCreateInterface[Play]
	OnAfterPlayUpdateCallback OnAfterUpdateInterface[Play]
	OnAfterPlayDeleteCallback OnAfterDeleteInterface[Play]
	OnAfterPlayReadCallback   OnAfterReadInterface[Play]

	Players           map[*Player]any
	Players_mapString map[string]*Player

	// insertion point for slice of pointers maps

	OnAfterPlayerCreateCallback OnAfterCreateInterface[Player]
	OnAfterPlayerUpdateCallback OnAfterUpdateInterface[Player]
	OnAfterPlayerDeleteCallback OnAfterDeleteInterface[Player]
	OnAfterPlayerReadCallback   OnAfterReadInterface[Player]

	Principal_voices           map[*Principal_voice]any
	Principal_voices_mapString map[string]*Principal_voice

	// insertion point for slice of pointers maps

	OnAfterPrincipal_voiceCreateCallback OnAfterCreateInterface[Principal_voice]
	OnAfterPrincipal_voiceUpdateCallback OnAfterUpdateInterface[Principal_voice]
	OnAfterPrincipal_voiceDeleteCallback OnAfterDeleteInterface[Principal_voice]
	OnAfterPrincipal_voiceReadCallback   OnAfterReadInterface[Principal_voice]

	Prints           map[*Print]any
	Prints_mapString map[string]*Print

	// insertion point for slice of pointers maps

	OnAfterPrintCreateCallback OnAfterCreateInterface[Print]
	OnAfterPrintUpdateCallback OnAfterUpdateInterface[Print]
	OnAfterPrintDeleteCallback OnAfterDeleteInterface[Print]
	OnAfterPrintReadCallback   OnAfterReadInterface[Print]

	Releases           map[*Release]any
	Releases_mapString map[string]*Release

	// insertion point for slice of pointers maps

	OnAfterReleaseCreateCallback OnAfterCreateInterface[Release]
	OnAfterReleaseUpdateCallback OnAfterUpdateInterface[Release]
	OnAfterReleaseDeleteCallback OnAfterDeleteInterface[Release]
	OnAfterReleaseReadCallback   OnAfterReadInterface[Release]

	Repeats           map[*Repeat]any
	Repeats_mapString map[string]*Repeat

	// insertion point for slice of pointers maps

	OnAfterRepeatCreateCallback OnAfterCreateInterface[Repeat]
	OnAfterRepeatUpdateCallback OnAfterUpdateInterface[Repeat]
	OnAfterRepeatDeleteCallback OnAfterDeleteInterface[Repeat]
	OnAfterRepeatReadCallback   OnAfterReadInterface[Repeat]

	Rests           map[*Rest]any
	Rests_mapString map[string]*Rest

	// insertion point for slice of pointers maps

	OnAfterRestCreateCallback OnAfterCreateInterface[Rest]
	OnAfterRestUpdateCallback OnAfterUpdateInterface[Rest]
	OnAfterRestDeleteCallback OnAfterDeleteInterface[Rest]
	OnAfterRestReadCallback   OnAfterReadInterface[Rest]

	Roots           map[*Root]any
	Roots_mapString map[string]*Root

	// insertion point for slice of pointers maps

	OnAfterRootCreateCallback OnAfterCreateInterface[Root]
	OnAfterRootUpdateCallback OnAfterUpdateInterface[Root]
	OnAfterRootDeleteCallback OnAfterDeleteInterface[Root]
	OnAfterRootReadCallback   OnAfterReadInterface[Root]

	Root_steps           map[*Root_step]any
	Root_steps_mapString map[string]*Root_step

	// insertion point for slice of pointers maps

	OnAfterRoot_stepCreateCallback OnAfterCreateInterface[Root_step]
	OnAfterRoot_stepUpdateCallback OnAfterUpdateInterface[Root_step]
	OnAfterRoot_stepDeleteCallback OnAfterDeleteInterface[Root_step]
	OnAfterRoot_stepReadCallback   OnAfterReadInterface[Root_step]

	Scalings           map[*Scaling]any
	Scalings_mapString map[string]*Scaling

	// insertion point for slice of pointers maps

	OnAfterScalingCreateCallback OnAfterCreateInterface[Scaling]
	OnAfterScalingUpdateCallback OnAfterUpdateInterface[Scaling]
	OnAfterScalingDeleteCallback OnAfterDeleteInterface[Scaling]
	OnAfterScalingReadCallback   OnAfterReadInterface[Scaling]

	Scordaturas           map[*Scordatura]any
	Scordaturas_mapString map[string]*Scordatura

	// insertion point for slice of pointers maps
	Scordatura_Accord_reverseMap map[*Accord]*Scordatura

	OnAfterScordaturaCreateCallback OnAfterCreateInterface[Scordatura]
	OnAfterScordaturaUpdateCallback OnAfterUpdateInterface[Scordatura]
	OnAfterScordaturaDeleteCallback OnAfterDeleteInterface[Scordatura]
	OnAfterScordaturaReadCallback   OnAfterReadInterface[Scordatura]

	Score_instruments           map[*Score_instrument]any
	Score_instruments_mapString map[string]*Score_instrument

	// insertion point for slice of pointers maps

	OnAfterScore_instrumentCreateCallback OnAfterCreateInterface[Score_instrument]
	OnAfterScore_instrumentUpdateCallback OnAfterUpdateInterface[Score_instrument]
	OnAfterScore_instrumentDeleteCallback OnAfterDeleteInterface[Score_instrument]
	OnAfterScore_instrumentReadCallback   OnAfterReadInterface[Score_instrument]

	Score_parts           map[*Score_part]any
	Score_parts_mapString map[string]*Score_part

	// insertion point for slice of pointers maps
	Score_part_Part_link_reverseMap        map[*Part_link]*Score_part
	Score_part_Score_instrument_reverseMap map[*Score_instrument]*Score_part
	Score_part_Player_reverseMap           map[*Player]*Score_part

	OnAfterScore_partCreateCallback OnAfterCreateInterface[Score_part]
	OnAfterScore_partUpdateCallback OnAfterUpdateInterface[Score_part]
	OnAfterScore_partDeleteCallback OnAfterDeleteInterface[Score_part]
	OnAfterScore_partReadCallback   OnAfterReadInterface[Score_part]

	Score_partwises           map[*Score_partwise]any
	Score_partwises_mapString map[string]*Score_partwise

	// insertion point for slice of pointers maps

	OnAfterScore_partwiseCreateCallback OnAfterCreateInterface[Score_partwise]
	OnAfterScore_partwiseUpdateCallback OnAfterUpdateInterface[Score_partwise]
	OnAfterScore_partwiseDeleteCallback OnAfterDeleteInterface[Score_partwise]
	OnAfterScore_partwiseReadCallback   OnAfterReadInterface[Score_partwise]

	Score_timewises           map[*Score_timewise]any
	Score_timewises_mapString map[string]*Score_timewise

	// insertion point for slice of pointers maps

	OnAfterScore_timewiseCreateCallback OnAfterCreateInterface[Score_timewise]
	OnAfterScore_timewiseUpdateCallback OnAfterUpdateInterface[Score_timewise]
	OnAfterScore_timewiseDeleteCallback OnAfterDeleteInterface[Score_timewise]
	OnAfterScore_timewiseReadCallback   OnAfterReadInterface[Score_timewise]

	Segnos           map[*Segno]any
	Segnos_mapString map[string]*Segno

	// insertion point for slice of pointers maps

	OnAfterSegnoCreateCallback OnAfterCreateInterface[Segno]
	OnAfterSegnoUpdateCallback OnAfterUpdateInterface[Segno]
	OnAfterSegnoDeleteCallback OnAfterDeleteInterface[Segno]
	OnAfterSegnoReadCallback   OnAfterReadInterface[Segno]

	Slashs           map[*Slash]any
	Slashs_mapString map[string]*Slash

	// insertion point for slice of pointers maps

	OnAfterSlashCreateCallback OnAfterCreateInterface[Slash]
	OnAfterSlashUpdateCallback OnAfterUpdateInterface[Slash]
	OnAfterSlashDeleteCallback OnAfterDeleteInterface[Slash]
	OnAfterSlashReadCallback   OnAfterReadInterface[Slash]

	Slides           map[*Slide]any
	Slides_mapString map[string]*Slide

	// insertion point for slice of pointers maps

	OnAfterSlideCreateCallback OnAfterCreateInterface[Slide]
	OnAfterSlideUpdateCallback OnAfterUpdateInterface[Slide]
	OnAfterSlideDeleteCallback OnAfterDeleteInterface[Slide]
	OnAfterSlideReadCallback   OnAfterReadInterface[Slide]

	Slurs           map[*Slur]any
	Slurs_mapString map[string]*Slur

	// insertion point for slice of pointers maps

	OnAfterSlurCreateCallback OnAfterCreateInterface[Slur]
	OnAfterSlurUpdateCallback OnAfterUpdateInterface[Slur]
	OnAfterSlurDeleteCallback OnAfterDeleteInterface[Slur]
	OnAfterSlurReadCallback   OnAfterReadInterface[Slur]

	Sounds           map[*Sound]any
	Sounds_mapString map[string]*Sound

	// insertion point for slice of pointers maps

	OnAfterSoundCreateCallback OnAfterCreateInterface[Sound]
	OnAfterSoundUpdateCallback OnAfterUpdateInterface[Sound]
	OnAfterSoundDeleteCallback OnAfterDeleteInterface[Sound]
	OnAfterSoundReadCallback   OnAfterReadInterface[Sound]

	Staff_detailss           map[*Staff_details]any
	Staff_detailss_mapString map[string]*Staff_details

	// insertion point for slice of pointers maps
	Staff_details_Staff_tuning_reverseMap map[*Staff_tuning]*Staff_details

	OnAfterStaff_detailsCreateCallback OnAfterCreateInterface[Staff_details]
	OnAfterStaff_detailsUpdateCallback OnAfterUpdateInterface[Staff_details]
	OnAfterStaff_detailsDeleteCallback OnAfterDeleteInterface[Staff_details]
	OnAfterStaff_detailsReadCallback   OnAfterReadInterface[Staff_details]

	Staff_divides           map[*Staff_divide]any
	Staff_divides_mapString map[string]*Staff_divide

	// insertion point for slice of pointers maps

	OnAfterStaff_divideCreateCallback OnAfterCreateInterface[Staff_divide]
	OnAfterStaff_divideUpdateCallback OnAfterUpdateInterface[Staff_divide]
	OnAfterStaff_divideDeleteCallback OnAfterDeleteInterface[Staff_divide]
	OnAfterStaff_divideReadCallback   OnAfterReadInterface[Staff_divide]

	Staff_layouts           map[*Staff_layout]any
	Staff_layouts_mapString map[string]*Staff_layout

	// insertion point for slice of pointers maps

	OnAfterStaff_layoutCreateCallback OnAfterCreateInterface[Staff_layout]
	OnAfterStaff_layoutUpdateCallback OnAfterUpdateInterface[Staff_layout]
	OnAfterStaff_layoutDeleteCallback OnAfterDeleteInterface[Staff_layout]
	OnAfterStaff_layoutReadCallback   OnAfterReadInterface[Staff_layout]

	Staff_sizes           map[*Staff_size]any
	Staff_sizes_mapString map[string]*Staff_size

	// insertion point for slice of pointers maps

	OnAfterStaff_sizeCreateCallback OnAfterCreateInterface[Staff_size]
	OnAfterStaff_sizeUpdateCallback OnAfterUpdateInterface[Staff_size]
	OnAfterStaff_sizeDeleteCallback OnAfterDeleteInterface[Staff_size]
	OnAfterStaff_sizeReadCallback   OnAfterReadInterface[Staff_size]

	Staff_tunings           map[*Staff_tuning]any
	Staff_tunings_mapString map[string]*Staff_tuning

	// insertion point for slice of pointers maps

	OnAfterStaff_tuningCreateCallback OnAfterCreateInterface[Staff_tuning]
	OnAfterStaff_tuningUpdateCallback OnAfterUpdateInterface[Staff_tuning]
	OnAfterStaff_tuningDeleteCallback OnAfterDeleteInterface[Staff_tuning]
	OnAfterStaff_tuningReadCallback   OnAfterReadInterface[Staff_tuning]

	Stems           map[*Stem]any
	Stems_mapString map[string]*Stem

	// insertion point for slice of pointers maps

	OnAfterStemCreateCallback OnAfterCreateInterface[Stem]
	OnAfterStemUpdateCallback OnAfterUpdateInterface[Stem]
	OnAfterStemDeleteCallback OnAfterDeleteInterface[Stem]
	OnAfterStemReadCallback   OnAfterReadInterface[Stem]

	Sticks           map[*Stick]any
	Sticks_mapString map[string]*Stick

	// insertion point for slice of pointers maps

	OnAfterStickCreateCallback OnAfterCreateInterface[Stick]
	OnAfterStickUpdateCallback OnAfterUpdateInterface[Stick]
	OnAfterStickDeleteCallback OnAfterDeleteInterface[Stick]
	OnAfterStickReadCallback   OnAfterReadInterface[Stick]

	String_mutes           map[*String_mute]any
	String_mutes_mapString map[string]*String_mute

	// insertion point for slice of pointers maps

	OnAfterString_muteCreateCallback OnAfterCreateInterface[String_mute]
	OnAfterString_muteUpdateCallback OnAfterUpdateInterface[String_mute]
	OnAfterString_muteDeleteCallback OnAfterDeleteInterface[String_mute]
	OnAfterString_muteReadCallback   OnAfterReadInterface[String_mute]

	Strong_accents           map[*Strong_accent]any
	Strong_accents_mapString map[string]*Strong_accent

	// insertion point for slice of pointers maps

	OnAfterStrong_accentCreateCallback OnAfterCreateInterface[Strong_accent]
	OnAfterStrong_accentUpdateCallback OnAfterUpdateInterface[Strong_accent]
	OnAfterStrong_accentDeleteCallback OnAfterDeleteInterface[Strong_accent]
	OnAfterStrong_accentReadCallback   OnAfterReadInterface[Strong_accent]

	Supportss           map[*Supports]any
	Supportss_mapString map[string]*Supports

	// insertion point for slice of pointers maps

	OnAfterSupportsCreateCallback OnAfterCreateInterface[Supports]
	OnAfterSupportsUpdateCallback OnAfterUpdateInterface[Supports]
	OnAfterSupportsDeleteCallback OnAfterDeleteInterface[Supports]
	OnAfterSupportsReadCallback   OnAfterReadInterface[Supports]

	Swings           map[*Swing]any
	Swings_mapString map[string]*Swing

	// insertion point for slice of pointers maps

	OnAfterSwingCreateCallback OnAfterCreateInterface[Swing]
	OnAfterSwingUpdateCallback OnAfterUpdateInterface[Swing]
	OnAfterSwingDeleteCallback OnAfterDeleteInterface[Swing]
	OnAfterSwingReadCallback   OnAfterReadInterface[Swing]

	Syncs           map[*Sync]any
	Syncs_mapString map[string]*Sync

	// insertion point for slice of pointers maps

	OnAfterSyncCreateCallback OnAfterCreateInterface[Sync]
	OnAfterSyncUpdateCallback OnAfterUpdateInterface[Sync]
	OnAfterSyncDeleteCallback OnAfterDeleteInterface[Sync]
	OnAfterSyncReadCallback   OnAfterReadInterface[Sync]

	System_dividerss           map[*System_dividers]any
	System_dividerss_mapString map[string]*System_dividers

	// insertion point for slice of pointers maps

	OnAfterSystem_dividersCreateCallback OnAfterCreateInterface[System_dividers]
	OnAfterSystem_dividersUpdateCallback OnAfterUpdateInterface[System_dividers]
	OnAfterSystem_dividersDeleteCallback OnAfterDeleteInterface[System_dividers]
	OnAfterSystem_dividersReadCallback   OnAfterReadInterface[System_dividers]

	System_layouts           map[*System_layout]any
	System_layouts_mapString map[string]*System_layout

	// insertion point for slice of pointers maps

	OnAfterSystem_layoutCreateCallback OnAfterCreateInterface[System_layout]
	OnAfterSystem_layoutUpdateCallback OnAfterUpdateInterface[System_layout]
	OnAfterSystem_layoutDeleteCallback OnAfterDeleteInterface[System_layout]
	OnAfterSystem_layoutReadCallback   OnAfterReadInterface[System_layout]

	System_marginss           map[*System_margins]any
	System_marginss_mapString map[string]*System_margins

	// insertion point for slice of pointers maps

	OnAfterSystem_marginsCreateCallback OnAfterCreateInterface[System_margins]
	OnAfterSystem_marginsUpdateCallback OnAfterUpdateInterface[System_margins]
	OnAfterSystem_marginsDeleteCallback OnAfterDeleteInterface[System_margins]
	OnAfterSystem_marginsReadCallback   OnAfterReadInterface[System_margins]

	Taps           map[*Tap]any
	Taps_mapString map[string]*Tap

	// insertion point for slice of pointers maps

	OnAfterTapCreateCallback OnAfterCreateInterface[Tap]
	OnAfterTapUpdateCallback OnAfterUpdateInterface[Tap]
	OnAfterTapDeleteCallback OnAfterDeleteInterface[Tap]
	OnAfterTapReadCallback   OnAfterReadInterface[Tap]

	Technicals           map[*Technical]any
	Technicals_mapString map[string]*Technical

	// insertion point for slice of pointers maps

	OnAfterTechnicalCreateCallback OnAfterCreateInterface[Technical]
	OnAfterTechnicalUpdateCallback OnAfterUpdateInterface[Technical]
	OnAfterTechnicalDeleteCallback OnAfterDeleteInterface[Technical]
	OnAfterTechnicalReadCallback   OnAfterReadInterface[Technical]

	Text_element_datas           map[*Text_element_data]any
	Text_element_datas_mapString map[string]*Text_element_data

	// insertion point for slice of pointers maps

	OnAfterText_element_dataCreateCallback OnAfterCreateInterface[Text_element_data]
	OnAfterText_element_dataUpdateCallback OnAfterUpdateInterface[Text_element_data]
	OnAfterText_element_dataDeleteCallback OnAfterDeleteInterface[Text_element_data]
	OnAfterText_element_dataReadCallback   OnAfterReadInterface[Text_element_data]

	Ties           map[*Tie]any
	Ties_mapString map[string]*Tie

	// insertion point for slice of pointers maps

	OnAfterTieCreateCallback OnAfterCreateInterface[Tie]
	OnAfterTieUpdateCallback OnAfterUpdateInterface[Tie]
	OnAfterTieDeleteCallback OnAfterDeleteInterface[Tie]
	OnAfterTieReadCallback   OnAfterReadInterface[Tie]

	Tieds           map[*Tied]any
	Tieds_mapString map[string]*Tied

	// insertion point for slice of pointers maps

	OnAfterTiedCreateCallback OnAfterCreateInterface[Tied]
	OnAfterTiedUpdateCallback OnAfterUpdateInterface[Tied]
	OnAfterTiedDeleteCallback OnAfterDeleteInterface[Tied]
	OnAfterTiedReadCallback   OnAfterReadInterface[Tied]

	Times           map[*Time]any
	Times_mapString map[string]*Time

	// insertion point for slice of pointers maps

	OnAfterTimeCreateCallback OnAfterCreateInterface[Time]
	OnAfterTimeUpdateCallback OnAfterUpdateInterface[Time]
	OnAfterTimeDeleteCallback OnAfterDeleteInterface[Time]
	OnAfterTimeReadCallback   OnAfterReadInterface[Time]

	Time_modifications           map[*Time_modification]any
	Time_modifications_mapString map[string]*Time_modification

	// insertion point for slice of pointers maps

	OnAfterTime_modificationCreateCallback OnAfterCreateInterface[Time_modification]
	OnAfterTime_modificationUpdateCallback OnAfterUpdateInterface[Time_modification]
	OnAfterTime_modificationDeleteCallback OnAfterDeleteInterface[Time_modification]
	OnAfterTime_modificationReadCallback   OnAfterReadInterface[Time_modification]

	Timpanis           map[*Timpani]any
	Timpanis_mapString map[string]*Timpani

	// insertion point for slice of pointers maps

	OnAfterTimpaniCreateCallback OnAfterCreateInterface[Timpani]
	OnAfterTimpaniUpdateCallback OnAfterUpdateInterface[Timpani]
	OnAfterTimpaniDeleteCallback OnAfterDeleteInterface[Timpani]
	OnAfterTimpaniReadCallback   OnAfterReadInterface[Timpani]

	Transposes           map[*Transpose]any
	Transposes_mapString map[string]*Transpose

	// insertion point for slice of pointers maps

	OnAfterTransposeCreateCallback OnAfterCreateInterface[Transpose]
	OnAfterTransposeUpdateCallback OnAfterUpdateInterface[Transpose]
	OnAfterTransposeDeleteCallback OnAfterDeleteInterface[Transpose]
	OnAfterTransposeReadCallback   OnAfterReadInterface[Transpose]

	Tremolos           map[*Tremolo]any
	Tremolos_mapString map[string]*Tremolo

	// insertion point for slice of pointers maps

	OnAfterTremoloCreateCallback OnAfterCreateInterface[Tremolo]
	OnAfterTremoloUpdateCallback OnAfterUpdateInterface[Tremolo]
	OnAfterTremoloDeleteCallback OnAfterDeleteInterface[Tremolo]
	OnAfterTremoloReadCallback   OnAfterReadInterface[Tremolo]

	Tuplets           map[*Tuplet]any
	Tuplets_mapString map[string]*Tuplet

	// insertion point for slice of pointers maps

	OnAfterTupletCreateCallback OnAfterCreateInterface[Tuplet]
	OnAfterTupletUpdateCallback OnAfterUpdateInterface[Tuplet]
	OnAfterTupletDeleteCallback OnAfterDeleteInterface[Tuplet]
	OnAfterTupletReadCallback   OnAfterReadInterface[Tuplet]

	Tuplet_dots           map[*Tuplet_dot]any
	Tuplet_dots_mapString map[string]*Tuplet_dot

	// insertion point for slice of pointers maps

	OnAfterTuplet_dotCreateCallback OnAfterCreateInterface[Tuplet_dot]
	OnAfterTuplet_dotUpdateCallback OnAfterUpdateInterface[Tuplet_dot]
	OnAfterTuplet_dotDeleteCallback OnAfterDeleteInterface[Tuplet_dot]
	OnAfterTuplet_dotReadCallback   OnAfterReadInterface[Tuplet_dot]

	Tuplet_numbers           map[*Tuplet_number]any
	Tuplet_numbers_mapString map[string]*Tuplet_number

	// insertion point for slice of pointers maps

	OnAfterTuplet_numberCreateCallback OnAfterCreateInterface[Tuplet_number]
	OnAfterTuplet_numberUpdateCallback OnAfterUpdateInterface[Tuplet_number]
	OnAfterTuplet_numberDeleteCallback OnAfterDeleteInterface[Tuplet_number]
	OnAfterTuplet_numberReadCallback   OnAfterReadInterface[Tuplet_number]

	Tuplet_portions           map[*Tuplet_portion]any
	Tuplet_portions_mapString map[string]*Tuplet_portion

	// insertion point for slice of pointers maps
	Tuplet_portion_Tuplet_dot_reverseMap map[*Tuplet_dot]*Tuplet_portion

	OnAfterTuplet_portionCreateCallback OnAfterCreateInterface[Tuplet_portion]
	OnAfterTuplet_portionUpdateCallback OnAfterUpdateInterface[Tuplet_portion]
	OnAfterTuplet_portionDeleteCallback OnAfterDeleteInterface[Tuplet_portion]
	OnAfterTuplet_portionReadCallback   OnAfterReadInterface[Tuplet_portion]

	Tuplet_types           map[*Tuplet_type]any
	Tuplet_types_mapString map[string]*Tuplet_type

	// insertion point for slice of pointers maps

	OnAfterTuplet_typeCreateCallback OnAfterCreateInterface[Tuplet_type]
	OnAfterTuplet_typeUpdateCallback OnAfterUpdateInterface[Tuplet_type]
	OnAfterTuplet_typeDeleteCallback OnAfterDeleteInterface[Tuplet_type]
	OnAfterTuplet_typeReadCallback   OnAfterReadInterface[Tuplet_type]

	Typed_texts           map[*Typed_text]any
	Typed_texts_mapString map[string]*Typed_text

	// insertion point for slice of pointers maps

	OnAfterTyped_textCreateCallback OnAfterCreateInterface[Typed_text]
	OnAfterTyped_textUpdateCallback OnAfterUpdateInterface[Typed_text]
	OnAfterTyped_textDeleteCallback OnAfterDeleteInterface[Typed_text]
	OnAfterTyped_textReadCallback   OnAfterReadInterface[Typed_text]

	Unpitcheds           map[*Unpitched]any
	Unpitcheds_mapString map[string]*Unpitched

	// insertion point for slice of pointers maps

	OnAfterUnpitchedCreateCallback OnAfterCreateInterface[Unpitched]
	OnAfterUnpitchedUpdateCallback OnAfterUpdateInterface[Unpitched]
	OnAfterUnpitchedDeleteCallback OnAfterDeleteInterface[Unpitched]
	OnAfterUnpitchedReadCallback   OnAfterReadInterface[Unpitched]

	Virtual_instruments           map[*Virtual_instrument]any
	Virtual_instruments_mapString map[string]*Virtual_instrument

	// insertion point for slice of pointers maps

	OnAfterVirtual_instrumentCreateCallback OnAfterCreateInterface[Virtual_instrument]
	OnAfterVirtual_instrumentUpdateCallback OnAfterUpdateInterface[Virtual_instrument]
	OnAfterVirtual_instrumentDeleteCallback OnAfterDeleteInterface[Virtual_instrument]
	OnAfterVirtual_instrumentReadCallback   OnAfterReadInterface[Virtual_instrument]

	Waits           map[*Wait]any
	Waits_mapString map[string]*Wait

	// insertion point for slice of pointers maps

	OnAfterWaitCreateCallback OnAfterCreateInterface[Wait]
	OnAfterWaitUpdateCallback OnAfterUpdateInterface[Wait]
	OnAfterWaitDeleteCallback OnAfterDeleteInterface[Wait]
	OnAfterWaitReadCallback   OnAfterReadInterface[Wait]

	Wavy_lines           map[*Wavy_line]any
	Wavy_lines_mapString map[string]*Wavy_line

	// insertion point for slice of pointers maps

	OnAfterWavy_lineCreateCallback OnAfterCreateInterface[Wavy_line]
	OnAfterWavy_lineUpdateCallback OnAfterUpdateInterface[Wavy_line]
	OnAfterWavy_lineDeleteCallback OnAfterDeleteInterface[Wavy_line]
	OnAfterWavy_lineReadCallback   OnAfterReadInterface[Wavy_line]

	Wedges           map[*Wedge]any
	Wedges_mapString map[string]*Wedge

	// insertion point for slice of pointers maps

	OnAfterWedgeCreateCallback OnAfterCreateInterface[Wedge]
	OnAfterWedgeUpdateCallback OnAfterUpdateInterface[Wedge]
	OnAfterWedgeDeleteCallback OnAfterDeleteInterface[Wedge]
	OnAfterWedgeReadCallback   OnAfterReadInterface[Wedge]

	Woods           map[*Wood]any
	Woods_mapString map[string]*Wood

	// insertion point for slice of pointers maps

	OnAfterWoodCreateCallback OnAfterCreateInterface[Wood]
	OnAfterWoodUpdateCallback OnAfterUpdateInterface[Wood]
	OnAfterWoodDeleteCallback OnAfterDeleteInterface[Wood]
	OnAfterWoodReadCallback   OnAfterReadInterface[Wood]

	Works           map[*Work]any
	Works_mapString map[string]*Work

	// insertion point for slice of pointers maps

	OnAfterWorkCreateCallback OnAfterCreateInterface[Work]
	OnAfterWorkUpdateCallback OnAfterUpdateInterface[Work]
	OnAfterWorkDeleteCallback OnAfterDeleteInterface[Work]
	OnAfterWorkReadCallback   OnAfterReadInterface[Work]

	AllModelsStructCreateCallback AllModelsStructCreateInterface

	AllModelsStructDeleteCallback AllModelsStructDeleteInterface

	BackRepo BackRepoInterface

	// if set will be called before each commit to the back repo
	OnInitCommitCallback          OnInitCommitInterface
	OnInitCommitFromFrontCallback OnInitCommitInterface
	OnInitCommitFromBackCallback  OnInitCommitInterface

	// store the number of instance per gongstruct
	Map_GongStructName_InstancesNb map[string]int

	// store meta package import
	MetaPackageImportPath  string
	MetaPackageImportAlias string

	// to be removed after fix of [issue](https://github.com/golang/go/issues/57559)
	// map to enable docLink renaming when an identifier is renamed
	Map_DocLink_Renaming map[string]GONG__Identifier
	// the to be removed stops here
}

func (stage *StageStruct) GetType() string {
	return "github.com/fullstack-lang/gongmusicxml/go/models"
}

type GONG__Identifier struct {
	Ident string
	Type  GONG__ExpressionType
}

type OnInitCommitInterface interface {
	BeforeCommit(stage *StageStruct)
}

// OnAfterCreateInterface callback when an instance is updated from the front
type OnAfterCreateInterface[Type Gongstruct] interface {
	OnAfterCreate(stage *StageStruct,
		instance *Type)
}

// OnAfterReadInterface callback when an instance is updated from the front
type OnAfterReadInterface[Type Gongstruct] interface {
	OnAfterRead(stage *StageStruct,
		instance *Type)
}

// OnAfterUpdateInterface callback when an instance is updated from the front
type OnAfterUpdateInterface[Type Gongstruct] interface {
	OnAfterUpdate(stage *StageStruct, old, new *Type)
}

// OnAfterDeleteInterface callback when an instance is updated from the front
type OnAfterDeleteInterface[Type Gongstruct] interface {
	OnAfterDelete(stage *StageStruct,
		staged, front *Type)
}

type BackRepoInterface interface {
	Commit(stage *StageStruct)
	Checkout(stage *StageStruct)
	Backup(stage *StageStruct, dirPath string)
	Restore(stage *StageStruct, dirPath string)
	BackupXL(stage *StageStruct, dirPath string)
	RestoreXL(stage *StageStruct, dirPath string)
	// insertion point for Commit and Checkout signatures
	CommitAccidental(accidental *Accidental)
	CheckoutAccidental(accidental *Accidental)
	CommitAccidental_mark(accidental_mark *Accidental_mark)
	CheckoutAccidental_mark(accidental_mark *Accidental_mark)
	CommitAccidental_text(accidental_text *Accidental_text)
	CheckoutAccidental_text(accidental_text *Accidental_text)
	CommitAccord(accord *Accord)
	CheckoutAccord(accord *Accord)
	CommitAccordion_registration(accordion_registration *Accordion_registration)
	CheckoutAccordion_registration(accordion_registration *Accordion_registration)
	CommitAnyType(anytype *AnyType)
	CheckoutAnyType(anytype *AnyType)
	CommitAppearance(appearance *Appearance)
	CheckoutAppearance(appearance *Appearance)
	CommitArpeggiate(arpeggiate *Arpeggiate)
	CheckoutArpeggiate(arpeggiate *Arpeggiate)
	CommitArrow(arrow *Arrow)
	CheckoutArrow(arrow *Arrow)
	CommitArticulations(articulations *Articulations)
	CheckoutArticulations(articulations *Articulations)
	CommitAssess(assess *Assess)
	CheckoutAssess(assess *Assess)
	CommitAttributes(attributes *Attributes)
	CheckoutAttributes(attributes *Attributes)
	CommitBackup(backup *Backup)
	CheckoutBackup(backup *Backup)
	CommitBar_style_color(bar_style_color *Bar_style_color)
	CheckoutBar_style_color(bar_style_color *Bar_style_color)
	CommitBarline(barline *Barline)
	CheckoutBarline(barline *Barline)
	CommitBarre(barre *Barre)
	CheckoutBarre(barre *Barre)
	CommitBass(bass *Bass)
	CheckoutBass(bass *Bass)
	CommitBass_step(bass_step *Bass_step)
	CheckoutBass_step(bass_step *Bass_step)
	CommitBeam(beam *Beam)
	CheckoutBeam(beam *Beam)
	CommitBeat_repeat(beat_repeat *Beat_repeat)
	CheckoutBeat_repeat(beat_repeat *Beat_repeat)
	CommitBeat_unit_tied(beat_unit_tied *Beat_unit_tied)
	CheckoutBeat_unit_tied(beat_unit_tied *Beat_unit_tied)
	CommitBeater(beater *Beater)
	CheckoutBeater(beater *Beater)
	CommitBend(bend *Bend)
	CheckoutBend(bend *Bend)
	CommitBookmark(bookmark *Bookmark)
	CheckoutBookmark(bookmark *Bookmark)
	CommitBracket(bracket *Bracket)
	CheckoutBracket(bracket *Bracket)
	CommitBreath_mark(breath_mark *Breath_mark)
	CheckoutBreath_mark(breath_mark *Breath_mark)
	CommitCaesura(caesura *Caesura)
	CheckoutCaesura(caesura *Caesura)
	CommitCancel(cancel *Cancel)
	CheckoutCancel(cancel *Cancel)
	CommitClef(clef *Clef)
	CheckoutClef(clef *Clef)
	CommitCoda(coda *Coda)
	CheckoutCoda(coda *Coda)
	CommitCredit(credit *Credit)
	CheckoutCredit(credit *Credit)
	CommitDashes(dashes *Dashes)
	CheckoutDashes(dashes *Dashes)
	CommitDefaults(defaults *Defaults)
	CheckoutDefaults(defaults *Defaults)
	CommitDegree(degree *Degree)
	CheckoutDegree(degree *Degree)
	CommitDegree_alter(degree_alter *Degree_alter)
	CheckoutDegree_alter(degree_alter *Degree_alter)
	CommitDegree_type(degree_type *Degree_type)
	CheckoutDegree_type(degree_type *Degree_type)
	CommitDegree_value(degree_value *Degree_value)
	CheckoutDegree_value(degree_value *Degree_value)
	CommitDirection(direction *Direction)
	CheckoutDirection(direction *Direction)
	CommitDirection_type(direction_type *Direction_type)
	CheckoutDirection_type(direction_type *Direction_type)
	CommitDistance(distance *Distance)
	CheckoutDistance(distance *Distance)
	CommitDouble(double *Double)
	CheckoutDouble(double *Double)
	CommitDynamics(dynamics *Dynamics)
	CheckoutDynamics(dynamics *Dynamics)
	CommitEffect(effect *Effect)
	CheckoutEffect(effect *Effect)
	CommitElision(elision *Elision)
	CheckoutElision(elision *Elision)
	CommitEmpty(empty *Empty)
	CheckoutEmpty(empty *Empty)
	CommitEmpty_font(empty_font *Empty_font)
	CheckoutEmpty_font(empty_font *Empty_font)
	CommitEmpty_line(empty_line *Empty_line)
	CheckoutEmpty_line(empty_line *Empty_line)
	CommitEmpty_placement(empty_placement *Empty_placement)
	CheckoutEmpty_placement(empty_placement *Empty_placement)
	CommitEmpty_placement_smufl(empty_placement_smufl *Empty_placement_smufl)
	CheckoutEmpty_placement_smufl(empty_placement_smufl *Empty_placement_smufl)
	CommitEmpty_print_object_style_align(empty_print_object_style_align *Empty_print_object_style_align)
	CheckoutEmpty_print_object_style_align(empty_print_object_style_align *Empty_print_object_style_align)
	CommitEmpty_print_style(empty_print_style *Empty_print_style)
	CheckoutEmpty_print_style(empty_print_style *Empty_print_style)
	CommitEmpty_print_style_align(empty_print_style_align *Empty_print_style_align)
	CheckoutEmpty_print_style_align(empty_print_style_align *Empty_print_style_align)
	CommitEmpty_print_style_align_id(empty_print_style_align_id *Empty_print_style_align_id)
	CheckoutEmpty_print_style_align_id(empty_print_style_align_id *Empty_print_style_align_id)
	CommitEmpty_trill_sound(empty_trill_sound *Empty_trill_sound)
	CheckoutEmpty_trill_sound(empty_trill_sound *Empty_trill_sound)
	CommitEncoding(encoding *Encoding)
	CheckoutEncoding(encoding *Encoding)
	CommitEnding(ending *Ending)
	CheckoutEnding(ending *Ending)
	CommitExtend(extend *Extend)
	CheckoutExtend(extend *Extend)
	CommitFeature(feature *Feature)
	CheckoutFeature(feature *Feature)
	CommitFermata(fermata *Fermata)
	CheckoutFermata(fermata *Fermata)
	CommitFigure(figure *Figure)
	CheckoutFigure(figure *Figure)
	CommitFigured_bass(figured_bass *Figured_bass)
	CheckoutFigured_bass(figured_bass *Figured_bass)
	CommitFingering(fingering *Fingering)
	CheckoutFingering(fingering *Fingering)
	CommitFirst_fret(first_fret *First_fret)
	CheckoutFirst_fret(first_fret *First_fret)
	CommitFoo(foo *Foo)
	CheckoutFoo(foo *Foo)
	CommitFor_part(for_part *For_part)
	CheckoutFor_part(for_part *For_part)
	CommitFormatted_symbol(formatted_symbol *Formatted_symbol)
	CheckoutFormatted_symbol(formatted_symbol *Formatted_symbol)
	CommitFormatted_symbol_id(formatted_symbol_id *Formatted_symbol_id)
	CheckoutFormatted_symbol_id(formatted_symbol_id *Formatted_symbol_id)
	CommitForward(forward *Forward)
	CheckoutForward(forward *Forward)
	CommitFrame(frame *Frame)
	CheckoutFrame(frame *Frame)
	CommitFrame_note(frame_note *Frame_note)
	CheckoutFrame_note(frame_note *Frame_note)
	CommitFret(fret *Fret)
	CheckoutFret(fret *Fret)
	CommitGlass(glass *Glass)
	CheckoutGlass(glass *Glass)
	CommitGlissando(glissando *Glissando)
	CheckoutGlissando(glissando *Glissando)
	CommitGlyph(glyph *Glyph)
	CheckoutGlyph(glyph *Glyph)
	CommitGrace(grace *Grace)
	CheckoutGrace(grace *Grace)
	CommitGroup_barline(group_barline *Group_barline)
	CheckoutGroup_barline(group_barline *Group_barline)
	CommitGroup_symbol(group_symbol *Group_symbol)
	CheckoutGroup_symbol(group_symbol *Group_symbol)
	CommitGrouping(grouping *Grouping)
	CheckoutGrouping(grouping *Grouping)
	CommitHammer_on_pull_off(hammer_on_pull_off *Hammer_on_pull_off)
	CheckoutHammer_on_pull_off(hammer_on_pull_off *Hammer_on_pull_off)
	CommitHandbell(handbell *Handbell)
	CheckoutHandbell(handbell *Handbell)
	CommitHarmon_closed(harmon_closed *Harmon_closed)
	CheckoutHarmon_closed(harmon_closed *Harmon_closed)
	CommitHarmon_mute(harmon_mute *Harmon_mute)
	CheckoutHarmon_mute(harmon_mute *Harmon_mute)
	CommitHarmonic(harmonic *Harmonic)
	CheckoutHarmonic(harmonic *Harmonic)
	CommitHarmony(harmony *Harmony)
	CheckoutHarmony(harmony *Harmony)
	CommitHarmony_alter(harmony_alter *Harmony_alter)
	CheckoutHarmony_alter(harmony_alter *Harmony_alter)
	CommitHarp_pedals(harp_pedals *Harp_pedals)
	CheckoutHarp_pedals(harp_pedals *Harp_pedals)
	CommitHeel_toe(heel_toe *Heel_toe)
	CheckoutHeel_toe(heel_toe *Heel_toe)
	CommitHole(hole *Hole)
	CheckoutHole(hole *Hole)
	CommitHole_closed(hole_closed *Hole_closed)
	CheckoutHole_closed(hole_closed *Hole_closed)
	CommitHorizontal_turn(horizontal_turn *Horizontal_turn)
	CheckoutHorizontal_turn(horizontal_turn *Horizontal_turn)
	CommitIdentification(identification *Identification)
	CheckoutIdentification(identification *Identification)
	CommitImage(image *Image)
	CheckoutImage(image *Image)
	CommitInstrument(instrument *Instrument)
	CheckoutInstrument(instrument *Instrument)
	CommitInstrument_change(instrument_change *Instrument_change)
	CheckoutInstrument_change(instrument_change *Instrument_change)
	CommitInstrument_link(instrument_link *Instrument_link)
	CheckoutInstrument_link(instrument_link *Instrument_link)
	CommitInterchangeable(interchangeable *Interchangeable)
	CheckoutInterchangeable(interchangeable *Interchangeable)
	CommitInversion(inversion *Inversion)
	CheckoutInversion(inversion *Inversion)
	CommitKey(key *Key)
	CheckoutKey(key *Key)
	CommitKey_accidental(key_accidental *Key_accidental)
	CheckoutKey_accidental(key_accidental *Key_accidental)
	CommitKey_octave(key_octave *Key_octave)
	CheckoutKey_octave(key_octave *Key_octave)
	CommitKind(kind *Kind)
	CheckoutKind(kind *Kind)
	CommitLevel(level *Level)
	CheckoutLevel(level *Level)
	CommitLine_detail(line_detail *Line_detail)
	CheckoutLine_detail(line_detail *Line_detail)
	CommitLine_width(line_width *Line_width)
	CheckoutLine_width(line_width *Line_width)
	CommitLink(link *Link)
	CheckoutLink(link *Link)
	CommitListen(listen *Listen)
	CheckoutListen(listen *Listen)
	CommitListening(listening *Listening)
	CheckoutListening(listening *Listening)
	CommitLyric(lyric *Lyric)
	CheckoutLyric(lyric *Lyric)
	CommitLyric_font(lyric_font *Lyric_font)
	CheckoutLyric_font(lyric_font *Lyric_font)
	CommitLyric_language(lyric_language *Lyric_language)
	CheckoutLyric_language(lyric_language *Lyric_language)
	CommitMeasure_layout(measure_layout *Measure_layout)
	CheckoutMeasure_layout(measure_layout *Measure_layout)
	CommitMeasure_numbering(measure_numbering *Measure_numbering)
	CheckoutMeasure_numbering(measure_numbering *Measure_numbering)
	CommitMeasure_repeat(measure_repeat *Measure_repeat)
	CheckoutMeasure_repeat(measure_repeat *Measure_repeat)
	CommitMeasure_style(measure_style *Measure_style)
	CheckoutMeasure_style(measure_style *Measure_style)
	CommitMembrane(membrane *Membrane)
	CheckoutMembrane(membrane *Membrane)
	CommitMetal(metal *Metal)
	CheckoutMetal(metal *Metal)
	CommitMetronome(metronome *Metronome)
	CheckoutMetronome(metronome *Metronome)
	CommitMetronome_beam(metronome_beam *Metronome_beam)
	CheckoutMetronome_beam(metronome_beam *Metronome_beam)
	CommitMetronome_note(metronome_note *Metronome_note)
	CheckoutMetronome_note(metronome_note *Metronome_note)
	CommitMetronome_tied(metronome_tied *Metronome_tied)
	CheckoutMetronome_tied(metronome_tied *Metronome_tied)
	CommitMetronome_tuplet(metronome_tuplet *Metronome_tuplet)
	CheckoutMetronome_tuplet(metronome_tuplet *Metronome_tuplet)
	CommitMidi_device(midi_device *Midi_device)
	CheckoutMidi_device(midi_device *Midi_device)
	CommitMidi_instrument(midi_instrument *Midi_instrument)
	CheckoutMidi_instrument(midi_instrument *Midi_instrument)
	CommitMiscellaneous(miscellaneous *Miscellaneous)
	CheckoutMiscellaneous(miscellaneous *Miscellaneous)
	CommitMiscellaneous_field(miscellaneous_field *Miscellaneous_field)
	CheckoutMiscellaneous_field(miscellaneous_field *Miscellaneous_field)
	CommitMordent(mordent *Mordent)
	CheckoutMordent(mordent *Mordent)
	CommitMultiple_rest(multiple_rest *Multiple_rest)
	CheckoutMultiple_rest(multiple_rest *Multiple_rest)
	CommitName_display(name_display *Name_display)
	CheckoutName_display(name_display *Name_display)
	CommitNon_arpeggiate(non_arpeggiate *Non_arpeggiate)
	CheckoutNon_arpeggiate(non_arpeggiate *Non_arpeggiate)
	CommitNotations(notations *Notations)
	CheckoutNotations(notations *Notations)
	CommitNote(note *Note)
	CheckoutNote(note *Note)
	CommitNote_size(note_size *Note_size)
	CheckoutNote_size(note_size *Note_size)
	CommitNote_type(note_type *Note_type)
	CheckoutNote_type(note_type *Note_type)
	CommitNotehead(notehead *Notehead)
	CheckoutNotehead(notehead *Notehead)
	CommitNotehead_text(notehead_text *Notehead_text)
	CheckoutNotehead_text(notehead_text *Notehead_text)
	CommitNumeral(numeral *Numeral)
	CheckoutNumeral(numeral *Numeral)
	CommitNumeral_key(numeral_key *Numeral_key)
	CheckoutNumeral_key(numeral_key *Numeral_key)
	CommitNumeral_root(numeral_root *Numeral_root)
	CheckoutNumeral_root(numeral_root *Numeral_root)
	CommitOctave_shift(octave_shift *Octave_shift)
	CheckoutOctave_shift(octave_shift *Octave_shift)
	CommitOffset(offset *Offset)
	CheckoutOffset(offset *Offset)
	CommitOpus(opus *Opus)
	CheckoutOpus(opus *Opus)
	CommitOrnaments(ornaments *Ornaments)
	CheckoutOrnaments(ornaments *Ornaments)
	CommitOther_appearance(other_appearance *Other_appearance)
	CheckoutOther_appearance(other_appearance *Other_appearance)
	CommitOther_listening(other_listening *Other_listening)
	CheckoutOther_listening(other_listening *Other_listening)
	CommitOther_notation(other_notation *Other_notation)
	CheckoutOther_notation(other_notation *Other_notation)
	CommitOther_play(other_play *Other_play)
	CheckoutOther_play(other_play *Other_play)
	CommitPage_layout(page_layout *Page_layout)
	CheckoutPage_layout(page_layout *Page_layout)
	CommitPage_margins(page_margins *Page_margins)
	CheckoutPage_margins(page_margins *Page_margins)
	CommitPart_clef(part_clef *Part_clef)
	CheckoutPart_clef(part_clef *Part_clef)
	CommitPart_group(part_group *Part_group)
	CheckoutPart_group(part_group *Part_group)
	CommitPart_link(part_link *Part_link)
	CheckoutPart_link(part_link *Part_link)
	CommitPart_list(part_list *Part_list)
	CheckoutPart_list(part_list *Part_list)
	CommitPart_symbol(part_symbol *Part_symbol)
	CheckoutPart_symbol(part_symbol *Part_symbol)
	CommitPart_transpose(part_transpose *Part_transpose)
	CheckoutPart_transpose(part_transpose *Part_transpose)
	CommitPedal(pedal *Pedal)
	CheckoutPedal(pedal *Pedal)
	CommitPedal_tuning(pedal_tuning *Pedal_tuning)
	CheckoutPedal_tuning(pedal_tuning *Pedal_tuning)
	CommitPercussion(percussion *Percussion)
	CheckoutPercussion(percussion *Percussion)
	CommitPitch(pitch *Pitch)
	CheckoutPitch(pitch *Pitch)
	CommitPitched(pitched *Pitched)
	CheckoutPitched(pitched *Pitched)
	CommitPlay(play *Play)
	CheckoutPlay(play *Play)
	CommitPlayer(player *Player)
	CheckoutPlayer(player *Player)
	CommitPrincipal_voice(principal_voice *Principal_voice)
	CheckoutPrincipal_voice(principal_voice *Principal_voice)
	CommitPrint(print *Print)
	CheckoutPrint(print *Print)
	CommitRelease(release *Release)
	CheckoutRelease(release *Release)
	CommitRepeat(repeat *Repeat)
	CheckoutRepeat(repeat *Repeat)
	CommitRest(rest *Rest)
	CheckoutRest(rest *Rest)
	CommitRoot(root *Root)
	CheckoutRoot(root *Root)
	CommitRoot_step(root_step *Root_step)
	CheckoutRoot_step(root_step *Root_step)
	CommitScaling(scaling *Scaling)
	CheckoutScaling(scaling *Scaling)
	CommitScordatura(scordatura *Scordatura)
	CheckoutScordatura(scordatura *Scordatura)
	CommitScore_instrument(score_instrument *Score_instrument)
	CheckoutScore_instrument(score_instrument *Score_instrument)
	CommitScore_part(score_part *Score_part)
	CheckoutScore_part(score_part *Score_part)
	CommitScore_partwise(score_partwise *Score_partwise)
	CheckoutScore_partwise(score_partwise *Score_partwise)
	CommitScore_timewise(score_timewise *Score_timewise)
	CheckoutScore_timewise(score_timewise *Score_timewise)
	CommitSegno(segno *Segno)
	CheckoutSegno(segno *Segno)
	CommitSlash(slash *Slash)
	CheckoutSlash(slash *Slash)
	CommitSlide(slide *Slide)
	CheckoutSlide(slide *Slide)
	CommitSlur(slur *Slur)
	CheckoutSlur(slur *Slur)
	CommitSound(sound *Sound)
	CheckoutSound(sound *Sound)
	CommitStaff_details(staff_details *Staff_details)
	CheckoutStaff_details(staff_details *Staff_details)
	CommitStaff_divide(staff_divide *Staff_divide)
	CheckoutStaff_divide(staff_divide *Staff_divide)
	CommitStaff_layout(staff_layout *Staff_layout)
	CheckoutStaff_layout(staff_layout *Staff_layout)
	CommitStaff_size(staff_size *Staff_size)
	CheckoutStaff_size(staff_size *Staff_size)
	CommitStaff_tuning(staff_tuning *Staff_tuning)
	CheckoutStaff_tuning(staff_tuning *Staff_tuning)
	CommitStem(stem *Stem)
	CheckoutStem(stem *Stem)
	CommitStick(stick *Stick)
	CheckoutStick(stick *Stick)
	CommitString_mute(string_mute *String_mute)
	CheckoutString_mute(string_mute *String_mute)
	CommitStrong_accent(strong_accent *Strong_accent)
	CheckoutStrong_accent(strong_accent *Strong_accent)
	CommitSupports(supports *Supports)
	CheckoutSupports(supports *Supports)
	CommitSwing(swing *Swing)
	CheckoutSwing(swing *Swing)
	CommitSync(sync *Sync)
	CheckoutSync(sync *Sync)
	CommitSystem_dividers(system_dividers *System_dividers)
	CheckoutSystem_dividers(system_dividers *System_dividers)
	CommitSystem_layout(system_layout *System_layout)
	CheckoutSystem_layout(system_layout *System_layout)
	CommitSystem_margins(system_margins *System_margins)
	CheckoutSystem_margins(system_margins *System_margins)
	CommitTap(tap *Tap)
	CheckoutTap(tap *Tap)
	CommitTechnical(technical *Technical)
	CheckoutTechnical(technical *Technical)
	CommitText_element_data(text_element_data *Text_element_data)
	CheckoutText_element_data(text_element_data *Text_element_data)
	CommitTie(tie *Tie)
	CheckoutTie(tie *Tie)
	CommitTied(tied *Tied)
	CheckoutTied(tied *Tied)
	CommitTime(time *Time)
	CheckoutTime(time *Time)
	CommitTime_modification(time_modification *Time_modification)
	CheckoutTime_modification(time_modification *Time_modification)
	CommitTimpani(timpani *Timpani)
	CheckoutTimpani(timpani *Timpani)
	CommitTranspose(transpose *Transpose)
	CheckoutTranspose(transpose *Transpose)
	CommitTremolo(tremolo *Tremolo)
	CheckoutTremolo(tremolo *Tremolo)
	CommitTuplet(tuplet *Tuplet)
	CheckoutTuplet(tuplet *Tuplet)
	CommitTuplet_dot(tuplet_dot *Tuplet_dot)
	CheckoutTuplet_dot(tuplet_dot *Tuplet_dot)
	CommitTuplet_number(tuplet_number *Tuplet_number)
	CheckoutTuplet_number(tuplet_number *Tuplet_number)
	CommitTuplet_portion(tuplet_portion *Tuplet_portion)
	CheckoutTuplet_portion(tuplet_portion *Tuplet_portion)
	CommitTuplet_type(tuplet_type *Tuplet_type)
	CheckoutTuplet_type(tuplet_type *Tuplet_type)
	CommitTyped_text(typed_text *Typed_text)
	CheckoutTyped_text(typed_text *Typed_text)
	CommitUnpitched(unpitched *Unpitched)
	CheckoutUnpitched(unpitched *Unpitched)
	CommitVirtual_instrument(virtual_instrument *Virtual_instrument)
	CheckoutVirtual_instrument(virtual_instrument *Virtual_instrument)
	CommitWait(wait *Wait)
	CheckoutWait(wait *Wait)
	CommitWavy_line(wavy_line *Wavy_line)
	CheckoutWavy_line(wavy_line *Wavy_line)
	CommitWedge(wedge *Wedge)
	CheckoutWedge(wedge *Wedge)
	CommitWood(wood *Wood)
	CheckoutWood(wood *Wood)
	CommitWork(work *Work)
	CheckoutWork(work *Work)
	GetLastCommitFromBackNb() uint
	GetLastPushFromFrontNb() uint
}

func NewStage(path string) (stage *StageStruct) {

	stage = &StageStruct{ // insertion point for array initiatialisation
		Accidentals:           make(map[*Accidental]any),
		Accidentals_mapString: make(map[string]*Accidental),

		Accidental_marks:           make(map[*Accidental_mark]any),
		Accidental_marks_mapString: make(map[string]*Accidental_mark),

		Accidental_texts:           make(map[*Accidental_text]any),
		Accidental_texts_mapString: make(map[string]*Accidental_text),

		Accords:           make(map[*Accord]any),
		Accords_mapString: make(map[string]*Accord),

		Accordion_registrations:           make(map[*Accordion_registration]any),
		Accordion_registrations_mapString: make(map[string]*Accordion_registration),

		AnyTypes:           make(map[*AnyType]any),
		AnyTypes_mapString: make(map[string]*AnyType),

		Appearances:           make(map[*Appearance]any),
		Appearances_mapString: make(map[string]*Appearance),

		Arpeggiates:           make(map[*Arpeggiate]any),
		Arpeggiates_mapString: make(map[string]*Arpeggiate),

		Arrows:           make(map[*Arrow]any),
		Arrows_mapString: make(map[string]*Arrow),

		Articulationss:           make(map[*Articulations]any),
		Articulationss_mapString: make(map[string]*Articulations),

		Assesss:           make(map[*Assess]any),
		Assesss_mapString: make(map[string]*Assess),

		Attributess:           make(map[*Attributes]any),
		Attributess_mapString: make(map[string]*Attributes),

		Backups:           make(map[*Backup]any),
		Backups_mapString: make(map[string]*Backup),

		Bar_style_colors:           make(map[*Bar_style_color]any),
		Bar_style_colors_mapString: make(map[string]*Bar_style_color),

		Barlines:           make(map[*Barline]any),
		Barlines_mapString: make(map[string]*Barline),

		Barres:           make(map[*Barre]any),
		Barres_mapString: make(map[string]*Barre),

		Basss:           make(map[*Bass]any),
		Basss_mapString: make(map[string]*Bass),

		Bass_steps:           make(map[*Bass_step]any),
		Bass_steps_mapString: make(map[string]*Bass_step),

		Beams:           make(map[*Beam]any),
		Beams_mapString: make(map[string]*Beam),

		Beat_repeats:           make(map[*Beat_repeat]any),
		Beat_repeats_mapString: make(map[string]*Beat_repeat),

		Beat_unit_tieds:           make(map[*Beat_unit_tied]any),
		Beat_unit_tieds_mapString: make(map[string]*Beat_unit_tied),

		Beaters:           make(map[*Beater]any),
		Beaters_mapString: make(map[string]*Beater),

		Bends:           make(map[*Bend]any),
		Bends_mapString: make(map[string]*Bend),

		Bookmarks:           make(map[*Bookmark]any),
		Bookmarks_mapString: make(map[string]*Bookmark),

		Brackets:           make(map[*Bracket]any),
		Brackets_mapString: make(map[string]*Bracket),

		Breath_marks:           make(map[*Breath_mark]any),
		Breath_marks_mapString: make(map[string]*Breath_mark),

		Caesuras:           make(map[*Caesura]any),
		Caesuras_mapString: make(map[string]*Caesura),

		Cancels:           make(map[*Cancel]any),
		Cancels_mapString: make(map[string]*Cancel),

		Clefs:           make(map[*Clef]any),
		Clefs_mapString: make(map[string]*Clef),

		Codas:           make(map[*Coda]any),
		Codas_mapString: make(map[string]*Coda),

		Credits:           make(map[*Credit]any),
		Credits_mapString: make(map[string]*Credit),

		Dashess:           make(map[*Dashes]any),
		Dashess_mapString: make(map[string]*Dashes),

		Defaultss:           make(map[*Defaults]any),
		Defaultss_mapString: make(map[string]*Defaults),

		Degrees:           make(map[*Degree]any),
		Degrees_mapString: make(map[string]*Degree),

		Degree_alters:           make(map[*Degree_alter]any),
		Degree_alters_mapString: make(map[string]*Degree_alter),

		Degree_types:           make(map[*Degree_type]any),
		Degree_types_mapString: make(map[string]*Degree_type),

		Degree_values:           make(map[*Degree_value]any),
		Degree_values_mapString: make(map[string]*Degree_value),

		Directions:           make(map[*Direction]any),
		Directions_mapString: make(map[string]*Direction),

		Direction_types:           make(map[*Direction_type]any),
		Direction_types_mapString: make(map[string]*Direction_type),

		Distances:           make(map[*Distance]any),
		Distances_mapString: make(map[string]*Distance),

		Doubles:           make(map[*Double]any),
		Doubles_mapString: make(map[string]*Double),

		Dynamicss:           make(map[*Dynamics]any),
		Dynamicss_mapString: make(map[string]*Dynamics),

		Effects:           make(map[*Effect]any),
		Effects_mapString: make(map[string]*Effect),

		Elisions:           make(map[*Elision]any),
		Elisions_mapString: make(map[string]*Elision),

		Emptys:           make(map[*Empty]any),
		Emptys_mapString: make(map[string]*Empty),

		Empty_fonts:           make(map[*Empty_font]any),
		Empty_fonts_mapString: make(map[string]*Empty_font),

		Empty_lines:           make(map[*Empty_line]any),
		Empty_lines_mapString: make(map[string]*Empty_line),

		Empty_placements:           make(map[*Empty_placement]any),
		Empty_placements_mapString: make(map[string]*Empty_placement),

		Empty_placement_smufls:           make(map[*Empty_placement_smufl]any),
		Empty_placement_smufls_mapString: make(map[string]*Empty_placement_smufl),

		Empty_print_object_style_aligns:           make(map[*Empty_print_object_style_align]any),
		Empty_print_object_style_aligns_mapString: make(map[string]*Empty_print_object_style_align),

		Empty_print_styles:           make(map[*Empty_print_style]any),
		Empty_print_styles_mapString: make(map[string]*Empty_print_style),

		Empty_print_style_aligns:           make(map[*Empty_print_style_align]any),
		Empty_print_style_aligns_mapString: make(map[string]*Empty_print_style_align),

		Empty_print_style_align_ids:           make(map[*Empty_print_style_align_id]any),
		Empty_print_style_align_ids_mapString: make(map[string]*Empty_print_style_align_id),

		Empty_trill_sounds:           make(map[*Empty_trill_sound]any),
		Empty_trill_sounds_mapString: make(map[string]*Empty_trill_sound),

		Encodings:           make(map[*Encoding]any),
		Encodings_mapString: make(map[string]*Encoding),

		Endings:           make(map[*Ending]any),
		Endings_mapString: make(map[string]*Ending),

		Extends:           make(map[*Extend]any),
		Extends_mapString: make(map[string]*Extend),

		Features:           make(map[*Feature]any),
		Features_mapString: make(map[string]*Feature),

		Fermatas:           make(map[*Fermata]any),
		Fermatas_mapString: make(map[string]*Fermata),

		Figures:           make(map[*Figure]any),
		Figures_mapString: make(map[string]*Figure),

		Figured_basss:           make(map[*Figured_bass]any),
		Figured_basss_mapString: make(map[string]*Figured_bass),

		Fingerings:           make(map[*Fingering]any),
		Fingerings_mapString: make(map[string]*Fingering),

		First_frets:           make(map[*First_fret]any),
		First_frets_mapString: make(map[string]*First_fret),

		Foos:           make(map[*Foo]any),
		Foos_mapString: make(map[string]*Foo),

		For_parts:           make(map[*For_part]any),
		For_parts_mapString: make(map[string]*For_part),

		Formatted_symbols:           make(map[*Formatted_symbol]any),
		Formatted_symbols_mapString: make(map[string]*Formatted_symbol),

		Formatted_symbol_ids:           make(map[*Formatted_symbol_id]any),
		Formatted_symbol_ids_mapString: make(map[string]*Formatted_symbol_id),

		Forwards:           make(map[*Forward]any),
		Forwards_mapString: make(map[string]*Forward),

		Frames:           make(map[*Frame]any),
		Frames_mapString: make(map[string]*Frame),

		Frame_notes:           make(map[*Frame_note]any),
		Frame_notes_mapString: make(map[string]*Frame_note),

		Frets:           make(map[*Fret]any),
		Frets_mapString: make(map[string]*Fret),

		Glasss:           make(map[*Glass]any),
		Glasss_mapString: make(map[string]*Glass),

		Glissandos:           make(map[*Glissando]any),
		Glissandos_mapString: make(map[string]*Glissando),

		Glyphs:           make(map[*Glyph]any),
		Glyphs_mapString: make(map[string]*Glyph),

		Graces:           make(map[*Grace]any),
		Graces_mapString: make(map[string]*Grace),

		Group_barlines:           make(map[*Group_barline]any),
		Group_barlines_mapString: make(map[string]*Group_barline),

		Group_symbols:           make(map[*Group_symbol]any),
		Group_symbols_mapString: make(map[string]*Group_symbol),

		Groupings:           make(map[*Grouping]any),
		Groupings_mapString: make(map[string]*Grouping),

		Hammer_on_pull_offs:           make(map[*Hammer_on_pull_off]any),
		Hammer_on_pull_offs_mapString: make(map[string]*Hammer_on_pull_off),

		Handbells:           make(map[*Handbell]any),
		Handbells_mapString: make(map[string]*Handbell),

		Harmon_closeds:           make(map[*Harmon_closed]any),
		Harmon_closeds_mapString: make(map[string]*Harmon_closed),

		Harmon_mutes:           make(map[*Harmon_mute]any),
		Harmon_mutes_mapString: make(map[string]*Harmon_mute),

		Harmonics:           make(map[*Harmonic]any),
		Harmonics_mapString: make(map[string]*Harmonic),

		Harmonys:           make(map[*Harmony]any),
		Harmonys_mapString: make(map[string]*Harmony),

		Harmony_alters:           make(map[*Harmony_alter]any),
		Harmony_alters_mapString: make(map[string]*Harmony_alter),

		Harp_pedalss:           make(map[*Harp_pedals]any),
		Harp_pedalss_mapString: make(map[string]*Harp_pedals),

		Heel_toes:           make(map[*Heel_toe]any),
		Heel_toes_mapString: make(map[string]*Heel_toe),

		Holes:           make(map[*Hole]any),
		Holes_mapString: make(map[string]*Hole),

		Hole_closeds:           make(map[*Hole_closed]any),
		Hole_closeds_mapString: make(map[string]*Hole_closed),

		Horizontal_turns:           make(map[*Horizontal_turn]any),
		Horizontal_turns_mapString: make(map[string]*Horizontal_turn),

		Identifications:           make(map[*Identification]any),
		Identifications_mapString: make(map[string]*Identification),

		Images:           make(map[*Image]any),
		Images_mapString: make(map[string]*Image),

		Instruments:           make(map[*Instrument]any),
		Instruments_mapString: make(map[string]*Instrument),

		Instrument_changes:           make(map[*Instrument_change]any),
		Instrument_changes_mapString: make(map[string]*Instrument_change),

		Instrument_links:           make(map[*Instrument_link]any),
		Instrument_links_mapString: make(map[string]*Instrument_link),

		Interchangeables:           make(map[*Interchangeable]any),
		Interchangeables_mapString: make(map[string]*Interchangeable),

		Inversions:           make(map[*Inversion]any),
		Inversions_mapString: make(map[string]*Inversion),

		Keys:           make(map[*Key]any),
		Keys_mapString: make(map[string]*Key),

		Key_accidentals:           make(map[*Key_accidental]any),
		Key_accidentals_mapString: make(map[string]*Key_accidental),

		Key_octaves:           make(map[*Key_octave]any),
		Key_octaves_mapString: make(map[string]*Key_octave),

		Kinds:           make(map[*Kind]any),
		Kinds_mapString: make(map[string]*Kind),

		Levels:           make(map[*Level]any),
		Levels_mapString: make(map[string]*Level),

		Line_details:           make(map[*Line_detail]any),
		Line_details_mapString: make(map[string]*Line_detail),

		Line_widths:           make(map[*Line_width]any),
		Line_widths_mapString: make(map[string]*Line_width),

		Links:           make(map[*Link]any),
		Links_mapString: make(map[string]*Link),

		Listens:           make(map[*Listen]any),
		Listens_mapString: make(map[string]*Listen),

		Listenings:           make(map[*Listening]any),
		Listenings_mapString: make(map[string]*Listening),

		Lyrics:           make(map[*Lyric]any),
		Lyrics_mapString: make(map[string]*Lyric),

		Lyric_fonts:           make(map[*Lyric_font]any),
		Lyric_fonts_mapString: make(map[string]*Lyric_font),

		Lyric_languages:           make(map[*Lyric_language]any),
		Lyric_languages_mapString: make(map[string]*Lyric_language),

		Measure_layouts:           make(map[*Measure_layout]any),
		Measure_layouts_mapString: make(map[string]*Measure_layout),

		Measure_numberings:           make(map[*Measure_numbering]any),
		Measure_numberings_mapString: make(map[string]*Measure_numbering),

		Measure_repeats:           make(map[*Measure_repeat]any),
		Measure_repeats_mapString: make(map[string]*Measure_repeat),

		Measure_styles:           make(map[*Measure_style]any),
		Measure_styles_mapString: make(map[string]*Measure_style),

		Membranes:           make(map[*Membrane]any),
		Membranes_mapString: make(map[string]*Membrane),

		Metals:           make(map[*Metal]any),
		Metals_mapString: make(map[string]*Metal),

		Metronomes:           make(map[*Metronome]any),
		Metronomes_mapString: make(map[string]*Metronome),

		Metronome_beams:           make(map[*Metronome_beam]any),
		Metronome_beams_mapString: make(map[string]*Metronome_beam),

		Metronome_notes:           make(map[*Metronome_note]any),
		Metronome_notes_mapString: make(map[string]*Metronome_note),

		Metronome_tieds:           make(map[*Metronome_tied]any),
		Metronome_tieds_mapString: make(map[string]*Metronome_tied),

		Metronome_tuplets:           make(map[*Metronome_tuplet]any),
		Metronome_tuplets_mapString: make(map[string]*Metronome_tuplet),

		Midi_devices:           make(map[*Midi_device]any),
		Midi_devices_mapString: make(map[string]*Midi_device),

		Midi_instruments:           make(map[*Midi_instrument]any),
		Midi_instruments_mapString: make(map[string]*Midi_instrument),

		Miscellaneouss:           make(map[*Miscellaneous]any),
		Miscellaneouss_mapString: make(map[string]*Miscellaneous),

		Miscellaneous_fields:           make(map[*Miscellaneous_field]any),
		Miscellaneous_fields_mapString: make(map[string]*Miscellaneous_field),

		Mordents:           make(map[*Mordent]any),
		Mordents_mapString: make(map[string]*Mordent),

		Multiple_rests:           make(map[*Multiple_rest]any),
		Multiple_rests_mapString: make(map[string]*Multiple_rest),

		Name_displays:           make(map[*Name_display]any),
		Name_displays_mapString: make(map[string]*Name_display),

		Non_arpeggiates:           make(map[*Non_arpeggiate]any),
		Non_arpeggiates_mapString: make(map[string]*Non_arpeggiate),

		Notationss:           make(map[*Notations]any),
		Notationss_mapString: make(map[string]*Notations),

		Notes:           make(map[*Note]any),
		Notes_mapString: make(map[string]*Note),

		Note_sizes:           make(map[*Note_size]any),
		Note_sizes_mapString: make(map[string]*Note_size),

		Note_types:           make(map[*Note_type]any),
		Note_types_mapString: make(map[string]*Note_type),

		Noteheads:           make(map[*Notehead]any),
		Noteheads_mapString: make(map[string]*Notehead),

		Notehead_texts:           make(map[*Notehead_text]any),
		Notehead_texts_mapString: make(map[string]*Notehead_text),

		Numerals:           make(map[*Numeral]any),
		Numerals_mapString: make(map[string]*Numeral),

		Numeral_keys:           make(map[*Numeral_key]any),
		Numeral_keys_mapString: make(map[string]*Numeral_key),

		Numeral_roots:           make(map[*Numeral_root]any),
		Numeral_roots_mapString: make(map[string]*Numeral_root),

		Octave_shifts:           make(map[*Octave_shift]any),
		Octave_shifts_mapString: make(map[string]*Octave_shift),

		Offsets:           make(map[*Offset]any),
		Offsets_mapString: make(map[string]*Offset),

		Opuss:           make(map[*Opus]any),
		Opuss_mapString: make(map[string]*Opus),

		Ornamentss:           make(map[*Ornaments]any),
		Ornamentss_mapString: make(map[string]*Ornaments),

		Other_appearances:           make(map[*Other_appearance]any),
		Other_appearances_mapString: make(map[string]*Other_appearance),

		Other_listenings:           make(map[*Other_listening]any),
		Other_listenings_mapString: make(map[string]*Other_listening),

		Other_notations:           make(map[*Other_notation]any),
		Other_notations_mapString: make(map[string]*Other_notation),

		Other_plays:           make(map[*Other_play]any),
		Other_plays_mapString: make(map[string]*Other_play),

		Page_layouts:           make(map[*Page_layout]any),
		Page_layouts_mapString: make(map[string]*Page_layout),

		Page_marginss:           make(map[*Page_margins]any),
		Page_marginss_mapString: make(map[string]*Page_margins),

		Part_clefs:           make(map[*Part_clef]any),
		Part_clefs_mapString: make(map[string]*Part_clef),

		Part_groups:           make(map[*Part_group]any),
		Part_groups_mapString: make(map[string]*Part_group),

		Part_links:           make(map[*Part_link]any),
		Part_links_mapString: make(map[string]*Part_link),

		Part_lists:           make(map[*Part_list]any),
		Part_lists_mapString: make(map[string]*Part_list),

		Part_symbols:           make(map[*Part_symbol]any),
		Part_symbols_mapString: make(map[string]*Part_symbol),

		Part_transposes:           make(map[*Part_transpose]any),
		Part_transposes_mapString: make(map[string]*Part_transpose),

		Pedals:           make(map[*Pedal]any),
		Pedals_mapString: make(map[string]*Pedal),

		Pedal_tunings:           make(map[*Pedal_tuning]any),
		Pedal_tunings_mapString: make(map[string]*Pedal_tuning),

		Percussions:           make(map[*Percussion]any),
		Percussions_mapString: make(map[string]*Percussion),

		Pitchs:           make(map[*Pitch]any),
		Pitchs_mapString: make(map[string]*Pitch),

		Pitcheds:           make(map[*Pitched]any),
		Pitcheds_mapString: make(map[string]*Pitched),

		Plays:           make(map[*Play]any),
		Plays_mapString: make(map[string]*Play),

		Players:           make(map[*Player]any),
		Players_mapString: make(map[string]*Player),

		Principal_voices:           make(map[*Principal_voice]any),
		Principal_voices_mapString: make(map[string]*Principal_voice),

		Prints:           make(map[*Print]any),
		Prints_mapString: make(map[string]*Print),

		Releases:           make(map[*Release]any),
		Releases_mapString: make(map[string]*Release),

		Repeats:           make(map[*Repeat]any),
		Repeats_mapString: make(map[string]*Repeat),

		Rests:           make(map[*Rest]any),
		Rests_mapString: make(map[string]*Rest),

		Roots:           make(map[*Root]any),
		Roots_mapString: make(map[string]*Root),

		Root_steps:           make(map[*Root_step]any),
		Root_steps_mapString: make(map[string]*Root_step),

		Scalings:           make(map[*Scaling]any),
		Scalings_mapString: make(map[string]*Scaling),

		Scordaturas:           make(map[*Scordatura]any),
		Scordaturas_mapString: make(map[string]*Scordatura),

		Score_instruments:           make(map[*Score_instrument]any),
		Score_instruments_mapString: make(map[string]*Score_instrument),

		Score_parts:           make(map[*Score_part]any),
		Score_parts_mapString: make(map[string]*Score_part),

		Score_partwises:           make(map[*Score_partwise]any),
		Score_partwises_mapString: make(map[string]*Score_partwise),

		Score_timewises:           make(map[*Score_timewise]any),
		Score_timewises_mapString: make(map[string]*Score_timewise),

		Segnos:           make(map[*Segno]any),
		Segnos_mapString: make(map[string]*Segno),

		Slashs:           make(map[*Slash]any),
		Slashs_mapString: make(map[string]*Slash),

		Slides:           make(map[*Slide]any),
		Slides_mapString: make(map[string]*Slide),

		Slurs:           make(map[*Slur]any),
		Slurs_mapString: make(map[string]*Slur),

		Sounds:           make(map[*Sound]any),
		Sounds_mapString: make(map[string]*Sound),

		Staff_detailss:           make(map[*Staff_details]any),
		Staff_detailss_mapString: make(map[string]*Staff_details),

		Staff_divides:           make(map[*Staff_divide]any),
		Staff_divides_mapString: make(map[string]*Staff_divide),

		Staff_layouts:           make(map[*Staff_layout]any),
		Staff_layouts_mapString: make(map[string]*Staff_layout),

		Staff_sizes:           make(map[*Staff_size]any),
		Staff_sizes_mapString: make(map[string]*Staff_size),

		Staff_tunings:           make(map[*Staff_tuning]any),
		Staff_tunings_mapString: make(map[string]*Staff_tuning),

		Stems:           make(map[*Stem]any),
		Stems_mapString: make(map[string]*Stem),

		Sticks:           make(map[*Stick]any),
		Sticks_mapString: make(map[string]*Stick),

		String_mutes:           make(map[*String_mute]any),
		String_mutes_mapString: make(map[string]*String_mute),

		Strong_accents:           make(map[*Strong_accent]any),
		Strong_accents_mapString: make(map[string]*Strong_accent),

		Supportss:           make(map[*Supports]any),
		Supportss_mapString: make(map[string]*Supports),

		Swings:           make(map[*Swing]any),
		Swings_mapString: make(map[string]*Swing),

		Syncs:           make(map[*Sync]any),
		Syncs_mapString: make(map[string]*Sync),

		System_dividerss:           make(map[*System_dividers]any),
		System_dividerss_mapString: make(map[string]*System_dividers),

		System_layouts:           make(map[*System_layout]any),
		System_layouts_mapString: make(map[string]*System_layout),

		System_marginss:           make(map[*System_margins]any),
		System_marginss_mapString: make(map[string]*System_margins),

		Taps:           make(map[*Tap]any),
		Taps_mapString: make(map[string]*Tap),

		Technicals:           make(map[*Technical]any),
		Technicals_mapString: make(map[string]*Technical),

		Text_element_datas:           make(map[*Text_element_data]any),
		Text_element_datas_mapString: make(map[string]*Text_element_data),

		Ties:           make(map[*Tie]any),
		Ties_mapString: make(map[string]*Tie),

		Tieds:           make(map[*Tied]any),
		Tieds_mapString: make(map[string]*Tied),

		Times:           make(map[*Time]any),
		Times_mapString: make(map[string]*Time),

		Time_modifications:           make(map[*Time_modification]any),
		Time_modifications_mapString: make(map[string]*Time_modification),

		Timpanis:           make(map[*Timpani]any),
		Timpanis_mapString: make(map[string]*Timpani),

		Transposes:           make(map[*Transpose]any),
		Transposes_mapString: make(map[string]*Transpose),

		Tremolos:           make(map[*Tremolo]any),
		Tremolos_mapString: make(map[string]*Tremolo),

		Tuplets:           make(map[*Tuplet]any),
		Tuplets_mapString: make(map[string]*Tuplet),

		Tuplet_dots:           make(map[*Tuplet_dot]any),
		Tuplet_dots_mapString: make(map[string]*Tuplet_dot),

		Tuplet_numbers:           make(map[*Tuplet_number]any),
		Tuplet_numbers_mapString: make(map[string]*Tuplet_number),

		Tuplet_portions:           make(map[*Tuplet_portion]any),
		Tuplet_portions_mapString: make(map[string]*Tuplet_portion),

		Tuplet_types:           make(map[*Tuplet_type]any),
		Tuplet_types_mapString: make(map[string]*Tuplet_type),

		Typed_texts:           make(map[*Typed_text]any),
		Typed_texts_mapString: make(map[string]*Typed_text),

		Unpitcheds:           make(map[*Unpitched]any),
		Unpitcheds_mapString: make(map[string]*Unpitched),

		Virtual_instruments:           make(map[*Virtual_instrument]any),
		Virtual_instruments_mapString: make(map[string]*Virtual_instrument),

		Waits:           make(map[*Wait]any),
		Waits_mapString: make(map[string]*Wait),

		Wavy_lines:           make(map[*Wavy_line]any),
		Wavy_lines_mapString: make(map[string]*Wavy_line),

		Wedges:           make(map[*Wedge]any),
		Wedges_mapString: make(map[string]*Wedge),

		Woods:           make(map[*Wood]any),
		Woods_mapString: make(map[string]*Wood),

		Works:           make(map[*Work]any),
		Works_mapString: make(map[string]*Work),

		// end of insertion point
		Map_GongStructName_InstancesNb: make(map[string]int),

		path: path,

		// to be removed after fix of [issue](https://github.com/golang/go/issues/57559)
		Map_DocLink_Renaming: make(map[string]GONG__Identifier),
		// the to be removed stops here
	}

	return
}

func (stage *StageStruct) GetPath() string {
	return stage.path
}

func (stage *StageStruct) CommitWithSuspendedCallbacks() {

	tmp := stage.OnInitCommitFromBackCallback
	stage.OnInitCommitFromBackCallback = nil
	stage.Commit()
	stage.OnInitCommitFromBackCallback = tmp
}

func (stage *StageStruct) Commit() {
	stage.ComputeReverseMaps()

	if stage.BackRepo != nil {
		stage.BackRepo.Commit(stage)
	}

	// insertion point for computing the map of number of instances per gongstruct
	stage.Map_GongStructName_InstancesNb["Accidental"] = len(stage.Accidentals)
	stage.Map_GongStructName_InstancesNb["Accidental_mark"] = len(stage.Accidental_marks)
	stage.Map_GongStructName_InstancesNb["Accidental_text"] = len(stage.Accidental_texts)
	stage.Map_GongStructName_InstancesNb["Accord"] = len(stage.Accords)
	stage.Map_GongStructName_InstancesNb["Accordion_registration"] = len(stage.Accordion_registrations)
	stage.Map_GongStructName_InstancesNb["AnyType"] = len(stage.AnyTypes)
	stage.Map_GongStructName_InstancesNb["Appearance"] = len(stage.Appearances)
	stage.Map_GongStructName_InstancesNb["Arpeggiate"] = len(stage.Arpeggiates)
	stage.Map_GongStructName_InstancesNb["Arrow"] = len(stage.Arrows)
	stage.Map_GongStructName_InstancesNb["Articulations"] = len(stage.Articulationss)
	stage.Map_GongStructName_InstancesNb["Assess"] = len(stage.Assesss)
	stage.Map_GongStructName_InstancesNb["Attributes"] = len(stage.Attributess)
	stage.Map_GongStructName_InstancesNb["Backup"] = len(stage.Backups)
	stage.Map_GongStructName_InstancesNb["Bar_style_color"] = len(stage.Bar_style_colors)
	stage.Map_GongStructName_InstancesNb["Barline"] = len(stage.Barlines)
	stage.Map_GongStructName_InstancesNb["Barre"] = len(stage.Barres)
	stage.Map_GongStructName_InstancesNb["Bass"] = len(stage.Basss)
	stage.Map_GongStructName_InstancesNb["Bass_step"] = len(stage.Bass_steps)
	stage.Map_GongStructName_InstancesNb["Beam"] = len(stage.Beams)
	stage.Map_GongStructName_InstancesNb["Beat_repeat"] = len(stage.Beat_repeats)
	stage.Map_GongStructName_InstancesNb["Beat_unit_tied"] = len(stage.Beat_unit_tieds)
	stage.Map_GongStructName_InstancesNb["Beater"] = len(stage.Beaters)
	stage.Map_GongStructName_InstancesNb["Bend"] = len(stage.Bends)
	stage.Map_GongStructName_InstancesNb["Bookmark"] = len(stage.Bookmarks)
	stage.Map_GongStructName_InstancesNb["Bracket"] = len(stage.Brackets)
	stage.Map_GongStructName_InstancesNb["Breath_mark"] = len(stage.Breath_marks)
	stage.Map_GongStructName_InstancesNb["Caesura"] = len(stage.Caesuras)
	stage.Map_GongStructName_InstancesNb["Cancel"] = len(stage.Cancels)
	stage.Map_GongStructName_InstancesNb["Clef"] = len(stage.Clefs)
	stage.Map_GongStructName_InstancesNb["Coda"] = len(stage.Codas)
	stage.Map_GongStructName_InstancesNb["Credit"] = len(stage.Credits)
	stage.Map_GongStructName_InstancesNb["Dashes"] = len(stage.Dashess)
	stage.Map_GongStructName_InstancesNb["Defaults"] = len(stage.Defaultss)
	stage.Map_GongStructName_InstancesNb["Degree"] = len(stage.Degrees)
	stage.Map_GongStructName_InstancesNb["Degree_alter"] = len(stage.Degree_alters)
	stage.Map_GongStructName_InstancesNb["Degree_type"] = len(stage.Degree_types)
	stage.Map_GongStructName_InstancesNb["Degree_value"] = len(stage.Degree_values)
	stage.Map_GongStructName_InstancesNb["Direction"] = len(stage.Directions)
	stage.Map_GongStructName_InstancesNb["Direction_type"] = len(stage.Direction_types)
	stage.Map_GongStructName_InstancesNb["Distance"] = len(stage.Distances)
	stage.Map_GongStructName_InstancesNb["Double"] = len(stage.Doubles)
	stage.Map_GongStructName_InstancesNb["Dynamics"] = len(stage.Dynamicss)
	stage.Map_GongStructName_InstancesNb["Effect"] = len(stage.Effects)
	stage.Map_GongStructName_InstancesNb["Elision"] = len(stage.Elisions)
	stage.Map_GongStructName_InstancesNb["Empty"] = len(stage.Emptys)
	stage.Map_GongStructName_InstancesNb["Empty_font"] = len(stage.Empty_fonts)
	stage.Map_GongStructName_InstancesNb["Empty_line"] = len(stage.Empty_lines)
	stage.Map_GongStructName_InstancesNb["Empty_placement"] = len(stage.Empty_placements)
	stage.Map_GongStructName_InstancesNb["Empty_placement_smufl"] = len(stage.Empty_placement_smufls)
	stage.Map_GongStructName_InstancesNb["Empty_print_object_style_align"] = len(stage.Empty_print_object_style_aligns)
	stage.Map_GongStructName_InstancesNb["Empty_print_style"] = len(stage.Empty_print_styles)
	stage.Map_GongStructName_InstancesNb["Empty_print_style_align"] = len(stage.Empty_print_style_aligns)
	stage.Map_GongStructName_InstancesNb["Empty_print_style_align_id"] = len(stage.Empty_print_style_align_ids)
	stage.Map_GongStructName_InstancesNb["Empty_trill_sound"] = len(stage.Empty_trill_sounds)
	stage.Map_GongStructName_InstancesNb["Encoding"] = len(stage.Encodings)
	stage.Map_GongStructName_InstancesNb["Ending"] = len(stage.Endings)
	stage.Map_GongStructName_InstancesNb["Extend"] = len(stage.Extends)
	stage.Map_GongStructName_InstancesNb["Feature"] = len(stage.Features)
	stage.Map_GongStructName_InstancesNb["Fermata"] = len(stage.Fermatas)
	stage.Map_GongStructName_InstancesNb["Figure"] = len(stage.Figures)
	stage.Map_GongStructName_InstancesNb["Figured_bass"] = len(stage.Figured_basss)
	stage.Map_GongStructName_InstancesNb["Fingering"] = len(stage.Fingerings)
	stage.Map_GongStructName_InstancesNb["First_fret"] = len(stage.First_frets)
	stage.Map_GongStructName_InstancesNb["Foo"] = len(stage.Foos)
	stage.Map_GongStructName_InstancesNb["For_part"] = len(stage.For_parts)
	stage.Map_GongStructName_InstancesNb["Formatted_symbol"] = len(stage.Formatted_symbols)
	stage.Map_GongStructName_InstancesNb["Formatted_symbol_id"] = len(stage.Formatted_symbol_ids)
	stage.Map_GongStructName_InstancesNb["Forward"] = len(stage.Forwards)
	stage.Map_GongStructName_InstancesNb["Frame"] = len(stage.Frames)
	stage.Map_GongStructName_InstancesNb["Frame_note"] = len(stage.Frame_notes)
	stage.Map_GongStructName_InstancesNb["Fret"] = len(stage.Frets)
	stage.Map_GongStructName_InstancesNb["Glass"] = len(stage.Glasss)
	stage.Map_GongStructName_InstancesNb["Glissando"] = len(stage.Glissandos)
	stage.Map_GongStructName_InstancesNb["Glyph"] = len(stage.Glyphs)
	stage.Map_GongStructName_InstancesNb["Grace"] = len(stage.Graces)
	stage.Map_GongStructName_InstancesNb["Group_barline"] = len(stage.Group_barlines)
	stage.Map_GongStructName_InstancesNb["Group_symbol"] = len(stage.Group_symbols)
	stage.Map_GongStructName_InstancesNb["Grouping"] = len(stage.Groupings)
	stage.Map_GongStructName_InstancesNb["Hammer_on_pull_off"] = len(stage.Hammer_on_pull_offs)
	stage.Map_GongStructName_InstancesNb["Handbell"] = len(stage.Handbells)
	stage.Map_GongStructName_InstancesNb["Harmon_closed"] = len(stage.Harmon_closeds)
	stage.Map_GongStructName_InstancesNb["Harmon_mute"] = len(stage.Harmon_mutes)
	stage.Map_GongStructName_InstancesNb["Harmonic"] = len(stage.Harmonics)
	stage.Map_GongStructName_InstancesNb["Harmony"] = len(stage.Harmonys)
	stage.Map_GongStructName_InstancesNb["Harmony_alter"] = len(stage.Harmony_alters)
	stage.Map_GongStructName_InstancesNb["Harp_pedals"] = len(stage.Harp_pedalss)
	stage.Map_GongStructName_InstancesNb["Heel_toe"] = len(stage.Heel_toes)
	stage.Map_GongStructName_InstancesNb["Hole"] = len(stage.Holes)
	stage.Map_GongStructName_InstancesNb["Hole_closed"] = len(stage.Hole_closeds)
	stage.Map_GongStructName_InstancesNb["Horizontal_turn"] = len(stage.Horizontal_turns)
	stage.Map_GongStructName_InstancesNb["Identification"] = len(stage.Identifications)
	stage.Map_GongStructName_InstancesNb["Image"] = len(stage.Images)
	stage.Map_GongStructName_InstancesNb["Instrument"] = len(stage.Instruments)
	stage.Map_GongStructName_InstancesNb["Instrument_change"] = len(stage.Instrument_changes)
	stage.Map_GongStructName_InstancesNb["Instrument_link"] = len(stage.Instrument_links)
	stage.Map_GongStructName_InstancesNb["Interchangeable"] = len(stage.Interchangeables)
	stage.Map_GongStructName_InstancesNb["Inversion"] = len(stage.Inversions)
	stage.Map_GongStructName_InstancesNb["Key"] = len(stage.Keys)
	stage.Map_GongStructName_InstancesNb["Key_accidental"] = len(stage.Key_accidentals)
	stage.Map_GongStructName_InstancesNb["Key_octave"] = len(stage.Key_octaves)
	stage.Map_GongStructName_InstancesNb["Kind"] = len(stage.Kinds)
	stage.Map_GongStructName_InstancesNb["Level"] = len(stage.Levels)
	stage.Map_GongStructName_InstancesNb["Line_detail"] = len(stage.Line_details)
	stage.Map_GongStructName_InstancesNb["Line_width"] = len(stage.Line_widths)
	stage.Map_GongStructName_InstancesNb["Link"] = len(stage.Links)
	stage.Map_GongStructName_InstancesNb["Listen"] = len(stage.Listens)
	stage.Map_GongStructName_InstancesNb["Listening"] = len(stage.Listenings)
	stage.Map_GongStructName_InstancesNb["Lyric"] = len(stage.Lyrics)
	stage.Map_GongStructName_InstancesNb["Lyric_font"] = len(stage.Lyric_fonts)
	stage.Map_GongStructName_InstancesNb["Lyric_language"] = len(stage.Lyric_languages)
	stage.Map_GongStructName_InstancesNb["Measure_layout"] = len(stage.Measure_layouts)
	stage.Map_GongStructName_InstancesNb["Measure_numbering"] = len(stage.Measure_numberings)
	stage.Map_GongStructName_InstancesNb["Measure_repeat"] = len(stage.Measure_repeats)
	stage.Map_GongStructName_InstancesNb["Measure_style"] = len(stage.Measure_styles)
	stage.Map_GongStructName_InstancesNb["Membrane"] = len(stage.Membranes)
	stage.Map_GongStructName_InstancesNb["Metal"] = len(stage.Metals)
	stage.Map_GongStructName_InstancesNb["Metronome"] = len(stage.Metronomes)
	stage.Map_GongStructName_InstancesNb["Metronome_beam"] = len(stage.Metronome_beams)
	stage.Map_GongStructName_InstancesNb["Metronome_note"] = len(stage.Metronome_notes)
	stage.Map_GongStructName_InstancesNb["Metronome_tied"] = len(stage.Metronome_tieds)
	stage.Map_GongStructName_InstancesNb["Metronome_tuplet"] = len(stage.Metronome_tuplets)
	stage.Map_GongStructName_InstancesNb["Midi_device"] = len(stage.Midi_devices)
	stage.Map_GongStructName_InstancesNb["Midi_instrument"] = len(stage.Midi_instruments)
	stage.Map_GongStructName_InstancesNb["Miscellaneous"] = len(stage.Miscellaneouss)
	stage.Map_GongStructName_InstancesNb["Miscellaneous_field"] = len(stage.Miscellaneous_fields)
	stage.Map_GongStructName_InstancesNb["Mordent"] = len(stage.Mordents)
	stage.Map_GongStructName_InstancesNb["Multiple_rest"] = len(stage.Multiple_rests)
	stage.Map_GongStructName_InstancesNb["Name_display"] = len(stage.Name_displays)
	stage.Map_GongStructName_InstancesNb["Non_arpeggiate"] = len(stage.Non_arpeggiates)
	stage.Map_GongStructName_InstancesNb["Notations"] = len(stage.Notationss)
	stage.Map_GongStructName_InstancesNb["Note"] = len(stage.Notes)
	stage.Map_GongStructName_InstancesNb["Note_size"] = len(stage.Note_sizes)
	stage.Map_GongStructName_InstancesNb["Note_type"] = len(stage.Note_types)
	stage.Map_GongStructName_InstancesNb["Notehead"] = len(stage.Noteheads)
	stage.Map_GongStructName_InstancesNb["Notehead_text"] = len(stage.Notehead_texts)
	stage.Map_GongStructName_InstancesNb["Numeral"] = len(stage.Numerals)
	stage.Map_GongStructName_InstancesNb["Numeral_key"] = len(stage.Numeral_keys)
	stage.Map_GongStructName_InstancesNb["Numeral_root"] = len(stage.Numeral_roots)
	stage.Map_GongStructName_InstancesNb["Octave_shift"] = len(stage.Octave_shifts)
	stage.Map_GongStructName_InstancesNb["Offset"] = len(stage.Offsets)
	stage.Map_GongStructName_InstancesNb["Opus"] = len(stage.Opuss)
	stage.Map_GongStructName_InstancesNb["Ornaments"] = len(stage.Ornamentss)
	stage.Map_GongStructName_InstancesNb["Other_appearance"] = len(stage.Other_appearances)
	stage.Map_GongStructName_InstancesNb["Other_listening"] = len(stage.Other_listenings)
	stage.Map_GongStructName_InstancesNb["Other_notation"] = len(stage.Other_notations)
	stage.Map_GongStructName_InstancesNb["Other_play"] = len(stage.Other_plays)
	stage.Map_GongStructName_InstancesNb["Page_layout"] = len(stage.Page_layouts)
	stage.Map_GongStructName_InstancesNb["Page_margins"] = len(stage.Page_marginss)
	stage.Map_GongStructName_InstancesNb["Part_clef"] = len(stage.Part_clefs)
	stage.Map_GongStructName_InstancesNb["Part_group"] = len(stage.Part_groups)
	stage.Map_GongStructName_InstancesNb["Part_link"] = len(stage.Part_links)
	stage.Map_GongStructName_InstancesNb["Part_list"] = len(stage.Part_lists)
	stage.Map_GongStructName_InstancesNb["Part_symbol"] = len(stage.Part_symbols)
	stage.Map_GongStructName_InstancesNb["Part_transpose"] = len(stage.Part_transposes)
	stage.Map_GongStructName_InstancesNb["Pedal"] = len(stage.Pedals)
	stage.Map_GongStructName_InstancesNb["Pedal_tuning"] = len(stage.Pedal_tunings)
	stage.Map_GongStructName_InstancesNb["Percussion"] = len(stage.Percussions)
	stage.Map_GongStructName_InstancesNb["Pitch"] = len(stage.Pitchs)
	stage.Map_GongStructName_InstancesNb["Pitched"] = len(stage.Pitcheds)
	stage.Map_GongStructName_InstancesNb["Play"] = len(stage.Plays)
	stage.Map_GongStructName_InstancesNb["Player"] = len(stage.Players)
	stage.Map_GongStructName_InstancesNb["Principal_voice"] = len(stage.Principal_voices)
	stage.Map_GongStructName_InstancesNb["Print"] = len(stage.Prints)
	stage.Map_GongStructName_InstancesNb["Release"] = len(stage.Releases)
	stage.Map_GongStructName_InstancesNb["Repeat"] = len(stage.Repeats)
	stage.Map_GongStructName_InstancesNb["Rest"] = len(stage.Rests)
	stage.Map_GongStructName_InstancesNb["Root"] = len(stage.Roots)
	stage.Map_GongStructName_InstancesNb["Root_step"] = len(stage.Root_steps)
	stage.Map_GongStructName_InstancesNb["Scaling"] = len(stage.Scalings)
	stage.Map_GongStructName_InstancesNb["Scordatura"] = len(stage.Scordaturas)
	stage.Map_GongStructName_InstancesNb["Score_instrument"] = len(stage.Score_instruments)
	stage.Map_GongStructName_InstancesNb["Score_part"] = len(stage.Score_parts)
	stage.Map_GongStructName_InstancesNb["Score_partwise"] = len(stage.Score_partwises)
	stage.Map_GongStructName_InstancesNb["Score_timewise"] = len(stage.Score_timewises)
	stage.Map_GongStructName_InstancesNb["Segno"] = len(stage.Segnos)
	stage.Map_GongStructName_InstancesNb["Slash"] = len(stage.Slashs)
	stage.Map_GongStructName_InstancesNb["Slide"] = len(stage.Slides)
	stage.Map_GongStructName_InstancesNb["Slur"] = len(stage.Slurs)
	stage.Map_GongStructName_InstancesNb["Sound"] = len(stage.Sounds)
	stage.Map_GongStructName_InstancesNb["Staff_details"] = len(stage.Staff_detailss)
	stage.Map_GongStructName_InstancesNb["Staff_divide"] = len(stage.Staff_divides)
	stage.Map_GongStructName_InstancesNb["Staff_layout"] = len(stage.Staff_layouts)
	stage.Map_GongStructName_InstancesNb["Staff_size"] = len(stage.Staff_sizes)
	stage.Map_GongStructName_InstancesNb["Staff_tuning"] = len(stage.Staff_tunings)
	stage.Map_GongStructName_InstancesNb["Stem"] = len(stage.Stems)
	stage.Map_GongStructName_InstancesNb["Stick"] = len(stage.Sticks)
	stage.Map_GongStructName_InstancesNb["String_mute"] = len(stage.String_mutes)
	stage.Map_GongStructName_InstancesNb["Strong_accent"] = len(stage.Strong_accents)
	stage.Map_GongStructName_InstancesNb["Supports"] = len(stage.Supportss)
	stage.Map_GongStructName_InstancesNb["Swing"] = len(stage.Swings)
	stage.Map_GongStructName_InstancesNb["Sync"] = len(stage.Syncs)
	stage.Map_GongStructName_InstancesNb["System_dividers"] = len(stage.System_dividerss)
	stage.Map_GongStructName_InstancesNb["System_layout"] = len(stage.System_layouts)
	stage.Map_GongStructName_InstancesNb["System_margins"] = len(stage.System_marginss)
	stage.Map_GongStructName_InstancesNb["Tap"] = len(stage.Taps)
	stage.Map_GongStructName_InstancesNb["Technical"] = len(stage.Technicals)
	stage.Map_GongStructName_InstancesNb["Text_element_data"] = len(stage.Text_element_datas)
	stage.Map_GongStructName_InstancesNb["Tie"] = len(stage.Ties)
	stage.Map_GongStructName_InstancesNb["Tied"] = len(stage.Tieds)
	stage.Map_GongStructName_InstancesNb["Time"] = len(stage.Times)
	stage.Map_GongStructName_InstancesNb["Time_modification"] = len(stage.Time_modifications)
	stage.Map_GongStructName_InstancesNb["Timpani"] = len(stage.Timpanis)
	stage.Map_GongStructName_InstancesNb["Transpose"] = len(stage.Transposes)
	stage.Map_GongStructName_InstancesNb["Tremolo"] = len(stage.Tremolos)
	stage.Map_GongStructName_InstancesNb["Tuplet"] = len(stage.Tuplets)
	stage.Map_GongStructName_InstancesNb["Tuplet_dot"] = len(stage.Tuplet_dots)
	stage.Map_GongStructName_InstancesNb["Tuplet_number"] = len(stage.Tuplet_numbers)
	stage.Map_GongStructName_InstancesNb["Tuplet_portion"] = len(stage.Tuplet_portions)
	stage.Map_GongStructName_InstancesNb["Tuplet_type"] = len(stage.Tuplet_types)
	stage.Map_GongStructName_InstancesNb["Typed_text"] = len(stage.Typed_texts)
	stage.Map_GongStructName_InstancesNb["Unpitched"] = len(stage.Unpitcheds)
	stage.Map_GongStructName_InstancesNb["Virtual_instrument"] = len(stage.Virtual_instruments)
	stage.Map_GongStructName_InstancesNb["Wait"] = len(stage.Waits)
	stage.Map_GongStructName_InstancesNb["Wavy_line"] = len(stage.Wavy_lines)
	stage.Map_GongStructName_InstancesNb["Wedge"] = len(stage.Wedges)
	stage.Map_GongStructName_InstancesNb["Wood"] = len(stage.Woods)
	stage.Map_GongStructName_InstancesNb["Work"] = len(stage.Works)

}

func (stage *StageStruct) Checkout() {
	if stage.BackRepo != nil {
		stage.BackRepo.Checkout(stage)
	}

	stage.ComputeReverseMaps()
	// insertion point for computing the map of number of instances per gongstruct
	stage.Map_GongStructName_InstancesNb["Accidental"] = len(stage.Accidentals)
	stage.Map_GongStructName_InstancesNb["Accidental_mark"] = len(stage.Accidental_marks)
	stage.Map_GongStructName_InstancesNb["Accidental_text"] = len(stage.Accidental_texts)
	stage.Map_GongStructName_InstancesNb["Accord"] = len(stage.Accords)
	stage.Map_GongStructName_InstancesNb["Accordion_registration"] = len(stage.Accordion_registrations)
	stage.Map_GongStructName_InstancesNb["AnyType"] = len(stage.AnyTypes)
	stage.Map_GongStructName_InstancesNb["Appearance"] = len(stage.Appearances)
	stage.Map_GongStructName_InstancesNb["Arpeggiate"] = len(stage.Arpeggiates)
	stage.Map_GongStructName_InstancesNb["Arrow"] = len(stage.Arrows)
	stage.Map_GongStructName_InstancesNb["Articulations"] = len(stage.Articulationss)
	stage.Map_GongStructName_InstancesNb["Assess"] = len(stage.Assesss)
	stage.Map_GongStructName_InstancesNb["Attributes"] = len(stage.Attributess)
	stage.Map_GongStructName_InstancesNb["Backup"] = len(stage.Backups)
	stage.Map_GongStructName_InstancesNb["Bar_style_color"] = len(stage.Bar_style_colors)
	stage.Map_GongStructName_InstancesNb["Barline"] = len(stage.Barlines)
	stage.Map_GongStructName_InstancesNb["Barre"] = len(stage.Barres)
	stage.Map_GongStructName_InstancesNb["Bass"] = len(stage.Basss)
	stage.Map_GongStructName_InstancesNb["Bass_step"] = len(stage.Bass_steps)
	stage.Map_GongStructName_InstancesNb["Beam"] = len(stage.Beams)
	stage.Map_GongStructName_InstancesNb["Beat_repeat"] = len(stage.Beat_repeats)
	stage.Map_GongStructName_InstancesNb["Beat_unit_tied"] = len(stage.Beat_unit_tieds)
	stage.Map_GongStructName_InstancesNb["Beater"] = len(stage.Beaters)
	stage.Map_GongStructName_InstancesNb["Bend"] = len(stage.Bends)
	stage.Map_GongStructName_InstancesNb["Bookmark"] = len(stage.Bookmarks)
	stage.Map_GongStructName_InstancesNb["Bracket"] = len(stage.Brackets)
	stage.Map_GongStructName_InstancesNb["Breath_mark"] = len(stage.Breath_marks)
	stage.Map_GongStructName_InstancesNb["Caesura"] = len(stage.Caesuras)
	stage.Map_GongStructName_InstancesNb["Cancel"] = len(stage.Cancels)
	stage.Map_GongStructName_InstancesNb["Clef"] = len(stage.Clefs)
	stage.Map_GongStructName_InstancesNb["Coda"] = len(stage.Codas)
	stage.Map_GongStructName_InstancesNb["Credit"] = len(stage.Credits)
	stage.Map_GongStructName_InstancesNb["Dashes"] = len(stage.Dashess)
	stage.Map_GongStructName_InstancesNb["Defaults"] = len(stage.Defaultss)
	stage.Map_GongStructName_InstancesNb["Degree"] = len(stage.Degrees)
	stage.Map_GongStructName_InstancesNb["Degree_alter"] = len(stage.Degree_alters)
	stage.Map_GongStructName_InstancesNb["Degree_type"] = len(stage.Degree_types)
	stage.Map_GongStructName_InstancesNb["Degree_value"] = len(stage.Degree_values)
	stage.Map_GongStructName_InstancesNb["Direction"] = len(stage.Directions)
	stage.Map_GongStructName_InstancesNb["Direction_type"] = len(stage.Direction_types)
	stage.Map_GongStructName_InstancesNb["Distance"] = len(stage.Distances)
	stage.Map_GongStructName_InstancesNb["Double"] = len(stage.Doubles)
	stage.Map_GongStructName_InstancesNb["Dynamics"] = len(stage.Dynamicss)
	stage.Map_GongStructName_InstancesNb["Effect"] = len(stage.Effects)
	stage.Map_GongStructName_InstancesNb["Elision"] = len(stage.Elisions)
	stage.Map_GongStructName_InstancesNb["Empty"] = len(stage.Emptys)
	stage.Map_GongStructName_InstancesNb["Empty_font"] = len(stage.Empty_fonts)
	stage.Map_GongStructName_InstancesNb["Empty_line"] = len(stage.Empty_lines)
	stage.Map_GongStructName_InstancesNb["Empty_placement"] = len(stage.Empty_placements)
	stage.Map_GongStructName_InstancesNb["Empty_placement_smufl"] = len(stage.Empty_placement_smufls)
	stage.Map_GongStructName_InstancesNb["Empty_print_object_style_align"] = len(stage.Empty_print_object_style_aligns)
	stage.Map_GongStructName_InstancesNb["Empty_print_style"] = len(stage.Empty_print_styles)
	stage.Map_GongStructName_InstancesNb["Empty_print_style_align"] = len(stage.Empty_print_style_aligns)
	stage.Map_GongStructName_InstancesNb["Empty_print_style_align_id"] = len(stage.Empty_print_style_align_ids)
	stage.Map_GongStructName_InstancesNb["Empty_trill_sound"] = len(stage.Empty_trill_sounds)
	stage.Map_GongStructName_InstancesNb["Encoding"] = len(stage.Encodings)
	stage.Map_GongStructName_InstancesNb["Ending"] = len(stage.Endings)
	stage.Map_GongStructName_InstancesNb["Extend"] = len(stage.Extends)
	stage.Map_GongStructName_InstancesNb["Feature"] = len(stage.Features)
	stage.Map_GongStructName_InstancesNb["Fermata"] = len(stage.Fermatas)
	stage.Map_GongStructName_InstancesNb["Figure"] = len(stage.Figures)
	stage.Map_GongStructName_InstancesNb["Figured_bass"] = len(stage.Figured_basss)
	stage.Map_GongStructName_InstancesNb["Fingering"] = len(stage.Fingerings)
	stage.Map_GongStructName_InstancesNb["First_fret"] = len(stage.First_frets)
	stage.Map_GongStructName_InstancesNb["Foo"] = len(stage.Foos)
	stage.Map_GongStructName_InstancesNb["For_part"] = len(stage.For_parts)
	stage.Map_GongStructName_InstancesNb["Formatted_symbol"] = len(stage.Formatted_symbols)
	stage.Map_GongStructName_InstancesNb["Formatted_symbol_id"] = len(stage.Formatted_symbol_ids)
	stage.Map_GongStructName_InstancesNb["Forward"] = len(stage.Forwards)
	stage.Map_GongStructName_InstancesNb["Frame"] = len(stage.Frames)
	stage.Map_GongStructName_InstancesNb["Frame_note"] = len(stage.Frame_notes)
	stage.Map_GongStructName_InstancesNb["Fret"] = len(stage.Frets)
	stage.Map_GongStructName_InstancesNb["Glass"] = len(stage.Glasss)
	stage.Map_GongStructName_InstancesNb["Glissando"] = len(stage.Glissandos)
	stage.Map_GongStructName_InstancesNb["Glyph"] = len(stage.Glyphs)
	stage.Map_GongStructName_InstancesNb["Grace"] = len(stage.Graces)
	stage.Map_GongStructName_InstancesNb["Group_barline"] = len(stage.Group_barlines)
	stage.Map_GongStructName_InstancesNb["Group_symbol"] = len(stage.Group_symbols)
	stage.Map_GongStructName_InstancesNb["Grouping"] = len(stage.Groupings)
	stage.Map_GongStructName_InstancesNb["Hammer_on_pull_off"] = len(stage.Hammer_on_pull_offs)
	stage.Map_GongStructName_InstancesNb["Handbell"] = len(stage.Handbells)
	stage.Map_GongStructName_InstancesNb["Harmon_closed"] = len(stage.Harmon_closeds)
	stage.Map_GongStructName_InstancesNb["Harmon_mute"] = len(stage.Harmon_mutes)
	stage.Map_GongStructName_InstancesNb["Harmonic"] = len(stage.Harmonics)
	stage.Map_GongStructName_InstancesNb["Harmony"] = len(stage.Harmonys)
	stage.Map_GongStructName_InstancesNb["Harmony_alter"] = len(stage.Harmony_alters)
	stage.Map_GongStructName_InstancesNb["Harp_pedals"] = len(stage.Harp_pedalss)
	stage.Map_GongStructName_InstancesNb["Heel_toe"] = len(stage.Heel_toes)
	stage.Map_GongStructName_InstancesNb["Hole"] = len(stage.Holes)
	stage.Map_GongStructName_InstancesNb["Hole_closed"] = len(stage.Hole_closeds)
	stage.Map_GongStructName_InstancesNb["Horizontal_turn"] = len(stage.Horizontal_turns)
	stage.Map_GongStructName_InstancesNb["Identification"] = len(stage.Identifications)
	stage.Map_GongStructName_InstancesNb["Image"] = len(stage.Images)
	stage.Map_GongStructName_InstancesNb["Instrument"] = len(stage.Instruments)
	stage.Map_GongStructName_InstancesNb["Instrument_change"] = len(stage.Instrument_changes)
	stage.Map_GongStructName_InstancesNb["Instrument_link"] = len(stage.Instrument_links)
	stage.Map_GongStructName_InstancesNb["Interchangeable"] = len(stage.Interchangeables)
	stage.Map_GongStructName_InstancesNb["Inversion"] = len(stage.Inversions)
	stage.Map_GongStructName_InstancesNb["Key"] = len(stage.Keys)
	stage.Map_GongStructName_InstancesNb["Key_accidental"] = len(stage.Key_accidentals)
	stage.Map_GongStructName_InstancesNb["Key_octave"] = len(stage.Key_octaves)
	stage.Map_GongStructName_InstancesNb["Kind"] = len(stage.Kinds)
	stage.Map_GongStructName_InstancesNb["Level"] = len(stage.Levels)
	stage.Map_GongStructName_InstancesNb["Line_detail"] = len(stage.Line_details)
	stage.Map_GongStructName_InstancesNb["Line_width"] = len(stage.Line_widths)
	stage.Map_GongStructName_InstancesNb["Link"] = len(stage.Links)
	stage.Map_GongStructName_InstancesNb["Listen"] = len(stage.Listens)
	stage.Map_GongStructName_InstancesNb["Listening"] = len(stage.Listenings)
	stage.Map_GongStructName_InstancesNb["Lyric"] = len(stage.Lyrics)
	stage.Map_GongStructName_InstancesNb["Lyric_font"] = len(stage.Lyric_fonts)
	stage.Map_GongStructName_InstancesNb["Lyric_language"] = len(stage.Lyric_languages)
	stage.Map_GongStructName_InstancesNb["Measure_layout"] = len(stage.Measure_layouts)
	stage.Map_GongStructName_InstancesNb["Measure_numbering"] = len(stage.Measure_numberings)
	stage.Map_GongStructName_InstancesNb["Measure_repeat"] = len(stage.Measure_repeats)
	stage.Map_GongStructName_InstancesNb["Measure_style"] = len(stage.Measure_styles)
	stage.Map_GongStructName_InstancesNb["Membrane"] = len(stage.Membranes)
	stage.Map_GongStructName_InstancesNb["Metal"] = len(stage.Metals)
	stage.Map_GongStructName_InstancesNb["Metronome"] = len(stage.Metronomes)
	stage.Map_GongStructName_InstancesNb["Metronome_beam"] = len(stage.Metronome_beams)
	stage.Map_GongStructName_InstancesNb["Metronome_note"] = len(stage.Metronome_notes)
	stage.Map_GongStructName_InstancesNb["Metronome_tied"] = len(stage.Metronome_tieds)
	stage.Map_GongStructName_InstancesNb["Metronome_tuplet"] = len(stage.Metronome_tuplets)
	stage.Map_GongStructName_InstancesNb["Midi_device"] = len(stage.Midi_devices)
	stage.Map_GongStructName_InstancesNb["Midi_instrument"] = len(stage.Midi_instruments)
	stage.Map_GongStructName_InstancesNb["Miscellaneous"] = len(stage.Miscellaneouss)
	stage.Map_GongStructName_InstancesNb["Miscellaneous_field"] = len(stage.Miscellaneous_fields)
	stage.Map_GongStructName_InstancesNb["Mordent"] = len(stage.Mordents)
	stage.Map_GongStructName_InstancesNb["Multiple_rest"] = len(stage.Multiple_rests)
	stage.Map_GongStructName_InstancesNb["Name_display"] = len(stage.Name_displays)
	stage.Map_GongStructName_InstancesNb["Non_arpeggiate"] = len(stage.Non_arpeggiates)
	stage.Map_GongStructName_InstancesNb["Notations"] = len(stage.Notationss)
	stage.Map_GongStructName_InstancesNb["Note"] = len(stage.Notes)
	stage.Map_GongStructName_InstancesNb["Note_size"] = len(stage.Note_sizes)
	stage.Map_GongStructName_InstancesNb["Note_type"] = len(stage.Note_types)
	stage.Map_GongStructName_InstancesNb["Notehead"] = len(stage.Noteheads)
	stage.Map_GongStructName_InstancesNb["Notehead_text"] = len(stage.Notehead_texts)
	stage.Map_GongStructName_InstancesNb["Numeral"] = len(stage.Numerals)
	stage.Map_GongStructName_InstancesNb["Numeral_key"] = len(stage.Numeral_keys)
	stage.Map_GongStructName_InstancesNb["Numeral_root"] = len(stage.Numeral_roots)
	stage.Map_GongStructName_InstancesNb["Octave_shift"] = len(stage.Octave_shifts)
	stage.Map_GongStructName_InstancesNb["Offset"] = len(stage.Offsets)
	stage.Map_GongStructName_InstancesNb["Opus"] = len(stage.Opuss)
	stage.Map_GongStructName_InstancesNb["Ornaments"] = len(stage.Ornamentss)
	stage.Map_GongStructName_InstancesNb["Other_appearance"] = len(stage.Other_appearances)
	stage.Map_GongStructName_InstancesNb["Other_listening"] = len(stage.Other_listenings)
	stage.Map_GongStructName_InstancesNb["Other_notation"] = len(stage.Other_notations)
	stage.Map_GongStructName_InstancesNb["Other_play"] = len(stage.Other_plays)
	stage.Map_GongStructName_InstancesNb["Page_layout"] = len(stage.Page_layouts)
	stage.Map_GongStructName_InstancesNb["Page_margins"] = len(stage.Page_marginss)
	stage.Map_GongStructName_InstancesNb["Part_clef"] = len(stage.Part_clefs)
	stage.Map_GongStructName_InstancesNb["Part_group"] = len(stage.Part_groups)
	stage.Map_GongStructName_InstancesNb["Part_link"] = len(stage.Part_links)
	stage.Map_GongStructName_InstancesNb["Part_list"] = len(stage.Part_lists)
	stage.Map_GongStructName_InstancesNb["Part_symbol"] = len(stage.Part_symbols)
	stage.Map_GongStructName_InstancesNb["Part_transpose"] = len(stage.Part_transposes)
	stage.Map_GongStructName_InstancesNb["Pedal"] = len(stage.Pedals)
	stage.Map_GongStructName_InstancesNb["Pedal_tuning"] = len(stage.Pedal_tunings)
	stage.Map_GongStructName_InstancesNb["Percussion"] = len(stage.Percussions)
	stage.Map_GongStructName_InstancesNb["Pitch"] = len(stage.Pitchs)
	stage.Map_GongStructName_InstancesNb["Pitched"] = len(stage.Pitcheds)
	stage.Map_GongStructName_InstancesNb["Play"] = len(stage.Plays)
	stage.Map_GongStructName_InstancesNb["Player"] = len(stage.Players)
	stage.Map_GongStructName_InstancesNb["Principal_voice"] = len(stage.Principal_voices)
	stage.Map_GongStructName_InstancesNb["Print"] = len(stage.Prints)
	stage.Map_GongStructName_InstancesNb["Release"] = len(stage.Releases)
	stage.Map_GongStructName_InstancesNb["Repeat"] = len(stage.Repeats)
	stage.Map_GongStructName_InstancesNb["Rest"] = len(stage.Rests)
	stage.Map_GongStructName_InstancesNb["Root"] = len(stage.Roots)
	stage.Map_GongStructName_InstancesNb["Root_step"] = len(stage.Root_steps)
	stage.Map_GongStructName_InstancesNb["Scaling"] = len(stage.Scalings)
	stage.Map_GongStructName_InstancesNb["Scordatura"] = len(stage.Scordaturas)
	stage.Map_GongStructName_InstancesNb["Score_instrument"] = len(stage.Score_instruments)
	stage.Map_GongStructName_InstancesNb["Score_part"] = len(stage.Score_parts)
	stage.Map_GongStructName_InstancesNb["Score_partwise"] = len(stage.Score_partwises)
	stage.Map_GongStructName_InstancesNb["Score_timewise"] = len(stage.Score_timewises)
	stage.Map_GongStructName_InstancesNb["Segno"] = len(stage.Segnos)
	stage.Map_GongStructName_InstancesNb["Slash"] = len(stage.Slashs)
	stage.Map_GongStructName_InstancesNb["Slide"] = len(stage.Slides)
	stage.Map_GongStructName_InstancesNb["Slur"] = len(stage.Slurs)
	stage.Map_GongStructName_InstancesNb["Sound"] = len(stage.Sounds)
	stage.Map_GongStructName_InstancesNb["Staff_details"] = len(stage.Staff_detailss)
	stage.Map_GongStructName_InstancesNb["Staff_divide"] = len(stage.Staff_divides)
	stage.Map_GongStructName_InstancesNb["Staff_layout"] = len(stage.Staff_layouts)
	stage.Map_GongStructName_InstancesNb["Staff_size"] = len(stage.Staff_sizes)
	stage.Map_GongStructName_InstancesNb["Staff_tuning"] = len(stage.Staff_tunings)
	stage.Map_GongStructName_InstancesNb["Stem"] = len(stage.Stems)
	stage.Map_GongStructName_InstancesNb["Stick"] = len(stage.Sticks)
	stage.Map_GongStructName_InstancesNb["String_mute"] = len(stage.String_mutes)
	stage.Map_GongStructName_InstancesNb["Strong_accent"] = len(stage.Strong_accents)
	stage.Map_GongStructName_InstancesNb["Supports"] = len(stage.Supportss)
	stage.Map_GongStructName_InstancesNb["Swing"] = len(stage.Swings)
	stage.Map_GongStructName_InstancesNb["Sync"] = len(stage.Syncs)
	stage.Map_GongStructName_InstancesNb["System_dividers"] = len(stage.System_dividerss)
	stage.Map_GongStructName_InstancesNb["System_layout"] = len(stage.System_layouts)
	stage.Map_GongStructName_InstancesNb["System_margins"] = len(stage.System_marginss)
	stage.Map_GongStructName_InstancesNb["Tap"] = len(stage.Taps)
	stage.Map_GongStructName_InstancesNb["Technical"] = len(stage.Technicals)
	stage.Map_GongStructName_InstancesNb["Text_element_data"] = len(stage.Text_element_datas)
	stage.Map_GongStructName_InstancesNb["Tie"] = len(stage.Ties)
	stage.Map_GongStructName_InstancesNb["Tied"] = len(stage.Tieds)
	stage.Map_GongStructName_InstancesNb["Time"] = len(stage.Times)
	stage.Map_GongStructName_InstancesNb["Time_modification"] = len(stage.Time_modifications)
	stage.Map_GongStructName_InstancesNb["Timpani"] = len(stage.Timpanis)
	stage.Map_GongStructName_InstancesNb["Transpose"] = len(stage.Transposes)
	stage.Map_GongStructName_InstancesNb["Tremolo"] = len(stage.Tremolos)
	stage.Map_GongStructName_InstancesNb["Tuplet"] = len(stage.Tuplets)
	stage.Map_GongStructName_InstancesNb["Tuplet_dot"] = len(stage.Tuplet_dots)
	stage.Map_GongStructName_InstancesNb["Tuplet_number"] = len(stage.Tuplet_numbers)
	stage.Map_GongStructName_InstancesNb["Tuplet_portion"] = len(stage.Tuplet_portions)
	stage.Map_GongStructName_InstancesNb["Tuplet_type"] = len(stage.Tuplet_types)
	stage.Map_GongStructName_InstancesNb["Typed_text"] = len(stage.Typed_texts)
	stage.Map_GongStructName_InstancesNb["Unpitched"] = len(stage.Unpitcheds)
	stage.Map_GongStructName_InstancesNb["Virtual_instrument"] = len(stage.Virtual_instruments)
	stage.Map_GongStructName_InstancesNb["Wait"] = len(stage.Waits)
	stage.Map_GongStructName_InstancesNb["Wavy_line"] = len(stage.Wavy_lines)
	stage.Map_GongStructName_InstancesNb["Wedge"] = len(stage.Wedges)
	stage.Map_GongStructName_InstancesNb["Wood"] = len(stage.Woods)
	stage.Map_GongStructName_InstancesNb["Work"] = len(stage.Works)

}

// backup generates backup files in the dirPath
func (stage *StageStruct) Backup(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Backup(stage, dirPath)
	}
}

// Restore resets Stage & BackRepo and restores their content from the restore files in dirPath
func (stage *StageStruct) Restore(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Restore(stage, dirPath)
	}
}

// backup generates backup files in the dirPath
func (stage *StageStruct) BackupXL(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.BackupXL(stage, dirPath)
	}
}

// Restore resets Stage & BackRepo and restores their content from the restore files in dirPath
func (stage *StageStruct) RestoreXL(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.RestoreXL(stage, dirPath)
	}
}

// insertion point for cumulative sub template with model space calls
// Stage puts accidental to the model stage
func (accidental *Accidental) Stage(stage *StageStruct) *Accidental {
	stage.Accidentals[accidental] = __member
	stage.Accidentals_mapString[accidental.Name] = accidental

	return accidental
}

// Unstage removes accidental off the model stage
func (accidental *Accidental) Unstage(stage *StageStruct) *Accidental {
	delete(stage.Accidentals, accidental)
	delete(stage.Accidentals_mapString, accidental.Name)
	return accidental
}

// UnstageVoid removes accidental off the model stage
func (accidental *Accidental) UnstageVoid(stage *StageStruct) {
	delete(stage.Accidentals, accidental)
	delete(stage.Accidentals_mapString, accidental.Name)
}

// commit accidental to the back repo (if it is already staged)
func (accidental *Accidental) Commit(stage *StageStruct) *Accidental {
	if _, ok := stage.Accidentals[accidental]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitAccidental(accidental)
		}
	}
	return accidental
}

func (accidental *Accidental) CommitVoid(stage *StageStruct) {
	accidental.Commit(stage)
}

// Checkout accidental to the back repo (if it is already staged)
func (accidental *Accidental) Checkout(stage *StageStruct) *Accidental {
	if _, ok := stage.Accidentals[accidental]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutAccidental(accidental)
		}
	}
	return accidental
}

// for satisfaction of GongStruct interface
func (accidental *Accidental) GetName() (res string) {
	return accidental.Name
}

// Stage puts accidental_mark to the model stage
func (accidental_mark *Accidental_mark) Stage(stage *StageStruct) *Accidental_mark {
	stage.Accidental_marks[accidental_mark] = __member
	stage.Accidental_marks_mapString[accidental_mark.Name] = accidental_mark

	return accidental_mark
}

// Unstage removes accidental_mark off the model stage
func (accidental_mark *Accidental_mark) Unstage(stage *StageStruct) *Accidental_mark {
	delete(stage.Accidental_marks, accidental_mark)
	delete(stage.Accidental_marks_mapString, accidental_mark.Name)
	return accidental_mark
}

// UnstageVoid removes accidental_mark off the model stage
func (accidental_mark *Accidental_mark) UnstageVoid(stage *StageStruct) {
	delete(stage.Accidental_marks, accidental_mark)
	delete(stage.Accidental_marks_mapString, accidental_mark.Name)
}

// commit accidental_mark to the back repo (if it is already staged)
func (accidental_mark *Accidental_mark) Commit(stage *StageStruct) *Accidental_mark {
	if _, ok := stage.Accidental_marks[accidental_mark]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitAccidental_mark(accidental_mark)
		}
	}
	return accidental_mark
}

func (accidental_mark *Accidental_mark) CommitVoid(stage *StageStruct) {
	accidental_mark.Commit(stage)
}

// Checkout accidental_mark to the back repo (if it is already staged)
func (accidental_mark *Accidental_mark) Checkout(stage *StageStruct) *Accidental_mark {
	if _, ok := stage.Accidental_marks[accidental_mark]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutAccidental_mark(accidental_mark)
		}
	}
	return accidental_mark
}

// for satisfaction of GongStruct interface
func (accidental_mark *Accidental_mark) GetName() (res string) {
	return accidental_mark.Name
}

// Stage puts accidental_text to the model stage
func (accidental_text *Accidental_text) Stage(stage *StageStruct) *Accidental_text {
	stage.Accidental_texts[accidental_text] = __member
	stage.Accidental_texts_mapString[accidental_text.Name] = accidental_text

	return accidental_text
}

// Unstage removes accidental_text off the model stage
func (accidental_text *Accidental_text) Unstage(stage *StageStruct) *Accidental_text {
	delete(stage.Accidental_texts, accidental_text)
	delete(stage.Accidental_texts_mapString, accidental_text.Name)
	return accidental_text
}

// UnstageVoid removes accidental_text off the model stage
func (accidental_text *Accidental_text) UnstageVoid(stage *StageStruct) {
	delete(stage.Accidental_texts, accidental_text)
	delete(stage.Accidental_texts_mapString, accidental_text.Name)
}

// commit accidental_text to the back repo (if it is already staged)
func (accidental_text *Accidental_text) Commit(stage *StageStruct) *Accidental_text {
	if _, ok := stage.Accidental_texts[accidental_text]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitAccidental_text(accidental_text)
		}
	}
	return accidental_text
}

func (accidental_text *Accidental_text) CommitVoid(stage *StageStruct) {
	accidental_text.Commit(stage)
}

// Checkout accidental_text to the back repo (if it is already staged)
func (accidental_text *Accidental_text) Checkout(stage *StageStruct) *Accidental_text {
	if _, ok := stage.Accidental_texts[accidental_text]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutAccidental_text(accidental_text)
		}
	}
	return accidental_text
}

// for satisfaction of GongStruct interface
func (accidental_text *Accidental_text) GetName() (res string) {
	return accidental_text.Name
}

// Stage puts accord to the model stage
func (accord *Accord) Stage(stage *StageStruct) *Accord {
	stage.Accords[accord] = __member
	stage.Accords_mapString[accord.Name] = accord

	return accord
}

// Unstage removes accord off the model stage
func (accord *Accord) Unstage(stage *StageStruct) *Accord {
	delete(stage.Accords, accord)
	delete(stage.Accords_mapString, accord.Name)
	return accord
}

// UnstageVoid removes accord off the model stage
func (accord *Accord) UnstageVoid(stage *StageStruct) {
	delete(stage.Accords, accord)
	delete(stage.Accords_mapString, accord.Name)
}

// commit accord to the back repo (if it is already staged)
func (accord *Accord) Commit(stage *StageStruct) *Accord {
	if _, ok := stage.Accords[accord]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitAccord(accord)
		}
	}
	return accord
}

func (accord *Accord) CommitVoid(stage *StageStruct) {
	accord.Commit(stage)
}

// Checkout accord to the back repo (if it is already staged)
func (accord *Accord) Checkout(stage *StageStruct) *Accord {
	if _, ok := stage.Accords[accord]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutAccord(accord)
		}
	}
	return accord
}

// for satisfaction of GongStruct interface
func (accord *Accord) GetName() (res string) {
	return accord.Name
}

// Stage puts accordion_registration to the model stage
func (accordion_registration *Accordion_registration) Stage(stage *StageStruct) *Accordion_registration {
	stage.Accordion_registrations[accordion_registration] = __member
	stage.Accordion_registrations_mapString[accordion_registration.Name] = accordion_registration

	return accordion_registration
}

// Unstage removes accordion_registration off the model stage
func (accordion_registration *Accordion_registration) Unstage(stage *StageStruct) *Accordion_registration {
	delete(stage.Accordion_registrations, accordion_registration)
	delete(stage.Accordion_registrations_mapString, accordion_registration.Name)
	return accordion_registration
}

// UnstageVoid removes accordion_registration off the model stage
func (accordion_registration *Accordion_registration) UnstageVoid(stage *StageStruct) {
	delete(stage.Accordion_registrations, accordion_registration)
	delete(stage.Accordion_registrations_mapString, accordion_registration.Name)
}

// commit accordion_registration to the back repo (if it is already staged)
func (accordion_registration *Accordion_registration) Commit(stage *StageStruct) *Accordion_registration {
	if _, ok := stage.Accordion_registrations[accordion_registration]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitAccordion_registration(accordion_registration)
		}
	}
	return accordion_registration
}

func (accordion_registration *Accordion_registration) CommitVoid(stage *StageStruct) {
	accordion_registration.Commit(stage)
}

// Checkout accordion_registration to the back repo (if it is already staged)
func (accordion_registration *Accordion_registration) Checkout(stage *StageStruct) *Accordion_registration {
	if _, ok := stage.Accordion_registrations[accordion_registration]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutAccordion_registration(accordion_registration)
		}
	}
	return accordion_registration
}

// for satisfaction of GongStruct interface
func (accordion_registration *Accordion_registration) GetName() (res string) {
	return accordion_registration.Name
}

// Stage puts anytype to the model stage
func (anytype *AnyType) Stage(stage *StageStruct) *AnyType {
	stage.AnyTypes[anytype] = __member
	stage.AnyTypes_mapString[anytype.Name] = anytype

	return anytype
}

// Unstage removes anytype off the model stage
func (anytype *AnyType) Unstage(stage *StageStruct) *AnyType {
	delete(stage.AnyTypes, anytype)
	delete(stage.AnyTypes_mapString, anytype.Name)
	return anytype
}

// UnstageVoid removes anytype off the model stage
func (anytype *AnyType) UnstageVoid(stage *StageStruct) {
	delete(stage.AnyTypes, anytype)
	delete(stage.AnyTypes_mapString, anytype.Name)
}

// commit anytype to the back repo (if it is already staged)
func (anytype *AnyType) Commit(stage *StageStruct) *AnyType {
	if _, ok := stage.AnyTypes[anytype]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitAnyType(anytype)
		}
	}
	return anytype
}

func (anytype *AnyType) CommitVoid(stage *StageStruct) {
	anytype.Commit(stage)
}

// Checkout anytype to the back repo (if it is already staged)
func (anytype *AnyType) Checkout(stage *StageStruct) *AnyType {
	if _, ok := stage.AnyTypes[anytype]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutAnyType(anytype)
		}
	}
	return anytype
}

// for satisfaction of GongStruct interface
func (anytype *AnyType) GetName() (res string) {
	return anytype.Name
}

// Stage puts appearance to the model stage
func (appearance *Appearance) Stage(stage *StageStruct) *Appearance {
	stage.Appearances[appearance] = __member
	stage.Appearances_mapString[appearance.Name] = appearance

	return appearance
}

// Unstage removes appearance off the model stage
func (appearance *Appearance) Unstage(stage *StageStruct) *Appearance {
	delete(stage.Appearances, appearance)
	delete(stage.Appearances_mapString, appearance.Name)
	return appearance
}

// UnstageVoid removes appearance off the model stage
func (appearance *Appearance) UnstageVoid(stage *StageStruct) {
	delete(stage.Appearances, appearance)
	delete(stage.Appearances_mapString, appearance.Name)
}

// commit appearance to the back repo (if it is already staged)
func (appearance *Appearance) Commit(stage *StageStruct) *Appearance {
	if _, ok := stage.Appearances[appearance]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitAppearance(appearance)
		}
	}
	return appearance
}

func (appearance *Appearance) CommitVoid(stage *StageStruct) {
	appearance.Commit(stage)
}

// Checkout appearance to the back repo (if it is already staged)
func (appearance *Appearance) Checkout(stage *StageStruct) *Appearance {
	if _, ok := stage.Appearances[appearance]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutAppearance(appearance)
		}
	}
	return appearance
}

// for satisfaction of GongStruct interface
func (appearance *Appearance) GetName() (res string) {
	return appearance.Name
}

// Stage puts arpeggiate to the model stage
func (arpeggiate *Arpeggiate) Stage(stage *StageStruct) *Arpeggiate {
	stage.Arpeggiates[arpeggiate] = __member
	stage.Arpeggiates_mapString[arpeggiate.Name] = arpeggiate

	return arpeggiate
}

// Unstage removes arpeggiate off the model stage
func (arpeggiate *Arpeggiate) Unstage(stage *StageStruct) *Arpeggiate {
	delete(stage.Arpeggiates, arpeggiate)
	delete(stage.Arpeggiates_mapString, arpeggiate.Name)
	return arpeggiate
}

// UnstageVoid removes arpeggiate off the model stage
func (arpeggiate *Arpeggiate) UnstageVoid(stage *StageStruct) {
	delete(stage.Arpeggiates, arpeggiate)
	delete(stage.Arpeggiates_mapString, arpeggiate.Name)
}

// commit arpeggiate to the back repo (if it is already staged)
func (arpeggiate *Arpeggiate) Commit(stage *StageStruct) *Arpeggiate {
	if _, ok := stage.Arpeggiates[arpeggiate]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitArpeggiate(arpeggiate)
		}
	}
	return arpeggiate
}

func (arpeggiate *Arpeggiate) CommitVoid(stage *StageStruct) {
	arpeggiate.Commit(stage)
}

// Checkout arpeggiate to the back repo (if it is already staged)
func (arpeggiate *Arpeggiate) Checkout(stage *StageStruct) *Arpeggiate {
	if _, ok := stage.Arpeggiates[arpeggiate]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutArpeggiate(arpeggiate)
		}
	}
	return arpeggiate
}

// for satisfaction of GongStruct interface
func (arpeggiate *Arpeggiate) GetName() (res string) {
	return arpeggiate.Name
}

// Stage puts arrow to the model stage
func (arrow *Arrow) Stage(stage *StageStruct) *Arrow {
	stage.Arrows[arrow] = __member
	stage.Arrows_mapString[arrow.Name] = arrow

	return arrow
}

// Unstage removes arrow off the model stage
func (arrow *Arrow) Unstage(stage *StageStruct) *Arrow {
	delete(stage.Arrows, arrow)
	delete(stage.Arrows_mapString, arrow.Name)
	return arrow
}

// UnstageVoid removes arrow off the model stage
func (arrow *Arrow) UnstageVoid(stage *StageStruct) {
	delete(stage.Arrows, arrow)
	delete(stage.Arrows_mapString, arrow.Name)
}

// commit arrow to the back repo (if it is already staged)
func (arrow *Arrow) Commit(stage *StageStruct) *Arrow {
	if _, ok := stage.Arrows[arrow]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitArrow(arrow)
		}
	}
	return arrow
}

func (arrow *Arrow) CommitVoid(stage *StageStruct) {
	arrow.Commit(stage)
}

// Checkout arrow to the back repo (if it is already staged)
func (arrow *Arrow) Checkout(stage *StageStruct) *Arrow {
	if _, ok := stage.Arrows[arrow]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutArrow(arrow)
		}
	}
	return arrow
}

// for satisfaction of GongStruct interface
func (arrow *Arrow) GetName() (res string) {
	return arrow.Name
}

// Stage puts articulations to the model stage
func (articulations *Articulations) Stage(stage *StageStruct) *Articulations {
	stage.Articulationss[articulations] = __member
	stage.Articulationss_mapString[articulations.Name] = articulations

	return articulations
}

// Unstage removes articulations off the model stage
func (articulations *Articulations) Unstage(stage *StageStruct) *Articulations {
	delete(stage.Articulationss, articulations)
	delete(stage.Articulationss_mapString, articulations.Name)
	return articulations
}

// UnstageVoid removes articulations off the model stage
func (articulations *Articulations) UnstageVoid(stage *StageStruct) {
	delete(stage.Articulationss, articulations)
	delete(stage.Articulationss_mapString, articulations.Name)
}

// commit articulations to the back repo (if it is already staged)
func (articulations *Articulations) Commit(stage *StageStruct) *Articulations {
	if _, ok := stage.Articulationss[articulations]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitArticulations(articulations)
		}
	}
	return articulations
}

func (articulations *Articulations) CommitVoid(stage *StageStruct) {
	articulations.Commit(stage)
}

// Checkout articulations to the back repo (if it is already staged)
func (articulations *Articulations) Checkout(stage *StageStruct) *Articulations {
	if _, ok := stage.Articulationss[articulations]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutArticulations(articulations)
		}
	}
	return articulations
}

// for satisfaction of GongStruct interface
func (articulations *Articulations) GetName() (res string) {
	return articulations.Name
}

// Stage puts assess to the model stage
func (assess *Assess) Stage(stage *StageStruct) *Assess {
	stage.Assesss[assess] = __member
	stage.Assesss_mapString[assess.Name] = assess

	return assess
}

// Unstage removes assess off the model stage
func (assess *Assess) Unstage(stage *StageStruct) *Assess {
	delete(stage.Assesss, assess)
	delete(stage.Assesss_mapString, assess.Name)
	return assess
}

// UnstageVoid removes assess off the model stage
func (assess *Assess) UnstageVoid(stage *StageStruct) {
	delete(stage.Assesss, assess)
	delete(stage.Assesss_mapString, assess.Name)
}

// commit assess to the back repo (if it is already staged)
func (assess *Assess) Commit(stage *StageStruct) *Assess {
	if _, ok := stage.Assesss[assess]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitAssess(assess)
		}
	}
	return assess
}

func (assess *Assess) CommitVoid(stage *StageStruct) {
	assess.Commit(stage)
}

// Checkout assess to the back repo (if it is already staged)
func (assess *Assess) Checkout(stage *StageStruct) *Assess {
	if _, ok := stage.Assesss[assess]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutAssess(assess)
		}
	}
	return assess
}

// for satisfaction of GongStruct interface
func (assess *Assess) GetName() (res string) {
	return assess.Name
}

// Stage puts attributes to the model stage
func (attributes *Attributes) Stage(stage *StageStruct) *Attributes {
	stage.Attributess[attributes] = __member
	stage.Attributess_mapString[attributes.Name] = attributes

	return attributes
}

// Unstage removes attributes off the model stage
func (attributes *Attributes) Unstage(stage *StageStruct) *Attributes {
	delete(stage.Attributess, attributes)
	delete(stage.Attributess_mapString, attributes.Name)
	return attributes
}

// UnstageVoid removes attributes off the model stage
func (attributes *Attributes) UnstageVoid(stage *StageStruct) {
	delete(stage.Attributess, attributes)
	delete(stage.Attributess_mapString, attributes.Name)
}

// commit attributes to the back repo (if it is already staged)
func (attributes *Attributes) Commit(stage *StageStruct) *Attributes {
	if _, ok := stage.Attributess[attributes]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitAttributes(attributes)
		}
	}
	return attributes
}

func (attributes *Attributes) CommitVoid(stage *StageStruct) {
	attributes.Commit(stage)
}

// Checkout attributes to the back repo (if it is already staged)
func (attributes *Attributes) Checkout(stage *StageStruct) *Attributes {
	if _, ok := stage.Attributess[attributes]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutAttributes(attributes)
		}
	}
	return attributes
}

// for satisfaction of GongStruct interface
func (attributes *Attributes) GetName() (res string) {
	return attributes.Name
}

// Stage puts backup to the model stage
func (backup *Backup) Stage(stage *StageStruct) *Backup {
	stage.Backups[backup] = __member
	stage.Backups_mapString[backup.Name] = backup

	return backup
}

// Unstage removes backup off the model stage
func (backup *Backup) Unstage(stage *StageStruct) *Backup {
	delete(stage.Backups, backup)
	delete(stage.Backups_mapString, backup.Name)
	return backup
}

// UnstageVoid removes backup off the model stage
func (backup *Backup) UnstageVoid(stage *StageStruct) {
	delete(stage.Backups, backup)
	delete(stage.Backups_mapString, backup.Name)
}

// commit backup to the back repo (if it is already staged)
func (backup *Backup) Commit(stage *StageStruct) *Backup {
	if _, ok := stage.Backups[backup]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBackup(backup)
		}
	}
	return backup
}

func (backup *Backup) CommitVoid(stage *StageStruct) {
	backup.Commit(stage)
}

// Checkout backup to the back repo (if it is already staged)
func (backup *Backup) Checkout(stage *StageStruct) *Backup {
	if _, ok := stage.Backups[backup]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBackup(backup)
		}
	}
	return backup
}

// for satisfaction of GongStruct interface
func (backup *Backup) GetName() (res string) {
	return backup.Name
}

// Stage puts bar_style_color to the model stage
func (bar_style_color *Bar_style_color) Stage(stage *StageStruct) *Bar_style_color {
	stage.Bar_style_colors[bar_style_color] = __member
	stage.Bar_style_colors_mapString[bar_style_color.Name] = bar_style_color

	return bar_style_color
}

// Unstage removes bar_style_color off the model stage
func (bar_style_color *Bar_style_color) Unstage(stage *StageStruct) *Bar_style_color {
	delete(stage.Bar_style_colors, bar_style_color)
	delete(stage.Bar_style_colors_mapString, bar_style_color.Name)
	return bar_style_color
}

// UnstageVoid removes bar_style_color off the model stage
func (bar_style_color *Bar_style_color) UnstageVoid(stage *StageStruct) {
	delete(stage.Bar_style_colors, bar_style_color)
	delete(stage.Bar_style_colors_mapString, bar_style_color.Name)
}

// commit bar_style_color to the back repo (if it is already staged)
func (bar_style_color *Bar_style_color) Commit(stage *StageStruct) *Bar_style_color {
	if _, ok := stage.Bar_style_colors[bar_style_color]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBar_style_color(bar_style_color)
		}
	}
	return bar_style_color
}

func (bar_style_color *Bar_style_color) CommitVoid(stage *StageStruct) {
	bar_style_color.Commit(stage)
}

// Checkout bar_style_color to the back repo (if it is already staged)
func (bar_style_color *Bar_style_color) Checkout(stage *StageStruct) *Bar_style_color {
	if _, ok := stage.Bar_style_colors[bar_style_color]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBar_style_color(bar_style_color)
		}
	}
	return bar_style_color
}

// for satisfaction of GongStruct interface
func (bar_style_color *Bar_style_color) GetName() (res string) {
	return bar_style_color.Name
}

// Stage puts barline to the model stage
func (barline *Barline) Stage(stage *StageStruct) *Barline {
	stage.Barlines[barline] = __member
	stage.Barlines_mapString[barline.Name] = barline

	return barline
}

// Unstage removes barline off the model stage
func (barline *Barline) Unstage(stage *StageStruct) *Barline {
	delete(stage.Barlines, barline)
	delete(stage.Barlines_mapString, barline.Name)
	return barline
}

// UnstageVoid removes barline off the model stage
func (barline *Barline) UnstageVoid(stage *StageStruct) {
	delete(stage.Barlines, barline)
	delete(stage.Barlines_mapString, barline.Name)
}

// commit barline to the back repo (if it is already staged)
func (barline *Barline) Commit(stage *StageStruct) *Barline {
	if _, ok := stage.Barlines[barline]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBarline(barline)
		}
	}
	return barline
}

func (barline *Barline) CommitVoid(stage *StageStruct) {
	barline.Commit(stage)
}

// Checkout barline to the back repo (if it is already staged)
func (barline *Barline) Checkout(stage *StageStruct) *Barline {
	if _, ok := stage.Barlines[barline]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBarline(barline)
		}
	}
	return barline
}

// for satisfaction of GongStruct interface
func (barline *Barline) GetName() (res string) {
	return barline.Name
}

// Stage puts barre to the model stage
func (barre *Barre) Stage(stage *StageStruct) *Barre {
	stage.Barres[barre] = __member
	stage.Barres_mapString[barre.Name] = barre

	return barre
}

// Unstage removes barre off the model stage
func (barre *Barre) Unstage(stage *StageStruct) *Barre {
	delete(stage.Barres, barre)
	delete(stage.Barres_mapString, barre.Name)
	return barre
}

// UnstageVoid removes barre off the model stage
func (barre *Barre) UnstageVoid(stage *StageStruct) {
	delete(stage.Barres, barre)
	delete(stage.Barres_mapString, barre.Name)
}

// commit barre to the back repo (if it is already staged)
func (barre *Barre) Commit(stage *StageStruct) *Barre {
	if _, ok := stage.Barres[barre]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBarre(barre)
		}
	}
	return barre
}

func (barre *Barre) CommitVoid(stage *StageStruct) {
	barre.Commit(stage)
}

// Checkout barre to the back repo (if it is already staged)
func (barre *Barre) Checkout(stage *StageStruct) *Barre {
	if _, ok := stage.Barres[barre]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBarre(barre)
		}
	}
	return barre
}

// for satisfaction of GongStruct interface
func (barre *Barre) GetName() (res string) {
	return barre.Name
}

// Stage puts bass to the model stage
func (bass *Bass) Stage(stage *StageStruct) *Bass {
	stage.Basss[bass] = __member
	stage.Basss_mapString[bass.Name] = bass

	return bass
}

// Unstage removes bass off the model stage
func (bass *Bass) Unstage(stage *StageStruct) *Bass {
	delete(stage.Basss, bass)
	delete(stage.Basss_mapString, bass.Name)
	return bass
}

// UnstageVoid removes bass off the model stage
func (bass *Bass) UnstageVoid(stage *StageStruct) {
	delete(stage.Basss, bass)
	delete(stage.Basss_mapString, bass.Name)
}

// commit bass to the back repo (if it is already staged)
func (bass *Bass) Commit(stage *StageStruct) *Bass {
	if _, ok := stage.Basss[bass]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBass(bass)
		}
	}
	return bass
}

func (bass *Bass) CommitVoid(stage *StageStruct) {
	bass.Commit(stage)
}

// Checkout bass to the back repo (if it is already staged)
func (bass *Bass) Checkout(stage *StageStruct) *Bass {
	if _, ok := stage.Basss[bass]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBass(bass)
		}
	}
	return bass
}

// for satisfaction of GongStruct interface
func (bass *Bass) GetName() (res string) {
	return bass.Name
}

// Stage puts bass_step to the model stage
func (bass_step *Bass_step) Stage(stage *StageStruct) *Bass_step {
	stage.Bass_steps[bass_step] = __member
	stage.Bass_steps_mapString[bass_step.Name] = bass_step

	return bass_step
}

// Unstage removes bass_step off the model stage
func (bass_step *Bass_step) Unstage(stage *StageStruct) *Bass_step {
	delete(stage.Bass_steps, bass_step)
	delete(stage.Bass_steps_mapString, bass_step.Name)
	return bass_step
}

// UnstageVoid removes bass_step off the model stage
func (bass_step *Bass_step) UnstageVoid(stage *StageStruct) {
	delete(stage.Bass_steps, bass_step)
	delete(stage.Bass_steps_mapString, bass_step.Name)
}

// commit bass_step to the back repo (if it is already staged)
func (bass_step *Bass_step) Commit(stage *StageStruct) *Bass_step {
	if _, ok := stage.Bass_steps[bass_step]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBass_step(bass_step)
		}
	}
	return bass_step
}

func (bass_step *Bass_step) CommitVoid(stage *StageStruct) {
	bass_step.Commit(stage)
}

// Checkout bass_step to the back repo (if it is already staged)
func (bass_step *Bass_step) Checkout(stage *StageStruct) *Bass_step {
	if _, ok := stage.Bass_steps[bass_step]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBass_step(bass_step)
		}
	}
	return bass_step
}

// for satisfaction of GongStruct interface
func (bass_step *Bass_step) GetName() (res string) {
	return bass_step.Name
}

// Stage puts beam to the model stage
func (beam *Beam) Stage(stage *StageStruct) *Beam {
	stage.Beams[beam] = __member
	stage.Beams_mapString[beam.Name] = beam

	return beam
}

// Unstage removes beam off the model stage
func (beam *Beam) Unstage(stage *StageStruct) *Beam {
	delete(stage.Beams, beam)
	delete(stage.Beams_mapString, beam.Name)
	return beam
}

// UnstageVoid removes beam off the model stage
func (beam *Beam) UnstageVoid(stage *StageStruct) {
	delete(stage.Beams, beam)
	delete(stage.Beams_mapString, beam.Name)
}

// commit beam to the back repo (if it is already staged)
func (beam *Beam) Commit(stage *StageStruct) *Beam {
	if _, ok := stage.Beams[beam]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBeam(beam)
		}
	}
	return beam
}

func (beam *Beam) CommitVoid(stage *StageStruct) {
	beam.Commit(stage)
}

// Checkout beam to the back repo (if it is already staged)
func (beam *Beam) Checkout(stage *StageStruct) *Beam {
	if _, ok := stage.Beams[beam]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBeam(beam)
		}
	}
	return beam
}

// for satisfaction of GongStruct interface
func (beam *Beam) GetName() (res string) {
	return beam.Name
}

// Stage puts beat_repeat to the model stage
func (beat_repeat *Beat_repeat) Stage(stage *StageStruct) *Beat_repeat {
	stage.Beat_repeats[beat_repeat] = __member
	stage.Beat_repeats_mapString[beat_repeat.Name] = beat_repeat

	return beat_repeat
}

// Unstage removes beat_repeat off the model stage
func (beat_repeat *Beat_repeat) Unstage(stage *StageStruct) *Beat_repeat {
	delete(stage.Beat_repeats, beat_repeat)
	delete(stage.Beat_repeats_mapString, beat_repeat.Name)
	return beat_repeat
}

// UnstageVoid removes beat_repeat off the model stage
func (beat_repeat *Beat_repeat) UnstageVoid(stage *StageStruct) {
	delete(stage.Beat_repeats, beat_repeat)
	delete(stage.Beat_repeats_mapString, beat_repeat.Name)
}

// commit beat_repeat to the back repo (if it is already staged)
func (beat_repeat *Beat_repeat) Commit(stage *StageStruct) *Beat_repeat {
	if _, ok := stage.Beat_repeats[beat_repeat]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBeat_repeat(beat_repeat)
		}
	}
	return beat_repeat
}

func (beat_repeat *Beat_repeat) CommitVoid(stage *StageStruct) {
	beat_repeat.Commit(stage)
}

// Checkout beat_repeat to the back repo (if it is already staged)
func (beat_repeat *Beat_repeat) Checkout(stage *StageStruct) *Beat_repeat {
	if _, ok := stage.Beat_repeats[beat_repeat]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBeat_repeat(beat_repeat)
		}
	}
	return beat_repeat
}

// for satisfaction of GongStruct interface
func (beat_repeat *Beat_repeat) GetName() (res string) {
	return beat_repeat.Name
}

// Stage puts beat_unit_tied to the model stage
func (beat_unit_tied *Beat_unit_tied) Stage(stage *StageStruct) *Beat_unit_tied {
	stage.Beat_unit_tieds[beat_unit_tied] = __member
	stage.Beat_unit_tieds_mapString[beat_unit_tied.Name] = beat_unit_tied

	return beat_unit_tied
}

// Unstage removes beat_unit_tied off the model stage
func (beat_unit_tied *Beat_unit_tied) Unstage(stage *StageStruct) *Beat_unit_tied {
	delete(stage.Beat_unit_tieds, beat_unit_tied)
	delete(stage.Beat_unit_tieds_mapString, beat_unit_tied.Name)
	return beat_unit_tied
}

// UnstageVoid removes beat_unit_tied off the model stage
func (beat_unit_tied *Beat_unit_tied) UnstageVoid(stage *StageStruct) {
	delete(stage.Beat_unit_tieds, beat_unit_tied)
	delete(stage.Beat_unit_tieds_mapString, beat_unit_tied.Name)
}

// commit beat_unit_tied to the back repo (if it is already staged)
func (beat_unit_tied *Beat_unit_tied) Commit(stage *StageStruct) *Beat_unit_tied {
	if _, ok := stage.Beat_unit_tieds[beat_unit_tied]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBeat_unit_tied(beat_unit_tied)
		}
	}
	return beat_unit_tied
}

func (beat_unit_tied *Beat_unit_tied) CommitVoid(stage *StageStruct) {
	beat_unit_tied.Commit(stage)
}

// Checkout beat_unit_tied to the back repo (if it is already staged)
func (beat_unit_tied *Beat_unit_tied) Checkout(stage *StageStruct) *Beat_unit_tied {
	if _, ok := stage.Beat_unit_tieds[beat_unit_tied]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBeat_unit_tied(beat_unit_tied)
		}
	}
	return beat_unit_tied
}

// for satisfaction of GongStruct interface
func (beat_unit_tied *Beat_unit_tied) GetName() (res string) {
	return beat_unit_tied.Name
}

// Stage puts beater to the model stage
func (beater *Beater) Stage(stage *StageStruct) *Beater {
	stage.Beaters[beater] = __member
	stage.Beaters_mapString[beater.Name] = beater

	return beater
}

// Unstage removes beater off the model stage
func (beater *Beater) Unstage(stage *StageStruct) *Beater {
	delete(stage.Beaters, beater)
	delete(stage.Beaters_mapString, beater.Name)
	return beater
}

// UnstageVoid removes beater off the model stage
func (beater *Beater) UnstageVoid(stage *StageStruct) {
	delete(stage.Beaters, beater)
	delete(stage.Beaters_mapString, beater.Name)
}

// commit beater to the back repo (if it is already staged)
func (beater *Beater) Commit(stage *StageStruct) *Beater {
	if _, ok := stage.Beaters[beater]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBeater(beater)
		}
	}
	return beater
}

func (beater *Beater) CommitVoid(stage *StageStruct) {
	beater.Commit(stage)
}

// Checkout beater to the back repo (if it is already staged)
func (beater *Beater) Checkout(stage *StageStruct) *Beater {
	if _, ok := stage.Beaters[beater]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBeater(beater)
		}
	}
	return beater
}

// for satisfaction of GongStruct interface
func (beater *Beater) GetName() (res string) {
	return beater.Name
}

// Stage puts bend to the model stage
func (bend *Bend) Stage(stage *StageStruct) *Bend {
	stage.Bends[bend] = __member
	stage.Bends_mapString[bend.Name] = bend

	return bend
}

// Unstage removes bend off the model stage
func (bend *Bend) Unstage(stage *StageStruct) *Bend {
	delete(stage.Bends, bend)
	delete(stage.Bends_mapString, bend.Name)
	return bend
}

// UnstageVoid removes bend off the model stage
func (bend *Bend) UnstageVoid(stage *StageStruct) {
	delete(stage.Bends, bend)
	delete(stage.Bends_mapString, bend.Name)
}

// commit bend to the back repo (if it is already staged)
func (bend *Bend) Commit(stage *StageStruct) *Bend {
	if _, ok := stage.Bends[bend]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBend(bend)
		}
	}
	return bend
}

func (bend *Bend) CommitVoid(stage *StageStruct) {
	bend.Commit(stage)
}

// Checkout bend to the back repo (if it is already staged)
func (bend *Bend) Checkout(stage *StageStruct) *Bend {
	if _, ok := stage.Bends[bend]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBend(bend)
		}
	}
	return bend
}

// for satisfaction of GongStruct interface
func (bend *Bend) GetName() (res string) {
	return bend.Name
}

// Stage puts bookmark to the model stage
func (bookmark *Bookmark) Stage(stage *StageStruct) *Bookmark {
	stage.Bookmarks[bookmark] = __member
	stage.Bookmarks_mapString[bookmark.Name] = bookmark

	return bookmark
}

// Unstage removes bookmark off the model stage
func (bookmark *Bookmark) Unstage(stage *StageStruct) *Bookmark {
	delete(stage.Bookmarks, bookmark)
	delete(stage.Bookmarks_mapString, bookmark.Name)
	return bookmark
}

// UnstageVoid removes bookmark off the model stage
func (bookmark *Bookmark) UnstageVoid(stage *StageStruct) {
	delete(stage.Bookmarks, bookmark)
	delete(stage.Bookmarks_mapString, bookmark.Name)
}

// commit bookmark to the back repo (if it is already staged)
func (bookmark *Bookmark) Commit(stage *StageStruct) *Bookmark {
	if _, ok := stage.Bookmarks[bookmark]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBookmark(bookmark)
		}
	}
	return bookmark
}

func (bookmark *Bookmark) CommitVoid(stage *StageStruct) {
	bookmark.Commit(stage)
}

// Checkout bookmark to the back repo (if it is already staged)
func (bookmark *Bookmark) Checkout(stage *StageStruct) *Bookmark {
	if _, ok := stage.Bookmarks[bookmark]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBookmark(bookmark)
		}
	}
	return bookmark
}

// for satisfaction of GongStruct interface
func (bookmark *Bookmark) GetName() (res string) {
	return bookmark.Name
}

// Stage puts bracket to the model stage
func (bracket *Bracket) Stage(stage *StageStruct) *Bracket {
	stage.Brackets[bracket] = __member
	stage.Brackets_mapString[bracket.Name] = bracket

	return bracket
}

// Unstage removes bracket off the model stage
func (bracket *Bracket) Unstage(stage *StageStruct) *Bracket {
	delete(stage.Brackets, bracket)
	delete(stage.Brackets_mapString, bracket.Name)
	return bracket
}

// UnstageVoid removes bracket off the model stage
func (bracket *Bracket) UnstageVoid(stage *StageStruct) {
	delete(stage.Brackets, bracket)
	delete(stage.Brackets_mapString, bracket.Name)
}

// commit bracket to the back repo (if it is already staged)
func (bracket *Bracket) Commit(stage *StageStruct) *Bracket {
	if _, ok := stage.Brackets[bracket]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBracket(bracket)
		}
	}
	return bracket
}

func (bracket *Bracket) CommitVoid(stage *StageStruct) {
	bracket.Commit(stage)
}

// Checkout bracket to the back repo (if it is already staged)
func (bracket *Bracket) Checkout(stage *StageStruct) *Bracket {
	if _, ok := stage.Brackets[bracket]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBracket(bracket)
		}
	}
	return bracket
}

// for satisfaction of GongStruct interface
func (bracket *Bracket) GetName() (res string) {
	return bracket.Name
}

// Stage puts breath_mark to the model stage
func (breath_mark *Breath_mark) Stage(stage *StageStruct) *Breath_mark {
	stage.Breath_marks[breath_mark] = __member
	stage.Breath_marks_mapString[breath_mark.Name] = breath_mark

	return breath_mark
}

// Unstage removes breath_mark off the model stage
func (breath_mark *Breath_mark) Unstage(stage *StageStruct) *Breath_mark {
	delete(stage.Breath_marks, breath_mark)
	delete(stage.Breath_marks_mapString, breath_mark.Name)
	return breath_mark
}

// UnstageVoid removes breath_mark off the model stage
func (breath_mark *Breath_mark) UnstageVoid(stage *StageStruct) {
	delete(stage.Breath_marks, breath_mark)
	delete(stage.Breath_marks_mapString, breath_mark.Name)
}

// commit breath_mark to the back repo (if it is already staged)
func (breath_mark *Breath_mark) Commit(stage *StageStruct) *Breath_mark {
	if _, ok := stage.Breath_marks[breath_mark]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitBreath_mark(breath_mark)
		}
	}
	return breath_mark
}

func (breath_mark *Breath_mark) CommitVoid(stage *StageStruct) {
	breath_mark.Commit(stage)
}

// Checkout breath_mark to the back repo (if it is already staged)
func (breath_mark *Breath_mark) Checkout(stage *StageStruct) *Breath_mark {
	if _, ok := stage.Breath_marks[breath_mark]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutBreath_mark(breath_mark)
		}
	}
	return breath_mark
}

// for satisfaction of GongStruct interface
func (breath_mark *Breath_mark) GetName() (res string) {
	return breath_mark.Name
}

// Stage puts caesura to the model stage
func (caesura *Caesura) Stage(stage *StageStruct) *Caesura {
	stage.Caesuras[caesura] = __member
	stage.Caesuras_mapString[caesura.Name] = caesura

	return caesura
}

// Unstage removes caesura off the model stage
func (caesura *Caesura) Unstage(stage *StageStruct) *Caesura {
	delete(stage.Caesuras, caesura)
	delete(stage.Caesuras_mapString, caesura.Name)
	return caesura
}

// UnstageVoid removes caesura off the model stage
func (caesura *Caesura) UnstageVoid(stage *StageStruct) {
	delete(stage.Caesuras, caesura)
	delete(stage.Caesuras_mapString, caesura.Name)
}

// commit caesura to the back repo (if it is already staged)
func (caesura *Caesura) Commit(stage *StageStruct) *Caesura {
	if _, ok := stage.Caesuras[caesura]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitCaesura(caesura)
		}
	}
	return caesura
}

func (caesura *Caesura) CommitVoid(stage *StageStruct) {
	caesura.Commit(stage)
}

// Checkout caesura to the back repo (if it is already staged)
func (caesura *Caesura) Checkout(stage *StageStruct) *Caesura {
	if _, ok := stage.Caesuras[caesura]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutCaesura(caesura)
		}
	}
	return caesura
}

// for satisfaction of GongStruct interface
func (caesura *Caesura) GetName() (res string) {
	return caesura.Name
}

// Stage puts cancel to the model stage
func (cancel *Cancel) Stage(stage *StageStruct) *Cancel {
	stage.Cancels[cancel] = __member
	stage.Cancels_mapString[cancel.Name] = cancel

	return cancel
}

// Unstage removes cancel off the model stage
func (cancel *Cancel) Unstage(stage *StageStruct) *Cancel {
	delete(stage.Cancels, cancel)
	delete(stage.Cancels_mapString, cancel.Name)
	return cancel
}

// UnstageVoid removes cancel off the model stage
func (cancel *Cancel) UnstageVoid(stage *StageStruct) {
	delete(stage.Cancels, cancel)
	delete(stage.Cancels_mapString, cancel.Name)
}

// commit cancel to the back repo (if it is already staged)
func (cancel *Cancel) Commit(stage *StageStruct) *Cancel {
	if _, ok := stage.Cancels[cancel]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitCancel(cancel)
		}
	}
	return cancel
}

func (cancel *Cancel) CommitVoid(stage *StageStruct) {
	cancel.Commit(stage)
}

// Checkout cancel to the back repo (if it is already staged)
func (cancel *Cancel) Checkout(stage *StageStruct) *Cancel {
	if _, ok := stage.Cancels[cancel]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutCancel(cancel)
		}
	}
	return cancel
}

// for satisfaction of GongStruct interface
func (cancel *Cancel) GetName() (res string) {
	return cancel.Name
}

// Stage puts clef to the model stage
func (clef *Clef) Stage(stage *StageStruct) *Clef {
	stage.Clefs[clef] = __member
	stage.Clefs_mapString[clef.Name] = clef

	return clef
}

// Unstage removes clef off the model stage
func (clef *Clef) Unstage(stage *StageStruct) *Clef {
	delete(stage.Clefs, clef)
	delete(stage.Clefs_mapString, clef.Name)
	return clef
}

// UnstageVoid removes clef off the model stage
func (clef *Clef) UnstageVoid(stage *StageStruct) {
	delete(stage.Clefs, clef)
	delete(stage.Clefs_mapString, clef.Name)
}

// commit clef to the back repo (if it is already staged)
func (clef *Clef) Commit(stage *StageStruct) *Clef {
	if _, ok := stage.Clefs[clef]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitClef(clef)
		}
	}
	return clef
}

func (clef *Clef) CommitVoid(stage *StageStruct) {
	clef.Commit(stage)
}

// Checkout clef to the back repo (if it is already staged)
func (clef *Clef) Checkout(stage *StageStruct) *Clef {
	if _, ok := stage.Clefs[clef]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutClef(clef)
		}
	}
	return clef
}

// for satisfaction of GongStruct interface
func (clef *Clef) GetName() (res string) {
	return clef.Name
}

// Stage puts coda to the model stage
func (coda *Coda) Stage(stage *StageStruct) *Coda {
	stage.Codas[coda] = __member
	stage.Codas_mapString[coda.Name] = coda

	return coda
}

// Unstage removes coda off the model stage
func (coda *Coda) Unstage(stage *StageStruct) *Coda {
	delete(stage.Codas, coda)
	delete(stage.Codas_mapString, coda.Name)
	return coda
}

// UnstageVoid removes coda off the model stage
func (coda *Coda) UnstageVoid(stage *StageStruct) {
	delete(stage.Codas, coda)
	delete(stage.Codas_mapString, coda.Name)
}

// commit coda to the back repo (if it is already staged)
func (coda *Coda) Commit(stage *StageStruct) *Coda {
	if _, ok := stage.Codas[coda]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitCoda(coda)
		}
	}
	return coda
}

func (coda *Coda) CommitVoid(stage *StageStruct) {
	coda.Commit(stage)
}

// Checkout coda to the back repo (if it is already staged)
func (coda *Coda) Checkout(stage *StageStruct) *Coda {
	if _, ok := stage.Codas[coda]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutCoda(coda)
		}
	}
	return coda
}

// for satisfaction of GongStruct interface
func (coda *Coda) GetName() (res string) {
	return coda.Name
}

// Stage puts credit to the model stage
func (credit *Credit) Stage(stage *StageStruct) *Credit {
	stage.Credits[credit] = __member
	stage.Credits_mapString[credit.Name] = credit

	return credit
}

// Unstage removes credit off the model stage
func (credit *Credit) Unstage(stage *StageStruct) *Credit {
	delete(stage.Credits, credit)
	delete(stage.Credits_mapString, credit.Name)
	return credit
}

// UnstageVoid removes credit off the model stage
func (credit *Credit) UnstageVoid(stage *StageStruct) {
	delete(stage.Credits, credit)
	delete(stage.Credits_mapString, credit.Name)
}

// commit credit to the back repo (if it is already staged)
func (credit *Credit) Commit(stage *StageStruct) *Credit {
	if _, ok := stage.Credits[credit]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitCredit(credit)
		}
	}
	return credit
}

func (credit *Credit) CommitVoid(stage *StageStruct) {
	credit.Commit(stage)
}

// Checkout credit to the back repo (if it is already staged)
func (credit *Credit) Checkout(stage *StageStruct) *Credit {
	if _, ok := stage.Credits[credit]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutCredit(credit)
		}
	}
	return credit
}

// for satisfaction of GongStruct interface
func (credit *Credit) GetName() (res string) {
	return credit.Name
}

// Stage puts dashes to the model stage
func (dashes *Dashes) Stage(stage *StageStruct) *Dashes {
	stage.Dashess[dashes] = __member
	stage.Dashess_mapString[dashes.Name] = dashes

	return dashes
}

// Unstage removes dashes off the model stage
func (dashes *Dashes) Unstage(stage *StageStruct) *Dashes {
	delete(stage.Dashess, dashes)
	delete(stage.Dashess_mapString, dashes.Name)
	return dashes
}

// UnstageVoid removes dashes off the model stage
func (dashes *Dashes) UnstageVoid(stage *StageStruct) {
	delete(stage.Dashess, dashes)
	delete(stage.Dashess_mapString, dashes.Name)
}

// commit dashes to the back repo (if it is already staged)
func (dashes *Dashes) Commit(stage *StageStruct) *Dashes {
	if _, ok := stage.Dashess[dashes]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitDashes(dashes)
		}
	}
	return dashes
}

func (dashes *Dashes) CommitVoid(stage *StageStruct) {
	dashes.Commit(stage)
}

// Checkout dashes to the back repo (if it is already staged)
func (dashes *Dashes) Checkout(stage *StageStruct) *Dashes {
	if _, ok := stage.Dashess[dashes]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutDashes(dashes)
		}
	}
	return dashes
}

// for satisfaction of GongStruct interface
func (dashes *Dashes) GetName() (res string) {
	return dashes.Name
}

// Stage puts defaults to the model stage
func (defaults *Defaults) Stage(stage *StageStruct) *Defaults {
	stage.Defaultss[defaults] = __member
	stage.Defaultss_mapString[defaults.Name] = defaults

	return defaults
}

// Unstage removes defaults off the model stage
func (defaults *Defaults) Unstage(stage *StageStruct) *Defaults {
	delete(stage.Defaultss, defaults)
	delete(stage.Defaultss_mapString, defaults.Name)
	return defaults
}

// UnstageVoid removes defaults off the model stage
func (defaults *Defaults) UnstageVoid(stage *StageStruct) {
	delete(stage.Defaultss, defaults)
	delete(stage.Defaultss_mapString, defaults.Name)
}

// commit defaults to the back repo (if it is already staged)
func (defaults *Defaults) Commit(stage *StageStruct) *Defaults {
	if _, ok := stage.Defaultss[defaults]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitDefaults(defaults)
		}
	}
	return defaults
}

func (defaults *Defaults) CommitVoid(stage *StageStruct) {
	defaults.Commit(stage)
}

// Checkout defaults to the back repo (if it is already staged)
func (defaults *Defaults) Checkout(stage *StageStruct) *Defaults {
	if _, ok := stage.Defaultss[defaults]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutDefaults(defaults)
		}
	}
	return defaults
}

// for satisfaction of GongStruct interface
func (defaults *Defaults) GetName() (res string) {
	return defaults.Name
}

// Stage puts degree to the model stage
func (degree *Degree) Stage(stage *StageStruct) *Degree {
	stage.Degrees[degree] = __member
	stage.Degrees_mapString[degree.Name] = degree

	return degree
}

// Unstage removes degree off the model stage
func (degree *Degree) Unstage(stage *StageStruct) *Degree {
	delete(stage.Degrees, degree)
	delete(stage.Degrees_mapString, degree.Name)
	return degree
}

// UnstageVoid removes degree off the model stage
func (degree *Degree) UnstageVoid(stage *StageStruct) {
	delete(stage.Degrees, degree)
	delete(stage.Degrees_mapString, degree.Name)
}

// commit degree to the back repo (if it is already staged)
func (degree *Degree) Commit(stage *StageStruct) *Degree {
	if _, ok := stage.Degrees[degree]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitDegree(degree)
		}
	}
	return degree
}

func (degree *Degree) CommitVoid(stage *StageStruct) {
	degree.Commit(stage)
}

// Checkout degree to the back repo (if it is already staged)
func (degree *Degree) Checkout(stage *StageStruct) *Degree {
	if _, ok := stage.Degrees[degree]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutDegree(degree)
		}
	}
	return degree
}

// for satisfaction of GongStruct interface
func (degree *Degree) GetName() (res string) {
	return degree.Name
}

// Stage puts degree_alter to the model stage
func (degree_alter *Degree_alter) Stage(stage *StageStruct) *Degree_alter {
	stage.Degree_alters[degree_alter] = __member
	stage.Degree_alters_mapString[degree_alter.Name] = degree_alter

	return degree_alter
}

// Unstage removes degree_alter off the model stage
func (degree_alter *Degree_alter) Unstage(stage *StageStruct) *Degree_alter {
	delete(stage.Degree_alters, degree_alter)
	delete(stage.Degree_alters_mapString, degree_alter.Name)
	return degree_alter
}

// UnstageVoid removes degree_alter off the model stage
func (degree_alter *Degree_alter) UnstageVoid(stage *StageStruct) {
	delete(stage.Degree_alters, degree_alter)
	delete(stage.Degree_alters_mapString, degree_alter.Name)
}

// commit degree_alter to the back repo (if it is already staged)
func (degree_alter *Degree_alter) Commit(stage *StageStruct) *Degree_alter {
	if _, ok := stage.Degree_alters[degree_alter]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitDegree_alter(degree_alter)
		}
	}
	return degree_alter
}

func (degree_alter *Degree_alter) CommitVoid(stage *StageStruct) {
	degree_alter.Commit(stage)
}

// Checkout degree_alter to the back repo (if it is already staged)
func (degree_alter *Degree_alter) Checkout(stage *StageStruct) *Degree_alter {
	if _, ok := stage.Degree_alters[degree_alter]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutDegree_alter(degree_alter)
		}
	}
	return degree_alter
}

// for satisfaction of GongStruct interface
func (degree_alter *Degree_alter) GetName() (res string) {
	return degree_alter.Name
}

// Stage puts degree_type to the model stage
func (degree_type *Degree_type) Stage(stage *StageStruct) *Degree_type {
	stage.Degree_types[degree_type] = __member
	stage.Degree_types_mapString[degree_type.Name] = degree_type

	return degree_type
}

// Unstage removes degree_type off the model stage
func (degree_type *Degree_type) Unstage(stage *StageStruct) *Degree_type {
	delete(stage.Degree_types, degree_type)
	delete(stage.Degree_types_mapString, degree_type.Name)
	return degree_type
}

// UnstageVoid removes degree_type off the model stage
func (degree_type *Degree_type) UnstageVoid(stage *StageStruct) {
	delete(stage.Degree_types, degree_type)
	delete(stage.Degree_types_mapString, degree_type.Name)
}

// commit degree_type to the back repo (if it is already staged)
func (degree_type *Degree_type) Commit(stage *StageStruct) *Degree_type {
	if _, ok := stage.Degree_types[degree_type]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitDegree_type(degree_type)
		}
	}
	return degree_type
}

func (degree_type *Degree_type) CommitVoid(stage *StageStruct) {
	degree_type.Commit(stage)
}

// Checkout degree_type to the back repo (if it is already staged)
func (degree_type *Degree_type) Checkout(stage *StageStruct) *Degree_type {
	if _, ok := stage.Degree_types[degree_type]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutDegree_type(degree_type)
		}
	}
	return degree_type
}

// for satisfaction of GongStruct interface
func (degree_type *Degree_type) GetName() (res string) {
	return degree_type.Name
}

// Stage puts degree_value to the model stage
func (degree_value *Degree_value) Stage(stage *StageStruct) *Degree_value {
	stage.Degree_values[degree_value] = __member
	stage.Degree_values_mapString[degree_value.Name] = degree_value

	return degree_value
}

// Unstage removes degree_value off the model stage
func (degree_value *Degree_value) Unstage(stage *StageStruct) *Degree_value {
	delete(stage.Degree_values, degree_value)
	delete(stage.Degree_values_mapString, degree_value.Name)
	return degree_value
}

// UnstageVoid removes degree_value off the model stage
func (degree_value *Degree_value) UnstageVoid(stage *StageStruct) {
	delete(stage.Degree_values, degree_value)
	delete(stage.Degree_values_mapString, degree_value.Name)
}

// commit degree_value to the back repo (if it is already staged)
func (degree_value *Degree_value) Commit(stage *StageStruct) *Degree_value {
	if _, ok := stage.Degree_values[degree_value]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitDegree_value(degree_value)
		}
	}
	return degree_value
}

func (degree_value *Degree_value) CommitVoid(stage *StageStruct) {
	degree_value.Commit(stage)
}

// Checkout degree_value to the back repo (if it is already staged)
func (degree_value *Degree_value) Checkout(stage *StageStruct) *Degree_value {
	if _, ok := stage.Degree_values[degree_value]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutDegree_value(degree_value)
		}
	}
	return degree_value
}

// for satisfaction of GongStruct interface
func (degree_value *Degree_value) GetName() (res string) {
	return degree_value.Name
}

// Stage puts direction to the model stage
func (direction *Direction) Stage(stage *StageStruct) *Direction {
	stage.Directions[direction] = __member
	stage.Directions_mapString[direction.Name] = direction

	return direction
}

// Unstage removes direction off the model stage
func (direction *Direction) Unstage(stage *StageStruct) *Direction {
	delete(stage.Directions, direction)
	delete(stage.Directions_mapString, direction.Name)
	return direction
}

// UnstageVoid removes direction off the model stage
func (direction *Direction) UnstageVoid(stage *StageStruct) {
	delete(stage.Directions, direction)
	delete(stage.Directions_mapString, direction.Name)
}

// commit direction to the back repo (if it is already staged)
func (direction *Direction) Commit(stage *StageStruct) *Direction {
	if _, ok := stage.Directions[direction]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitDirection(direction)
		}
	}
	return direction
}

func (direction *Direction) CommitVoid(stage *StageStruct) {
	direction.Commit(stage)
}

// Checkout direction to the back repo (if it is already staged)
func (direction *Direction) Checkout(stage *StageStruct) *Direction {
	if _, ok := stage.Directions[direction]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutDirection(direction)
		}
	}
	return direction
}

// for satisfaction of GongStruct interface
func (direction *Direction) GetName() (res string) {
	return direction.Name
}

// Stage puts direction_type to the model stage
func (direction_type *Direction_type) Stage(stage *StageStruct) *Direction_type {
	stage.Direction_types[direction_type] = __member
	stage.Direction_types_mapString[direction_type.Name] = direction_type

	return direction_type
}

// Unstage removes direction_type off the model stage
func (direction_type *Direction_type) Unstage(stage *StageStruct) *Direction_type {
	delete(stage.Direction_types, direction_type)
	delete(stage.Direction_types_mapString, direction_type.Name)
	return direction_type
}

// UnstageVoid removes direction_type off the model stage
func (direction_type *Direction_type) UnstageVoid(stage *StageStruct) {
	delete(stage.Direction_types, direction_type)
	delete(stage.Direction_types_mapString, direction_type.Name)
}

// commit direction_type to the back repo (if it is already staged)
func (direction_type *Direction_type) Commit(stage *StageStruct) *Direction_type {
	if _, ok := stage.Direction_types[direction_type]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitDirection_type(direction_type)
		}
	}
	return direction_type
}

func (direction_type *Direction_type) CommitVoid(stage *StageStruct) {
	direction_type.Commit(stage)
}

// Checkout direction_type to the back repo (if it is already staged)
func (direction_type *Direction_type) Checkout(stage *StageStruct) *Direction_type {
	if _, ok := stage.Direction_types[direction_type]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutDirection_type(direction_type)
		}
	}
	return direction_type
}

// for satisfaction of GongStruct interface
func (direction_type *Direction_type) GetName() (res string) {
	return direction_type.Name
}

// Stage puts distance to the model stage
func (distance *Distance) Stage(stage *StageStruct) *Distance {
	stage.Distances[distance] = __member
	stage.Distances_mapString[distance.Name] = distance

	return distance
}

// Unstage removes distance off the model stage
func (distance *Distance) Unstage(stage *StageStruct) *Distance {
	delete(stage.Distances, distance)
	delete(stage.Distances_mapString, distance.Name)
	return distance
}

// UnstageVoid removes distance off the model stage
func (distance *Distance) UnstageVoid(stage *StageStruct) {
	delete(stage.Distances, distance)
	delete(stage.Distances_mapString, distance.Name)
}

// commit distance to the back repo (if it is already staged)
func (distance *Distance) Commit(stage *StageStruct) *Distance {
	if _, ok := stage.Distances[distance]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitDistance(distance)
		}
	}
	return distance
}

func (distance *Distance) CommitVoid(stage *StageStruct) {
	distance.Commit(stage)
}

// Checkout distance to the back repo (if it is already staged)
func (distance *Distance) Checkout(stage *StageStruct) *Distance {
	if _, ok := stage.Distances[distance]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutDistance(distance)
		}
	}
	return distance
}

// for satisfaction of GongStruct interface
func (distance *Distance) GetName() (res string) {
	return distance.Name
}

// Stage puts double to the model stage
func (double *Double) Stage(stage *StageStruct) *Double {
	stage.Doubles[double] = __member
	stage.Doubles_mapString[double.Name] = double

	return double
}

// Unstage removes double off the model stage
func (double *Double) Unstage(stage *StageStruct) *Double {
	delete(stage.Doubles, double)
	delete(stage.Doubles_mapString, double.Name)
	return double
}

// UnstageVoid removes double off the model stage
func (double *Double) UnstageVoid(stage *StageStruct) {
	delete(stage.Doubles, double)
	delete(stage.Doubles_mapString, double.Name)
}

// commit double to the back repo (if it is already staged)
func (double *Double) Commit(stage *StageStruct) *Double {
	if _, ok := stage.Doubles[double]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitDouble(double)
		}
	}
	return double
}

func (double *Double) CommitVoid(stage *StageStruct) {
	double.Commit(stage)
}

// Checkout double to the back repo (if it is already staged)
func (double *Double) Checkout(stage *StageStruct) *Double {
	if _, ok := stage.Doubles[double]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutDouble(double)
		}
	}
	return double
}

// for satisfaction of GongStruct interface
func (double *Double) GetName() (res string) {
	return double.Name
}

// Stage puts dynamics to the model stage
func (dynamics *Dynamics) Stage(stage *StageStruct) *Dynamics {
	stage.Dynamicss[dynamics] = __member
	stage.Dynamicss_mapString[dynamics.Name] = dynamics

	return dynamics
}

// Unstage removes dynamics off the model stage
func (dynamics *Dynamics) Unstage(stage *StageStruct) *Dynamics {
	delete(stage.Dynamicss, dynamics)
	delete(stage.Dynamicss_mapString, dynamics.Name)
	return dynamics
}

// UnstageVoid removes dynamics off the model stage
func (dynamics *Dynamics) UnstageVoid(stage *StageStruct) {
	delete(stage.Dynamicss, dynamics)
	delete(stage.Dynamicss_mapString, dynamics.Name)
}

// commit dynamics to the back repo (if it is already staged)
func (dynamics *Dynamics) Commit(stage *StageStruct) *Dynamics {
	if _, ok := stage.Dynamicss[dynamics]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitDynamics(dynamics)
		}
	}
	return dynamics
}

func (dynamics *Dynamics) CommitVoid(stage *StageStruct) {
	dynamics.Commit(stage)
}

// Checkout dynamics to the back repo (if it is already staged)
func (dynamics *Dynamics) Checkout(stage *StageStruct) *Dynamics {
	if _, ok := stage.Dynamicss[dynamics]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutDynamics(dynamics)
		}
	}
	return dynamics
}

// for satisfaction of GongStruct interface
func (dynamics *Dynamics) GetName() (res string) {
	return dynamics.Name
}

// Stage puts effect to the model stage
func (effect *Effect) Stage(stage *StageStruct) *Effect {
	stage.Effects[effect] = __member
	stage.Effects_mapString[effect.Name] = effect

	return effect
}

// Unstage removes effect off the model stage
func (effect *Effect) Unstage(stage *StageStruct) *Effect {
	delete(stage.Effects, effect)
	delete(stage.Effects_mapString, effect.Name)
	return effect
}

// UnstageVoid removes effect off the model stage
func (effect *Effect) UnstageVoid(stage *StageStruct) {
	delete(stage.Effects, effect)
	delete(stage.Effects_mapString, effect.Name)
}

// commit effect to the back repo (if it is already staged)
func (effect *Effect) Commit(stage *StageStruct) *Effect {
	if _, ok := stage.Effects[effect]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEffect(effect)
		}
	}
	return effect
}

func (effect *Effect) CommitVoid(stage *StageStruct) {
	effect.Commit(stage)
}

// Checkout effect to the back repo (if it is already staged)
func (effect *Effect) Checkout(stage *StageStruct) *Effect {
	if _, ok := stage.Effects[effect]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEffect(effect)
		}
	}
	return effect
}

// for satisfaction of GongStruct interface
func (effect *Effect) GetName() (res string) {
	return effect.Name
}

// Stage puts elision to the model stage
func (elision *Elision) Stage(stage *StageStruct) *Elision {
	stage.Elisions[elision] = __member
	stage.Elisions_mapString[elision.Name] = elision

	return elision
}

// Unstage removes elision off the model stage
func (elision *Elision) Unstage(stage *StageStruct) *Elision {
	delete(stage.Elisions, elision)
	delete(stage.Elisions_mapString, elision.Name)
	return elision
}

// UnstageVoid removes elision off the model stage
func (elision *Elision) UnstageVoid(stage *StageStruct) {
	delete(stage.Elisions, elision)
	delete(stage.Elisions_mapString, elision.Name)
}

// commit elision to the back repo (if it is already staged)
func (elision *Elision) Commit(stage *StageStruct) *Elision {
	if _, ok := stage.Elisions[elision]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitElision(elision)
		}
	}
	return elision
}

func (elision *Elision) CommitVoid(stage *StageStruct) {
	elision.Commit(stage)
}

// Checkout elision to the back repo (if it is already staged)
func (elision *Elision) Checkout(stage *StageStruct) *Elision {
	if _, ok := stage.Elisions[elision]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutElision(elision)
		}
	}
	return elision
}

// for satisfaction of GongStruct interface
func (elision *Elision) GetName() (res string) {
	return elision.Name
}

// Stage puts empty to the model stage
func (empty *Empty) Stage(stage *StageStruct) *Empty {
	stage.Emptys[empty] = __member
	stage.Emptys_mapString[empty.Name] = empty

	return empty
}

// Unstage removes empty off the model stage
func (empty *Empty) Unstage(stage *StageStruct) *Empty {
	delete(stage.Emptys, empty)
	delete(stage.Emptys_mapString, empty.Name)
	return empty
}

// UnstageVoid removes empty off the model stage
func (empty *Empty) UnstageVoid(stage *StageStruct) {
	delete(stage.Emptys, empty)
	delete(stage.Emptys_mapString, empty.Name)
}

// commit empty to the back repo (if it is already staged)
func (empty *Empty) Commit(stage *StageStruct) *Empty {
	if _, ok := stage.Emptys[empty]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEmpty(empty)
		}
	}
	return empty
}

func (empty *Empty) CommitVoid(stage *StageStruct) {
	empty.Commit(stage)
}

// Checkout empty to the back repo (if it is already staged)
func (empty *Empty) Checkout(stage *StageStruct) *Empty {
	if _, ok := stage.Emptys[empty]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEmpty(empty)
		}
	}
	return empty
}

// for satisfaction of GongStruct interface
func (empty *Empty) GetName() (res string) {
	return empty.Name
}

// Stage puts empty_font to the model stage
func (empty_font *Empty_font) Stage(stage *StageStruct) *Empty_font {
	stage.Empty_fonts[empty_font] = __member
	stage.Empty_fonts_mapString[empty_font.Name] = empty_font

	return empty_font
}

// Unstage removes empty_font off the model stage
func (empty_font *Empty_font) Unstage(stage *StageStruct) *Empty_font {
	delete(stage.Empty_fonts, empty_font)
	delete(stage.Empty_fonts_mapString, empty_font.Name)
	return empty_font
}

// UnstageVoid removes empty_font off the model stage
func (empty_font *Empty_font) UnstageVoid(stage *StageStruct) {
	delete(stage.Empty_fonts, empty_font)
	delete(stage.Empty_fonts_mapString, empty_font.Name)
}

// commit empty_font to the back repo (if it is already staged)
func (empty_font *Empty_font) Commit(stage *StageStruct) *Empty_font {
	if _, ok := stage.Empty_fonts[empty_font]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEmpty_font(empty_font)
		}
	}
	return empty_font
}

func (empty_font *Empty_font) CommitVoid(stage *StageStruct) {
	empty_font.Commit(stage)
}

// Checkout empty_font to the back repo (if it is already staged)
func (empty_font *Empty_font) Checkout(stage *StageStruct) *Empty_font {
	if _, ok := stage.Empty_fonts[empty_font]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEmpty_font(empty_font)
		}
	}
	return empty_font
}

// for satisfaction of GongStruct interface
func (empty_font *Empty_font) GetName() (res string) {
	return empty_font.Name
}

// Stage puts empty_line to the model stage
func (empty_line *Empty_line) Stage(stage *StageStruct) *Empty_line {
	stage.Empty_lines[empty_line] = __member
	stage.Empty_lines_mapString[empty_line.Name] = empty_line

	return empty_line
}

// Unstage removes empty_line off the model stage
func (empty_line *Empty_line) Unstage(stage *StageStruct) *Empty_line {
	delete(stage.Empty_lines, empty_line)
	delete(stage.Empty_lines_mapString, empty_line.Name)
	return empty_line
}

// UnstageVoid removes empty_line off the model stage
func (empty_line *Empty_line) UnstageVoid(stage *StageStruct) {
	delete(stage.Empty_lines, empty_line)
	delete(stage.Empty_lines_mapString, empty_line.Name)
}

// commit empty_line to the back repo (if it is already staged)
func (empty_line *Empty_line) Commit(stage *StageStruct) *Empty_line {
	if _, ok := stage.Empty_lines[empty_line]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEmpty_line(empty_line)
		}
	}
	return empty_line
}

func (empty_line *Empty_line) CommitVoid(stage *StageStruct) {
	empty_line.Commit(stage)
}

// Checkout empty_line to the back repo (if it is already staged)
func (empty_line *Empty_line) Checkout(stage *StageStruct) *Empty_line {
	if _, ok := stage.Empty_lines[empty_line]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEmpty_line(empty_line)
		}
	}
	return empty_line
}

// for satisfaction of GongStruct interface
func (empty_line *Empty_line) GetName() (res string) {
	return empty_line.Name
}

// Stage puts empty_placement to the model stage
func (empty_placement *Empty_placement) Stage(stage *StageStruct) *Empty_placement {
	stage.Empty_placements[empty_placement] = __member
	stage.Empty_placements_mapString[empty_placement.Name] = empty_placement

	return empty_placement
}

// Unstage removes empty_placement off the model stage
func (empty_placement *Empty_placement) Unstage(stage *StageStruct) *Empty_placement {
	delete(stage.Empty_placements, empty_placement)
	delete(stage.Empty_placements_mapString, empty_placement.Name)
	return empty_placement
}

// UnstageVoid removes empty_placement off the model stage
func (empty_placement *Empty_placement) UnstageVoid(stage *StageStruct) {
	delete(stage.Empty_placements, empty_placement)
	delete(stage.Empty_placements_mapString, empty_placement.Name)
}

// commit empty_placement to the back repo (if it is already staged)
func (empty_placement *Empty_placement) Commit(stage *StageStruct) *Empty_placement {
	if _, ok := stage.Empty_placements[empty_placement]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEmpty_placement(empty_placement)
		}
	}
	return empty_placement
}

func (empty_placement *Empty_placement) CommitVoid(stage *StageStruct) {
	empty_placement.Commit(stage)
}

// Checkout empty_placement to the back repo (if it is already staged)
func (empty_placement *Empty_placement) Checkout(stage *StageStruct) *Empty_placement {
	if _, ok := stage.Empty_placements[empty_placement]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEmpty_placement(empty_placement)
		}
	}
	return empty_placement
}

// for satisfaction of GongStruct interface
func (empty_placement *Empty_placement) GetName() (res string) {
	return empty_placement.Name
}

// Stage puts empty_placement_smufl to the model stage
func (empty_placement_smufl *Empty_placement_smufl) Stage(stage *StageStruct) *Empty_placement_smufl {
	stage.Empty_placement_smufls[empty_placement_smufl] = __member
	stage.Empty_placement_smufls_mapString[empty_placement_smufl.Name] = empty_placement_smufl

	return empty_placement_smufl
}

// Unstage removes empty_placement_smufl off the model stage
func (empty_placement_smufl *Empty_placement_smufl) Unstage(stage *StageStruct) *Empty_placement_smufl {
	delete(stage.Empty_placement_smufls, empty_placement_smufl)
	delete(stage.Empty_placement_smufls_mapString, empty_placement_smufl.Name)
	return empty_placement_smufl
}

// UnstageVoid removes empty_placement_smufl off the model stage
func (empty_placement_smufl *Empty_placement_smufl) UnstageVoid(stage *StageStruct) {
	delete(stage.Empty_placement_smufls, empty_placement_smufl)
	delete(stage.Empty_placement_smufls_mapString, empty_placement_smufl.Name)
}

// commit empty_placement_smufl to the back repo (if it is already staged)
func (empty_placement_smufl *Empty_placement_smufl) Commit(stage *StageStruct) *Empty_placement_smufl {
	if _, ok := stage.Empty_placement_smufls[empty_placement_smufl]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEmpty_placement_smufl(empty_placement_smufl)
		}
	}
	return empty_placement_smufl
}

func (empty_placement_smufl *Empty_placement_smufl) CommitVoid(stage *StageStruct) {
	empty_placement_smufl.Commit(stage)
}

// Checkout empty_placement_smufl to the back repo (if it is already staged)
func (empty_placement_smufl *Empty_placement_smufl) Checkout(stage *StageStruct) *Empty_placement_smufl {
	if _, ok := stage.Empty_placement_smufls[empty_placement_smufl]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEmpty_placement_smufl(empty_placement_smufl)
		}
	}
	return empty_placement_smufl
}

// for satisfaction of GongStruct interface
func (empty_placement_smufl *Empty_placement_smufl) GetName() (res string) {
	return empty_placement_smufl.Name
}

// Stage puts empty_print_object_style_align to the model stage
func (empty_print_object_style_align *Empty_print_object_style_align) Stage(stage *StageStruct) *Empty_print_object_style_align {
	stage.Empty_print_object_style_aligns[empty_print_object_style_align] = __member
	stage.Empty_print_object_style_aligns_mapString[empty_print_object_style_align.Name] = empty_print_object_style_align

	return empty_print_object_style_align
}

// Unstage removes empty_print_object_style_align off the model stage
func (empty_print_object_style_align *Empty_print_object_style_align) Unstage(stage *StageStruct) *Empty_print_object_style_align {
	delete(stage.Empty_print_object_style_aligns, empty_print_object_style_align)
	delete(stage.Empty_print_object_style_aligns_mapString, empty_print_object_style_align.Name)
	return empty_print_object_style_align
}

// UnstageVoid removes empty_print_object_style_align off the model stage
func (empty_print_object_style_align *Empty_print_object_style_align) UnstageVoid(stage *StageStruct) {
	delete(stage.Empty_print_object_style_aligns, empty_print_object_style_align)
	delete(stage.Empty_print_object_style_aligns_mapString, empty_print_object_style_align.Name)
}

// commit empty_print_object_style_align to the back repo (if it is already staged)
func (empty_print_object_style_align *Empty_print_object_style_align) Commit(stage *StageStruct) *Empty_print_object_style_align {
	if _, ok := stage.Empty_print_object_style_aligns[empty_print_object_style_align]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEmpty_print_object_style_align(empty_print_object_style_align)
		}
	}
	return empty_print_object_style_align
}

func (empty_print_object_style_align *Empty_print_object_style_align) CommitVoid(stage *StageStruct) {
	empty_print_object_style_align.Commit(stage)
}

// Checkout empty_print_object_style_align to the back repo (if it is already staged)
func (empty_print_object_style_align *Empty_print_object_style_align) Checkout(stage *StageStruct) *Empty_print_object_style_align {
	if _, ok := stage.Empty_print_object_style_aligns[empty_print_object_style_align]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEmpty_print_object_style_align(empty_print_object_style_align)
		}
	}
	return empty_print_object_style_align
}

// for satisfaction of GongStruct interface
func (empty_print_object_style_align *Empty_print_object_style_align) GetName() (res string) {
	return empty_print_object_style_align.Name
}

// Stage puts empty_print_style to the model stage
func (empty_print_style *Empty_print_style) Stage(stage *StageStruct) *Empty_print_style {
	stage.Empty_print_styles[empty_print_style] = __member
	stage.Empty_print_styles_mapString[empty_print_style.Name] = empty_print_style

	return empty_print_style
}

// Unstage removes empty_print_style off the model stage
func (empty_print_style *Empty_print_style) Unstage(stage *StageStruct) *Empty_print_style {
	delete(stage.Empty_print_styles, empty_print_style)
	delete(stage.Empty_print_styles_mapString, empty_print_style.Name)
	return empty_print_style
}

// UnstageVoid removes empty_print_style off the model stage
func (empty_print_style *Empty_print_style) UnstageVoid(stage *StageStruct) {
	delete(stage.Empty_print_styles, empty_print_style)
	delete(stage.Empty_print_styles_mapString, empty_print_style.Name)
}

// commit empty_print_style to the back repo (if it is already staged)
func (empty_print_style *Empty_print_style) Commit(stage *StageStruct) *Empty_print_style {
	if _, ok := stage.Empty_print_styles[empty_print_style]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEmpty_print_style(empty_print_style)
		}
	}
	return empty_print_style
}

func (empty_print_style *Empty_print_style) CommitVoid(stage *StageStruct) {
	empty_print_style.Commit(stage)
}

// Checkout empty_print_style to the back repo (if it is already staged)
func (empty_print_style *Empty_print_style) Checkout(stage *StageStruct) *Empty_print_style {
	if _, ok := stage.Empty_print_styles[empty_print_style]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEmpty_print_style(empty_print_style)
		}
	}
	return empty_print_style
}

// for satisfaction of GongStruct interface
func (empty_print_style *Empty_print_style) GetName() (res string) {
	return empty_print_style.Name
}

// Stage puts empty_print_style_align to the model stage
func (empty_print_style_align *Empty_print_style_align) Stage(stage *StageStruct) *Empty_print_style_align {
	stage.Empty_print_style_aligns[empty_print_style_align] = __member
	stage.Empty_print_style_aligns_mapString[empty_print_style_align.Name] = empty_print_style_align

	return empty_print_style_align
}

// Unstage removes empty_print_style_align off the model stage
func (empty_print_style_align *Empty_print_style_align) Unstage(stage *StageStruct) *Empty_print_style_align {
	delete(stage.Empty_print_style_aligns, empty_print_style_align)
	delete(stage.Empty_print_style_aligns_mapString, empty_print_style_align.Name)
	return empty_print_style_align
}

// UnstageVoid removes empty_print_style_align off the model stage
func (empty_print_style_align *Empty_print_style_align) UnstageVoid(stage *StageStruct) {
	delete(stage.Empty_print_style_aligns, empty_print_style_align)
	delete(stage.Empty_print_style_aligns_mapString, empty_print_style_align.Name)
}

// commit empty_print_style_align to the back repo (if it is already staged)
func (empty_print_style_align *Empty_print_style_align) Commit(stage *StageStruct) *Empty_print_style_align {
	if _, ok := stage.Empty_print_style_aligns[empty_print_style_align]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEmpty_print_style_align(empty_print_style_align)
		}
	}
	return empty_print_style_align
}

func (empty_print_style_align *Empty_print_style_align) CommitVoid(stage *StageStruct) {
	empty_print_style_align.Commit(stage)
}

// Checkout empty_print_style_align to the back repo (if it is already staged)
func (empty_print_style_align *Empty_print_style_align) Checkout(stage *StageStruct) *Empty_print_style_align {
	if _, ok := stage.Empty_print_style_aligns[empty_print_style_align]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEmpty_print_style_align(empty_print_style_align)
		}
	}
	return empty_print_style_align
}

// for satisfaction of GongStruct interface
func (empty_print_style_align *Empty_print_style_align) GetName() (res string) {
	return empty_print_style_align.Name
}

// Stage puts empty_print_style_align_id to the model stage
func (empty_print_style_align_id *Empty_print_style_align_id) Stage(stage *StageStruct) *Empty_print_style_align_id {
	stage.Empty_print_style_align_ids[empty_print_style_align_id] = __member
	stage.Empty_print_style_align_ids_mapString[empty_print_style_align_id.Name] = empty_print_style_align_id

	return empty_print_style_align_id
}

// Unstage removes empty_print_style_align_id off the model stage
func (empty_print_style_align_id *Empty_print_style_align_id) Unstage(stage *StageStruct) *Empty_print_style_align_id {
	delete(stage.Empty_print_style_align_ids, empty_print_style_align_id)
	delete(stage.Empty_print_style_align_ids_mapString, empty_print_style_align_id.Name)
	return empty_print_style_align_id
}

// UnstageVoid removes empty_print_style_align_id off the model stage
func (empty_print_style_align_id *Empty_print_style_align_id) UnstageVoid(stage *StageStruct) {
	delete(stage.Empty_print_style_align_ids, empty_print_style_align_id)
	delete(stage.Empty_print_style_align_ids_mapString, empty_print_style_align_id.Name)
}

// commit empty_print_style_align_id to the back repo (if it is already staged)
func (empty_print_style_align_id *Empty_print_style_align_id) Commit(stage *StageStruct) *Empty_print_style_align_id {
	if _, ok := stage.Empty_print_style_align_ids[empty_print_style_align_id]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEmpty_print_style_align_id(empty_print_style_align_id)
		}
	}
	return empty_print_style_align_id
}

func (empty_print_style_align_id *Empty_print_style_align_id) CommitVoid(stage *StageStruct) {
	empty_print_style_align_id.Commit(stage)
}

// Checkout empty_print_style_align_id to the back repo (if it is already staged)
func (empty_print_style_align_id *Empty_print_style_align_id) Checkout(stage *StageStruct) *Empty_print_style_align_id {
	if _, ok := stage.Empty_print_style_align_ids[empty_print_style_align_id]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEmpty_print_style_align_id(empty_print_style_align_id)
		}
	}
	return empty_print_style_align_id
}

// for satisfaction of GongStruct interface
func (empty_print_style_align_id *Empty_print_style_align_id) GetName() (res string) {
	return empty_print_style_align_id.Name
}

// Stage puts empty_trill_sound to the model stage
func (empty_trill_sound *Empty_trill_sound) Stage(stage *StageStruct) *Empty_trill_sound {
	stage.Empty_trill_sounds[empty_trill_sound] = __member
	stage.Empty_trill_sounds_mapString[empty_trill_sound.Name] = empty_trill_sound

	return empty_trill_sound
}

// Unstage removes empty_trill_sound off the model stage
func (empty_trill_sound *Empty_trill_sound) Unstage(stage *StageStruct) *Empty_trill_sound {
	delete(stage.Empty_trill_sounds, empty_trill_sound)
	delete(stage.Empty_trill_sounds_mapString, empty_trill_sound.Name)
	return empty_trill_sound
}

// UnstageVoid removes empty_trill_sound off the model stage
func (empty_trill_sound *Empty_trill_sound) UnstageVoid(stage *StageStruct) {
	delete(stage.Empty_trill_sounds, empty_trill_sound)
	delete(stage.Empty_trill_sounds_mapString, empty_trill_sound.Name)
}

// commit empty_trill_sound to the back repo (if it is already staged)
func (empty_trill_sound *Empty_trill_sound) Commit(stage *StageStruct) *Empty_trill_sound {
	if _, ok := stage.Empty_trill_sounds[empty_trill_sound]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEmpty_trill_sound(empty_trill_sound)
		}
	}
	return empty_trill_sound
}

func (empty_trill_sound *Empty_trill_sound) CommitVoid(stage *StageStruct) {
	empty_trill_sound.Commit(stage)
}

// Checkout empty_trill_sound to the back repo (if it is already staged)
func (empty_trill_sound *Empty_trill_sound) Checkout(stage *StageStruct) *Empty_trill_sound {
	if _, ok := stage.Empty_trill_sounds[empty_trill_sound]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEmpty_trill_sound(empty_trill_sound)
		}
	}
	return empty_trill_sound
}

// for satisfaction of GongStruct interface
func (empty_trill_sound *Empty_trill_sound) GetName() (res string) {
	return empty_trill_sound.Name
}

// Stage puts encoding to the model stage
func (encoding *Encoding) Stage(stage *StageStruct) *Encoding {
	stage.Encodings[encoding] = __member
	stage.Encodings_mapString[encoding.Name] = encoding

	return encoding
}

// Unstage removes encoding off the model stage
func (encoding *Encoding) Unstage(stage *StageStruct) *Encoding {
	delete(stage.Encodings, encoding)
	delete(stage.Encodings_mapString, encoding.Name)
	return encoding
}

// UnstageVoid removes encoding off the model stage
func (encoding *Encoding) UnstageVoid(stage *StageStruct) {
	delete(stage.Encodings, encoding)
	delete(stage.Encodings_mapString, encoding.Name)
}

// commit encoding to the back repo (if it is already staged)
func (encoding *Encoding) Commit(stage *StageStruct) *Encoding {
	if _, ok := stage.Encodings[encoding]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEncoding(encoding)
		}
	}
	return encoding
}

func (encoding *Encoding) CommitVoid(stage *StageStruct) {
	encoding.Commit(stage)
}

// Checkout encoding to the back repo (if it is already staged)
func (encoding *Encoding) Checkout(stage *StageStruct) *Encoding {
	if _, ok := stage.Encodings[encoding]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEncoding(encoding)
		}
	}
	return encoding
}

// for satisfaction of GongStruct interface
func (encoding *Encoding) GetName() (res string) {
	return encoding.Name
}

// Stage puts ending to the model stage
func (ending *Ending) Stage(stage *StageStruct) *Ending {
	stage.Endings[ending] = __member
	stage.Endings_mapString[ending.Name] = ending

	return ending
}

// Unstage removes ending off the model stage
func (ending *Ending) Unstage(stage *StageStruct) *Ending {
	delete(stage.Endings, ending)
	delete(stage.Endings_mapString, ending.Name)
	return ending
}

// UnstageVoid removes ending off the model stage
func (ending *Ending) UnstageVoid(stage *StageStruct) {
	delete(stage.Endings, ending)
	delete(stage.Endings_mapString, ending.Name)
}

// commit ending to the back repo (if it is already staged)
func (ending *Ending) Commit(stage *StageStruct) *Ending {
	if _, ok := stage.Endings[ending]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitEnding(ending)
		}
	}
	return ending
}

func (ending *Ending) CommitVoid(stage *StageStruct) {
	ending.Commit(stage)
}

// Checkout ending to the back repo (if it is already staged)
func (ending *Ending) Checkout(stage *StageStruct) *Ending {
	if _, ok := stage.Endings[ending]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutEnding(ending)
		}
	}
	return ending
}

// for satisfaction of GongStruct interface
func (ending *Ending) GetName() (res string) {
	return ending.Name
}

// Stage puts extend to the model stage
func (extend *Extend) Stage(stage *StageStruct) *Extend {
	stage.Extends[extend] = __member
	stage.Extends_mapString[extend.Name] = extend

	return extend
}

// Unstage removes extend off the model stage
func (extend *Extend) Unstage(stage *StageStruct) *Extend {
	delete(stage.Extends, extend)
	delete(stage.Extends_mapString, extend.Name)
	return extend
}

// UnstageVoid removes extend off the model stage
func (extend *Extend) UnstageVoid(stage *StageStruct) {
	delete(stage.Extends, extend)
	delete(stage.Extends_mapString, extend.Name)
}

// commit extend to the back repo (if it is already staged)
func (extend *Extend) Commit(stage *StageStruct) *Extend {
	if _, ok := stage.Extends[extend]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitExtend(extend)
		}
	}
	return extend
}

func (extend *Extend) CommitVoid(stage *StageStruct) {
	extend.Commit(stage)
}

// Checkout extend to the back repo (if it is already staged)
func (extend *Extend) Checkout(stage *StageStruct) *Extend {
	if _, ok := stage.Extends[extend]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutExtend(extend)
		}
	}
	return extend
}

// for satisfaction of GongStruct interface
func (extend *Extend) GetName() (res string) {
	return extend.Name
}

// Stage puts feature to the model stage
func (feature *Feature) Stage(stage *StageStruct) *Feature {
	stage.Features[feature] = __member
	stage.Features_mapString[feature.Name] = feature

	return feature
}

// Unstage removes feature off the model stage
func (feature *Feature) Unstage(stage *StageStruct) *Feature {
	delete(stage.Features, feature)
	delete(stage.Features_mapString, feature.Name)
	return feature
}

// UnstageVoid removes feature off the model stage
func (feature *Feature) UnstageVoid(stage *StageStruct) {
	delete(stage.Features, feature)
	delete(stage.Features_mapString, feature.Name)
}

// commit feature to the back repo (if it is already staged)
func (feature *Feature) Commit(stage *StageStruct) *Feature {
	if _, ok := stage.Features[feature]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFeature(feature)
		}
	}
	return feature
}

func (feature *Feature) CommitVoid(stage *StageStruct) {
	feature.Commit(stage)
}

// Checkout feature to the back repo (if it is already staged)
func (feature *Feature) Checkout(stage *StageStruct) *Feature {
	if _, ok := stage.Features[feature]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFeature(feature)
		}
	}
	return feature
}

// for satisfaction of GongStruct interface
func (feature *Feature) GetName() (res string) {
	return feature.Name
}

// Stage puts fermata to the model stage
func (fermata *Fermata) Stage(stage *StageStruct) *Fermata {
	stage.Fermatas[fermata] = __member
	stage.Fermatas_mapString[fermata.Name] = fermata

	return fermata
}

// Unstage removes fermata off the model stage
func (fermata *Fermata) Unstage(stage *StageStruct) *Fermata {
	delete(stage.Fermatas, fermata)
	delete(stage.Fermatas_mapString, fermata.Name)
	return fermata
}

// UnstageVoid removes fermata off the model stage
func (fermata *Fermata) UnstageVoid(stage *StageStruct) {
	delete(stage.Fermatas, fermata)
	delete(stage.Fermatas_mapString, fermata.Name)
}

// commit fermata to the back repo (if it is already staged)
func (fermata *Fermata) Commit(stage *StageStruct) *Fermata {
	if _, ok := stage.Fermatas[fermata]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFermata(fermata)
		}
	}
	return fermata
}

func (fermata *Fermata) CommitVoid(stage *StageStruct) {
	fermata.Commit(stage)
}

// Checkout fermata to the back repo (if it is already staged)
func (fermata *Fermata) Checkout(stage *StageStruct) *Fermata {
	if _, ok := stage.Fermatas[fermata]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFermata(fermata)
		}
	}
	return fermata
}

// for satisfaction of GongStruct interface
func (fermata *Fermata) GetName() (res string) {
	return fermata.Name
}

// Stage puts figure to the model stage
func (figure *Figure) Stage(stage *StageStruct) *Figure {
	stage.Figures[figure] = __member
	stage.Figures_mapString[figure.Name] = figure

	return figure
}

// Unstage removes figure off the model stage
func (figure *Figure) Unstage(stage *StageStruct) *Figure {
	delete(stage.Figures, figure)
	delete(stage.Figures_mapString, figure.Name)
	return figure
}

// UnstageVoid removes figure off the model stage
func (figure *Figure) UnstageVoid(stage *StageStruct) {
	delete(stage.Figures, figure)
	delete(stage.Figures_mapString, figure.Name)
}

// commit figure to the back repo (if it is already staged)
func (figure *Figure) Commit(stage *StageStruct) *Figure {
	if _, ok := stage.Figures[figure]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFigure(figure)
		}
	}
	return figure
}

func (figure *Figure) CommitVoid(stage *StageStruct) {
	figure.Commit(stage)
}

// Checkout figure to the back repo (if it is already staged)
func (figure *Figure) Checkout(stage *StageStruct) *Figure {
	if _, ok := stage.Figures[figure]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFigure(figure)
		}
	}
	return figure
}

// for satisfaction of GongStruct interface
func (figure *Figure) GetName() (res string) {
	return figure.Name
}

// Stage puts figured_bass to the model stage
func (figured_bass *Figured_bass) Stage(stage *StageStruct) *Figured_bass {
	stage.Figured_basss[figured_bass] = __member
	stage.Figured_basss_mapString[figured_bass.Name] = figured_bass

	return figured_bass
}

// Unstage removes figured_bass off the model stage
func (figured_bass *Figured_bass) Unstage(stage *StageStruct) *Figured_bass {
	delete(stage.Figured_basss, figured_bass)
	delete(stage.Figured_basss_mapString, figured_bass.Name)
	return figured_bass
}

// UnstageVoid removes figured_bass off the model stage
func (figured_bass *Figured_bass) UnstageVoid(stage *StageStruct) {
	delete(stage.Figured_basss, figured_bass)
	delete(stage.Figured_basss_mapString, figured_bass.Name)
}

// commit figured_bass to the back repo (if it is already staged)
func (figured_bass *Figured_bass) Commit(stage *StageStruct) *Figured_bass {
	if _, ok := stage.Figured_basss[figured_bass]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFigured_bass(figured_bass)
		}
	}
	return figured_bass
}

func (figured_bass *Figured_bass) CommitVoid(stage *StageStruct) {
	figured_bass.Commit(stage)
}

// Checkout figured_bass to the back repo (if it is already staged)
func (figured_bass *Figured_bass) Checkout(stage *StageStruct) *Figured_bass {
	if _, ok := stage.Figured_basss[figured_bass]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFigured_bass(figured_bass)
		}
	}
	return figured_bass
}

// for satisfaction of GongStruct interface
func (figured_bass *Figured_bass) GetName() (res string) {
	return figured_bass.Name
}

// Stage puts fingering to the model stage
func (fingering *Fingering) Stage(stage *StageStruct) *Fingering {
	stage.Fingerings[fingering] = __member
	stage.Fingerings_mapString[fingering.Name] = fingering

	return fingering
}

// Unstage removes fingering off the model stage
func (fingering *Fingering) Unstage(stage *StageStruct) *Fingering {
	delete(stage.Fingerings, fingering)
	delete(stage.Fingerings_mapString, fingering.Name)
	return fingering
}

// UnstageVoid removes fingering off the model stage
func (fingering *Fingering) UnstageVoid(stage *StageStruct) {
	delete(stage.Fingerings, fingering)
	delete(stage.Fingerings_mapString, fingering.Name)
}

// commit fingering to the back repo (if it is already staged)
func (fingering *Fingering) Commit(stage *StageStruct) *Fingering {
	if _, ok := stage.Fingerings[fingering]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFingering(fingering)
		}
	}
	return fingering
}

func (fingering *Fingering) CommitVoid(stage *StageStruct) {
	fingering.Commit(stage)
}

// Checkout fingering to the back repo (if it is already staged)
func (fingering *Fingering) Checkout(stage *StageStruct) *Fingering {
	if _, ok := stage.Fingerings[fingering]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFingering(fingering)
		}
	}
	return fingering
}

// for satisfaction of GongStruct interface
func (fingering *Fingering) GetName() (res string) {
	return fingering.Name
}

// Stage puts first_fret to the model stage
func (first_fret *First_fret) Stage(stage *StageStruct) *First_fret {
	stage.First_frets[first_fret] = __member
	stage.First_frets_mapString[first_fret.Name] = first_fret

	return first_fret
}

// Unstage removes first_fret off the model stage
func (first_fret *First_fret) Unstage(stage *StageStruct) *First_fret {
	delete(stage.First_frets, first_fret)
	delete(stage.First_frets_mapString, first_fret.Name)
	return first_fret
}

// UnstageVoid removes first_fret off the model stage
func (first_fret *First_fret) UnstageVoid(stage *StageStruct) {
	delete(stage.First_frets, first_fret)
	delete(stage.First_frets_mapString, first_fret.Name)
}

// commit first_fret to the back repo (if it is already staged)
func (first_fret *First_fret) Commit(stage *StageStruct) *First_fret {
	if _, ok := stage.First_frets[first_fret]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFirst_fret(first_fret)
		}
	}
	return first_fret
}

func (first_fret *First_fret) CommitVoid(stage *StageStruct) {
	first_fret.Commit(stage)
}

// Checkout first_fret to the back repo (if it is already staged)
func (first_fret *First_fret) Checkout(stage *StageStruct) *First_fret {
	if _, ok := stage.First_frets[first_fret]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFirst_fret(first_fret)
		}
	}
	return first_fret
}

// for satisfaction of GongStruct interface
func (first_fret *First_fret) GetName() (res string) {
	return first_fret.Name
}

// Stage puts foo to the model stage
func (foo *Foo) Stage(stage *StageStruct) *Foo {
	stage.Foos[foo] = __member
	stage.Foos_mapString[foo.Name] = foo

	return foo
}

// Unstage removes foo off the model stage
func (foo *Foo) Unstage(stage *StageStruct) *Foo {
	delete(stage.Foos, foo)
	delete(stage.Foos_mapString, foo.Name)
	return foo
}

// UnstageVoid removes foo off the model stage
func (foo *Foo) UnstageVoid(stage *StageStruct) {
	delete(stage.Foos, foo)
	delete(stage.Foos_mapString, foo.Name)
}

// commit foo to the back repo (if it is already staged)
func (foo *Foo) Commit(stage *StageStruct) *Foo {
	if _, ok := stage.Foos[foo]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFoo(foo)
		}
	}
	return foo
}

func (foo *Foo) CommitVoid(stage *StageStruct) {
	foo.Commit(stage)
}

// Checkout foo to the back repo (if it is already staged)
func (foo *Foo) Checkout(stage *StageStruct) *Foo {
	if _, ok := stage.Foos[foo]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFoo(foo)
		}
	}
	return foo
}

// for satisfaction of GongStruct interface
func (foo *Foo) GetName() (res string) {
	return foo.Name
}

// Stage puts for_part to the model stage
func (for_part *For_part) Stage(stage *StageStruct) *For_part {
	stage.For_parts[for_part] = __member
	stage.For_parts_mapString[for_part.Name] = for_part

	return for_part
}

// Unstage removes for_part off the model stage
func (for_part *For_part) Unstage(stage *StageStruct) *For_part {
	delete(stage.For_parts, for_part)
	delete(stage.For_parts_mapString, for_part.Name)
	return for_part
}

// UnstageVoid removes for_part off the model stage
func (for_part *For_part) UnstageVoid(stage *StageStruct) {
	delete(stage.For_parts, for_part)
	delete(stage.For_parts_mapString, for_part.Name)
}

// commit for_part to the back repo (if it is already staged)
func (for_part *For_part) Commit(stage *StageStruct) *For_part {
	if _, ok := stage.For_parts[for_part]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFor_part(for_part)
		}
	}
	return for_part
}

func (for_part *For_part) CommitVoid(stage *StageStruct) {
	for_part.Commit(stage)
}

// Checkout for_part to the back repo (if it is already staged)
func (for_part *For_part) Checkout(stage *StageStruct) *For_part {
	if _, ok := stage.For_parts[for_part]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFor_part(for_part)
		}
	}
	return for_part
}

// for satisfaction of GongStruct interface
func (for_part *For_part) GetName() (res string) {
	return for_part.Name
}

// Stage puts formatted_symbol to the model stage
func (formatted_symbol *Formatted_symbol) Stage(stage *StageStruct) *Formatted_symbol {
	stage.Formatted_symbols[formatted_symbol] = __member
	stage.Formatted_symbols_mapString[formatted_symbol.Name] = formatted_symbol

	return formatted_symbol
}

// Unstage removes formatted_symbol off the model stage
func (formatted_symbol *Formatted_symbol) Unstage(stage *StageStruct) *Formatted_symbol {
	delete(stage.Formatted_symbols, formatted_symbol)
	delete(stage.Formatted_symbols_mapString, formatted_symbol.Name)
	return formatted_symbol
}

// UnstageVoid removes formatted_symbol off the model stage
func (formatted_symbol *Formatted_symbol) UnstageVoid(stage *StageStruct) {
	delete(stage.Formatted_symbols, formatted_symbol)
	delete(stage.Formatted_symbols_mapString, formatted_symbol.Name)
}

// commit formatted_symbol to the back repo (if it is already staged)
func (formatted_symbol *Formatted_symbol) Commit(stage *StageStruct) *Formatted_symbol {
	if _, ok := stage.Formatted_symbols[formatted_symbol]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFormatted_symbol(formatted_symbol)
		}
	}
	return formatted_symbol
}

func (formatted_symbol *Formatted_symbol) CommitVoid(stage *StageStruct) {
	formatted_symbol.Commit(stage)
}

// Checkout formatted_symbol to the back repo (if it is already staged)
func (formatted_symbol *Formatted_symbol) Checkout(stage *StageStruct) *Formatted_symbol {
	if _, ok := stage.Formatted_symbols[formatted_symbol]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFormatted_symbol(formatted_symbol)
		}
	}
	return formatted_symbol
}

// for satisfaction of GongStruct interface
func (formatted_symbol *Formatted_symbol) GetName() (res string) {
	return formatted_symbol.Name
}

// Stage puts formatted_symbol_id to the model stage
func (formatted_symbol_id *Formatted_symbol_id) Stage(stage *StageStruct) *Formatted_symbol_id {
	stage.Formatted_symbol_ids[formatted_symbol_id] = __member
	stage.Formatted_symbol_ids_mapString[formatted_symbol_id.Name] = formatted_symbol_id

	return formatted_symbol_id
}

// Unstage removes formatted_symbol_id off the model stage
func (formatted_symbol_id *Formatted_symbol_id) Unstage(stage *StageStruct) *Formatted_symbol_id {
	delete(stage.Formatted_symbol_ids, formatted_symbol_id)
	delete(stage.Formatted_symbol_ids_mapString, formatted_symbol_id.Name)
	return formatted_symbol_id
}

// UnstageVoid removes formatted_symbol_id off the model stage
func (formatted_symbol_id *Formatted_symbol_id) UnstageVoid(stage *StageStruct) {
	delete(stage.Formatted_symbol_ids, formatted_symbol_id)
	delete(stage.Formatted_symbol_ids_mapString, formatted_symbol_id.Name)
}

// commit formatted_symbol_id to the back repo (if it is already staged)
func (formatted_symbol_id *Formatted_symbol_id) Commit(stage *StageStruct) *Formatted_symbol_id {
	if _, ok := stage.Formatted_symbol_ids[formatted_symbol_id]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFormatted_symbol_id(formatted_symbol_id)
		}
	}
	return formatted_symbol_id
}

func (formatted_symbol_id *Formatted_symbol_id) CommitVoid(stage *StageStruct) {
	formatted_symbol_id.Commit(stage)
}

// Checkout formatted_symbol_id to the back repo (if it is already staged)
func (formatted_symbol_id *Formatted_symbol_id) Checkout(stage *StageStruct) *Formatted_symbol_id {
	if _, ok := stage.Formatted_symbol_ids[formatted_symbol_id]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFormatted_symbol_id(formatted_symbol_id)
		}
	}
	return formatted_symbol_id
}

// for satisfaction of GongStruct interface
func (formatted_symbol_id *Formatted_symbol_id) GetName() (res string) {
	return formatted_symbol_id.Name
}

// Stage puts forward to the model stage
func (forward *Forward) Stage(stage *StageStruct) *Forward {
	stage.Forwards[forward] = __member
	stage.Forwards_mapString[forward.Name] = forward

	return forward
}

// Unstage removes forward off the model stage
func (forward *Forward) Unstage(stage *StageStruct) *Forward {
	delete(stage.Forwards, forward)
	delete(stage.Forwards_mapString, forward.Name)
	return forward
}

// UnstageVoid removes forward off the model stage
func (forward *Forward) UnstageVoid(stage *StageStruct) {
	delete(stage.Forwards, forward)
	delete(stage.Forwards_mapString, forward.Name)
}

// commit forward to the back repo (if it is already staged)
func (forward *Forward) Commit(stage *StageStruct) *Forward {
	if _, ok := stage.Forwards[forward]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitForward(forward)
		}
	}
	return forward
}

func (forward *Forward) CommitVoid(stage *StageStruct) {
	forward.Commit(stage)
}

// Checkout forward to the back repo (if it is already staged)
func (forward *Forward) Checkout(stage *StageStruct) *Forward {
	if _, ok := stage.Forwards[forward]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutForward(forward)
		}
	}
	return forward
}

// for satisfaction of GongStruct interface
func (forward *Forward) GetName() (res string) {
	return forward.Name
}

// Stage puts frame to the model stage
func (frame *Frame) Stage(stage *StageStruct) *Frame {
	stage.Frames[frame] = __member
	stage.Frames_mapString[frame.Name] = frame

	return frame
}

// Unstage removes frame off the model stage
func (frame *Frame) Unstage(stage *StageStruct) *Frame {
	delete(stage.Frames, frame)
	delete(stage.Frames_mapString, frame.Name)
	return frame
}

// UnstageVoid removes frame off the model stage
func (frame *Frame) UnstageVoid(stage *StageStruct) {
	delete(stage.Frames, frame)
	delete(stage.Frames_mapString, frame.Name)
}

// commit frame to the back repo (if it is already staged)
func (frame *Frame) Commit(stage *StageStruct) *Frame {
	if _, ok := stage.Frames[frame]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFrame(frame)
		}
	}
	return frame
}

func (frame *Frame) CommitVoid(stage *StageStruct) {
	frame.Commit(stage)
}

// Checkout frame to the back repo (if it is already staged)
func (frame *Frame) Checkout(stage *StageStruct) *Frame {
	if _, ok := stage.Frames[frame]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFrame(frame)
		}
	}
	return frame
}

// for satisfaction of GongStruct interface
func (frame *Frame) GetName() (res string) {
	return frame.Name
}

// Stage puts frame_note to the model stage
func (frame_note *Frame_note) Stage(stage *StageStruct) *Frame_note {
	stage.Frame_notes[frame_note] = __member
	stage.Frame_notes_mapString[frame_note.Name] = frame_note

	return frame_note
}

// Unstage removes frame_note off the model stage
func (frame_note *Frame_note) Unstage(stage *StageStruct) *Frame_note {
	delete(stage.Frame_notes, frame_note)
	delete(stage.Frame_notes_mapString, frame_note.Name)
	return frame_note
}

// UnstageVoid removes frame_note off the model stage
func (frame_note *Frame_note) UnstageVoid(stage *StageStruct) {
	delete(stage.Frame_notes, frame_note)
	delete(stage.Frame_notes_mapString, frame_note.Name)
}

// commit frame_note to the back repo (if it is already staged)
func (frame_note *Frame_note) Commit(stage *StageStruct) *Frame_note {
	if _, ok := stage.Frame_notes[frame_note]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFrame_note(frame_note)
		}
	}
	return frame_note
}

func (frame_note *Frame_note) CommitVoid(stage *StageStruct) {
	frame_note.Commit(stage)
}

// Checkout frame_note to the back repo (if it is already staged)
func (frame_note *Frame_note) Checkout(stage *StageStruct) *Frame_note {
	if _, ok := stage.Frame_notes[frame_note]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFrame_note(frame_note)
		}
	}
	return frame_note
}

// for satisfaction of GongStruct interface
func (frame_note *Frame_note) GetName() (res string) {
	return frame_note.Name
}

// Stage puts fret to the model stage
func (fret *Fret) Stage(stage *StageStruct) *Fret {
	stage.Frets[fret] = __member
	stage.Frets_mapString[fret.Name] = fret

	return fret
}

// Unstage removes fret off the model stage
func (fret *Fret) Unstage(stage *StageStruct) *Fret {
	delete(stage.Frets, fret)
	delete(stage.Frets_mapString, fret.Name)
	return fret
}

// UnstageVoid removes fret off the model stage
func (fret *Fret) UnstageVoid(stage *StageStruct) {
	delete(stage.Frets, fret)
	delete(stage.Frets_mapString, fret.Name)
}

// commit fret to the back repo (if it is already staged)
func (fret *Fret) Commit(stage *StageStruct) *Fret {
	if _, ok := stage.Frets[fret]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitFret(fret)
		}
	}
	return fret
}

func (fret *Fret) CommitVoid(stage *StageStruct) {
	fret.Commit(stage)
}

// Checkout fret to the back repo (if it is already staged)
func (fret *Fret) Checkout(stage *StageStruct) *Fret {
	if _, ok := stage.Frets[fret]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutFret(fret)
		}
	}
	return fret
}

// for satisfaction of GongStruct interface
func (fret *Fret) GetName() (res string) {
	return fret.Name
}

// Stage puts glass to the model stage
func (glass *Glass) Stage(stage *StageStruct) *Glass {
	stage.Glasss[glass] = __member
	stage.Glasss_mapString[glass.Name] = glass

	return glass
}

// Unstage removes glass off the model stage
func (glass *Glass) Unstage(stage *StageStruct) *Glass {
	delete(stage.Glasss, glass)
	delete(stage.Glasss_mapString, glass.Name)
	return glass
}

// UnstageVoid removes glass off the model stage
func (glass *Glass) UnstageVoid(stage *StageStruct) {
	delete(stage.Glasss, glass)
	delete(stage.Glasss_mapString, glass.Name)
}

// commit glass to the back repo (if it is already staged)
func (glass *Glass) Commit(stage *StageStruct) *Glass {
	if _, ok := stage.Glasss[glass]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitGlass(glass)
		}
	}
	return glass
}

func (glass *Glass) CommitVoid(stage *StageStruct) {
	glass.Commit(stage)
}

// Checkout glass to the back repo (if it is already staged)
func (glass *Glass) Checkout(stage *StageStruct) *Glass {
	if _, ok := stage.Glasss[glass]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutGlass(glass)
		}
	}
	return glass
}

// for satisfaction of GongStruct interface
func (glass *Glass) GetName() (res string) {
	return glass.Name
}

// Stage puts glissando to the model stage
func (glissando *Glissando) Stage(stage *StageStruct) *Glissando {
	stage.Glissandos[glissando] = __member
	stage.Glissandos_mapString[glissando.Name] = glissando

	return glissando
}

// Unstage removes glissando off the model stage
func (glissando *Glissando) Unstage(stage *StageStruct) *Glissando {
	delete(stage.Glissandos, glissando)
	delete(stage.Glissandos_mapString, glissando.Name)
	return glissando
}

// UnstageVoid removes glissando off the model stage
func (glissando *Glissando) UnstageVoid(stage *StageStruct) {
	delete(stage.Glissandos, glissando)
	delete(stage.Glissandos_mapString, glissando.Name)
}

// commit glissando to the back repo (if it is already staged)
func (glissando *Glissando) Commit(stage *StageStruct) *Glissando {
	if _, ok := stage.Glissandos[glissando]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitGlissando(glissando)
		}
	}
	return glissando
}

func (glissando *Glissando) CommitVoid(stage *StageStruct) {
	glissando.Commit(stage)
}

// Checkout glissando to the back repo (if it is already staged)
func (glissando *Glissando) Checkout(stage *StageStruct) *Glissando {
	if _, ok := stage.Glissandos[glissando]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutGlissando(glissando)
		}
	}
	return glissando
}

// for satisfaction of GongStruct interface
func (glissando *Glissando) GetName() (res string) {
	return glissando.Name
}

// Stage puts glyph to the model stage
func (glyph *Glyph) Stage(stage *StageStruct) *Glyph {
	stage.Glyphs[glyph] = __member
	stage.Glyphs_mapString[glyph.Name] = glyph

	return glyph
}

// Unstage removes glyph off the model stage
func (glyph *Glyph) Unstage(stage *StageStruct) *Glyph {
	delete(stage.Glyphs, glyph)
	delete(stage.Glyphs_mapString, glyph.Name)
	return glyph
}

// UnstageVoid removes glyph off the model stage
func (glyph *Glyph) UnstageVoid(stage *StageStruct) {
	delete(stage.Glyphs, glyph)
	delete(stage.Glyphs_mapString, glyph.Name)
}

// commit glyph to the back repo (if it is already staged)
func (glyph *Glyph) Commit(stage *StageStruct) *Glyph {
	if _, ok := stage.Glyphs[glyph]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitGlyph(glyph)
		}
	}
	return glyph
}

func (glyph *Glyph) CommitVoid(stage *StageStruct) {
	glyph.Commit(stage)
}

// Checkout glyph to the back repo (if it is already staged)
func (glyph *Glyph) Checkout(stage *StageStruct) *Glyph {
	if _, ok := stage.Glyphs[glyph]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutGlyph(glyph)
		}
	}
	return glyph
}

// for satisfaction of GongStruct interface
func (glyph *Glyph) GetName() (res string) {
	return glyph.Name
}

// Stage puts grace to the model stage
func (grace *Grace) Stage(stage *StageStruct) *Grace {
	stage.Graces[grace] = __member
	stage.Graces_mapString[grace.Name] = grace

	return grace
}

// Unstage removes grace off the model stage
func (grace *Grace) Unstage(stage *StageStruct) *Grace {
	delete(stage.Graces, grace)
	delete(stage.Graces_mapString, grace.Name)
	return grace
}

// UnstageVoid removes grace off the model stage
func (grace *Grace) UnstageVoid(stage *StageStruct) {
	delete(stage.Graces, grace)
	delete(stage.Graces_mapString, grace.Name)
}

// commit grace to the back repo (if it is already staged)
func (grace *Grace) Commit(stage *StageStruct) *Grace {
	if _, ok := stage.Graces[grace]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitGrace(grace)
		}
	}
	return grace
}

func (grace *Grace) CommitVoid(stage *StageStruct) {
	grace.Commit(stage)
}

// Checkout grace to the back repo (if it is already staged)
func (grace *Grace) Checkout(stage *StageStruct) *Grace {
	if _, ok := stage.Graces[grace]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutGrace(grace)
		}
	}
	return grace
}

// for satisfaction of GongStruct interface
func (grace *Grace) GetName() (res string) {
	return grace.Name
}

// Stage puts group_barline to the model stage
func (group_barline *Group_barline) Stage(stage *StageStruct) *Group_barline {
	stage.Group_barlines[group_barline] = __member
	stage.Group_barlines_mapString[group_barline.Name] = group_barline

	return group_barline
}

// Unstage removes group_barline off the model stage
func (group_barline *Group_barline) Unstage(stage *StageStruct) *Group_barline {
	delete(stage.Group_barlines, group_barline)
	delete(stage.Group_barlines_mapString, group_barline.Name)
	return group_barline
}

// UnstageVoid removes group_barline off the model stage
func (group_barline *Group_barline) UnstageVoid(stage *StageStruct) {
	delete(stage.Group_barlines, group_barline)
	delete(stage.Group_barlines_mapString, group_barline.Name)
}

// commit group_barline to the back repo (if it is already staged)
func (group_barline *Group_barline) Commit(stage *StageStruct) *Group_barline {
	if _, ok := stage.Group_barlines[group_barline]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitGroup_barline(group_barline)
		}
	}
	return group_barline
}

func (group_barline *Group_barline) CommitVoid(stage *StageStruct) {
	group_barline.Commit(stage)
}

// Checkout group_barline to the back repo (if it is already staged)
func (group_barline *Group_barline) Checkout(stage *StageStruct) *Group_barline {
	if _, ok := stage.Group_barlines[group_barline]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutGroup_barline(group_barline)
		}
	}
	return group_barline
}

// for satisfaction of GongStruct interface
func (group_barline *Group_barline) GetName() (res string) {
	return group_barline.Name
}

// Stage puts group_symbol to the model stage
func (group_symbol *Group_symbol) Stage(stage *StageStruct) *Group_symbol {
	stage.Group_symbols[group_symbol] = __member
	stage.Group_symbols_mapString[group_symbol.Name] = group_symbol

	return group_symbol
}

// Unstage removes group_symbol off the model stage
func (group_symbol *Group_symbol) Unstage(stage *StageStruct) *Group_symbol {
	delete(stage.Group_symbols, group_symbol)
	delete(stage.Group_symbols_mapString, group_symbol.Name)
	return group_symbol
}

// UnstageVoid removes group_symbol off the model stage
func (group_symbol *Group_symbol) UnstageVoid(stage *StageStruct) {
	delete(stage.Group_symbols, group_symbol)
	delete(stage.Group_symbols_mapString, group_symbol.Name)
}

// commit group_symbol to the back repo (if it is already staged)
func (group_symbol *Group_symbol) Commit(stage *StageStruct) *Group_symbol {
	if _, ok := stage.Group_symbols[group_symbol]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitGroup_symbol(group_symbol)
		}
	}
	return group_symbol
}

func (group_symbol *Group_symbol) CommitVoid(stage *StageStruct) {
	group_symbol.Commit(stage)
}

// Checkout group_symbol to the back repo (if it is already staged)
func (group_symbol *Group_symbol) Checkout(stage *StageStruct) *Group_symbol {
	if _, ok := stage.Group_symbols[group_symbol]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutGroup_symbol(group_symbol)
		}
	}
	return group_symbol
}

// for satisfaction of GongStruct interface
func (group_symbol *Group_symbol) GetName() (res string) {
	return group_symbol.Name
}

// Stage puts grouping to the model stage
func (grouping *Grouping) Stage(stage *StageStruct) *Grouping {
	stage.Groupings[grouping] = __member
	stage.Groupings_mapString[grouping.Name] = grouping

	return grouping
}

// Unstage removes grouping off the model stage
func (grouping *Grouping) Unstage(stage *StageStruct) *Grouping {
	delete(stage.Groupings, grouping)
	delete(stage.Groupings_mapString, grouping.Name)
	return grouping
}

// UnstageVoid removes grouping off the model stage
func (grouping *Grouping) UnstageVoid(stage *StageStruct) {
	delete(stage.Groupings, grouping)
	delete(stage.Groupings_mapString, grouping.Name)
}

// commit grouping to the back repo (if it is already staged)
func (grouping *Grouping) Commit(stage *StageStruct) *Grouping {
	if _, ok := stage.Groupings[grouping]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitGrouping(grouping)
		}
	}
	return grouping
}

func (grouping *Grouping) CommitVoid(stage *StageStruct) {
	grouping.Commit(stage)
}

// Checkout grouping to the back repo (if it is already staged)
func (grouping *Grouping) Checkout(stage *StageStruct) *Grouping {
	if _, ok := stage.Groupings[grouping]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutGrouping(grouping)
		}
	}
	return grouping
}

// for satisfaction of GongStruct interface
func (grouping *Grouping) GetName() (res string) {
	return grouping.Name
}

// Stage puts hammer_on_pull_off to the model stage
func (hammer_on_pull_off *Hammer_on_pull_off) Stage(stage *StageStruct) *Hammer_on_pull_off {
	stage.Hammer_on_pull_offs[hammer_on_pull_off] = __member
	stage.Hammer_on_pull_offs_mapString[hammer_on_pull_off.Name] = hammer_on_pull_off

	return hammer_on_pull_off
}

// Unstage removes hammer_on_pull_off off the model stage
func (hammer_on_pull_off *Hammer_on_pull_off) Unstage(stage *StageStruct) *Hammer_on_pull_off {
	delete(stage.Hammer_on_pull_offs, hammer_on_pull_off)
	delete(stage.Hammer_on_pull_offs_mapString, hammer_on_pull_off.Name)
	return hammer_on_pull_off
}

// UnstageVoid removes hammer_on_pull_off off the model stage
func (hammer_on_pull_off *Hammer_on_pull_off) UnstageVoid(stage *StageStruct) {
	delete(stage.Hammer_on_pull_offs, hammer_on_pull_off)
	delete(stage.Hammer_on_pull_offs_mapString, hammer_on_pull_off.Name)
}

// commit hammer_on_pull_off to the back repo (if it is already staged)
func (hammer_on_pull_off *Hammer_on_pull_off) Commit(stage *StageStruct) *Hammer_on_pull_off {
	if _, ok := stage.Hammer_on_pull_offs[hammer_on_pull_off]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHammer_on_pull_off(hammer_on_pull_off)
		}
	}
	return hammer_on_pull_off
}

func (hammer_on_pull_off *Hammer_on_pull_off) CommitVoid(stage *StageStruct) {
	hammer_on_pull_off.Commit(stage)
}

// Checkout hammer_on_pull_off to the back repo (if it is already staged)
func (hammer_on_pull_off *Hammer_on_pull_off) Checkout(stage *StageStruct) *Hammer_on_pull_off {
	if _, ok := stage.Hammer_on_pull_offs[hammer_on_pull_off]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHammer_on_pull_off(hammer_on_pull_off)
		}
	}
	return hammer_on_pull_off
}

// for satisfaction of GongStruct interface
func (hammer_on_pull_off *Hammer_on_pull_off) GetName() (res string) {
	return hammer_on_pull_off.Name
}

// Stage puts handbell to the model stage
func (handbell *Handbell) Stage(stage *StageStruct) *Handbell {
	stage.Handbells[handbell] = __member
	stage.Handbells_mapString[handbell.Name] = handbell

	return handbell
}

// Unstage removes handbell off the model stage
func (handbell *Handbell) Unstage(stage *StageStruct) *Handbell {
	delete(stage.Handbells, handbell)
	delete(stage.Handbells_mapString, handbell.Name)
	return handbell
}

// UnstageVoid removes handbell off the model stage
func (handbell *Handbell) UnstageVoid(stage *StageStruct) {
	delete(stage.Handbells, handbell)
	delete(stage.Handbells_mapString, handbell.Name)
}

// commit handbell to the back repo (if it is already staged)
func (handbell *Handbell) Commit(stage *StageStruct) *Handbell {
	if _, ok := stage.Handbells[handbell]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHandbell(handbell)
		}
	}
	return handbell
}

func (handbell *Handbell) CommitVoid(stage *StageStruct) {
	handbell.Commit(stage)
}

// Checkout handbell to the back repo (if it is already staged)
func (handbell *Handbell) Checkout(stage *StageStruct) *Handbell {
	if _, ok := stage.Handbells[handbell]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHandbell(handbell)
		}
	}
	return handbell
}

// for satisfaction of GongStruct interface
func (handbell *Handbell) GetName() (res string) {
	return handbell.Name
}

// Stage puts harmon_closed to the model stage
func (harmon_closed *Harmon_closed) Stage(stage *StageStruct) *Harmon_closed {
	stage.Harmon_closeds[harmon_closed] = __member
	stage.Harmon_closeds_mapString[harmon_closed.Name] = harmon_closed

	return harmon_closed
}

// Unstage removes harmon_closed off the model stage
func (harmon_closed *Harmon_closed) Unstage(stage *StageStruct) *Harmon_closed {
	delete(stage.Harmon_closeds, harmon_closed)
	delete(stage.Harmon_closeds_mapString, harmon_closed.Name)
	return harmon_closed
}

// UnstageVoid removes harmon_closed off the model stage
func (harmon_closed *Harmon_closed) UnstageVoid(stage *StageStruct) {
	delete(stage.Harmon_closeds, harmon_closed)
	delete(stage.Harmon_closeds_mapString, harmon_closed.Name)
}

// commit harmon_closed to the back repo (if it is already staged)
func (harmon_closed *Harmon_closed) Commit(stage *StageStruct) *Harmon_closed {
	if _, ok := stage.Harmon_closeds[harmon_closed]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHarmon_closed(harmon_closed)
		}
	}
	return harmon_closed
}

func (harmon_closed *Harmon_closed) CommitVoid(stage *StageStruct) {
	harmon_closed.Commit(stage)
}

// Checkout harmon_closed to the back repo (if it is already staged)
func (harmon_closed *Harmon_closed) Checkout(stage *StageStruct) *Harmon_closed {
	if _, ok := stage.Harmon_closeds[harmon_closed]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHarmon_closed(harmon_closed)
		}
	}
	return harmon_closed
}

// for satisfaction of GongStruct interface
func (harmon_closed *Harmon_closed) GetName() (res string) {
	return harmon_closed.Name
}

// Stage puts harmon_mute to the model stage
func (harmon_mute *Harmon_mute) Stage(stage *StageStruct) *Harmon_mute {
	stage.Harmon_mutes[harmon_mute] = __member
	stage.Harmon_mutes_mapString[harmon_mute.Name] = harmon_mute

	return harmon_mute
}

// Unstage removes harmon_mute off the model stage
func (harmon_mute *Harmon_mute) Unstage(stage *StageStruct) *Harmon_mute {
	delete(stage.Harmon_mutes, harmon_mute)
	delete(stage.Harmon_mutes_mapString, harmon_mute.Name)
	return harmon_mute
}

// UnstageVoid removes harmon_mute off the model stage
func (harmon_mute *Harmon_mute) UnstageVoid(stage *StageStruct) {
	delete(stage.Harmon_mutes, harmon_mute)
	delete(stage.Harmon_mutes_mapString, harmon_mute.Name)
}

// commit harmon_mute to the back repo (if it is already staged)
func (harmon_mute *Harmon_mute) Commit(stage *StageStruct) *Harmon_mute {
	if _, ok := stage.Harmon_mutes[harmon_mute]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHarmon_mute(harmon_mute)
		}
	}
	return harmon_mute
}

func (harmon_mute *Harmon_mute) CommitVoid(stage *StageStruct) {
	harmon_mute.Commit(stage)
}

// Checkout harmon_mute to the back repo (if it is already staged)
func (harmon_mute *Harmon_mute) Checkout(stage *StageStruct) *Harmon_mute {
	if _, ok := stage.Harmon_mutes[harmon_mute]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHarmon_mute(harmon_mute)
		}
	}
	return harmon_mute
}

// for satisfaction of GongStruct interface
func (harmon_mute *Harmon_mute) GetName() (res string) {
	return harmon_mute.Name
}

// Stage puts harmonic to the model stage
func (harmonic *Harmonic) Stage(stage *StageStruct) *Harmonic {
	stage.Harmonics[harmonic] = __member
	stage.Harmonics_mapString[harmonic.Name] = harmonic

	return harmonic
}

// Unstage removes harmonic off the model stage
func (harmonic *Harmonic) Unstage(stage *StageStruct) *Harmonic {
	delete(stage.Harmonics, harmonic)
	delete(stage.Harmonics_mapString, harmonic.Name)
	return harmonic
}

// UnstageVoid removes harmonic off the model stage
func (harmonic *Harmonic) UnstageVoid(stage *StageStruct) {
	delete(stage.Harmonics, harmonic)
	delete(stage.Harmonics_mapString, harmonic.Name)
}

// commit harmonic to the back repo (if it is already staged)
func (harmonic *Harmonic) Commit(stage *StageStruct) *Harmonic {
	if _, ok := stage.Harmonics[harmonic]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHarmonic(harmonic)
		}
	}
	return harmonic
}

func (harmonic *Harmonic) CommitVoid(stage *StageStruct) {
	harmonic.Commit(stage)
}

// Checkout harmonic to the back repo (if it is already staged)
func (harmonic *Harmonic) Checkout(stage *StageStruct) *Harmonic {
	if _, ok := stage.Harmonics[harmonic]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHarmonic(harmonic)
		}
	}
	return harmonic
}

// for satisfaction of GongStruct interface
func (harmonic *Harmonic) GetName() (res string) {
	return harmonic.Name
}

// Stage puts harmony to the model stage
func (harmony *Harmony) Stage(stage *StageStruct) *Harmony {
	stage.Harmonys[harmony] = __member
	stage.Harmonys_mapString[harmony.Name] = harmony

	return harmony
}

// Unstage removes harmony off the model stage
func (harmony *Harmony) Unstage(stage *StageStruct) *Harmony {
	delete(stage.Harmonys, harmony)
	delete(stage.Harmonys_mapString, harmony.Name)
	return harmony
}

// UnstageVoid removes harmony off the model stage
func (harmony *Harmony) UnstageVoid(stage *StageStruct) {
	delete(stage.Harmonys, harmony)
	delete(stage.Harmonys_mapString, harmony.Name)
}

// commit harmony to the back repo (if it is already staged)
func (harmony *Harmony) Commit(stage *StageStruct) *Harmony {
	if _, ok := stage.Harmonys[harmony]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHarmony(harmony)
		}
	}
	return harmony
}

func (harmony *Harmony) CommitVoid(stage *StageStruct) {
	harmony.Commit(stage)
}

// Checkout harmony to the back repo (if it is already staged)
func (harmony *Harmony) Checkout(stage *StageStruct) *Harmony {
	if _, ok := stage.Harmonys[harmony]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHarmony(harmony)
		}
	}
	return harmony
}

// for satisfaction of GongStruct interface
func (harmony *Harmony) GetName() (res string) {
	return harmony.Name
}

// Stage puts harmony_alter to the model stage
func (harmony_alter *Harmony_alter) Stage(stage *StageStruct) *Harmony_alter {
	stage.Harmony_alters[harmony_alter] = __member
	stage.Harmony_alters_mapString[harmony_alter.Name] = harmony_alter

	return harmony_alter
}

// Unstage removes harmony_alter off the model stage
func (harmony_alter *Harmony_alter) Unstage(stage *StageStruct) *Harmony_alter {
	delete(stage.Harmony_alters, harmony_alter)
	delete(stage.Harmony_alters_mapString, harmony_alter.Name)
	return harmony_alter
}

// UnstageVoid removes harmony_alter off the model stage
func (harmony_alter *Harmony_alter) UnstageVoid(stage *StageStruct) {
	delete(stage.Harmony_alters, harmony_alter)
	delete(stage.Harmony_alters_mapString, harmony_alter.Name)
}

// commit harmony_alter to the back repo (if it is already staged)
func (harmony_alter *Harmony_alter) Commit(stage *StageStruct) *Harmony_alter {
	if _, ok := stage.Harmony_alters[harmony_alter]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHarmony_alter(harmony_alter)
		}
	}
	return harmony_alter
}

func (harmony_alter *Harmony_alter) CommitVoid(stage *StageStruct) {
	harmony_alter.Commit(stage)
}

// Checkout harmony_alter to the back repo (if it is already staged)
func (harmony_alter *Harmony_alter) Checkout(stage *StageStruct) *Harmony_alter {
	if _, ok := stage.Harmony_alters[harmony_alter]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHarmony_alter(harmony_alter)
		}
	}
	return harmony_alter
}

// for satisfaction of GongStruct interface
func (harmony_alter *Harmony_alter) GetName() (res string) {
	return harmony_alter.Name
}

// Stage puts harp_pedals to the model stage
func (harp_pedals *Harp_pedals) Stage(stage *StageStruct) *Harp_pedals {
	stage.Harp_pedalss[harp_pedals] = __member
	stage.Harp_pedalss_mapString[harp_pedals.Name] = harp_pedals

	return harp_pedals
}

// Unstage removes harp_pedals off the model stage
func (harp_pedals *Harp_pedals) Unstage(stage *StageStruct) *Harp_pedals {
	delete(stage.Harp_pedalss, harp_pedals)
	delete(stage.Harp_pedalss_mapString, harp_pedals.Name)
	return harp_pedals
}

// UnstageVoid removes harp_pedals off the model stage
func (harp_pedals *Harp_pedals) UnstageVoid(stage *StageStruct) {
	delete(stage.Harp_pedalss, harp_pedals)
	delete(stage.Harp_pedalss_mapString, harp_pedals.Name)
}

// commit harp_pedals to the back repo (if it is already staged)
func (harp_pedals *Harp_pedals) Commit(stage *StageStruct) *Harp_pedals {
	if _, ok := stage.Harp_pedalss[harp_pedals]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHarp_pedals(harp_pedals)
		}
	}
	return harp_pedals
}

func (harp_pedals *Harp_pedals) CommitVoid(stage *StageStruct) {
	harp_pedals.Commit(stage)
}

// Checkout harp_pedals to the back repo (if it is already staged)
func (harp_pedals *Harp_pedals) Checkout(stage *StageStruct) *Harp_pedals {
	if _, ok := stage.Harp_pedalss[harp_pedals]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHarp_pedals(harp_pedals)
		}
	}
	return harp_pedals
}

// for satisfaction of GongStruct interface
func (harp_pedals *Harp_pedals) GetName() (res string) {
	return harp_pedals.Name
}

// Stage puts heel_toe to the model stage
func (heel_toe *Heel_toe) Stage(stage *StageStruct) *Heel_toe {
	stage.Heel_toes[heel_toe] = __member
	stage.Heel_toes_mapString[heel_toe.Name] = heel_toe

	return heel_toe
}

// Unstage removes heel_toe off the model stage
func (heel_toe *Heel_toe) Unstage(stage *StageStruct) *Heel_toe {
	delete(stage.Heel_toes, heel_toe)
	delete(stage.Heel_toes_mapString, heel_toe.Name)
	return heel_toe
}

// UnstageVoid removes heel_toe off the model stage
func (heel_toe *Heel_toe) UnstageVoid(stage *StageStruct) {
	delete(stage.Heel_toes, heel_toe)
	delete(stage.Heel_toes_mapString, heel_toe.Name)
}

// commit heel_toe to the back repo (if it is already staged)
func (heel_toe *Heel_toe) Commit(stage *StageStruct) *Heel_toe {
	if _, ok := stage.Heel_toes[heel_toe]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHeel_toe(heel_toe)
		}
	}
	return heel_toe
}

func (heel_toe *Heel_toe) CommitVoid(stage *StageStruct) {
	heel_toe.Commit(stage)
}

// Checkout heel_toe to the back repo (if it is already staged)
func (heel_toe *Heel_toe) Checkout(stage *StageStruct) *Heel_toe {
	if _, ok := stage.Heel_toes[heel_toe]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHeel_toe(heel_toe)
		}
	}
	return heel_toe
}

// for satisfaction of GongStruct interface
func (heel_toe *Heel_toe) GetName() (res string) {
	return heel_toe.Name
}

// Stage puts hole to the model stage
func (hole *Hole) Stage(stage *StageStruct) *Hole {
	stage.Holes[hole] = __member
	stage.Holes_mapString[hole.Name] = hole

	return hole
}

// Unstage removes hole off the model stage
func (hole *Hole) Unstage(stage *StageStruct) *Hole {
	delete(stage.Holes, hole)
	delete(stage.Holes_mapString, hole.Name)
	return hole
}

// UnstageVoid removes hole off the model stage
func (hole *Hole) UnstageVoid(stage *StageStruct) {
	delete(stage.Holes, hole)
	delete(stage.Holes_mapString, hole.Name)
}

// commit hole to the back repo (if it is already staged)
func (hole *Hole) Commit(stage *StageStruct) *Hole {
	if _, ok := stage.Holes[hole]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHole(hole)
		}
	}
	return hole
}

func (hole *Hole) CommitVoid(stage *StageStruct) {
	hole.Commit(stage)
}

// Checkout hole to the back repo (if it is already staged)
func (hole *Hole) Checkout(stage *StageStruct) *Hole {
	if _, ok := stage.Holes[hole]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHole(hole)
		}
	}
	return hole
}

// for satisfaction of GongStruct interface
func (hole *Hole) GetName() (res string) {
	return hole.Name
}

// Stage puts hole_closed to the model stage
func (hole_closed *Hole_closed) Stage(stage *StageStruct) *Hole_closed {
	stage.Hole_closeds[hole_closed] = __member
	stage.Hole_closeds_mapString[hole_closed.Name] = hole_closed

	return hole_closed
}

// Unstage removes hole_closed off the model stage
func (hole_closed *Hole_closed) Unstage(stage *StageStruct) *Hole_closed {
	delete(stage.Hole_closeds, hole_closed)
	delete(stage.Hole_closeds_mapString, hole_closed.Name)
	return hole_closed
}

// UnstageVoid removes hole_closed off the model stage
func (hole_closed *Hole_closed) UnstageVoid(stage *StageStruct) {
	delete(stage.Hole_closeds, hole_closed)
	delete(stage.Hole_closeds_mapString, hole_closed.Name)
}

// commit hole_closed to the back repo (if it is already staged)
func (hole_closed *Hole_closed) Commit(stage *StageStruct) *Hole_closed {
	if _, ok := stage.Hole_closeds[hole_closed]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHole_closed(hole_closed)
		}
	}
	return hole_closed
}

func (hole_closed *Hole_closed) CommitVoid(stage *StageStruct) {
	hole_closed.Commit(stage)
}

// Checkout hole_closed to the back repo (if it is already staged)
func (hole_closed *Hole_closed) Checkout(stage *StageStruct) *Hole_closed {
	if _, ok := stage.Hole_closeds[hole_closed]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHole_closed(hole_closed)
		}
	}
	return hole_closed
}

// for satisfaction of GongStruct interface
func (hole_closed *Hole_closed) GetName() (res string) {
	return hole_closed.Name
}

// Stage puts horizontal_turn to the model stage
func (horizontal_turn *Horizontal_turn) Stage(stage *StageStruct) *Horizontal_turn {
	stage.Horizontal_turns[horizontal_turn] = __member
	stage.Horizontal_turns_mapString[horizontal_turn.Name] = horizontal_turn

	return horizontal_turn
}

// Unstage removes horizontal_turn off the model stage
func (horizontal_turn *Horizontal_turn) Unstage(stage *StageStruct) *Horizontal_turn {
	delete(stage.Horizontal_turns, horizontal_turn)
	delete(stage.Horizontal_turns_mapString, horizontal_turn.Name)
	return horizontal_turn
}

// UnstageVoid removes horizontal_turn off the model stage
func (horizontal_turn *Horizontal_turn) UnstageVoid(stage *StageStruct) {
	delete(stage.Horizontal_turns, horizontal_turn)
	delete(stage.Horizontal_turns_mapString, horizontal_turn.Name)
}

// commit horizontal_turn to the back repo (if it is already staged)
func (horizontal_turn *Horizontal_turn) Commit(stage *StageStruct) *Horizontal_turn {
	if _, ok := stage.Horizontal_turns[horizontal_turn]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitHorizontal_turn(horizontal_turn)
		}
	}
	return horizontal_turn
}

func (horizontal_turn *Horizontal_turn) CommitVoid(stage *StageStruct) {
	horizontal_turn.Commit(stage)
}

// Checkout horizontal_turn to the back repo (if it is already staged)
func (horizontal_turn *Horizontal_turn) Checkout(stage *StageStruct) *Horizontal_turn {
	if _, ok := stage.Horizontal_turns[horizontal_turn]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutHorizontal_turn(horizontal_turn)
		}
	}
	return horizontal_turn
}

// for satisfaction of GongStruct interface
func (horizontal_turn *Horizontal_turn) GetName() (res string) {
	return horizontal_turn.Name
}

// Stage puts identification to the model stage
func (identification *Identification) Stage(stage *StageStruct) *Identification {
	stage.Identifications[identification] = __member
	stage.Identifications_mapString[identification.Name] = identification

	return identification
}

// Unstage removes identification off the model stage
func (identification *Identification) Unstage(stage *StageStruct) *Identification {
	delete(stage.Identifications, identification)
	delete(stage.Identifications_mapString, identification.Name)
	return identification
}

// UnstageVoid removes identification off the model stage
func (identification *Identification) UnstageVoid(stage *StageStruct) {
	delete(stage.Identifications, identification)
	delete(stage.Identifications_mapString, identification.Name)
}

// commit identification to the back repo (if it is already staged)
func (identification *Identification) Commit(stage *StageStruct) *Identification {
	if _, ok := stage.Identifications[identification]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitIdentification(identification)
		}
	}
	return identification
}

func (identification *Identification) CommitVoid(stage *StageStruct) {
	identification.Commit(stage)
}

// Checkout identification to the back repo (if it is already staged)
func (identification *Identification) Checkout(stage *StageStruct) *Identification {
	if _, ok := stage.Identifications[identification]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutIdentification(identification)
		}
	}
	return identification
}

// for satisfaction of GongStruct interface
func (identification *Identification) GetName() (res string) {
	return identification.Name
}

// Stage puts image to the model stage
func (image *Image) Stage(stage *StageStruct) *Image {
	stage.Images[image] = __member
	stage.Images_mapString[image.Name] = image

	return image
}

// Unstage removes image off the model stage
func (image *Image) Unstage(stage *StageStruct) *Image {
	delete(stage.Images, image)
	delete(stage.Images_mapString, image.Name)
	return image
}

// UnstageVoid removes image off the model stage
func (image *Image) UnstageVoid(stage *StageStruct) {
	delete(stage.Images, image)
	delete(stage.Images_mapString, image.Name)
}

// commit image to the back repo (if it is already staged)
func (image *Image) Commit(stage *StageStruct) *Image {
	if _, ok := stage.Images[image]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitImage(image)
		}
	}
	return image
}

func (image *Image) CommitVoid(stage *StageStruct) {
	image.Commit(stage)
}

// Checkout image to the back repo (if it is already staged)
func (image *Image) Checkout(stage *StageStruct) *Image {
	if _, ok := stage.Images[image]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutImage(image)
		}
	}
	return image
}

// for satisfaction of GongStruct interface
func (image *Image) GetName() (res string) {
	return image.Name
}

// Stage puts instrument to the model stage
func (instrument *Instrument) Stage(stage *StageStruct) *Instrument {
	stage.Instruments[instrument] = __member
	stage.Instruments_mapString[instrument.Name] = instrument

	return instrument
}

// Unstage removes instrument off the model stage
func (instrument *Instrument) Unstage(stage *StageStruct) *Instrument {
	delete(stage.Instruments, instrument)
	delete(stage.Instruments_mapString, instrument.Name)
	return instrument
}

// UnstageVoid removes instrument off the model stage
func (instrument *Instrument) UnstageVoid(stage *StageStruct) {
	delete(stage.Instruments, instrument)
	delete(stage.Instruments_mapString, instrument.Name)
}

// commit instrument to the back repo (if it is already staged)
func (instrument *Instrument) Commit(stage *StageStruct) *Instrument {
	if _, ok := stage.Instruments[instrument]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitInstrument(instrument)
		}
	}
	return instrument
}

func (instrument *Instrument) CommitVoid(stage *StageStruct) {
	instrument.Commit(stage)
}

// Checkout instrument to the back repo (if it is already staged)
func (instrument *Instrument) Checkout(stage *StageStruct) *Instrument {
	if _, ok := stage.Instruments[instrument]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutInstrument(instrument)
		}
	}
	return instrument
}

// for satisfaction of GongStruct interface
func (instrument *Instrument) GetName() (res string) {
	return instrument.Name
}

// Stage puts instrument_change to the model stage
func (instrument_change *Instrument_change) Stage(stage *StageStruct) *Instrument_change {
	stage.Instrument_changes[instrument_change] = __member
	stage.Instrument_changes_mapString[instrument_change.Name] = instrument_change

	return instrument_change
}

// Unstage removes instrument_change off the model stage
func (instrument_change *Instrument_change) Unstage(stage *StageStruct) *Instrument_change {
	delete(stage.Instrument_changes, instrument_change)
	delete(stage.Instrument_changes_mapString, instrument_change.Name)
	return instrument_change
}

// UnstageVoid removes instrument_change off the model stage
func (instrument_change *Instrument_change) UnstageVoid(stage *StageStruct) {
	delete(stage.Instrument_changes, instrument_change)
	delete(stage.Instrument_changes_mapString, instrument_change.Name)
}

// commit instrument_change to the back repo (if it is already staged)
func (instrument_change *Instrument_change) Commit(stage *StageStruct) *Instrument_change {
	if _, ok := stage.Instrument_changes[instrument_change]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitInstrument_change(instrument_change)
		}
	}
	return instrument_change
}

func (instrument_change *Instrument_change) CommitVoid(stage *StageStruct) {
	instrument_change.Commit(stage)
}

// Checkout instrument_change to the back repo (if it is already staged)
func (instrument_change *Instrument_change) Checkout(stage *StageStruct) *Instrument_change {
	if _, ok := stage.Instrument_changes[instrument_change]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutInstrument_change(instrument_change)
		}
	}
	return instrument_change
}

// for satisfaction of GongStruct interface
func (instrument_change *Instrument_change) GetName() (res string) {
	return instrument_change.Name
}

// Stage puts instrument_link to the model stage
func (instrument_link *Instrument_link) Stage(stage *StageStruct) *Instrument_link {
	stage.Instrument_links[instrument_link] = __member
	stage.Instrument_links_mapString[instrument_link.Name] = instrument_link

	return instrument_link
}

// Unstage removes instrument_link off the model stage
func (instrument_link *Instrument_link) Unstage(stage *StageStruct) *Instrument_link {
	delete(stage.Instrument_links, instrument_link)
	delete(stage.Instrument_links_mapString, instrument_link.Name)
	return instrument_link
}

// UnstageVoid removes instrument_link off the model stage
func (instrument_link *Instrument_link) UnstageVoid(stage *StageStruct) {
	delete(stage.Instrument_links, instrument_link)
	delete(stage.Instrument_links_mapString, instrument_link.Name)
}

// commit instrument_link to the back repo (if it is already staged)
func (instrument_link *Instrument_link) Commit(stage *StageStruct) *Instrument_link {
	if _, ok := stage.Instrument_links[instrument_link]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitInstrument_link(instrument_link)
		}
	}
	return instrument_link
}

func (instrument_link *Instrument_link) CommitVoid(stage *StageStruct) {
	instrument_link.Commit(stage)
}

// Checkout instrument_link to the back repo (if it is already staged)
func (instrument_link *Instrument_link) Checkout(stage *StageStruct) *Instrument_link {
	if _, ok := stage.Instrument_links[instrument_link]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutInstrument_link(instrument_link)
		}
	}
	return instrument_link
}

// for satisfaction of GongStruct interface
func (instrument_link *Instrument_link) GetName() (res string) {
	return instrument_link.Name
}

// Stage puts interchangeable to the model stage
func (interchangeable *Interchangeable) Stage(stage *StageStruct) *Interchangeable {
	stage.Interchangeables[interchangeable] = __member
	stage.Interchangeables_mapString[interchangeable.Name] = interchangeable

	return interchangeable
}

// Unstage removes interchangeable off the model stage
func (interchangeable *Interchangeable) Unstage(stage *StageStruct) *Interchangeable {
	delete(stage.Interchangeables, interchangeable)
	delete(stage.Interchangeables_mapString, interchangeable.Name)
	return interchangeable
}

// UnstageVoid removes interchangeable off the model stage
func (interchangeable *Interchangeable) UnstageVoid(stage *StageStruct) {
	delete(stage.Interchangeables, interchangeable)
	delete(stage.Interchangeables_mapString, interchangeable.Name)
}

// commit interchangeable to the back repo (if it is already staged)
func (interchangeable *Interchangeable) Commit(stage *StageStruct) *Interchangeable {
	if _, ok := stage.Interchangeables[interchangeable]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitInterchangeable(interchangeable)
		}
	}
	return interchangeable
}

func (interchangeable *Interchangeable) CommitVoid(stage *StageStruct) {
	interchangeable.Commit(stage)
}

// Checkout interchangeable to the back repo (if it is already staged)
func (interchangeable *Interchangeable) Checkout(stage *StageStruct) *Interchangeable {
	if _, ok := stage.Interchangeables[interchangeable]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutInterchangeable(interchangeable)
		}
	}
	return interchangeable
}

// for satisfaction of GongStruct interface
func (interchangeable *Interchangeable) GetName() (res string) {
	return interchangeable.Name
}

// Stage puts inversion to the model stage
func (inversion *Inversion) Stage(stage *StageStruct) *Inversion {
	stage.Inversions[inversion] = __member
	stage.Inversions_mapString[inversion.Name] = inversion

	return inversion
}

// Unstage removes inversion off the model stage
func (inversion *Inversion) Unstage(stage *StageStruct) *Inversion {
	delete(stage.Inversions, inversion)
	delete(stage.Inversions_mapString, inversion.Name)
	return inversion
}

// UnstageVoid removes inversion off the model stage
func (inversion *Inversion) UnstageVoid(stage *StageStruct) {
	delete(stage.Inversions, inversion)
	delete(stage.Inversions_mapString, inversion.Name)
}

// commit inversion to the back repo (if it is already staged)
func (inversion *Inversion) Commit(stage *StageStruct) *Inversion {
	if _, ok := stage.Inversions[inversion]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitInversion(inversion)
		}
	}
	return inversion
}

func (inversion *Inversion) CommitVoid(stage *StageStruct) {
	inversion.Commit(stage)
}

// Checkout inversion to the back repo (if it is already staged)
func (inversion *Inversion) Checkout(stage *StageStruct) *Inversion {
	if _, ok := stage.Inversions[inversion]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutInversion(inversion)
		}
	}
	return inversion
}

// for satisfaction of GongStruct interface
func (inversion *Inversion) GetName() (res string) {
	return inversion.Name
}

// Stage puts key to the model stage
func (key *Key) Stage(stage *StageStruct) *Key {
	stage.Keys[key] = __member
	stage.Keys_mapString[key.Name] = key

	return key
}

// Unstage removes key off the model stage
func (key *Key) Unstage(stage *StageStruct) *Key {
	delete(stage.Keys, key)
	delete(stage.Keys_mapString, key.Name)
	return key
}

// UnstageVoid removes key off the model stage
func (key *Key) UnstageVoid(stage *StageStruct) {
	delete(stage.Keys, key)
	delete(stage.Keys_mapString, key.Name)
}

// commit key to the back repo (if it is already staged)
func (key *Key) Commit(stage *StageStruct) *Key {
	if _, ok := stage.Keys[key]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitKey(key)
		}
	}
	return key
}

func (key *Key) CommitVoid(stage *StageStruct) {
	key.Commit(stage)
}

// Checkout key to the back repo (if it is already staged)
func (key *Key) Checkout(stage *StageStruct) *Key {
	if _, ok := stage.Keys[key]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutKey(key)
		}
	}
	return key
}

// for satisfaction of GongStruct interface
func (key *Key) GetName() (res string) {
	return key.Name
}

// Stage puts key_accidental to the model stage
func (key_accidental *Key_accidental) Stage(stage *StageStruct) *Key_accidental {
	stage.Key_accidentals[key_accidental] = __member
	stage.Key_accidentals_mapString[key_accidental.Name] = key_accidental

	return key_accidental
}

// Unstage removes key_accidental off the model stage
func (key_accidental *Key_accidental) Unstage(stage *StageStruct) *Key_accidental {
	delete(stage.Key_accidentals, key_accidental)
	delete(stage.Key_accidentals_mapString, key_accidental.Name)
	return key_accidental
}

// UnstageVoid removes key_accidental off the model stage
func (key_accidental *Key_accidental) UnstageVoid(stage *StageStruct) {
	delete(stage.Key_accidentals, key_accidental)
	delete(stage.Key_accidentals_mapString, key_accidental.Name)
}

// commit key_accidental to the back repo (if it is already staged)
func (key_accidental *Key_accidental) Commit(stage *StageStruct) *Key_accidental {
	if _, ok := stage.Key_accidentals[key_accidental]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitKey_accidental(key_accidental)
		}
	}
	return key_accidental
}

func (key_accidental *Key_accidental) CommitVoid(stage *StageStruct) {
	key_accidental.Commit(stage)
}

// Checkout key_accidental to the back repo (if it is already staged)
func (key_accidental *Key_accidental) Checkout(stage *StageStruct) *Key_accidental {
	if _, ok := stage.Key_accidentals[key_accidental]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutKey_accidental(key_accidental)
		}
	}
	return key_accidental
}

// for satisfaction of GongStruct interface
func (key_accidental *Key_accidental) GetName() (res string) {
	return key_accidental.Name
}

// Stage puts key_octave to the model stage
func (key_octave *Key_octave) Stage(stage *StageStruct) *Key_octave {
	stage.Key_octaves[key_octave] = __member
	stage.Key_octaves_mapString[key_octave.Name] = key_octave

	return key_octave
}

// Unstage removes key_octave off the model stage
func (key_octave *Key_octave) Unstage(stage *StageStruct) *Key_octave {
	delete(stage.Key_octaves, key_octave)
	delete(stage.Key_octaves_mapString, key_octave.Name)
	return key_octave
}

// UnstageVoid removes key_octave off the model stage
func (key_octave *Key_octave) UnstageVoid(stage *StageStruct) {
	delete(stage.Key_octaves, key_octave)
	delete(stage.Key_octaves_mapString, key_octave.Name)
}

// commit key_octave to the back repo (if it is already staged)
func (key_octave *Key_octave) Commit(stage *StageStruct) *Key_octave {
	if _, ok := stage.Key_octaves[key_octave]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitKey_octave(key_octave)
		}
	}
	return key_octave
}

func (key_octave *Key_octave) CommitVoid(stage *StageStruct) {
	key_octave.Commit(stage)
}

// Checkout key_octave to the back repo (if it is already staged)
func (key_octave *Key_octave) Checkout(stage *StageStruct) *Key_octave {
	if _, ok := stage.Key_octaves[key_octave]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutKey_octave(key_octave)
		}
	}
	return key_octave
}

// for satisfaction of GongStruct interface
func (key_octave *Key_octave) GetName() (res string) {
	return key_octave.Name
}

// Stage puts kind to the model stage
func (kind *Kind) Stage(stage *StageStruct) *Kind {
	stage.Kinds[kind] = __member
	stage.Kinds_mapString[kind.Name] = kind

	return kind
}

// Unstage removes kind off the model stage
func (kind *Kind) Unstage(stage *StageStruct) *Kind {
	delete(stage.Kinds, kind)
	delete(stage.Kinds_mapString, kind.Name)
	return kind
}

// UnstageVoid removes kind off the model stage
func (kind *Kind) UnstageVoid(stage *StageStruct) {
	delete(stage.Kinds, kind)
	delete(stage.Kinds_mapString, kind.Name)
}

// commit kind to the back repo (if it is already staged)
func (kind *Kind) Commit(stage *StageStruct) *Kind {
	if _, ok := stage.Kinds[kind]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitKind(kind)
		}
	}
	return kind
}

func (kind *Kind) CommitVoid(stage *StageStruct) {
	kind.Commit(stage)
}

// Checkout kind to the back repo (if it is already staged)
func (kind *Kind) Checkout(stage *StageStruct) *Kind {
	if _, ok := stage.Kinds[kind]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutKind(kind)
		}
	}
	return kind
}

// for satisfaction of GongStruct interface
func (kind *Kind) GetName() (res string) {
	return kind.Name
}

// Stage puts level to the model stage
func (level *Level) Stage(stage *StageStruct) *Level {
	stage.Levels[level] = __member
	stage.Levels_mapString[level.Name] = level

	return level
}

// Unstage removes level off the model stage
func (level *Level) Unstage(stage *StageStruct) *Level {
	delete(stage.Levels, level)
	delete(stage.Levels_mapString, level.Name)
	return level
}

// UnstageVoid removes level off the model stage
func (level *Level) UnstageVoid(stage *StageStruct) {
	delete(stage.Levels, level)
	delete(stage.Levels_mapString, level.Name)
}

// commit level to the back repo (if it is already staged)
func (level *Level) Commit(stage *StageStruct) *Level {
	if _, ok := stage.Levels[level]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitLevel(level)
		}
	}
	return level
}

func (level *Level) CommitVoid(stage *StageStruct) {
	level.Commit(stage)
}

// Checkout level to the back repo (if it is already staged)
func (level *Level) Checkout(stage *StageStruct) *Level {
	if _, ok := stage.Levels[level]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutLevel(level)
		}
	}
	return level
}

// for satisfaction of GongStruct interface
func (level *Level) GetName() (res string) {
	return level.Name
}

// Stage puts line_detail to the model stage
func (line_detail *Line_detail) Stage(stage *StageStruct) *Line_detail {
	stage.Line_details[line_detail] = __member
	stage.Line_details_mapString[line_detail.Name] = line_detail

	return line_detail
}

// Unstage removes line_detail off the model stage
func (line_detail *Line_detail) Unstage(stage *StageStruct) *Line_detail {
	delete(stage.Line_details, line_detail)
	delete(stage.Line_details_mapString, line_detail.Name)
	return line_detail
}

// UnstageVoid removes line_detail off the model stage
func (line_detail *Line_detail) UnstageVoid(stage *StageStruct) {
	delete(stage.Line_details, line_detail)
	delete(stage.Line_details_mapString, line_detail.Name)
}

// commit line_detail to the back repo (if it is already staged)
func (line_detail *Line_detail) Commit(stage *StageStruct) *Line_detail {
	if _, ok := stage.Line_details[line_detail]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitLine_detail(line_detail)
		}
	}
	return line_detail
}

func (line_detail *Line_detail) CommitVoid(stage *StageStruct) {
	line_detail.Commit(stage)
}

// Checkout line_detail to the back repo (if it is already staged)
func (line_detail *Line_detail) Checkout(stage *StageStruct) *Line_detail {
	if _, ok := stage.Line_details[line_detail]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutLine_detail(line_detail)
		}
	}
	return line_detail
}

// for satisfaction of GongStruct interface
func (line_detail *Line_detail) GetName() (res string) {
	return line_detail.Name
}

// Stage puts line_width to the model stage
func (line_width *Line_width) Stage(stage *StageStruct) *Line_width {
	stage.Line_widths[line_width] = __member
	stage.Line_widths_mapString[line_width.Name] = line_width

	return line_width
}

// Unstage removes line_width off the model stage
func (line_width *Line_width) Unstage(stage *StageStruct) *Line_width {
	delete(stage.Line_widths, line_width)
	delete(stage.Line_widths_mapString, line_width.Name)
	return line_width
}

// UnstageVoid removes line_width off the model stage
func (line_width *Line_width) UnstageVoid(stage *StageStruct) {
	delete(stage.Line_widths, line_width)
	delete(stage.Line_widths_mapString, line_width.Name)
}

// commit line_width to the back repo (if it is already staged)
func (line_width *Line_width) Commit(stage *StageStruct) *Line_width {
	if _, ok := stage.Line_widths[line_width]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitLine_width(line_width)
		}
	}
	return line_width
}

func (line_width *Line_width) CommitVoid(stage *StageStruct) {
	line_width.Commit(stage)
}

// Checkout line_width to the back repo (if it is already staged)
func (line_width *Line_width) Checkout(stage *StageStruct) *Line_width {
	if _, ok := stage.Line_widths[line_width]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutLine_width(line_width)
		}
	}
	return line_width
}

// for satisfaction of GongStruct interface
func (line_width *Line_width) GetName() (res string) {
	return line_width.Name
}

// Stage puts link to the model stage
func (link *Link) Stage(stage *StageStruct) *Link {
	stage.Links[link] = __member
	stage.Links_mapString[link.Name] = link

	return link
}

// Unstage removes link off the model stage
func (link *Link) Unstage(stage *StageStruct) *Link {
	delete(stage.Links, link)
	delete(stage.Links_mapString, link.Name)
	return link
}

// UnstageVoid removes link off the model stage
func (link *Link) UnstageVoid(stage *StageStruct) {
	delete(stage.Links, link)
	delete(stage.Links_mapString, link.Name)
}

// commit link to the back repo (if it is already staged)
func (link *Link) Commit(stage *StageStruct) *Link {
	if _, ok := stage.Links[link]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitLink(link)
		}
	}
	return link
}

func (link *Link) CommitVoid(stage *StageStruct) {
	link.Commit(stage)
}

// Checkout link to the back repo (if it is already staged)
func (link *Link) Checkout(stage *StageStruct) *Link {
	if _, ok := stage.Links[link]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutLink(link)
		}
	}
	return link
}

// for satisfaction of GongStruct interface
func (link *Link) GetName() (res string) {
	return link.Name
}

// Stage puts listen to the model stage
func (listen *Listen) Stage(stage *StageStruct) *Listen {
	stage.Listens[listen] = __member
	stage.Listens_mapString[listen.Name] = listen

	return listen
}

// Unstage removes listen off the model stage
func (listen *Listen) Unstage(stage *StageStruct) *Listen {
	delete(stage.Listens, listen)
	delete(stage.Listens_mapString, listen.Name)
	return listen
}

// UnstageVoid removes listen off the model stage
func (listen *Listen) UnstageVoid(stage *StageStruct) {
	delete(stage.Listens, listen)
	delete(stage.Listens_mapString, listen.Name)
}

// commit listen to the back repo (if it is already staged)
func (listen *Listen) Commit(stage *StageStruct) *Listen {
	if _, ok := stage.Listens[listen]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitListen(listen)
		}
	}
	return listen
}

func (listen *Listen) CommitVoid(stage *StageStruct) {
	listen.Commit(stage)
}

// Checkout listen to the back repo (if it is already staged)
func (listen *Listen) Checkout(stage *StageStruct) *Listen {
	if _, ok := stage.Listens[listen]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutListen(listen)
		}
	}
	return listen
}

// for satisfaction of GongStruct interface
func (listen *Listen) GetName() (res string) {
	return listen.Name
}

// Stage puts listening to the model stage
func (listening *Listening) Stage(stage *StageStruct) *Listening {
	stage.Listenings[listening] = __member
	stage.Listenings_mapString[listening.Name] = listening

	return listening
}

// Unstage removes listening off the model stage
func (listening *Listening) Unstage(stage *StageStruct) *Listening {
	delete(stage.Listenings, listening)
	delete(stage.Listenings_mapString, listening.Name)
	return listening
}

// UnstageVoid removes listening off the model stage
func (listening *Listening) UnstageVoid(stage *StageStruct) {
	delete(stage.Listenings, listening)
	delete(stage.Listenings_mapString, listening.Name)
}

// commit listening to the back repo (if it is already staged)
func (listening *Listening) Commit(stage *StageStruct) *Listening {
	if _, ok := stage.Listenings[listening]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitListening(listening)
		}
	}
	return listening
}

func (listening *Listening) CommitVoid(stage *StageStruct) {
	listening.Commit(stage)
}

// Checkout listening to the back repo (if it is already staged)
func (listening *Listening) Checkout(stage *StageStruct) *Listening {
	if _, ok := stage.Listenings[listening]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutListening(listening)
		}
	}
	return listening
}

// for satisfaction of GongStruct interface
func (listening *Listening) GetName() (res string) {
	return listening.Name
}

// Stage puts lyric to the model stage
func (lyric *Lyric) Stage(stage *StageStruct) *Lyric {
	stage.Lyrics[lyric] = __member
	stage.Lyrics_mapString[lyric.Name] = lyric

	return lyric
}

// Unstage removes lyric off the model stage
func (lyric *Lyric) Unstage(stage *StageStruct) *Lyric {
	delete(stage.Lyrics, lyric)
	delete(stage.Lyrics_mapString, lyric.Name)
	return lyric
}

// UnstageVoid removes lyric off the model stage
func (lyric *Lyric) UnstageVoid(stage *StageStruct) {
	delete(stage.Lyrics, lyric)
	delete(stage.Lyrics_mapString, lyric.Name)
}

// commit lyric to the back repo (if it is already staged)
func (lyric *Lyric) Commit(stage *StageStruct) *Lyric {
	if _, ok := stage.Lyrics[lyric]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitLyric(lyric)
		}
	}
	return lyric
}

func (lyric *Lyric) CommitVoid(stage *StageStruct) {
	lyric.Commit(stage)
}

// Checkout lyric to the back repo (if it is already staged)
func (lyric *Lyric) Checkout(stage *StageStruct) *Lyric {
	if _, ok := stage.Lyrics[lyric]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutLyric(lyric)
		}
	}
	return lyric
}

// for satisfaction of GongStruct interface
func (lyric *Lyric) GetName() (res string) {
	return lyric.Name
}

// Stage puts lyric_font to the model stage
func (lyric_font *Lyric_font) Stage(stage *StageStruct) *Lyric_font {
	stage.Lyric_fonts[lyric_font] = __member
	stage.Lyric_fonts_mapString[lyric_font.Name] = lyric_font

	return lyric_font
}

// Unstage removes lyric_font off the model stage
func (lyric_font *Lyric_font) Unstage(stage *StageStruct) *Lyric_font {
	delete(stage.Lyric_fonts, lyric_font)
	delete(stage.Lyric_fonts_mapString, lyric_font.Name)
	return lyric_font
}

// UnstageVoid removes lyric_font off the model stage
func (lyric_font *Lyric_font) UnstageVoid(stage *StageStruct) {
	delete(stage.Lyric_fonts, lyric_font)
	delete(stage.Lyric_fonts_mapString, lyric_font.Name)
}

// commit lyric_font to the back repo (if it is already staged)
func (lyric_font *Lyric_font) Commit(stage *StageStruct) *Lyric_font {
	if _, ok := stage.Lyric_fonts[lyric_font]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitLyric_font(lyric_font)
		}
	}
	return lyric_font
}

func (lyric_font *Lyric_font) CommitVoid(stage *StageStruct) {
	lyric_font.Commit(stage)
}

// Checkout lyric_font to the back repo (if it is already staged)
func (lyric_font *Lyric_font) Checkout(stage *StageStruct) *Lyric_font {
	if _, ok := stage.Lyric_fonts[lyric_font]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutLyric_font(lyric_font)
		}
	}
	return lyric_font
}

// for satisfaction of GongStruct interface
func (lyric_font *Lyric_font) GetName() (res string) {
	return lyric_font.Name
}

// Stage puts lyric_language to the model stage
func (lyric_language *Lyric_language) Stage(stage *StageStruct) *Lyric_language {
	stage.Lyric_languages[lyric_language] = __member
	stage.Lyric_languages_mapString[lyric_language.Name] = lyric_language

	return lyric_language
}

// Unstage removes lyric_language off the model stage
func (lyric_language *Lyric_language) Unstage(stage *StageStruct) *Lyric_language {
	delete(stage.Lyric_languages, lyric_language)
	delete(stage.Lyric_languages_mapString, lyric_language.Name)
	return lyric_language
}

// UnstageVoid removes lyric_language off the model stage
func (lyric_language *Lyric_language) UnstageVoid(stage *StageStruct) {
	delete(stage.Lyric_languages, lyric_language)
	delete(stage.Lyric_languages_mapString, lyric_language.Name)
}

// commit lyric_language to the back repo (if it is already staged)
func (lyric_language *Lyric_language) Commit(stage *StageStruct) *Lyric_language {
	if _, ok := stage.Lyric_languages[lyric_language]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitLyric_language(lyric_language)
		}
	}
	return lyric_language
}

func (lyric_language *Lyric_language) CommitVoid(stage *StageStruct) {
	lyric_language.Commit(stage)
}

// Checkout lyric_language to the back repo (if it is already staged)
func (lyric_language *Lyric_language) Checkout(stage *StageStruct) *Lyric_language {
	if _, ok := stage.Lyric_languages[lyric_language]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutLyric_language(lyric_language)
		}
	}
	return lyric_language
}

// for satisfaction of GongStruct interface
func (lyric_language *Lyric_language) GetName() (res string) {
	return lyric_language.Name
}

// Stage puts measure_layout to the model stage
func (measure_layout *Measure_layout) Stage(stage *StageStruct) *Measure_layout {
	stage.Measure_layouts[measure_layout] = __member
	stage.Measure_layouts_mapString[measure_layout.Name] = measure_layout

	return measure_layout
}

// Unstage removes measure_layout off the model stage
func (measure_layout *Measure_layout) Unstage(stage *StageStruct) *Measure_layout {
	delete(stage.Measure_layouts, measure_layout)
	delete(stage.Measure_layouts_mapString, measure_layout.Name)
	return measure_layout
}

// UnstageVoid removes measure_layout off the model stage
func (measure_layout *Measure_layout) UnstageVoid(stage *StageStruct) {
	delete(stage.Measure_layouts, measure_layout)
	delete(stage.Measure_layouts_mapString, measure_layout.Name)
}

// commit measure_layout to the back repo (if it is already staged)
func (measure_layout *Measure_layout) Commit(stage *StageStruct) *Measure_layout {
	if _, ok := stage.Measure_layouts[measure_layout]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMeasure_layout(measure_layout)
		}
	}
	return measure_layout
}

func (measure_layout *Measure_layout) CommitVoid(stage *StageStruct) {
	measure_layout.Commit(stage)
}

// Checkout measure_layout to the back repo (if it is already staged)
func (measure_layout *Measure_layout) Checkout(stage *StageStruct) *Measure_layout {
	if _, ok := stage.Measure_layouts[measure_layout]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMeasure_layout(measure_layout)
		}
	}
	return measure_layout
}

// for satisfaction of GongStruct interface
func (measure_layout *Measure_layout) GetName() (res string) {
	return measure_layout.Name
}

// Stage puts measure_numbering to the model stage
func (measure_numbering *Measure_numbering) Stage(stage *StageStruct) *Measure_numbering {
	stage.Measure_numberings[measure_numbering] = __member
	stage.Measure_numberings_mapString[measure_numbering.Name] = measure_numbering

	return measure_numbering
}

// Unstage removes measure_numbering off the model stage
func (measure_numbering *Measure_numbering) Unstage(stage *StageStruct) *Measure_numbering {
	delete(stage.Measure_numberings, measure_numbering)
	delete(stage.Measure_numberings_mapString, measure_numbering.Name)
	return measure_numbering
}

// UnstageVoid removes measure_numbering off the model stage
func (measure_numbering *Measure_numbering) UnstageVoid(stage *StageStruct) {
	delete(stage.Measure_numberings, measure_numbering)
	delete(stage.Measure_numberings_mapString, measure_numbering.Name)
}

// commit measure_numbering to the back repo (if it is already staged)
func (measure_numbering *Measure_numbering) Commit(stage *StageStruct) *Measure_numbering {
	if _, ok := stage.Measure_numberings[measure_numbering]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMeasure_numbering(measure_numbering)
		}
	}
	return measure_numbering
}

func (measure_numbering *Measure_numbering) CommitVoid(stage *StageStruct) {
	measure_numbering.Commit(stage)
}

// Checkout measure_numbering to the back repo (if it is already staged)
func (measure_numbering *Measure_numbering) Checkout(stage *StageStruct) *Measure_numbering {
	if _, ok := stage.Measure_numberings[measure_numbering]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMeasure_numbering(measure_numbering)
		}
	}
	return measure_numbering
}

// for satisfaction of GongStruct interface
func (measure_numbering *Measure_numbering) GetName() (res string) {
	return measure_numbering.Name
}

// Stage puts measure_repeat to the model stage
func (measure_repeat *Measure_repeat) Stage(stage *StageStruct) *Measure_repeat {
	stage.Measure_repeats[measure_repeat] = __member
	stage.Measure_repeats_mapString[measure_repeat.Name] = measure_repeat

	return measure_repeat
}

// Unstage removes measure_repeat off the model stage
func (measure_repeat *Measure_repeat) Unstage(stage *StageStruct) *Measure_repeat {
	delete(stage.Measure_repeats, measure_repeat)
	delete(stage.Measure_repeats_mapString, measure_repeat.Name)
	return measure_repeat
}

// UnstageVoid removes measure_repeat off the model stage
func (measure_repeat *Measure_repeat) UnstageVoid(stage *StageStruct) {
	delete(stage.Measure_repeats, measure_repeat)
	delete(stage.Measure_repeats_mapString, measure_repeat.Name)
}

// commit measure_repeat to the back repo (if it is already staged)
func (measure_repeat *Measure_repeat) Commit(stage *StageStruct) *Measure_repeat {
	if _, ok := stage.Measure_repeats[measure_repeat]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMeasure_repeat(measure_repeat)
		}
	}
	return measure_repeat
}

func (measure_repeat *Measure_repeat) CommitVoid(stage *StageStruct) {
	measure_repeat.Commit(stage)
}

// Checkout measure_repeat to the back repo (if it is already staged)
func (measure_repeat *Measure_repeat) Checkout(stage *StageStruct) *Measure_repeat {
	if _, ok := stage.Measure_repeats[measure_repeat]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMeasure_repeat(measure_repeat)
		}
	}
	return measure_repeat
}

// for satisfaction of GongStruct interface
func (measure_repeat *Measure_repeat) GetName() (res string) {
	return measure_repeat.Name
}

// Stage puts measure_style to the model stage
func (measure_style *Measure_style) Stage(stage *StageStruct) *Measure_style {
	stage.Measure_styles[measure_style] = __member
	stage.Measure_styles_mapString[measure_style.Name] = measure_style

	return measure_style
}

// Unstage removes measure_style off the model stage
func (measure_style *Measure_style) Unstage(stage *StageStruct) *Measure_style {
	delete(stage.Measure_styles, measure_style)
	delete(stage.Measure_styles_mapString, measure_style.Name)
	return measure_style
}

// UnstageVoid removes measure_style off the model stage
func (measure_style *Measure_style) UnstageVoid(stage *StageStruct) {
	delete(stage.Measure_styles, measure_style)
	delete(stage.Measure_styles_mapString, measure_style.Name)
}

// commit measure_style to the back repo (if it is already staged)
func (measure_style *Measure_style) Commit(stage *StageStruct) *Measure_style {
	if _, ok := stage.Measure_styles[measure_style]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMeasure_style(measure_style)
		}
	}
	return measure_style
}

func (measure_style *Measure_style) CommitVoid(stage *StageStruct) {
	measure_style.Commit(stage)
}

// Checkout measure_style to the back repo (if it is already staged)
func (measure_style *Measure_style) Checkout(stage *StageStruct) *Measure_style {
	if _, ok := stage.Measure_styles[measure_style]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMeasure_style(measure_style)
		}
	}
	return measure_style
}

// for satisfaction of GongStruct interface
func (measure_style *Measure_style) GetName() (res string) {
	return measure_style.Name
}

// Stage puts membrane to the model stage
func (membrane *Membrane) Stage(stage *StageStruct) *Membrane {
	stage.Membranes[membrane] = __member
	stage.Membranes_mapString[membrane.Name] = membrane

	return membrane
}

// Unstage removes membrane off the model stage
func (membrane *Membrane) Unstage(stage *StageStruct) *Membrane {
	delete(stage.Membranes, membrane)
	delete(stage.Membranes_mapString, membrane.Name)
	return membrane
}

// UnstageVoid removes membrane off the model stage
func (membrane *Membrane) UnstageVoid(stage *StageStruct) {
	delete(stage.Membranes, membrane)
	delete(stage.Membranes_mapString, membrane.Name)
}

// commit membrane to the back repo (if it is already staged)
func (membrane *Membrane) Commit(stage *StageStruct) *Membrane {
	if _, ok := stage.Membranes[membrane]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMembrane(membrane)
		}
	}
	return membrane
}

func (membrane *Membrane) CommitVoid(stage *StageStruct) {
	membrane.Commit(stage)
}

// Checkout membrane to the back repo (if it is already staged)
func (membrane *Membrane) Checkout(stage *StageStruct) *Membrane {
	if _, ok := stage.Membranes[membrane]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMembrane(membrane)
		}
	}
	return membrane
}

// for satisfaction of GongStruct interface
func (membrane *Membrane) GetName() (res string) {
	return membrane.Name
}

// Stage puts metal to the model stage
func (metal *Metal) Stage(stage *StageStruct) *Metal {
	stage.Metals[metal] = __member
	stage.Metals_mapString[metal.Name] = metal

	return metal
}

// Unstage removes metal off the model stage
func (metal *Metal) Unstage(stage *StageStruct) *Metal {
	delete(stage.Metals, metal)
	delete(stage.Metals_mapString, metal.Name)
	return metal
}

// UnstageVoid removes metal off the model stage
func (metal *Metal) UnstageVoid(stage *StageStruct) {
	delete(stage.Metals, metal)
	delete(stage.Metals_mapString, metal.Name)
}

// commit metal to the back repo (if it is already staged)
func (metal *Metal) Commit(stage *StageStruct) *Metal {
	if _, ok := stage.Metals[metal]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMetal(metal)
		}
	}
	return metal
}

func (metal *Metal) CommitVoid(stage *StageStruct) {
	metal.Commit(stage)
}

// Checkout metal to the back repo (if it is already staged)
func (metal *Metal) Checkout(stage *StageStruct) *Metal {
	if _, ok := stage.Metals[metal]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMetal(metal)
		}
	}
	return metal
}

// for satisfaction of GongStruct interface
func (metal *Metal) GetName() (res string) {
	return metal.Name
}

// Stage puts metronome to the model stage
func (metronome *Metronome) Stage(stage *StageStruct) *Metronome {
	stage.Metronomes[metronome] = __member
	stage.Metronomes_mapString[metronome.Name] = metronome

	return metronome
}

// Unstage removes metronome off the model stage
func (metronome *Metronome) Unstage(stage *StageStruct) *Metronome {
	delete(stage.Metronomes, metronome)
	delete(stage.Metronomes_mapString, metronome.Name)
	return metronome
}

// UnstageVoid removes metronome off the model stage
func (metronome *Metronome) UnstageVoid(stage *StageStruct) {
	delete(stage.Metronomes, metronome)
	delete(stage.Metronomes_mapString, metronome.Name)
}

// commit metronome to the back repo (if it is already staged)
func (metronome *Metronome) Commit(stage *StageStruct) *Metronome {
	if _, ok := stage.Metronomes[metronome]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMetronome(metronome)
		}
	}
	return metronome
}

func (metronome *Metronome) CommitVoid(stage *StageStruct) {
	metronome.Commit(stage)
}

// Checkout metronome to the back repo (if it is already staged)
func (metronome *Metronome) Checkout(stage *StageStruct) *Metronome {
	if _, ok := stage.Metronomes[metronome]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMetronome(metronome)
		}
	}
	return metronome
}

// for satisfaction of GongStruct interface
func (metronome *Metronome) GetName() (res string) {
	return metronome.Name
}

// Stage puts metronome_beam to the model stage
func (metronome_beam *Metronome_beam) Stage(stage *StageStruct) *Metronome_beam {
	stage.Metronome_beams[metronome_beam] = __member
	stage.Metronome_beams_mapString[metronome_beam.Name] = metronome_beam

	return metronome_beam
}

// Unstage removes metronome_beam off the model stage
func (metronome_beam *Metronome_beam) Unstage(stage *StageStruct) *Metronome_beam {
	delete(stage.Metronome_beams, metronome_beam)
	delete(stage.Metronome_beams_mapString, metronome_beam.Name)
	return metronome_beam
}

// UnstageVoid removes metronome_beam off the model stage
func (metronome_beam *Metronome_beam) UnstageVoid(stage *StageStruct) {
	delete(stage.Metronome_beams, metronome_beam)
	delete(stage.Metronome_beams_mapString, metronome_beam.Name)
}

// commit metronome_beam to the back repo (if it is already staged)
func (metronome_beam *Metronome_beam) Commit(stage *StageStruct) *Metronome_beam {
	if _, ok := stage.Metronome_beams[metronome_beam]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMetronome_beam(metronome_beam)
		}
	}
	return metronome_beam
}

func (metronome_beam *Metronome_beam) CommitVoid(stage *StageStruct) {
	metronome_beam.Commit(stage)
}

// Checkout metronome_beam to the back repo (if it is already staged)
func (metronome_beam *Metronome_beam) Checkout(stage *StageStruct) *Metronome_beam {
	if _, ok := stage.Metronome_beams[metronome_beam]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMetronome_beam(metronome_beam)
		}
	}
	return metronome_beam
}

// for satisfaction of GongStruct interface
func (metronome_beam *Metronome_beam) GetName() (res string) {
	return metronome_beam.Name
}

// Stage puts metronome_note to the model stage
func (metronome_note *Metronome_note) Stage(stage *StageStruct) *Metronome_note {
	stage.Metronome_notes[metronome_note] = __member
	stage.Metronome_notes_mapString[metronome_note.Name] = metronome_note

	return metronome_note
}

// Unstage removes metronome_note off the model stage
func (metronome_note *Metronome_note) Unstage(stage *StageStruct) *Metronome_note {
	delete(stage.Metronome_notes, metronome_note)
	delete(stage.Metronome_notes_mapString, metronome_note.Name)
	return metronome_note
}

// UnstageVoid removes metronome_note off the model stage
func (metronome_note *Metronome_note) UnstageVoid(stage *StageStruct) {
	delete(stage.Metronome_notes, metronome_note)
	delete(stage.Metronome_notes_mapString, metronome_note.Name)
}

// commit metronome_note to the back repo (if it is already staged)
func (metronome_note *Metronome_note) Commit(stage *StageStruct) *Metronome_note {
	if _, ok := stage.Metronome_notes[metronome_note]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMetronome_note(metronome_note)
		}
	}
	return metronome_note
}

func (metronome_note *Metronome_note) CommitVoid(stage *StageStruct) {
	metronome_note.Commit(stage)
}

// Checkout metronome_note to the back repo (if it is already staged)
func (metronome_note *Metronome_note) Checkout(stage *StageStruct) *Metronome_note {
	if _, ok := stage.Metronome_notes[metronome_note]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMetronome_note(metronome_note)
		}
	}
	return metronome_note
}

// for satisfaction of GongStruct interface
func (metronome_note *Metronome_note) GetName() (res string) {
	return metronome_note.Name
}

// Stage puts metronome_tied to the model stage
func (metronome_tied *Metronome_tied) Stage(stage *StageStruct) *Metronome_tied {
	stage.Metronome_tieds[metronome_tied] = __member
	stage.Metronome_tieds_mapString[metronome_tied.Name] = metronome_tied

	return metronome_tied
}

// Unstage removes metronome_tied off the model stage
func (metronome_tied *Metronome_tied) Unstage(stage *StageStruct) *Metronome_tied {
	delete(stage.Metronome_tieds, metronome_tied)
	delete(stage.Metronome_tieds_mapString, metronome_tied.Name)
	return metronome_tied
}

// UnstageVoid removes metronome_tied off the model stage
func (metronome_tied *Metronome_tied) UnstageVoid(stage *StageStruct) {
	delete(stage.Metronome_tieds, metronome_tied)
	delete(stage.Metronome_tieds_mapString, metronome_tied.Name)
}

// commit metronome_tied to the back repo (if it is already staged)
func (metronome_tied *Metronome_tied) Commit(stage *StageStruct) *Metronome_tied {
	if _, ok := stage.Metronome_tieds[metronome_tied]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMetronome_tied(metronome_tied)
		}
	}
	return metronome_tied
}

func (metronome_tied *Metronome_tied) CommitVoid(stage *StageStruct) {
	metronome_tied.Commit(stage)
}

// Checkout metronome_tied to the back repo (if it is already staged)
func (metronome_tied *Metronome_tied) Checkout(stage *StageStruct) *Metronome_tied {
	if _, ok := stage.Metronome_tieds[metronome_tied]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMetronome_tied(metronome_tied)
		}
	}
	return metronome_tied
}

// for satisfaction of GongStruct interface
func (metronome_tied *Metronome_tied) GetName() (res string) {
	return metronome_tied.Name
}

// Stage puts metronome_tuplet to the model stage
func (metronome_tuplet *Metronome_tuplet) Stage(stage *StageStruct) *Metronome_tuplet {
	stage.Metronome_tuplets[metronome_tuplet] = __member
	stage.Metronome_tuplets_mapString[metronome_tuplet.Name] = metronome_tuplet

	return metronome_tuplet
}

// Unstage removes metronome_tuplet off the model stage
func (metronome_tuplet *Metronome_tuplet) Unstage(stage *StageStruct) *Metronome_tuplet {
	delete(stage.Metronome_tuplets, metronome_tuplet)
	delete(stage.Metronome_tuplets_mapString, metronome_tuplet.Name)
	return metronome_tuplet
}

// UnstageVoid removes metronome_tuplet off the model stage
func (metronome_tuplet *Metronome_tuplet) UnstageVoid(stage *StageStruct) {
	delete(stage.Metronome_tuplets, metronome_tuplet)
	delete(stage.Metronome_tuplets_mapString, metronome_tuplet.Name)
}

// commit metronome_tuplet to the back repo (if it is already staged)
func (metronome_tuplet *Metronome_tuplet) Commit(stage *StageStruct) *Metronome_tuplet {
	if _, ok := stage.Metronome_tuplets[metronome_tuplet]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMetronome_tuplet(metronome_tuplet)
		}
	}
	return metronome_tuplet
}

func (metronome_tuplet *Metronome_tuplet) CommitVoid(stage *StageStruct) {
	metronome_tuplet.Commit(stage)
}

// Checkout metronome_tuplet to the back repo (if it is already staged)
func (metronome_tuplet *Metronome_tuplet) Checkout(stage *StageStruct) *Metronome_tuplet {
	if _, ok := stage.Metronome_tuplets[metronome_tuplet]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMetronome_tuplet(metronome_tuplet)
		}
	}
	return metronome_tuplet
}

// for satisfaction of GongStruct interface
func (metronome_tuplet *Metronome_tuplet) GetName() (res string) {
	return metronome_tuplet.Name
}

// Stage puts midi_device to the model stage
func (midi_device *Midi_device) Stage(stage *StageStruct) *Midi_device {
	stage.Midi_devices[midi_device] = __member
	stage.Midi_devices_mapString[midi_device.Name] = midi_device

	return midi_device
}

// Unstage removes midi_device off the model stage
func (midi_device *Midi_device) Unstage(stage *StageStruct) *Midi_device {
	delete(stage.Midi_devices, midi_device)
	delete(stage.Midi_devices_mapString, midi_device.Name)
	return midi_device
}

// UnstageVoid removes midi_device off the model stage
func (midi_device *Midi_device) UnstageVoid(stage *StageStruct) {
	delete(stage.Midi_devices, midi_device)
	delete(stage.Midi_devices_mapString, midi_device.Name)
}

// commit midi_device to the back repo (if it is already staged)
func (midi_device *Midi_device) Commit(stage *StageStruct) *Midi_device {
	if _, ok := stage.Midi_devices[midi_device]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMidi_device(midi_device)
		}
	}
	return midi_device
}

func (midi_device *Midi_device) CommitVoid(stage *StageStruct) {
	midi_device.Commit(stage)
}

// Checkout midi_device to the back repo (if it is already staged)
func (midi_device *Midi_device) Checkout(stage *StageStruct) *Midi_device {
	if _, ok := stage.Midi_devices[midi_device]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMidi_device(midi_device)
		}
	}
	return midi_device
}

// for satisfaction of GongStruct interface
func (midi_device *Midi_device) GetName() (res string) {
	return midi_device.Name
}

// Stage puts midi_instrument to the model stage
func (midi_instrument *Midi_instrument) Stage(stage *StageStruct) *Midi_instrument {
	stage.Midi_instruments[midi_instrument] = __member
	stage.Midi_instruments_mapString[midi_instrument.Name] = midi_instrument

	return midi_instrument
}

// Unstage removes midi_instrument off the model stage
func (midi_instrument *Midi_instrument) Unstage(stage *StageStruct) *Midi_instrument {
	delete(stage.Midi_instruments, midi_instrument)
	delete(stage.Midi_instruments_mapString, midi_instrument.Name)
	return midi_instrument
}

// UnstageVoid removes midi_instrument off the model stage
func (midi_instrument *Midi_instrument) UnstageVoid(stage *StageStruct) {
	delete(stage.Midi_instruments, midi_instrument)
	delete(stage.Midi_instruments_mapString, midi_instrument.Name)
}

// commit midi_instrument to the back repo (if it is already staged)
func (midi_instrument *Midi_instrument) Commit(stage *StageStruct) *Midi_instrument {
	if _, ok := stage.Midi_instruments[midi_instrument]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMidi_instrument(midi_instrument)
		}
	}
	return midi_instrument
}

func (midi_instrument *Midi_instrument) CommitVoid(stage *StageStruct) {
	midi_instrument.Commit(stage)
}

// Checkout midi_instrument to the back repo (if it is already staged)
func (midi_instrument *Midi_instrument) Checkout(stage *StageStruct) *Midi_instrument {
	if _, ok := stage.Midi_instruments[midi_instrument]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMidi_instrument(midi_instrument)
		}
	}
	return midi_instrument
}

// for satisfaction of GongStruct interface
func (midi_instrument *Midi_instrument) GetName() (res string) {
	return midi_instrument.Name
}

// Stage puts miscellaneous to the model stage
func (miscellaneous *Miscellaneous) Stage(stage *StageStruct) *Miscellaneous {
	stage.Miscellaneouss[miscellaneous] = __member
	stage.Miscellaneouss_mapString[miscellaneous.Name] = miscellaneous

	return miscellaneous
}

// Unstage removes miscellaneous off the model stage
func (miscellaneous *Miscellaneous) Unstage(stage *StageStruct) *Miscellaneous {
	delete(stage.Miscellaneouss, miscellaneous)
	delete(stage.Miscellaneouss_mapString, miscellaneous.Name)
	return miscellaneous
}

// UnstageVoid removes miscellaneous off the model stage
func (miscellaneous *Miscellaneous) UnstageVoid(stage *StageStruct) {
	delete(stage.Miscellaneouss, miscellaneous)
	delete(stage.Miscellaneouss_mapString, miscellaneous.Name)
}

// commit miscellaneous to the back repo (if it is already staged)
func (miscellaneous *Miscellaneous) Commit(stage *StageStruct) *Miscellaneous {
	if _, ok := stage.Miscellaneouss[miscellaneous]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMiscellaneous(miscellaneous)
		}
	}
	return miscellaneous
}

func (miscellaneous *Miscellaneous) CommitVoid(stage *StageStruct) {
	miscellaneous.Commit(stage)
}

// Checkout miscellaneous to the back repo (if it is already staged)
func (miscellaneous *Miscellaneous) Checkout(stage *StageStruct) *Miscellaneous {
	if _, ok := stage.Miscellaneouss[miscellaneous]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMiscellaneous(miscellaneous)
		}
	}
	return miscellaneous
}

// for satisfaction of GongStruct interface
func (miscellaneous *Miscellaneous) GetName() (res string) {
	return miscellaneous.Name
}

// Stage puts miscellaneous_field to the model stage
func (miscellaneous_field *Miscellaneous_field) Stage(stage *StageStruct) *Miscellaneous_field {
	stage.Miscellaneous_fields[miscellaneous_field] = __member
	stage.Miscellaneous_fields_mapString[miscellaneous_field.Name] = miscellaneous_field

	return miscellaneous_field
}

// Unstage removes miscellaneous_field off the model stage
func (miscellaneous_field *Miscellaneous_field) Unstage(stage *StageStruct) *Miscellaneous_field {
	delete(stage.Miscellaneous_fields, miscellaneous_field)
	delete(stage.Miscellaneous_fields_mapString, miscellaneous_field.Name)
	return miscellaneous_field
}

// UnstageVoid removes miscellaneous_field off the model stage
func (miscellaneous_field *Miscellaneous_field) UnstageVoid(stage *StageStruct) {
	delete(stage.Miscellaneous_fields, miscellaneous_field)
	delete(stage.Miscellaneous_fields_mapString, miscellaneous_field.Name)
}

// commit miscellaneous_field to the back repo (if it is already staged)
func (miscellaneous_field *Miscellaneous_field) Commit(stage *StageStruct) *Miscellaneous_field {
	if _, ok := stage.Miscellaneous_fields[miscellaneous_field]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMiscellaneous_field(miscellaneous_field)
		}
	}
	return miscellaneous_field
}

func (miscellaneous_field *Miscellaneous_field) CommitVoid(stage *StageStruct) {
	miscellaneous_field.Commit(stage)
}

// Checkout miscellaneous_field to the back repo (if it is already staged)
func (miscellaneous_field *Miscellaneous_field) Checkout(stage *StageStruct) *Miscellaneous_field {
	if _, ok := stage.Miscellaneous_fields[miscellaneous_field]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMiscellaneous_field(miscellaneous_field)
		}
	}
	return miscellaneous_field
}

// for satisfaction of GongStruct interface
func (miscellaneous_field *Miscellaneous_field) GetName() (res string) {
	return miscellaneous_field.Name
}

// Stage puts mordent to the model stage
func (mordent *Mordent) Stage(stage *StageStruct) *Mordent {
	stage.Mordents[mordent] = __member
	stage.Mordents_mapString[mordent.Name] = mordent

	return mordent
}

// Unstage removes mordent off the model stage
func (mordent *Mordent) Unstage(stage *StageStruct) *Mordent {
	delete(stage.Mordents, mordent)
	delete(stage.Mordents_mapString, mordent.Name)
	return mordent
}

// UnstageVoid removes mordent off the model stage
func (mordent *Mordent) UnstageVoid(stage *StageStruct) {
	delete(stage.Mordents, mordent)
	delete(stage.Mordents_mapString, mordent.Name)
}

// commit mordent to the back repo (if it is already staged)
func (mordent *Mordent) Commit(stage *StageStruct) *Mordent {
	if _, ok := stage.Mordents[mordent]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMordent(mordent)
		}
	}
	return mordent
}

func (mordent *Mordent) CommitVoid(stage *StageStruct) {
	mordent.Commit(stage)
}

// Checkout mordent to the back repo (if it is already staged)
func (mordent *Mordent) Checkout(stage *StageStruct) *Mordent {
	if _, ok := stage.Mordents[mordent]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMordent(mordent)
		}
	}
	return mordent
}

// for satisfaction of GongStruct interface
func (mordent *Mordent) GetName() (res string) {
	return mordent.Name
}

// Stage puts multiple_rest to the model stage
func (multiple_rest *Multiple_rest) Stage(stage *StageStruct) *Multiple_rest {
	stage.Multiple_rests[multiple_rest] = __member
	stage.Multiple_rests_mapString[multiple_rest.Name] = multiple_rest

	return multiple_rest
}

// Unstage removes multiple_rest off the model stage
func (multiple_rest *Multiple_rest) Unstage(stage *StageStruct) *Multiple_rest {
	delete(stage.Multiple_rests, multiple_rest)
	delete(stage.Multiple_rests_mapString, multiple_rest.Name)
	return multiple_rest
}

// UnstageVoid removes multiple_rest off the model stage
func (multiple_rest *Multiple_rest) UnstageVoid(stage *StageStruct) {
	delete(stage.Multiple_rests, multiple_rest)
	delete(stage.Multiple_rests_mapString, multiple_rest.Name)
}

// commit multiple_rest to the back repo (if it is already staged)
func (multiple_rest *Multiple_rest) Commit(stage *StageStruct) *Multiple_rest {
	if _, ok := stage.Multiple_rests[multiple_rest]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitMultiple_rest(multiple_rest)
		}
	}
	return multiple_rest
}

func (multiple_rest *Multiple_rest) CommitVoid(stage *StageStruct) {
	multiple_rest.Commit(stage)
}

// Checkout multiple_rest to the back repo (if it is already staged)
func (multiple_rest *Multiple_rest) Checkout(stage *StageStruct) *Multiple_rest {
	if _, ok := stage.Multiple_rests[multiple_rest]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutMultiple_rest(multiple_rest)
		}
	}
	return multiple_rest
}

// for satisfaction of GongStruct interface
func (multiple_rest *Multiple_rest) GetName() (res string) {
	return multiple_rest.Name
}

// Stage puts name_display to the model stage
func (name_display *Name_display) Stage(stage *StageStruct) *Name_display {
	stage.Name_displays[name_display] = __member
	stage.Name_displays_mapString[name_display.Name] = name_display

	return name_display
}

// Unstage removes name_display off the model stage
func (name_display *Name_display) Unstage(stage *StageStruct) *Name_display {
	delete(stage.Name_displays, name_display)
	delete(stage.Name_displays_mapString, name_display.Name)
	return name_display
}

// UnstageVoid removes name_display off the model stage
func (name_display *Name_display) UnstageVoid(stage *StageStruct) {
	delete(stage.Name_displays, name_display)
	delete(stage.Name_displays_mapString, name_display.Name)
}

// commit name_display to the back repo (if it is already staged)
func (name_display *Name_display) Commit(stage *StageStruct) *Name_display {
	if _, ok := stage.Name_displays[name_display]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitName_display(name_display)
		}
	}
	return name_display
}

func (name_display *Name_display) CommitVoid(stage *StageStruct) {
	name_display.Commit(stage)
}

// Checkout name_display to the back repo (if it is already staged)
func (name_display *Name_display) Checkout(stage *StageStruct) *Name_display {
	if _, ok := stage.Name_displays[name_display]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutName_display(name_display)
		}
	}
	return name_display
}

// for satisfaction of GongStruct interface
func (name_display *Name_display) GetName() (res string) {
	return name_display.Name
}

// Stage puts non_arpeggiate to the model stage
func (non_arpeggiate *Non_arpeggiate) Stage(stage *StageStruct) *Non_arpeggiate {
	stage.Non_arpeggiates[non_arpeggiate] = __member
	stage.Non_arpeggiates_mapString[non_arpeggiate.Name] = non_arpeggiate

	return non_arpeggiate
}

// Unstage removes non_arpeggiate off the model stage
func (non_arpeggiate *Non_arpeggiate) Unstage(stage *StageStruct) *Non_arpeggiate {
	delete(stage.Non_arpeggiates, non_arpeggiate)
	delete(stage.Non_arpeggiates_mapString, non_arpeggiate.Name)
	return non_arpeggiate
}

// UnstageVoid removes non_arpeggiate off the model stage
func (non_arpeggiate *Non_arpeggiate) UnstageVoid(stage *StageStruct) {
	delete(stage.Non_arpeggiates, non_arpeggiate)
	delete(stage.Non_arpeggiates_mapString, non_arpeggiate.Name)
}

// commit non_arpeggiate to the back repo (if it is already staged)
func (non_arpeggiate *Non_arpeggiate) Commit(stage *StageStruct) *Non_arpeggiate {
	if _, ok := stage.Non_arpeggiates[non_arpeggiate]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitNon_arpeggiate(non_arpeggiate)
		}
	}
	return non_arpeggiate
}

func (non_arpeggiate *Non_arpeggiate) CommitVoid(stage *StageStruct) {
	non_arpeggiate.Commit(stage)
}

// Checkout non_arpeggiate to the back repo (if it is already staged)
func (non_arpeggiate *Non_arpeggiate) Checkout(stage *StageStruct) *Non_arpeggiate {
	if _, ok := stage.Non_arpeggiates[non_arpeggiate]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutNon_arpeggiate(non_arpeggiate)
		}
	}
	return non_arpeggiate
}

// for satisfaction of GongStruct interface
func (non_arpeggiate *Non_arpeggiate) GetName() (res string) {
	return non_arpeggiate.Name
}

// Stage puts notations to the model stage
func (notations *Notations) Stage(stage *StageStruct) *Notations {
	stage.Notationss[notations] = __member
	stage.Notationss_mapString[notations.Name] = notations

	return notations
}

// Unstage removes notations off the model stage
func (notations *Notations) Unstage(stage *StageStruct) *Notations {
	delete(stage.Notationss, notations)
	delete(stage.Notationss_mapString, notations.Name)
	return notations
}

// UnstageVoid removes notations off the model stage
func (notations *Notations) UnstageVoid(stage *StageStruct) {
	delete(stage.Notationss, notations)
	delete(stage.Notationss_mapString, notations.Name)
}

// commit notations to the back repo (if it is already staged)
func (notations *Notations) Commit(stage *StageStruct) *Notations {
	if _, ok := stage.Notationss[notations]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitNotations(notations)
		}
	}
	return notations
}

func (notations *Notations) CommitVoid(stage *StageStruct) {
	notations.Commit(stage)
}

// Checkout notations to the back repo (if it is already staged)
func (notations *Notations) Checkout(stage *StageStruct) *Notations {
	if _, ok := stage.Notationss[notations]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutNotations(notations)
		}
	}
	return notations
}

// for satisfaction of GongStruct interface
func (notations *Notations) GetName() (res string) {
	return notations.Name
}

// Stage puts note to the model stage
func (note *Note) Stage(stage *StageStruct) *Note {
	stage.Notes[note] = __member
	stage.Notes_mapString[note.Name] = note

	return note
}

// Unstage removes note off the model stage
func (note *Note) Unstage(stage *StageStruct) *Note {
	delete(stage.Notes, note)
	delete(stage.Notes_mapString, note.Name)
	return note
}

// UnstageVoid removes note off the model stage
func (note *Note) UnstageVoid(stage *StageStruct) {
	delete(stage.Notes, note)
	delete(stage.Notes_mapString, note.Name)
}

// commit note to the back repo (if it is already staged)
func (note *Note) Commit(stage *StageStruct) *Note {
	if _, ok := stage.Notes[note]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitNote(note)
		}
	}
	return note
}

func (note *Note) CommitVoid(stage *StageStruct) {
	note.Commit(stage)
}

// Checkout note to the back repo (if it is already staged)
func (note *Note) Checkout(stage *StageStruct) *Note {
	if _, ok := stage.Notes[note]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutNote(note)
		}
	}
	return note
}

// for satisfaction of GongStruct interface
func (note *Note) GetName() (res string) {
	return note.Name
}

// Stage puts note_size to the model stage
func (note_size *Note_size) Stage(stage *StageStruct) *Note_size {
	stage.Note_sizes[note_size] = __member
	stage.Note_sizes_mapString[note_size.Name] = note_size

	return note_size
}

// Unstage removes note_size off the model stage
func (note_size *Note_size) Unstage(stage *StageStruct) *Note_size {
	delete(stage.Note_sizes, note_size)
	delete(stage.Note_sizes_mapString, note_size.Name)
	return note_size
}

// UnstageVoid removes note_size off the model stage
func (note_size *Note_size) UnstageVoid(stage *StageStruct) {
	delete(stage.Note_sizes, note_size)
	delete(stage.Note_sizes_mapString, note_size.Name)
}

// commit note_size to the back repo (if it is already staged)
func (note_size *Note_size) Commit(stage *StageStruct) *Note_size {
	if _, ok := stage.Note_sizes[note_size]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitNote_size(note_size)
		}
	}
	return note_size
}

func (note_size *Note_size) CommitVoid(stage *StageStruct) {
	note_size.Commit(stage)
}

// Checkout note_size to the back repo (if it is already staged)
func (note_size *Note_size) Checkout(stage *StageStruct) *Note_size {
	if _, ok := stage.Note_sizes[note_size]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutNote_size(note_size)
		}
	}
	return note_size
}

// for satisfaction of GongStruct interface
func (note_size *Note_size) GetName() (res string) {
	return note_size.Name
}

// Stage puts note_type to the model stage
func (note_type *Note_type) Stage(stage *StageStruct) *Note_type {
	stage.Note_types[note_type] = __member
	stage.Note_types_mapString[note_type.Name] = note_type

	return note_type
}

// Unstage removes note_type off the model stage
func (note_type *Note_type) Unstage(stage *StageStruct) *Note_type {
	delete(stage.Note_types, note_type)
	delete(stage.Note_types_mapString, note_type.Name)
	return note_type
}

// UnstageVoid removes note_type off the model stage
func (note_type *Note_type) UnstageVoid(stage *StageStruct) {
	delete(stage.Note_types, note_type)
	delete(stage.Note_types_mapString, note_type.Name)
}

// commit note_type to the back repo (if it is already staged)
func (note_type *Note_type) Commit(stage *StageStruct) *Note_type {
	if _, ok := stage.Note_types[note_type]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitNote_type(note_type)
		}
	}
	return note_type
}

func (note_type *Note_type) CommitVoid(stage *StageStruct) {
	note_type.Commit(stage)
}

// Checkout note_type to the back repo (if it is already staged)
func (note_type *Note_type) Checkout(stage *StageStruct) *Note_type {
	if _, ok := stage.Note_types[note_type]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutNote_type(note_type)
		}
	}
	return note_type
}

// for satisfaction of GongStruct interface
func (note_type *Note_type) GetName() (res string) {
	return note_type.Name
}

// Stage puts notehead to the model stage
func (notehead *Notehead) Stage(stage *StageStruct) *Notehead {
	stage.Noteheads[notehead] = __member
	stage.Noteheads_mapString[notehead.Name] = notehead

	return notehead
}

// Unstage removes notehead off the model stage
func (notehead *Notehead) Unstage(stage *StageStruct) *Notehead {
	delete(stage.Noteheads, notehead)
	delete(stage.Noteheads_mapString, notehead.Name)
	return notehead
}

// UnstageVoid removes notehead off the model stage
func (notehead *Notehead) UnstageVoid(stage *StageStruct) {
	delete(stage.Noteheads, notehead)
	delete(stage.Noteheads_mapString, notehead.Name)
}

// commit notehead to the back repo (if it is already staged)
func (notehead *Notehead) Commit(stage *StageStruct) *Notehead {
	if _, ok := stage.Noteheads[notehead]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitNotehead(notehead)
		}
	}
	return notehead
}

func (notehead *Notehead) CommitVoid(stage *StageStruct) {
	notehead.Commit(stage)
}

// Checkout notehead to the back repo (if it is already staged)
func (notehead *Notehead) Checkout(stage *StageStruct) *Notehead {
	if _, ok := stage.Noteheads[notehead]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutNotehead(notehead)
		}
	}
	return notehead
}

// for satisfaction of GongStruct interface
func (notehead *Notehead) GetName() (res string) {
	return notehead.Name
}

// Stage puts notehead_text to the model stage
func (notehead_text *Notehead_text) Stage(stage *StageStruct) *Notehead_text {
	stage.Notehead_texts[notehead_text] = __member
	stage.Notehead_texts_mapString[notehead_text.Name] = notehead_text

	return notehead_text
}

// Unstage removes notehead_text off the model stage
func (notehead_text *Notehead_text) Unstage(stage *StageStruct) *Notehead_text {
	delete(stage.Notehead_texts, notehead_text)
	delete(stage.Notehead_texts_mapString, notehead_text.Name)
	return notehead_text
}

// UnstageVoid removes notehead_text off the model stage
func (notehead_text *Notehead_text) UnstageVoid(stage *StageStruct) {
	delete(stage.Notehead_texts, notehead_text)
	delete(stage.Notehead_texts_mapString, notehead_text.Name)
}

// commit notehead_text to the back repo (if it is already staged)
func (notehead_text *Notehead_text) Commit(stage *StageStruct) *Notehead_text {
	if _, ok := stage.Notehead_texts[notehead_text]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitNotehead_text(notehead_text)
		}
	}
	return notehead_text
}

func (notehead_text *Notehead_text) CommitVoid(stage *StageStruct) {
	notehead_text.Commit(stage)
}

// Checkout notehead_text to the back repo (if it is already staged)
func (notehead_text *Notehead_text) Checkout(stage *StageStruct) *Notehead_text {
	if _, ok := stage.Notehead_texts[notehead_text]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutNotehead_text(notehead_text)
		}
	}
	return notehead_text
}

// for satisfaction of GongStruct interface
func (notehead_text *Notehead_text) GetName() (res string) {
	return notehead_text.Name
}

// Stage puts numeral to the model stage
func (numeral *Numeral) Stage(stage *StageStruct) *Numeral {
	stage.Numerals[numeral] = __member
	stage.Numerals_mapString[numeral.Name] = numeral

	return numeral
}

// Unstage removes numeral off the model stage
func (numeral *Numeral) Unstage(stage *StageStruct) *Numeral {
	delete(stage.Numerals, numeral)
	delete(stage.Numerals_mapString, numeral.Name)
	return numeral
}

// UnstageVoid removes numeral off the model stage
func (numeral *Numeral) UnstageVoid(stage *StageStruct) {
	delete(stage.Numerals, numeral)
	delete(stage.Numerals_mapString, numeral.Name)
}

// commit numeral to the back repo (if it is already staged)
func (numeral *Numeral) Commit(stage *StageStruct) *Numeral {
	if _, ok := stage.Numerals[numeral]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitNumeral(numeral)
		}
	}
	return numeral
}

func (numeral *Numeral) CommitVoid(stage *StageStruct) {
	numeral.Commit(stage)
}

// Checkout numeral to the back repo (if it is already staged)
func (numeral *Numeral) Checkout(stage *StageStruct) *Numeral {
	if _, ok := stage.Numerals[numeral]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutNumeral(numeral)
		}
	}
	return numeral
}

// for satisfaction of GongStruct interface
func (numeral *Numeral) GetName() (res string) {
	return numeral.Name
}

// Stage puts numeral_key to the model stage
func (numeral_key *Numeral_key) Stage(stage *StageStruct) *Numeral_key {
	stage.Numeral_keys[numeral_key] = __member
	stage.Numeral_keys_mapString[numeral_key.Name] = numeral_key

	return numeral_key
}

// Unstage removes numeral_key off the model stage
func (numeral_key *Numeral_key) Unstage(stage *StageStruct) *Numeral_key {
	delete(stage.Numeral_keys, numeral_key)
	delete(stage.Numeral_keys_mapString, numeral_key.Name)
	return numeral_key
}

// UnstageVoid removes numeral_key off the model stage
func (numeral_key *Numeral_key) UnstageVoid(stage *StageStruct) {
	delete(stage.Numeral_keys, numeral_key)
	delete(stage.Numeral_keys_mapString, numeral_key.Name)
}

// commit numeral_key to the back repo (if it is already staged)
func (numeral_key *Numeral_key) Commit(stage *StageStruct) *Numeral_key {
	if _, ok := stage.Numeral_keys[numeral_key]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitNumeral_key(numeral_key)
		}
	}
	return numeral_key
}

func (numeral_key *Numeral_key) CommitVoid(stage *StageStruct) {
	numeral_key.Commit(stage)
}

// Checkout numeral_key to the back repo (if it is already staged)
func (numeral_key *Numeral_key) Checkout(stage *StageStruct) *Numeral_key {
	if _, ok := stage.Numeral_keys[numeral_key]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutNumeral_key(numeral_key)
		}
	}
	return numeral_key
}

// for satisfaction of GongStruct interface
func (numeral_key *Numeral_key) GetName() (res string) {
	return numeral_key.Name
}

// Stage puts numeral_root to the model stage
func (numeral_root *Numeral_root) Stage(stage *StageStruct) *Numeral_root {
	stage.Numeral_roots[numeral_root] = __member
	stage.Numeral_roots_mapString[numeral_root.Name] = numeral_root

	return numeral_root
}

// Unstage removes numeral_root off the model stage
func (numeral_root *Numeral_root) Unstage(stage *StageStruct) *Numeral_root {
	delete(stage.Numeral_roots, numeral_root)
	delete(stage.Numeral_roots_mapString, numeral_root.Name)
	return numeral_root
}

// UnstageVoid removes numeral_root off the model stage
func (numeral_root *Numeral_root) UnstageVoid(stage *StageStruct) {
	delete(stage.Numeral_roots, numeral_root)
	delete(stage.Numeral_roots_mapString, numeral_root.Name)
}

// commit numeral_root to the back repo (if it is already staged)
func (numeral_root *Numeral_root) Commit(stage *StageStruct) *Numeral_root {
	if _, ok := stage.Numeral_roots[numeral_root]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitNumeral_root(numeral_root)
		}
	}
	return numeral_root
}

func (numeral_root *Numeral_root) CommitVoid(stage *StageStruct) {
	numeral_root.Commit(stage)
}

// Checkout numeral_root to the back repo (if it is already staged)
func (numeral_root *Numeral_root) Checkout(stage *StageStruct) *Numeral_root {
	if _, ok := stage.Numeral_roots[numeral_root]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutNumeral_root(numeral_root)
		}
	}
	return numeral_root
}

// for satisfaction of GongStruct interface
func (numeral_root *Numeral_root) GetName() (res string) {
	return numeral_root.Name
}

// Stage puts octave_shift to the model stage
func (octave_shift *Octave_shift) Stage(stage *StageStruct) *Octave_shift {
	stage.Octave_shifts[octave_shift] = __member
	stage.Octave_shifts_mapString[octave_shift.Name] = octave_shift

	return octave_shift
}

// Unstage removes octave_shift off the model stage
func (octave_shift *Octave_shift) Unstage(stage *StageStruct) *Octave_shift {
	delete(stage.Octave_shifts, octave_shift)
	delete(stage.Octave_shifts_mapString, octave_shift.Name)
	return octave_shift
}

// UnstageVoid removes octave_shift off the model stage
func (octave_shift *Octave_shift) UnstageVoid(stage *StageStruct) {
	delete(stage.Octave_shifts, octave_shift)
	delete(stage.Octave_shifts_mapString, octave_shift.Name)
}

// commit octave_shift to the back repo (if it is already staged)
func (octave_shift *Octave_shift) Commit(stage *StageStruct) *Octave_shift {
	if _, ok := stage.Octave_shifts[octave_shift]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitOctave_shift(octave_shift)
		}
	}
	return octave_shift
}

func (octave_shift *Octave_shift) CommitVoid(stage *StageStruct) {
	octave_shift.Commit(stage)
}

// Checkout octave_shift to the back repo (if it is already staged)
func (octave_shift *Octave_shift) Checkout(stage *StageStruct) *Octave_shift {
	if _, ok := stage.Octave_shifts[octave_shift]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutOctave_shift(octave_shift)
		}
	}
	return octave_shift
}

// for satisfaction of GongStruct interface
func (octave_shift *Octave_shift) GetName() (res string) {
	return octave_shift.Name
}

// Stage puts offset to the model stage
func (offset *Offset) Stage(stage *StageStruct) *Offset {
	stage.Offsets[offset] = __member
	stage.Offsets_mapString[offset.Name] = offset

	return offset
}

// Unstage removes offset off the model stage
func (offset *Offset) Unstage(stage *StageStruct) *Offset {
	delete(stage.Offsets, offset)
	delete(stage.Offsets_mapString, offset.Name)
	return offset
}

// UnstageVoid removes offset off the model stage
func (offset *Offset) UnstageVoid(stage *StageStruct) {
	delete(stage.Offsets, offset)
	delete(stage.Offsets_mapString, offset.Name)
}

// commit offset to the back repo (if it is already staged)
func (offset *Offset) Commit(stage *StageStruct) *Offset {
	if _, ok := stage.Offsets[offset]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitOffset(offset)
		}
	}
	return offset
}

func (offset *Offset) CommitVoid(stage *StageStruct) {
	offset.Commit(stage)
}

// Checkout offset to the back repo (if it is already staged)
func (offset *Offset) Checkout(stage *StageStruct) *Offset {
	if _, ok := stage.Offsets[offset]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutOffset(offset)
		}
	}
	return offset
}

// for satisfaction of GongStruct interface
func (offset *Offset) GetName() (res string) {
	return offset.Name
}

// Stage puts opus to the model stage
func (opus *Opus) Stage(stage *StageStruct) *Opus {
	stage.Opuss[opus] = __member
	stage.Opuss_mapString[opus.Name] = opus

	return opus
}

// Unstage removes opus off the model stage
func (opus *Opus) Unstage(stage *StageStruct) *Opus {
	delete(stage.Opuss, opus)
	delete(stage.Opuss_mapString, opus.Name)
	return opus
}

// UnstageVoid removes opus off the model stage
func (opus *Opus) UnstageVoid(stage *StageStruct) {
	delete(stage.Opuss, opus)
	delete(stage.Opuss_mapString, opus.Name)
}

// commit opus to the back repo (if it is already staged)
func (opus *Opus) Commit(stage *StageStruct) *Opus {
	if _, ok := stage.Opuss[opus]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitOpus(opus)
		}
	}
	return opus
}

func (opus *Opus) CommitVoid(stage *StageStruct) {
	opus.Commit(stage)
}

// Checkout opus to the back repo (if it is already staged)
func (opus *Opus) Checkout(stage *StageStruct) *Opus {
	if _, ok := stage.Opuss[opus]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutOpus(opus)
		}
	}
	return opus
}

// for satisfaction of GongStruct interface
func (opus *Opus) GetName() (res string) {
	return opus.Name
}

// Stage puts ornaments to the model stage
func (ornaments *Ornaments) Stage(stage *StageStruct) *Ornaments {
	stage.Ornamentss[ornaments] = __member
	stage.Ornamentss_mapString[ornaments.Name] = ornaments

	return ornaments
}

// Unstage removes ornaments off the model stage
func (ornaments *Ornaments) Unstage(stage *StageStruct) *Ornaments {
	delete(stage.Ornamentss, ornaments)
	delete(stage.Ornamentss_mapString, ornaments.Name)
	return ornaments
}

// UnstageVoid removes ornaments off the model stage
func (ornaments *Ornaments) UnstageVoid(stage *StageStruct) {
	delete(stage.Ornamentss, ornaments)
	delete(stage.Ornamentss_mapString, ornaments.Name)
}

// commit ornaments to the back repo (if it is already staged)
func (ornaments *Ornaments) Commit(stage *StageStruct) *Ornaments {
	if _, ok := stage.Ornamentss[ornaments]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitOrnaments(ornaments)
		}
	}
	return ornaments
}

func (ornaments *Ornaments) CommitVoid(stage *StageStruct) {
	ornaments.Commit(stage)
}

// Checkout ornaments to the back repo (if it is already staged)
func (ornaments *Ornaments) Checkout(stage *StageStruct) *Ornaments {
	if _, ok := stage.Ornamentss[ornaments]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutOrnaments(ornaments)
		}
	}
	return ornaments
}

// for satisfaction of GongStruct interface
func (ornaments *Ornaments) GetName() (res string) {
	return ornaments.Name
}

// Stage puts other_appearance to the model stage
func (other_appearance *Other_appearance) Stage(stage *StageStruct) *Other_appearance {
	stage.Other_appearances[other_appearance] = __member
	stage.Other_appearances_mapString[other_appearance.Name] = other_appearance

	return other_appearance
}

// Unstage removes other_appearance off the model stage
func (other_appearance *Other_appearance) Unstage(stage *StageStruct) *Other_appearance {
	delete(stage.Other_appearances, other_appearance)
	delete(stage.Other_appearances_mapString, other_appearance.Name)
	return other_appearance
}

// UnstageVoid removes other_appearance off the model stage
func (other_appearance *Other_appearance) UnstageVoid(stage *StageStruct) {
	delete(stage.Other_appearances, other_appearance)
	delete(stage.Other_appearances_mapString, other_appearance.Name)
}

// commit other_appearance to the back repo (if it is already staged)
func (other_appearance *Other_appearance) Commit(stage *StageStruct) *Other_appearance {
	if _, ok := stage.Other_appearances[other_appearance]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitOther_appearance(other_appearance)
		}
	}
	return other_appearance
}

func (other_appearance *Other_appearance) CommitVoid(stage *StageStruct) {
	other_appearance.Commit(stage)
}

// Checkout other_appearance to the back repo (if it is already staged)
func (other_appearance *Other_appearance) Checkout(stage *StageStruct) *Other_appearance {
	if _, ok := stage.Other_appearances[other_appearance]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutOther_appearance(other_appearance)
		}
	}
	return other_appearance
}

// for satisfaction of GongStruct interface
func (other_appearance *Other_appearance) GetName() (res string) {
	return other_appearance.Name
}

// Stage puts other_listening to the model stage
func (other_listening *Other_listening) Stage(stage *StageStruct) *Other_listening {
	stage.Other_listenings[other_listening] = __member
	stage.Other_listenings_mapString[other_listening.Name] = other_listening

	return other_listening
}

// Unstage removes other_listening off the model stage
func (other_listening *Other_listening) Unstage(stage *StageStruct) *Other_listening {
	delete(stage.Other_listenings, other_listening)
	delete(stage.Other_listenings_mapString, other_listening.Name)
	return other_listening
}

// UnstageVoid removes other_listening off the model stage
func (other_listening *Other_listening) UnstageVoid(stage *StageStruct) {
	delete(stage.Other_listenings, other_listening)
	delete(stage.Other_listenings_mapString, other_listening.Name)
}

// commit other_listening to the back repo (if it is already staged)
func (other_listening *Other_listening) Commit(stage *StageStruct) *Other_listening {
	if _, ok := stage.Other_listenings[other_listening]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitOther_listening(other_listening)
		}
	}
	return other_listening
}

func (other_listening *Other_listening) CommitVoid(stage *StageStruct) {
	other_listening.Commit(stage)
}

// Checkout other_listening to the back repo (if it is already staged)
func (other_listening *Other_listening) Checkout(stage *StageStruct) *Other_listening {
	if _, ok := stage.Other_listenings[other_listening]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutOther_listening(other_listening)
		}
	}
	return other_listening
}

// for satisfaction of GongStruct interface
func (other_listening *Other_listening) GetName() (res string) {
	return other_listening.Name
}

// Stage puts other_notation to the model stage
func (other_notation *Other_notation) Stage(stage *StageStruct) *Other_notation {
	stage.Other_notations[other_notation] = __member
	stage.Other_notations_mapString[other_notation.Name] = other_notation

	return other_notation
}

// Unstage removes other_notation off the model stage
func (other_notation *Other_notation) Unstage(stage *StageStruct) *Other_notation {
	delete(stage.Other_notations, other_notation)
	delete(stage.Other_notations_mapString, other_notation.Name)
	return other_notation
}

// UnstageVoid removes other_notation off the model stage
func (other_notation *Other_notation) UnstageVoid(stage *StageStruct) {
	delete(stage.Other_notations, other_notation)
	delete(stage.Other_notations_mapString, other_notation.Name)
}

// commit other_notation to the back repo (if it is already staged)
func (other_notation *Other_notation) Commit(stage *StageStruct) *Other_notation {
	if _, ok := stage.Other_notations[other_notation]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitOther_notation(other_notation)
		}
	}
	return other_notation
}

func (other_notation *Other_notation) CommitVoid(stage *StageStruct) {
	other_notation.Commit(stage)
}

// Checkout other_notation to the back repo (if it is already staged)
func (other_notation *Other_notation) Checkout(stage *StageStruct) *Other_notation {
	if _, ok := stage.Other_notations[other_notation]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutOther_notation(other_notation)
		}
	}
	return other_notation
}

// for satisfaction of GongStruct interface
func (other_notation *Other_notation) GetName() (res string) {
	return other_notation.Name
}

// Stage puts other_play to the model stage
func (other_play *Other_play) Stage(stage *StageStruct) *Other_play {
	stage.Other_plays[other_play] = __member
	stage.Other_plays_mapString[other_play.Name] = other_play

	return other_play
}

// Unstage removes other_play off the model stage
func (other_play *Other_play) Unstage(stage *StageStruct) *Other_play {
	delete(stage.Other_plays, other_play)
	delete(stage.Other_plays_mapString, other_play.Name)
	return other_play
}

// UnstageVoid removes other_play off the model stage
func (other_play *Other_play) UnstageVoid(stage *StageStruct) {
	delete(stage.Other_plays, other_play)
	delete(stage.Other_plays_mapString, other_play.Name)
}

// commit other_play to the back repo (if it is already staged)
func (other_play *Other_play) Commit(stage *StageStruct) *Other_play {
	if _, ok := stage.Other_plays[other_play]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitOther_play(other_play)
		}
	}
	return other_play
}

func (other_play *Other_play) CommitVoid(stage *StageStruct) {
	other_play.Commit(stage)
}

// Checkout other_play to the back repo (if it is already staged)
func (other_play *Other_play) Checkout(stage *StageStruct) *Other_play {
	if _, ok := stage.Other_plays[other_play]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutOther_play(other_play)
		}
	}
	return other_play
}

// for satisfaction of GongStruct interface
func (other_play *Other_play) GetName() (res string) {
	return other_play.Name
}

// Stage puts page_layout to the model stage
func (page_layout *Page_layout) Stage(stage *StageStruct) *Page_layout {
	stage.Page_layouts[page_layout] = __member
	stage.Page_layouts_mapString[page_layout.Name] = page_layout

	return page_layout
}

// Unstage removes page_layout off the model stage
func (page_layout *Page_layout) Unstage(stage *StageStruct) *Page_layout {
	delete(stage.Page_layouts, page_layout)
	delete(stage.Page_layouts_mapString, page_layout.Name)
	return page_layout
}

// UnstageVoid removes page_layout off the model stage
func (page_layout *Page_layout) UnstageVoid(stage *StageStruct) {
	delete(stage.Page_layouts, page_layout)
	delete(stage.Page_layouts_mapString, page_layout.Name)
}

// commit page_layout to the back repo (if it is already staged)
func (page_layout *Page_layout) Commit(stage *StageStruct) *Page_layout {
	if _, ok := stage.Page_layouts[page_layout]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPage_layout(page_layout)
		}
	}
	return page_layout
}

func (page_layout *Page_layout) CommitVoid(stage *StageStruct) {
	page_layout.Commit(stage)
}

// Checkout page_layout to the back repo (if it is already staged)
func (page_layout *Page_layout) Checkout(stage *StageStruct) *Page_layout {
	if _, ok := stage.Page_layouts[page_layout]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPage_layout(page_layout)
		}
	}
	return page_layout
}

// for satisfaction of GongStruct interface
func (page_layout *Page_layout) GetName() (res string) {
	return page_layout.Name
}

// Stage puts page_margins to the model stage
func (page_margins *Page_margins) Stage(stage *StageStruct) *Page_margins {
	stage.Page_marginss[page_margins] = __member
	stage.Page_marginss_mapString[page_margins.Name] = page_margins

	return page_margins
}

// Unstage removes page_margins off the model stage
func (page_margins *Page_margins) Unstage(stage *StageStruct) *Page_margins {
	delete(stage.Page_marginss, page_margins)
	delete(stage.Page_marginss_mapString, page_margins.Name)
	return page_margins
}

// UnstageVoid removes page_margins off the model stage
func (page_margins *Page_margins) UnstageVoid(stage *StageStruct) {
	delete(stage.Page_marginss, page_margins)
	delete(stage.Page_marginss_mapString, page_margins.Name)
}

// commit page_margins to the back repo (if it is already staged)
func (page_margins *Page_margins) Commit(stage *StageStruct) *Page_margins {
	if _, ok := stage.Page_marginss[page_margins]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPage_margins(page_margins)
		}
	}
	return page_margins
}

func (page_margins *Page_margins) CommitVoid(stage *StageStruct) {
	page_margins.Commit(stage)
}

// Checkout page_margins to the back repo (if it is already staged)
func (page_margins *Page_margins) Checkout(stage *StageStruct) *Page_margins {
	if _, ok := stage.Page_marginss[page_margins]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPage_margins(page_margins)
		}
	}
	return page_margins
}

// for satisfaction of GongStruct interface
func (page_margins *Page_margins) GetName() (res string) {
	return page_margins.Name
}

// Stage puts part_clef to the model stage
func (part_clef *Part_clef) Stage(stage *StageStruct) *Part_clef {
	stage.Part_clefs[part_clef] = __member
	stage.Part_clefs_mapString[part_clef.Name] = part_clef

	return part_clef
}

// Unstage removes part_clef off the model stage
func (part_clef *Part_clef) Unstage(stage *StageStruct) *Part_clef {
	delete(stage.Part_clefs, part_clef)
	delete(stage.Part_clefs_mapString, part_clef.Name)
	return part_clef
}

// UnstageVoid removes part_clef off the model stage
func (part_clef *Part_clef) UnstageVoid(stage *StageStruct) {
	delete(stage.Part_clefs, part_clef)
	delete(stage.Part_clefs_mapString, part_clef.Name)
}

// commit part_clef to the back repo (if it is already staged)
func (part_clef *Part_clef) Commit(stage *StageStruct) *Part_clef {
	if _, ok := stage.Part_clefs[part_clef]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPart_clef(part_clef)
		}
	}
	return part_clef
}

func (part_clef *Part_clef) CommitVoid(stage *StageStruct) {
	part_clef.Commit(stage)
}

// Checkout part_clef to the back repo (if it is already staged)
func (part_clef *Part_clef) Checkout(stage *StageStruct) *Part_clef {
	if _, ok := stage.Part_clefs[part_clef]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPart_clef(part_clef)
		}
	}
	return part_clef
}

// for satisfaction of GongStruct interface
func (part_clef *Part_clef) GetName() (res string) {
	return part_clef.Name
}

// Stage puts part_group to the model stage
func (part_group *Part_group) Stage(stage *StageStruct) *Part_group {
	stage.Part_groups[part_group] = __member
	stage.Part_groups_mapString[part_group.Name] = part_group

	return part_group
}

// Unstage removes part_group off the model stage
func (part_group *Part_group) Unstage(stage *StageStruct) *Part_group {
	delete(stage.Part_groups, part_group)
	delete(stage.Part_groups_mapString, part_group.Name)
	return part_group
}

// UnstageVoid removes part_group off the model stage
func (part_group *Part_group) UnstageVoid(stage *StageStruct) {
	delete(stage.Part_groups, part_group)
	delete(stage.Part_groups_mapString, part_group.Name)
}

// commit part_group to the back repo (if it is already staged)
func (part_group *Part_group) Commit(stage *StageStruct) *Part_group {
	if _, ok := stage.Part_groups[part_group]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPart_group(part_group)
		}
	}
	return part_group
}

func (part_group *Part_group) CommitVoid(stage *StageStruct) {
	part_group.Commit(stage)
}

// Checkout part_group to the back repo (if it is already staged)
func (part_group *Part_group) Checkout(stage *StageStruct) *Part_group {
	if _, ok := stage.Part_groups[part_group]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPart_group(part_group)
		}
	}
	return part_group
}

// for satisfaction of GongStruct interface
func (part_group *Part_group) GetName() (res string) {
	return part_group.Name
}

// Stage puts part_link to the model stage
func (part_link *Part_link) Stage(stage *StageStruct) *Part_link {
	stage.Part_links[part_link] = __member
	stage.Part_links_mapString[part_link.Name] = part_link

	return part_link
}

// Unstage removes part_link off the model stage
func (part_link *Part_link) Unstage(stage *StageStruct) *Part_link {
	delete(stage.Part_links, part_link)
	delete(stage.Part_links_mapString, part_link.Name)
	return part_link
}

// UnstageVoid removes part_link off the model stage
func (part_link *Part_link) UnstageVoid(stage *StageStruct) {
	delete(stage.Part_links, part_link)
	delete(stage.Part_links_mapString, part_link.Name)
}

// commit part_link to the back repo (if it is already staged)
func (part_link *Part_link) Commit(stage *StageStruct) *Part_link {
	if _, ok := stage.Part_links[part_link]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPart_link(part_link)
		}
	}
	return part_link
}

func (part_link *Part_link) CommitVoid(stage *StageStruct) {
	part_link.Commit(stage)
}

// Checkout part_link to the back repo (if it is already staged)
func (part_link *Part_link) Checkout(stage *StageStruct) *Part_link {
	if _, ok := stage.Part_links[part_link]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPart_link(part_link)
		}
	}
	return part_link
}

// for satisfaction of GongStruct interface
func (part_link *Part_link) GetName() (res string) {
	return part_link.Name
}

// Stage puts part_list to the model stage
func (part_list *Part_list) Stage(stage *StageStruct) *Part_list {
	stage.Part_lists[part_list] = __member
	stage.Part_lists_mapString[part_list.Name] = part_list

	return part_list
}

// Unstage removes part_list off the model stage
func (part_list *Part_list) Unstage(stage *StageStruct) *Part_list {
	delete(stage.Part_lists, part_list)
	delete(stage.Part_lists_mapString, part_list.Name)
	return part_list
}

// UnstageVoid removes part_list off the model stage
func (part_list *Part_list) UnstageVoid(stage *StageStruct) {
	delete(stage.Part_lists, part_list)
	delete(stage.Part_lists_mapString, part_list.Name)
}

// commit part_list to the back repo (if it is already staged)
func (part_list *Part_list) Commit(stage *StageStruct) *Part_list {
	if _, ok := stage.Part_lists[part_list]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPart_list(part_list)
		}
	}
	return part_list
}

func (part_list *Part_list) CommitVoid(stage *StageStruct) {
	part_list.Commit(stage)
}

// Checkout part_list to the back repo (if it is already staged)
func (part_list *Part_list) Checkout(stage *StageStruct) *Part_list {
	if _, ok := stage.Part_lists[part_list]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPart_list(part_list)
		}
	}
	return part_list
}

// for satisfaction of GongStruct interface
func (part_list *Part_list) GetName() (res string) {
	return part_list.Name
}

// Stage puts part_symbol to the model stage
func (part_symbol *Part_symbol) Stage(stage *StageStruct) *Part_symbol {
	stage.Part_symbols[part_symbol] = __member
	stage.Part_symbols_mapString[part_symbol.Name] = part_symbol

	return part_symbol
}

// Unstage removes part_symbol off the model stage
func (part_symbol *Part_symbol) Unstage(stage *StageStruct) *Part_symbol {
	delete(stage.Part_symbols, part_symbol)
	delete(stage.Part_symbols_mapString, part_symbol.Name)
	return part_symbol
}

// UnstageVoid removes part_symbol off the model stage
func (part_symbol *Part_symbol) UnstageVoid(stage *StageStruct) {
	delete(stage.Part_symbols, part_symbol)
	delete(stage.Part_symbols_mapString, part_symbol.Name)
}

// commit part_symbol to the back repo (if it is already staged)
func (part_symbol *Part_symbol) Commit(stage *StageStruct) *Part_symbol {
	if _, ok := stage.Part_symbols[part_symbol]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPart_symbol(part_symbol)
		}
	}
	return part_symbol
}

func (part_symbol *Part_symbol) CommitVoid(stage *StageStruct) {
	part_symbol.Commit(stage)
}

// Checkout part_symbol to the back repo (if it is already staged)
func (part_symbol *Part_symbol) Checkout(stage *StageStruct) *Part_symbol {
	if _, ok := stage.Part_symbols[part_symbol]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPart_symbol(part_symbol)
		}
	}
	return part_symbol
}

// for satisfaction of GongStruct interface
func (part_symbol *Part_symbol) GetName() (res string) {
	return part_symbol.Name
}

// Stage puts part_transpose to the model stage
func (part_transpose *Part_transpose) Stage(stage *StageStruct) *Part_transpose {
	stage.Part_transposes[part_transpose] = __member
	stage.Part_transposes_mapString[part_transpose.Name] = part_transpose

	return part_transpose
}

// Unstage removes part_transpose off the model stage
func (part_transpose *Part_transpose) Unstage(stage *StageStruct) *Part_transpose {
	delete(stage.Part_transposes, part_transpose)
	delete(stage.Part_transposes_mapString, part_transpose.Name)
	return part_transpose
}

// UnstageVoid removes part_transpose off the model stage
func (part_transpose *Part_transpose) UnstageVoid(stage *StageStruct) {
	delete(stage.Part_transposes, part_transpose)
	delete(stage.Part_transposes_mapString, part_transpose.Name)
}

// commit part_transpose to the back repo (if it is already staged)
func (part_transpose *Part_transpose) Commit(stage *StageStruct) *Part_transpose {
	if _, ok := stage.Part_transposes[part_transpose]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPart_transpose(part_transpose)
		}
	}
	return part_transpose
}

func (part_transpose *Part_transpose) CommitVoid(stage *StageStruct) {
	part_transpose.Commit(stage)
}

// Checkout part_transpose to the back repo (if it is already staged)
func (part_transpose *Part_transpose) Checkout(stage *StageStruct) *Part_transpose {
	if _, ok := stage.Part_transposes[part_transpose]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPart_transpose(part_transpose)
		}
	}
	return part_transpose
}

// for satisfaction of GongStruct interface
func (part_transpose *Part_transpose) GetName() (res string) {
	return part_transpose.Name
}

// Stage puts pedal to the model stage
func (pedal *Pedal) Stage(stage *StageStruct) *Pedal {
	stage.Pedals[pedal] = __member
	stage.Pedals_mapString[pedal.Name] = pedal

	return pedal
}

// Unstage removes pedal off the model stage
func (pedal *Pedal) Unstage(stage *StageStruct) *Pedal {
	delete(stage.Pedals, pedal)
	delete(stage.Pedals_mapString, pedal.Name)
	return pedal
}

// UnstageVoid removes pedal off the model stage
func (pedal *Pedal) UnstageVoid(stage *StageStruct) {
	delete(stage.Pedals, pedal)
	delete(stage.Pedals_mapString, pedal.Name)
}

// commit pedal to the back repo (if it is already staged)
func (pedal *Pedal) Commit(stage *StageStruct) *Pedal {
	if _, ok := stage.Pedals[pedal]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPedal(pedal)
		}
	}
	return pedal
}

func (pedal *Pedal) CommitVoid(stage *StageStruct) {
	pedal.Commit(stage)
}

// Checkout pedal to the back repo (if it is already staged)
func (pedal *Pedal) Checkout(stage *StageStruct) *Pedal {
	if _, ok := stage.Pedals[pedal]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPedal(pedal)
		}
	}
	return pedal
}

// for satisfaction of GongStruct interface
func (pedal *Pedal) GetName() (res string) {
	return pedal.Name
}

// Stage puts pedal_tuning to the model stage
func (pedal_tuning *Pedal_tuning) Stage(stage *StageStruct) *Pedal_tuning {
	stage.Pedal_tunings[pedal_tuning] = __member
	stage.Pedal_tunings_mapString[pedal_tuning.Name] = pedal_tuning

	return pedal_tuning
}

// Unstage removes pedal_tuning off the model stage
func (pedal_tuning *Pedal_tuning) Unstage(stage *StageStruct) *Pedal_tuning {
	delete(stage.Pedal_tunings, pedal_tuning)
	delete(stage.Pedal_tunings_mapString, pedal_tuning.Name)
	return pedal_tuning
}

// UnstageVoid removes pedal_tuning off the model stage
func (pedal_tuning *Pedal_tuning) UnstageVoid(stage *StageStruct) {
	delete(stage.Pedal_tunings, pedal_tuning)
	delete(stage.Pedal_tunings_mapString, pedal_tuning.Name)
}

// commit pedal_tuning to the back repo (if it is already staged)
func (pedal_tuning *Pedal_tuning) Commit(stage *StageStruct) *Pedal_tuning {
	if _, ok := stage.Pedal_tunings[pedal_tuning]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPedal_tuning(pedal_tuning)
		}
	}
	return pedal_tuning
}

func (pedal_tuning *Pedal_tuning) CommitVoid(stage *StageStruct) {
	pedal_tuning.Commit(stage)
}

// Checkout pedal_tuning to the back repo (if it is already staged)
func (pedal_tuning *Pedal_tuning) Checkout(stage *StageStruct) *Pedal_tuning {
	if _, ok := stage.Pedal_tunings[pedal_tuning]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPedal_tuning(pedal_tuning)
		}
	}
	return pedal_tuning
}

// for satisfaction of GongStruct interface
func (pedal_tuning *Pedal_tuning) GetName() (res string) {
	return pedal_tuning.Name
}

// Stage puts percussion to the model stage
func (percussion *Percussion) Stage(stage *StageStruct) *Percussion {
	stage.Percussions[percussion] = __member
	stage.Percussions_mapString[percussion.Name] = percussion

	return percussion
}

// Unstage removes percussion off the model stage
func (percussion *Percussion) Unstage(stage *StageStruct) *Percussion {
	delete(stage.Percussions, percussion)
	delete(stage.Percussions_mapString, percussion.Name)
	return percussion
}

// UnstageVoid removes percussion off the model stage
func (percussion *Percussion) UnstageVoid(stage *StageStruct) {
	delete(stage.Percussions, percussion)
	delete(stage.Percussions_mapString, percussion.Name)
}

// commit percussion to the back repo (if it is already staged)
func (percussion *Percussion) Commit(stage *StageStruct) *Percussion {
	if _, ok := stage.Percussions[percussion]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPercussion(percussion)
		}
	}
	return percussion
}

func (percussion *Percussion) CommitVoid(stage *StageStruct) {
	percussion.Commit(stage)
}

// Checkout percussion to the back repo (if it is already staged)
func (percussion *Percussion) Checkout(stage *StageStruct) *Percussion {
	if _, ok := stage.Percussions[percussion]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPercussion(percussion)
		}
	}
	return percussion
}

// for satisfaction of GongStruct interface
func (percussion *Percussion) GetName() (res string) {
	return percussion.Name
}

// Stage puts pitch to the model stage
func (pitch *Pitch) Stage(stage *StageStruct) *Pitch {
	stage.Pitchs[pitch] = __member
	stage.Pitchs_mapString[pitch.Name] = pitch

	return pitch
}

// Unstage removes pitch off the model stage
func (pitch *Pitch) Unstage(stage *StageStruct) *Pitch {
	delete(stage.Pitchs, pitch)
	delete(stage.Pitchs_mapString, pitch.Name)
	return pitch
}

// UnstageVoid removes pitch off the model stage
func (pitch *Pitch) UnstageVoid(stage *StageStruct) {
	delete(stage.Pitchs, pitch)
	delete(stage.Pitchs_mapString, pitch.Name)
}

// commit pitch to the back repo (if it is already staged)
func (pitch *Pitch) Commit(stage *StageStruct) *Pitch {
	if _, ok := stage.Pitchs[pitch]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPitch(pitch)
		}
	}
	return pitch
}

func (pitch *Pitch) CommitVoid(stage *StageStruct) {
	pitch.Commit(stage)
}

// Checkout pitch to the back repo (if it is already staged)
func (pitch *Pitch) Checkout(stage *StageStruct) *Pitch {
	if _, ok := stage.Pitchs[pitch]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPitch(pitch)
		}
	}
	return pitch
}

// for satisfaction of GongStruct interface
func (pitch *Pitch) GetName() (res string) {
	return pitch.Name
}

// Stage puts pitched to the model stage
func (pitched *Pitched) Stage(stage *StageStruct) *Pitched {
	stage.Pitcheds[pitched] = __member
	stage.Pitcheds_mapString[pitched.Name] = pitched

	return pitched
}

// Unstage removes pitched off the model stage
func (pitched *Pitched) Unstage(stage *StageStruct) *Pitched {
	delete(stage.Pitcheds, pitched)
	delete(stage.Pitcheds_mapString, pitched.Name)
	return pitched
}

// UnstageVoid removes pitched off the model stage
func (pitched *Pitched) UnstageVoid(stage *StageStruct) {
	delete(stage.Pitcheds, pitched)
	delete(stage.Pitcheds_mapString, pitched.Name)
}

// commit pitched to the back repo (if it is already staged)
func (pitched *Pitched) Commit(stage *StageStruct) *Pitched {
	if _, ok := stage.Pitcheds[pitched]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPitched(pitched)
		}
	}
	return pitched
}

func (pitched *Pitched) CommitVoid(stage *StageStruct) {
	pitched.Commit(stage)
}

// Checkout pitched to the back repo (if it is already staged)
func (pitched *Pitched) Checkout(stage *StageStruct) *Pitched {
	if _, ok := stage.Pitcheds[pitched]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPitched(pitched)
		}
	}
	return pitched
}

// for satisfaction of GongStruct interface
func (pitched *Pitched) GetName() (res string) {
	return pitched.Name
}

// Stage puts play to the model stage
func (play *Play) Stage(stage *StageStruct) *Play {
	stage.Plays[play] = __member
	stage.Plays_mapString[play.Name] = play

	return play
}

// Unstage removes play off the model stage
func (play *Play) Unstage(stage *StageStruct) *Play {
	delete(stage.Plays, play)
	delete(stage.Plays_mapString, play.Name)
	return play
}

// UnstageVoid removes play off the model stage
func (play *Play) UnstageVoid(stage *StageStruct) {
	delete(stage.Plays, play)
	delete(stage.Plays_mapString, play.Name)
}

// commit play to the back repo (if it is already staged)
func (play *Play) Commit(stage *StageStruct) *Play {
	if _, ok := stage.Plays[play]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPlay(play)
		}
	}
	return play
}

func (play *Play) CommitVoid(stage *StageStruct) {
	play.Commit(stage)
}

// Checkout play to the back repo (if it is already staged)
func (play *Play) Checkout(stage *StageStruct) *Play {
	if _, ok := stage.Plays[play]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPlay(play)
		}
	}
	return play
}

// for satisfaction of GongStruct interface
func (play *Play) GetName() (res string) {
	return play.Name
}

// Stage puts player to the model stage
func (player *Player) Stage(stage *StageStruct) *Player {
	stage.Players[player] = __member
	stage.Players_mapString[player.Name] = player

	return player
}

// Unstage removes player off the model stage
func (player *Player) Unstage(stage *StageStruct) *Player {
	delete(stage.Players, player)
	delete(stage.Players_mapString, player.Name)
	return player
}

// UnstageVoid removes player off the model stage
func (player *Player) UnstageVoid(stage *StageStruct) {
	delete(stage.Players, player)
	delete(stage.Players_mapString, player.Name)
}

// commit player to the back repo (if it is already staged)
func (player *Player) Commit(stage *StageStruct) *Player {
	if _, ok := stage.Players[player]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPlayer(player)
		}
	}
	return player
}

func (player *Player) CommitVoid(stage *StageStruct) {
	player.Commit(stage)
}

// Checkout player to the back repo (if it is already staged)
func (player *Player) Checkout(stage *StageStruct) *Player {
	if _, ok := stage.Players[player]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPlayer(player)
		}
	}
	return player
}

// for satisfaction of GongStruct interface
func (player *Player) GetName() (res string) {
	return player.Name
}

// Stage puts principal_voice to the model stage
func (principal_voice *Principal_voice) Stage(stage *StageStruct) *Principal_voice {
	stage.Principal_voices[principal_voice] = __member
	stage.Principal_voices_mapString[principal_voice.Name] = principal_voice

	return principal_voice
}

// Unstage removes principal_voice off the model stage
func (principal_voice *Principal_voice) Unstage(stage *StageStruct) *Principal_voice {
	delete(stage.Principal_voices, principal_voice)
	delete(stage.Principal_voices_mapString, principal_voice.Name)
	return principal_voice
}

// UnstageVoid removes principal_voice off the model stage
func (principal_voice *Principal_voice) UnstageVoid(stage *StageStruct) {
	delete(stage.Principal_voices, principal_voice)
	delete(stage.Principal_voices_mapString, principal_voice.Name)
}

// commit principal_voice to the back repo (if it is already staged)
func (principal_voice *Principal_voice) Commit(stage *StageStruct) *Principal_voice {
	if _, ok := stage.Principal_voices[principal_voice]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPrincipal_voice(principal_voice)
		}
	}
	return principal_voice
}

func (principal_voice *Principal_voice) CommitVoid(stage *StageStruct) {
	principal_voice.Commit(stage)
}

// Checkout principal_voice to the back repo (if it is already staged)
func (principal_voice *Principal_voice) Checkout(stage *StageStruct) *Principal_voice {
	if _, ok := stage.Principal_voices[principal_voice]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPrincipal_voice(principal_voice)
		}
	}
	return principal_voice
}

// for satisfaction of GongStruct interface
func (principal_voice *Principal_voice) GetName() (res string) {
	return principal_voice.Name
}

// Stage puts print to the model stage
func (print *Print) Stage(stage *StageStruct) *Print {
	stage.Prints[print] = __member
	stage.Prints_mapString[print.Name] = print

	return print
}

// Unstage removes print off the model stage
func (print *Print) Unstage(stage *StageStruct) *Print {
	delete(stage.Prints, print)
	delete(stage.Prints_mapString, print.Name)
	return print
}

// UnstageVoid removes print off the model stage
func (print *Print) UnstageVoid(stage *StageStruct) {
	delete(stage.Prints, print)
	delete(stage.Prints_mapString, print.Name)
}

// commit print to the back repo (if it is already staged)
func (print *Print) Commit(stage *StageStruct) *Print {
	if _, ok := stage.Prints[print]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitPrint(print)
		}
	}
	return print
}

func (print *Print) CommitVoid(stage *StageStruct) {
	print.Commit(stage)
}

// Checkout print to the back repo (if it is already staged)
func (print *Print) Checkout(stage *StageStruct) *Print {
	if _, ok := stage.Prints[print]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutPrint(print)
		}
	}
	return print
}

// for satisfaction of GongStruct interface
func (print *Print) GetName() (res string) {
	return print.Name
}

// Stage puts release to the model stage
func (release *Release) Stage(stage *StageStruct) *Release {
	stage.Releases[release] = __member
	stage.Releases_mapString[release.Name] = release

	return release
}

// Unstage removes release off the model stage
func (release *Release) Unstage(stage *StageStruct) *Release {
	delete(stage.Releases, release)
	delete(stage.Releases_mapString, release.Name)
	return release
}

// UnstageVoid removes release off the model stage
func (release *Release) UnstageVoid(stage *StageStruct) {
	delete(stage.Releases, release)
	delete(stage.Releases_mapString, release.Name)
}

// commit release to the back repo (if it is already staged)
func (release *Release) Commit(stage *StageStruct) *Release {
	if _, ok := stage.Releases[release]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitRelease(release)
		}
	}
	return release
}

func (release *Release) CommitVoid(stage *StageStruct) {
	release.Commit(stage)
}

// Checkout release to the back repo (if it is already staged)
func (release *Release) Checkout(stage *StageStruct) *Release {
	if _, ok := stage.Releases[release]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutRelease(release)
		}
	}
	return release
}

// for satisfaction of GongStruct interface
func (release *Release) GetName() (res string) {
	return release.Name
}

// Stage puts repeat to the model stage
func (repeat *Repeat) Stage(stage *StageStruct) *Repeat {
	stage.Repeats[repeat] = __member
	stage.Repeats_mapString[repeat.Name] = repeat

	return repeat
}

// Unstage removes repeat off the model stage
func (repeat *Repeat) Unstage(stage *StageStruct) *Repeat {
	delete(stage.Repeats, repeat)
	delete(stage.Repeats_mapString, repeat.Name)
	return repeat
}

// UnstageVoid removes repeat off the model stage
func (repeat *Repeat) UnstageVoid(stage *StageStruct) {
	delete(stage.Repeats, repeat)
	delete(stage.Repeats_mapString, repeat.Name)
}

// commit repeat to the back repo (if it is already staged)
func (repeat *Repeat) Commit(stage *StageStruct) *Repeat {
	if _, ok := stage.Repeats[repeat]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitRepeat(repeat)
		}
	}
	return repeat
}

func (repeat *Repeat) CommitVoid(stage *StageStruct) {
	repeat.Commit(stage)
}

// Checkout repeat to the back repo (if it is already staged)
func (repeat *Repeat) Checkout(stage *StageStruct) *Repeat {
	if _, ok := stage.Repeats[repeat]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutRepeat(repeat)
		}
	}
	return repeat
}

// for satisfaction of GongStruct interface
func (repeat *Repeat) GetName() (res string) {
	return repeat.Name
}

// Stage puts rest to the model stage
func (rest *Rest) Stage(stage *StageStruct) *Rest {
	stage.Rests[rest] = __member
	stage.Rests_mapString[rest.Name] = rest

	return rest
}

// Unstage removes rest off the model stage
func (rest *Rest) Unstage(stage *StageStruct) *Rest {
	delete(stage.Rests, rest)
	delete(stage.Rests_mapString, rest.Name)
	return rest
}

// UnstageVoid removes rest off the model stage
func (rest *Rest) UnstageVoid(stage *StageStruct) {
	delete(stage.Rests, rest)
	delete(stage.Rests_mapString, rest.Name)
}

// commit rest to the back repo (if it is already staged)
func (rest *Rest) Commit(stage *StageStruct) *Rest {
	if _, ok := stage.Rests[rest]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitRest(rest)
		}
	}
	return rest
}

func (rest *Rest) CommitVoid(stage *StageStruct) {
	rest.Commit(stage)
}

// Checkout rest to the back repo (if it is already staged)
func (rest *Rest) Checkout(stage *StageStruct) *Rest {
	if _, ok := stage.Rests[rest]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutRest(rest)
		}
	}
	return rest
}

// for satisfaction of GongStruct interface
func (rest *Rest) GetName() (res string) {
	return rest.Name
}

// Stage puts root to the model stage
func (root *Root) Stage(stage *StageStruct) *Root {
	stage.Roots[root] = __member
	stage.Roots_mapString[root.Name] = root

	return root
}

// Unstage removes root off the model stage
func (root *Root) Unstage(stage *StageStruct) *Root {
	delete(stage.Roots, root)
	delete(stage.Roots_mapString, root.Name)
	return root
}

// UnstageVoid removes root off the model stage
func (root *Root) UnstageVoid(stage *StageStruct) {
	delete(stage.Roots, root)
	delete(stage.Roots_mapString, root.Name)
}

// commit root to the back repo (if it is already staged)
func (root *Root) Commit(stage *StageStruct) *Root {
	if _, ok := stage.Roots[root]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitRoot(root)
		}
	}
	return root
}

func (root *Root) CommitVoid(stage *StageStruct) {
	root.Commit(stage)
}

// Checkout root to the back repo (if it is already staged)
func (root *Root) Checkout(stage *StageStruct) *Root {
	if _, ok := stage.Roots[root]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutRoot(root)
		}
	}
	return root
}

// for satisfaction of GongStruct interface
func (root *Root) GetName() (res string) {
	return root.Name
}

// Stage puts root_step to the model stage
func (root_step *Root_step) Stage(stage *StageStruct) *Root_step {
	stage.Root_steps[root_step] = __member
	stage.Root_steps_mapString[root_step.Name] = root_step

	return root_step
}

// Unstage removes root_step off the model stage
func (root_step *Root_step) Unstage(stage *StageStruct) *Root_step {
	delete(stage.Root_steps, root_step)
	delete(stage.Root_steps_mapString, root_step.Name)
	return root_step
}

// UnstageVoid removes root_step off the model stage
func (root_step *Root_step) UnstageVoid(stage *StageStruct) {
	delete(stage.Root_steps, root_step)
	delete(stage.Root_steps_mapString, root_step.Name)
}

// commit root_step to the back repo (if it is already staged)
func (root_step *Root_step) Commit(stage *StageStruct) *Root_step {
	if _, ok := stage.Root_steps[root_step]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitRoot_step(root_step)
		}
	}
	return root_step
}

func (root_step *Root_step) CommitVoid(stage *StageStruct) {
	root_step.Commit(stage)
}

// Checkout root_step to the back repo (if it is already staged)
func (root_step *Root_step) Checkout(stage *StageStruct) *Root_step {
	if _, ok := stage.Root_steps[root_step]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutRoot_step(root_step)
		}
	}
	return root_step
}

// for satisfaction of GongStruct interface
func (root_step *Root_step) GetName() (res string) {
	return root_step.Name
}

// Stage puts scaling to the model stage
func (scaling *Scaling) Stage(stage *StageStruct) *Scaling {
	stage.Scalings[scaling] = __member
	stage.Scalings_mapString[scaling.Name] = scaling

	return scaling
}

// Unstage removes scaling off the model stage
func (scaling *Scaling) Unstage(stage *StageStruct) *Scaling {
	delete(stage.Scalings, scaling)
	delete(stage.Scalings_mapString, scaling.Name)
	return scaling
}

// UnstageVoid removes scaling off the model stage
func (scaling *Scaling) UnstageVoid(stage *StageStruct) {
	delete(stage.Scalings, scaling)
	delete(stage.Scalings_mapString, scaling.Name)
}

// commit scaling to the back repo (if it is already staged)
func (scaling *Scaling) Commit(stage *StageStruct) *Scaling {
	if _, ok := stage.Scalings[scaling]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitScaling(scaling)
		}
	}
	return scaling
}

func (scaling *Scaling) CommitVoid(stage *StageStruct) {
	scaling.Commit(stage)
}

// Checkout scaling to the back repo (if it is already staged)
func (scaling *Scaling) Checkout(stage *StageStruct) *Scaling {
	if _, ok := stage.Scalings[scaling]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutScaling(scaling)
		}
	}
	return scaling
}

// for satisfaction of GongStruct interface
func (scaling *Scaling) GetName() (res string) {
	return scaling.Name
}

// Stage puts scordatura to the model stage
func (scordatura *Scordatura) Stage(stage *StageStruct) *Scordatura {
	stage.Scordaturas[scordatura] = __member
	stage.Scordaturas_mapString[scordatura.Name] = scordatura

	return scordatura
}

// Unstage removes scordatura off the model stage
func (scordatura *Scordatura) Unstage(stage *StageStruct) *Scordatura {
	delete(stage.Scordaturas, scordatura)
	delete(stage.Scordaturas_mapString, scordatura.Name)
	return scordatura
}

// UnstageVoid removes scordatura off the model stage
func (scordatura *Scordatura) UnstageVoid(stage *StageStruct) {
	delete(stage.Scordaturas, scordatura)
	delete(stage.Scordaturas_mapString, scordatura.Name)
}

// commit scordatura to the back repo (if it is already staged)
func (scordatura *Scordatura) Commit(stage *StageStruct) *Scordatura {
	if _, ok := stage.Scordaturas[scordatura]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitScordatura(scordatura)
		}
	}
	return scordatura
}

func (scordatura *Scordatura) CommitVoid(stage *StageStruct) {
	scordatura.Commit(stage)
}

// Checkout scordatura to the back repo (if it is already staged)
func (scordatura *Scordatura) Checkout(stage *StageStruct) *Scordatura {
	if _, ok := stage.Scordaturas[scordatura]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutScordatura(scordatura)
		}
	}
	return scordatura
}

// for satisfaction of GongStruct interface
func (scordatura *Scordatura) GetName() (res string) {
	return scordatura.Name
}

// Stage puts score_instrument to the model stage
func (score_instrument *Score_instrument) Stage(stage *StageStruct) *Score_instrument {
	stage.Score_instruments[score_instrument] = __member
	stage.Score_instruments_mapString[score_instrument.Name] = score_instrument

	return score_instrument
}

// Unstage removes score_instrument off the model stage
func (score_instrument *Score_instrument) Unstage(stage *StageStruct) *Score_instrument {
	delete(stage.Score_instruments, score_instrument)
	delete(stage.Score_instruments_mapString, score_instrument.Name)
	return score_instrument
}

// UnstageVoid removes score_instrument off the model stage
func (score_instrument *Score_instrument) UnstageVoid(stage *StageStruct) {
	delete(stage.Score_instruments, score_instrument)
	delete(stage.Score_instruments_mapString, score_instrument.Name)
}

// commit score_instrument to the back repo (if it is already staged)
func (score_instrument *Score_instrument) Commit(stage *StageStruct) *Score_instrument {
	if _, ok := stage.Score_instruments[score_instrument]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitScore_instrument(score_instrument)
		}
	}
	return score_instrument
}

func (score_instrument *Score_instrument) CommitVoid(stage *StageStruct) {
	score_instrument.Commit(stage)
}

// Checkout score_instrument to the back repo (if it is already staged)
func (score_instrument *Score_instrument) Checkout(stage *StageStruct) *Score_instrument {
	if _, ok := stage.Score_instruments[score_instrument]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutScore_instrument(score_instrument)
		}
	}
	return score_instrument
}

// for satisfaction of GongStruct interface
func (score_instrument *Score_instrument) GetName() (res string) {
	return score_instrument.Name
}

// Stage puts score_part to the model stage
func (score_part *Score_part) Stage(stage *StageStruct) *Score_part {
	stage.Score_parts[score_part] = __member
	stage.Score_parts_mapString[score_part.Name] = score_part

	return score_part
}

// Unstage removes score_part off the model stage
func (score_part *Score_part) Unstage(stage *StageStruct) *Score_part {
	delete(stage.Score_parts, score_part)
	delete(stage.Score_parts_mapString, score_part.Name)
	return score_part
}

// UnstageVoid removes score_part off the model stage
func (score_part *Score_part) UnstageVoid(stage *StageStruct) {
	delete(stage.Score_parts, score_part)
	delete(stage.Score_parts_mapString, score_part.Name)
}

// commit score_part to the back repo (if it is already staged)
func (score_part *Score_part) Commit(stage *StageStruct) *Score_part {
	if _, ok := stage.Score_parts[score_part]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitScore_part(score_part)
		}
	}
	return score_part
}

func (score_part *Score_part) CommitVoid(stage *StageStruct) {
	score_part.Commit(stage)
}

// Checkout score_part to the back repo (if it is already staged)
func (score_part *Score_part) Checkout(stage *StageStruct) *Score_part {
	if _, ok := stage.Score_parts[score_part]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutScore_part(score_part)
		}
	}
	return score_part
}

// for satisfaction of GongStruct interface
func (score_part *Score_part) GetName() (res string) {
	return score_part.Name
}

// Stage puts score_partwise to the model stage
func (score_partwise *Score_partwise) Stage(stage *StageStruct) *Score_partwise {
	stage.Score_partwises[score_partwise] = __member
	stage.Score_partwises_mapString[score_partwise.Name] = score_partwise

	return score_partwise
}

// Unstage removes score_partwise off the model stage
func (score_partwise *Score_partwise) Unstage(stage *StageStruct) *Score_partwise {
	delete(stage.Score_partwises, score_partwise)
	delete(stage.Score_partwises_mapString, score_partwise.Name)
	return score_partwise
}

// UnstageVoid removes score_partwise off the model stage
func (score_partwise *Score_partwise) UnstageVoid(stage *StageStruct) {
	delete(stage.Score_partwises, score_partwise)
	delete(stage.Score_partwises_mapString, score_partwise.Name)
}

// commit score_partwise to the back repo (if it is already staged)
func (score_partwise *Score_partwise) Commit(stage *StageStruct) *Score_partwise {
	if _, ok := stage.Score_partwises[score_partwise]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitScore_partwise(score_partwise)
		}
	}
	return score_partwise
}

func (score_partwise *Score_partwise) CommitVoid(stage *StageStruct) {
	score_partwise.Commit(stage)
}

// Checkout score_partwise to the back repo (if it is already staged)
func (score_partwise *Score_partwise) Checkout(stage *StageStruct) *Score_partwise {
	if _, ok := stage.Score_partwises[score_partwise]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutScore_partwise(score_partwise)
		}
	}
	return score_partwise
}

// for satisfaction of GongStruct interface
func (score_partwise *Score_partwise) GetName() (res string) {
	return score_partwise.Name
}

// Stage puts score_timewise to the model stage
func (score_timewise *Score_timewise) Stage(stage *StageStruct) *Score_timewise {
	stage.Score_timewises[score_timewise] = __member
	stage.Score_timewises_mapString[score_timewise.Name] = score_timewise

	return score_timewise
}

// Unstage removes score_timewise off the model stage
func (score_timewise *Score_timewise) Unstage(stage *StageStruct) *Score_timewise {
	delete(stage.Score_timewises, score_timewise)
	delete(stage.Score_timewises_mapString, score_timewise.Name)
	return score_timewise
}

// UnstageVoid removes score_timewise off the model stage
func (score_timewise *Score_timewise) UnstageVoid(stage *StageStruct) {
	delete(stage.Score_timewises, score_timewise)
	delete(stage.Score_timewises_mapString, score_timewise.Name)
}

// commit score_timewise to the back repo (if it is already staged)
func (score_timewise *Score_timewise) Commit(stage *StageStruct) *Score_timewise {
	if _, ok := stage.Score_timewises[score_timewise]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitScore_timewise(score_timewise)
		}
	}
	return score_timewise
}

func (score_timewise *Score_timewise) CommitVoid(stage *StageStruct) {
	score_timewise.Commit(stage)
}

// Checkout score_timewise to the back repo (if it is already staged)
func (score_timewise *Score_timewise) Checkout(stage *StageStruct) *Score_timewise {
	if _, ok := stage.Score_timewises[score_timewise]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutScore_timewise(score_timewise)
		}
	}
	return score_timewise
}

// for satisfaction of GongStruct interface
func (score_timewise *Score_timewise) GetName() (res string) {
	return score_timewise.Name
}

// Stage puts segno to the model stage
func (segno *Segno) Stage(stage *StageStruct) *Segno {
	stage.Segnos[segno] = __member
	stage.Segnos_mapString[segno.Name] = segno

	return segno
}

// Unstage removes segno off the model stage
func (segno *Segno) Unstage(stage *StageStruct) *Segno {
	delete(stage.Segnos, segno)
	delete(stage.Segnos_mapString, segno.Name)
	return segno
}

// UnstageVoid removes segno off the model stage
func (segno *Segno) UnstageVoid(stage *StageStruct) {
	delete(stage.Segnos, segno)
	delete(stage.Segnos_mapString, segno.Name)
}

// commit segno to the back repo (if it is already staged)
func (segno *Segno) Commit(stage *StageStruct) *Segno {
	if _, ok := stage.Segnos[segno]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitSegno(segno)
		}
	}
	return segno
}

func (segno *Segno) CommitVoid(stage *StageStruct) {
	segno.Commit(stage)
}

// Checkout segno to the back repo (if it is already staged)
func (segno *Segno) Checkout(stage *StageStruct) *Segno {
	if _, ok := stage.Segnos[segno]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutSegno(segno)
		}
	}
	return segno
}

// for satisfaction of GongStruct interface
func (segno *Segno) GetName() (res string) {
	return segno.Name
}

// Stage puts slash to the model stage
func (slash *Slash) Stage(stage *StageStruct) *Slash {
	stage.Slashs[slash] = __member
	stage.Slashs_mapString[slash.Name] = slash

	return slash
}

// Unstage removes slash off the model stage
func (slash *Slash) Unstage(stage *StageStruct) *Slash {
	delete(stage.Slashs, slash)
	delete(stage.Slashs_mapString, slash.Name)
	return slash
}

// UnstageVoid removes slash off the model stage
func (slash *Slash) UnstageVoid(stage *StageStruct) {
	delete(stage.Slashs, slash)
	delete(stage.Slashs_mapString, slash.Name)
}

// commit slash to the back repo (if it is already staged)
func (slash *Slash) Commit(stage *StageStruct) *Slash {
	if _, ok := stage.Slashs[slash]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitSlash(slash)
		}
	}
	return slash
}

func (slash *Slash) CommitVoid(stage *StageStruct) {
	slash.Commit(stage)
}

// Checkout slash to the back repo (if it is already staged)
func (slash *Slash) Checkout(stage *StageStruct) *Slash {
	if _, ok := stage.Slashs[slash]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutSlash(slash)
		}
	}
	return slash
}

// for satisfaction of GongStruct interface
func (slash *Slash) GetName() (res string) {
	return slash.Name
}

// Stage puts slide to the model stage
func (slide *Slide) Stage(stage *StageStruct) *Slide {
	stage.Slides[slide] = __member
	stage.Slides_mapString[slide.Name] = slide

	return slide
}

// Unstage removes slide off the model stage
func (slide *Slide) Unstage(stage *StageStruct) *Slide {
	delete(stage.Slides, slide)
	delete(stage.Slides_mapString, slide.Name)
	return slide
}

// UnstageVoid removes slide off the model stage
func (slide *Slide) UnstageVoid(stage *StageStruct) {
	delete(stage.Slides, slide)
	delete(stage.Slides_mapString, slide.Name)
}

// commit slide to the back repo (if it is already staged)
func (slide *Slide) Commit(stage *StageStruct) *Slide {
	if _, ok := stage.Slides[slide]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitSlide(slide)
		}
	}
	return slide
}

func (slide *Slide) CommitVoid(stage *StageStruct) {
	slide.Commit(stage)
}

// Checkout slide to the back repo (if it is already staged)
func (slide *Slide) Checkout(stage *StageStruct) *Slide {
	if _, ok := stage.Slides[slide]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutSlide(slide)
		}
	}
	return slide
}

// for satisfaction of GongStruct interface
func (slide *Slide) GetName() (res string) {
	return slide.Name
}

// Stage puts slur to the model stage
func (slur *Slur) Stage(stage *StageStruct) *Slur {
	stage.Slurs[slur] = __member
	stage.Slurs_mapString[slur.Name] = slur

	return slur
}

// Unstage removes slur off the model stage
func (slur *Slur) Unstage(stage *StageStruct) *Slur {
	delete(stage.Slurs, slur)
	delete(stage.Slurs_mapString, slur.Name)
	return slur
}

// UnstageVoid removes slur off the model stage
func (slur *Slur) UnstageVoid(stage *StageStruct) {
	delete(stage.Slurs, slur)
	delete(stage.Slurs_mapString, slur.Name)
}

// commit slur to the back repo (if it is already staged)
func (slur *Slur) Commit(stage *StageStruct) *Slur {
	if _, ok := stage.Slurs[slur]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitSlur(slur)
		}
	}
	return slur
}

func (slur *Slur) CommitVoid(stage *StageStruct) {
	slur.Commit(stage)
}

// Checkout slur to the back repo (if it is already staged)
func (slur *Slur) Checkout(stage *StageStruct) *Slur {
	if _, ok := stage.Slurs[slur]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutSlur(slur)
		}
	}
	return slur
}

// for satisfaction of GongStruct interface
func (slur *Slur) GetName() (res string) {
	return slur.Name
}

// Stage puts sound to the model stage
func (sound *Sound) Stage(stage *StageStruct) *Sound {
	stage.Sounds[sound] = __member
	stage.Sounds_mapString[sound.Name] = sound

	return sound
}

// Unstage removes sound off the model stage
func (sound *Sound) Unstage(stage *StageStruct) *Sound {
	delete(stage.Sounds, sound)
	delete(stage.Sounds_mapString, sound.Name)
	return sound
}

// UnstageVoid removes sound off the model stage
func (sound *Sound) UnstageVoid(stage *StageStruct) {
	delete(stage.Sounds, sound)
	delete(stage.Sounds_mapString, sound.Name)
}

// commit sound to the back repo (if it is already staged)
func (sound *Sound) Commit(stage *StageStruct) *Sound {
	if _, ok := stage.Sounds[sound]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitSound(sound)
		}
	}
	return sound
}

func (sound *Sound) CommitVoid(stage *StageStruct) {
	sound.Commit(stage)
}

// Checkout sound to the back repo (if it is already staged)
func (sound *Sound) Checkout(stage *StageStruct) *Sound {
	if _, ok := stage.Sounds[sound]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutSound(sound)
		}
	}
	return sound
}

// for satisfaction of GongStruct interface
func (sound *Sound) GetName() (res string) {
	return sound.Name
}

// Stage puts staff_details to the model stage
func (staff_details *Staff_details) Stage(stage *StageStruct) *Staff_details {
	stage.Staff_detailss[staff_details] = __member
	stage.Staff_detailss_mapString[staff_details.Name] = staff_details

	return staff_details
}

// Unstage removes staff_details off the model stage
func (staff_details *Staff_details) Unstage(stage *StageStruct) *Staff_details {
	delete(stage.Staff_detailss, staff_details)
	delete(stage.Staff_detailss_mapString, staff_details.Name)
	return staff_details
}

// UnstageVoid removes staff_details off the model stage
func (staff_details *Staff_details) UnstageVoid(stage *StageStruct) {
	delete(stage.Staff_detailss, staff_details)
	delete(stage.Staff_detailss_mapString, staff_details.Name)
}

// commit staff_details to the back repo (if it is already staged)
func (staff_details *Staff_details) Commit(stage *StageStruct) *Staff_details {
	if _, ok := stage.Staff_detailss[staff_details]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitStaff_details(staff_details)
		}
	}
	return staff_details
}

func (staff_details *Staff_details) CommitVoid(stage *StageStruct) {
	staff_details.Commit(stage)
}

// Checkout staff_details to the back repo (if it is already staged)
func (staff_details *Staff_details) Checkout(stage *StageStruct) *Staff_details {
	if _, ok := stage.Staff_detailss[staff_details]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutStaff_details(staff_details)
		}
	}
	return staff_details
}

// for satisfaction of GongStruct interface
func (staff_details *Staff_details) GetName() (res string) {
	return staff_details.Name
}

// Stage puts staff_divide to the model stage
func (staff_divide *Staff_divide) Stage(stage *StageStruct) *Staff_divide {
	stage.Staff_divides[staff_divide] = __member
	stage.Staff_divides_mapString[staff_divide.Name] = staff_divide

	return staff_divide
}

// Unstage removes staff_divide off the model stage
func (staff_divide *Staff_divide) Unstage(stage *StageStruct) *Staff_divide {
	delete(stage.Staff_divides, staff_divide)
	delete(stage.Staff_divides_mapString, staff_divide.Name)
	return staff_divide
}

// UnstageVoid removes staff_divide off the model stage
func (staff_divide *Staff_divide) UnstageVoid(stage *StageStruct) {
	delete(stage.Staff_divides, staff_divide)
	delete(stage.Staff_divides_mapString, staff_divide.Name)
}

// commit staff_divide to the back repo (if it is already staged)
func (staff_divide *Staff_divide) Commit(stage *StageStruct) *Staff_divide {
	if _, ok := stage.Staff_divides[staff_divide]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitStaff_divide(staff_divide)
		}
	}
	return staff_divide
}

func (staff_divide *Staff_divide) CommitVoid(stage *StageStruct) {
	staff_divide.Commit(stage)
}

// Checkout staff_divide to the back repo (if it is already staged)
func (staff_divide *Staff_divide) Checkout(stage *StageStruct) *Staff_divide {
	if _, ok := stage.Staff_divides[staff_divide]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutStaff_divide(staff_divide)
		}
	}
	return staff_divide
}

// for satisfaction of GongStruct interface
func (staff_divide *Staff_divide) GetName() (res string) {
	return staff_divide.Name
}

// Stage puts staff_layout to the model stage
func (staff_layout *Staff_layout) Stage(stage *StageStruct) *Staff_layout {
	stage.Staff_layouts[staff_layout] = __member
	stage.Staff_layouts_mapString[staff_layout.Name] = staff_layout

	return staff_layout
}

// Unstage removes staff_layout off the model stage
func (staff_layout *Staff_layout) Unstage(stage *StageStruct) *Staff_layout {
	delete(stage.Staff_layouts, staff_layout)
	delete(stage.Staff_layouts_mapString, staff_layout.Name)
	return staff_layout
}

// UnstageVoid removes staff_layout off the model stage
func (staff_layout *Staff_layout) UnstageVoid(stage *StageStruct) {
	delete(stage.Staff_layouts, staff_layout)
	delete(stage.Staff_layouts_mapString, staff_layout.Name)
}

// commit staff_layout to the back repo (if it is already staged)
func (staff_layout *Staff_layout) Commit(stage *StageStruct) *Staff_layout {
	if _, ok := stage.Staff_layouts[staff_layout]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitStaff_layout(staff_layout)
		}
	}
	return staff_layout
}

func (staff_layout *Staff_layout) CommitVoid(stage *StageStruct) {
	staff_layout.Commit(stage)
}

// Checkout staff_layout to the back repo (if it is already staged)
func (staff_layout *Staff_layout) Checkout(stage *StageStruct) *Staff_layout {
	if _, ok := stage.Staff_layouts[staff_layout]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutStaff_layout(staff_layout)
		}
	}
	return staff_layout
}

// for satisfaction of GongStruct interface
func (staff_layout *Staff_layout) GetName() (res string) {
	return staff_layout.Name
}

// Stage puts staff_size to the model stage
func (staff_size *Staff_size) Stage(stage *StageStruct) *Staff_size {
	stage.Staff_sizes[staff_size] = __member
	stage.Staff_sizes_mapString[staff_size.Name] = staff_size

	return staff_size
}

// Unstage removes staff_size off the model stage
func (staff_size *Staff_size) Unstage(stage *StageStruct) *Staff_size {
	delete(stage.Staff_sizes, staff_size)
	delete(stage.Staff_sizes_mapString, staff_size.Name)
	return staff_size
}

// UnstageVoid removes staff_size off the model stage
func (staff_size *Staff_size) UnstageVoid(stage *StageStruct) {
	delete(stage.Staff_sizes, staff_size)
	delete(stage.Staff_sizes_mapString, staff_size.Name)
}

// commit staff_size to the back repo (if it is already staged)
func (staff_size *Staff_size) Commit(stage *StageStruct) *Staff_size {
	if _, ok := stage.Staff_sizes[staff_size]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitStaff_size(staff_size)
		}
	}
	return staff_size
}

func (staff_size *Staff_size) CommitVoid(stage *StageStruct) {
	staff_size.Commit(stage)
}

// Checkout staff_size to the back repo (if it is already staged)
func (staff_size *Staff_size) Checkout(stage *StageStruct) *Staff_size {
	if _, ok := stage.Staff_sizes[staff_size]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutStaff_size(staff_size)
		}
	}
	return staff_size
}

// for satisfaction of GongStruct interface
func (staff_size *Staff_size) GetName() (res string) {
	return staff_size.Name
}

// Stage puts staff_tuning to the model stage
func (staff_tuning *Staff_tuning) Stage(stage *StageStruct) *Staff_tuning {
	stage.Staff_tunings[staff_tuning] = __member
	stage.Staff_tunings_mapString[staff_tuning.Name] = staff_tuning

	return staff_tuning
}

// Unstage removes staff_tuning off the model stage
func (staff_tuning *Staff_tuning) Unstage(stage *StageStruct) *Staff_tuning {
	delete(stage.Staff_tunings, staff_tuning)
	delete(stage.Staff_tunings_mapString, staff_tuning.Name)
	return staff_tuning
}

// UnstageVoid removes staff_tuning off the model stage
func (staff_tuning *Staff_tuning) UnstageVoid(stage *StageStruct) {
	delete(stage.Staff_tunings, staff_tuning)
	delete(stage.Staff_tunings_mapString, staff_tuning.Name)
}

// commit staff_tuning to the back repo (if it is already staged)
func (staff_tuning *Staff_tuning) Commit(stage *StageStruct) *Staff_tuning {
	if _, ok := stage.Staff_tunings[staff_tuning]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitStaff_tuning(staff_tuning)
		}
	}
	return staff_tuning
}

func (staff_tuning *Staff_tuning) CommitVoid(stage *StageStruct) {
	staff_tuning.Commit(stage)
}

// Checkout staff_tuning to the back repo (if it is already staged)
func (staff_tuning *Staff_tuning) Checkout(stage *StageStruct) *Staff_tuning {
	if _, ok := stage.Staff_tunings[staff_tuning]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutStaff_tuning(staff_tuning)
		}
	}
	return staff_tuning
}

// for satisfaction of GongStruct interface
func (staff_tuning *Staff_tuning) GetName() (res string) {
	return staff_tuning.Name
}

// Stage puts stem to the model stage
func (stem *Stem) Stage(stage *StageStruct) *Stem {
	stage.Stems[stem] = __member
	stage.Stems_mapString[stem.Name] = stem

	return stem
}

// Unstage removes stem off the model stage
func (stem *Stem) Unstage(stage *StageStruct) *Stem {
	delete(stage.Stems, stem)
	delete(stage.Stems_mapString, stem.Name)
	return stem
}

// UnstageVoid removes stem off the model stage
func (stem *Stem) UnstageVoid(stage *StageStruct) {
	delete(stage.Stems, stem)
	delete(stage.Stems_mapString, stem.Name)
}

// commit stem to the back repo (if it is already staged)
func (stem *Stem) Commit(stage *StageStruct) *Stem {
	if _, ok := stage.Stems[stem]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitStem(stem)
		}
	}
	return stem
}

func (stem *Stem) CommitVoid(stage *StageStruct) {
	stem.Commit(stage)
}

// Checkout stem to the back repo (if it is already staged)
func (stem *Stem) Checkout(stage *StageStruct) *Stem {
	if _, ok := stage.Stems[stem]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutStem(stem)
		}
	}
	return stem
}

// for satisfaction of GongStruct interface
func (stem *Stem) GetName() (res string) {
	return stem.Name
}

// Stage puts stick to the model stage
func (stick *Stick) Stage(stage *StageStruct) *Stick {
	stage.Sticks[stick] = __member
	stage.Sticks_mapString[stick.Name] = stick

	return stick
}

// Unstage removes stick off the model stage
func (stick *Stick) Unstage(stage *StageStruct) *Stick {
	delete(stage.Sticks, stick)
	delete(stage.Sticks_mapString, stick.Name)
	return stick
}

// UnstageVoid removes stick off the model stage
func (stick *Stick) UnstageVoid(stage *StageStruct) {
	delete(stage.Sticks, stick)
	delete(stage.Sticks_mapString, stick.Name)
}

// commit stick to the back repo (if it is already staged)
func (stick *Stick) Commit(stage *StageStruct) *Stick {
	if _, ok := stage.Sticks[stick]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitStick(stick)
		}
	}
	return stick
}

func (stick *Stick) CommitVoid(stage *StageStruct) {
	stick.Commit(stage)
}

// Checkout stick to the back repo (if it is already staged)
func (stick *Stick) Checkout(stage *StageStruct) *Stick {
	if _, ok := stage.Sticks[stick]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutStick(stick)
		}
	}
	return stick
}

// for satisfaction of GongStruct interface
func (stick *Stick) GetName() (res string) {
	return stick.Name
}

// Stage puts string_mute to the model stage
func (string_mute *String_mute) Stage(stage *StageStruct) *String_mute {
	stage.String_mutes[string_mute] = __member
	stage.String_mutes_mapString[string_mute.Name] = string_mute

	return string_mute
}

// Unstage removes string_mute off the model stage
func (string_mute *String_mute) Unstage(stage *StageStruct) *String_mute {
	delete(stage.String_mutes, string_mute)
	delete(stage.String_mutes_mapString, string_mute.Name)
	return string_mute
}

// UnstageVoid removes string_mute off the model stage
func (string_mute *String_mute) UnstageVoid(stage *StageStruct) {
	delete(stage.String_mutes, string_mute)
	delete(stage.String_mutes_mapString, string_mute.Name)
}

// commit string_mute to the back repo (if it is already staged)
func (string_mute *String_mute) Commit(stage *StageStruct) *String_mute {
	if _, ok := stage.String_mutes[string_mute]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitString_mute(string_mute)
		}
	}
	return string_mute
}

func (string_mute *String_mute) CommitVoid(stage *StageStruct) {
	string_mute.Commit(stage)
}

// Checkout string_mute to the back repo (if it is already staged)
func (string_mute *String_mute) Checkout(stage *StageStruct) *String_mute {
	if _, ok := stage.String_mutes[string_mute]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutString_mute(string_mute)
		}
	}
	return string_mute
}

// for satisfaction of GongStruct interface
func (string_mute *String_mute) GetName() (res string) {
	return string_mute.Name
}

// Stage puts strong_accent to the model stage
func (strong_accent *Strong_accent) Stage(stage *StageStruct) *Strong_accent {
	stage.Strong_accents[strong_accent] = __member
	stage.Strong_accents_mapString[strong_accent.Name] = strong_accent

	return strong_accent
}

// Unstage removes strong_accent off the model stage
func (strong_accent *Strong_accent) Unstage(stage *StageStruct) *Strong_accent {
	delete(stage.Strong_accents, strong_accent)
	delete(stage.Strong_accents_mapString, strong_accent.Name)
	return strong_accent
}

// UnstageVoid removes strong_accent off the model stage
func (strong_accent *Strong_accent) UnstageVoid(stage *StageStruct) {
	delete(stage.Strong_accents, strong_accent)
	delete(stage.Strong_accents_mapString, strong_accent.Name)
}

// commit strong_accent to the back repo (if it is already staged)
func (strong_accent *Strong_accent) Commit(stage *StageStruct) *Strong_accent {
	if _, ok := stage.Strong_accents[strong_accent]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitStrong_accent(strong_accent)
		}
	}
	return strong_accent
}

func (strong_accent *Strong_accent) CommitVoid(stage *StageStruct) {
	strong_accent.Commit(stage)
}

// Checkout strong_accent to the back repo (if it is already staged)
func (strong_accent *Strong_accent) Checkout(stage *StageStruct) *Strong_accent {
	if _, ok := stage.Strong_accents[strong_accent]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutStrong_accent(strong_accent)
		}
	}
	return strong_accent
}

// for satisfaction of GongStruct interface
func (strong_accent *Strong_accent) GetName() (res string) {
	return strong_accent.Name
}

// Stage puts supports to the model stage
func (supports *Supports) Stage(stage *StageStruct) *Supports {
	stage.Supportss[supports] = __member
	stage.Supportss_mapString[supports.Name] = supports

	return supports
}

// Unstage removes supports off the model stage
func (supports *Supports) Unstage(stage *StageStruct) *Supports {
	delete(stage.Supportss, supports)
	delete(stage.Supportss_mapString, supports.Name)
	return supports
}

// UnstageVoid removes supports off the model stage
func (supports *Supports) UnstageVoid(stage *StageStruct) {
	delete(stage.Supportss, supports)
	delete(stage.Supportss_mapString, supports.Name)
}

// commit supports to the back repo (if it is already staged)
func (supports *Supports) Commit(stage *StageStruct) *Supports {
	if _, ok := stage.Supportss[supports]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitSupports(supports)
		}
	}
	return supports
}

func (supports *Supports) CommitVoid(stage *StageStruct) {
	supports.Commit(stage)
}

// Checkout supports to the back repo (if it is already staged)
func (supports *Supports) Checkout(stage *StageStruct) *Supports {
	if _, ok := stage.Supportss[supports]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutSupports(supports)
		}
	}
	return supports
}

// for satisfaction of GongStruct interface
func (supports *Supports) GetName() (res string) {
	return supports.Name
}

// Stage puts swing to the model stage
func (swing *Swing) Stage(stage *StageStruct) *Swing {
	stage.Swings[swing] = __member
	stage.Swings_mapString[swing.Name] = swing

	return swing
}

// Unstage removes swing off the model stage
func (swing *Swing) Unstage(stage *StageStruct) *Swing {
	delete(stage.Swings, swing)
	delete(stage.Swings_mapString, swing.Name)
	return swing
}

// UnstageVoid removes swing off the model stage
func (swing *Swing) UnstageVoid(stage *StageStruct) {
	delete(stage.Swings, swing)
	delete(stage.Swings_mapString, swing.Name)
}

// commit swing to the back repo (if it is already staged)
func (swing *Swing) Commit(stage *StageStruct) *Swing {
	if _, ok := stage.Swings[swing]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitSwing(swing)
		}
	}
	return swing
}

func (swing *Swing) CommitVoid(stage *StageStruct) {
	swing.Commit(stage)
}

// Checkout swing to the back repo (if it is already staged)
func (swing *Swing) Checkout(stage *StageStruct) *Swing {
	if _, ok := stage.Swings[swing]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutSwing(swing)
		}
	}
	return swing
}

// for satisfaction of GongStruct interface
func (swing *Swing) GetName() (res string) {
	return swing.Name
}

// Stage puts sync to the model stage
func (sync *Sync) Stage(stage *StageStruct) *Sync {
	stage.Syncs[sync] = __member
	stage.Syncs_mapString[sync.Name] = sync

	return sync
}

// Unstage removes sync off the model stage
func (sync *Sync) Unstage(stage *StageStruct) *Sync {
	delete(stage.Syncs, sync)
	delete(stage.Syncs_mapString, sync.Name)
	return sync
}

// UnstageVoid removes sync off the model stage
func (sync *Sync) UnstageVoid(stage *StageStruct) {
	delete(stage.Syncs, sync)
	delete(stage.Syncs_mapString, sync.Name)
}

// commit sync to the back repo (if it is already staged)
func (sync *Sync) Commit(stage *StageStruct) *Sync {
	if _, ok := stage.Syncs[sync]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitSync(sync)
		}
	}
	return sync
}

func (sync *Sync) CommitVoid(stage *StageStruct) {
	sync.Commit(stage)
}

// Checkout sync to the back repo (if it is already staged)
func (sync *Sync) Checkout(stage *StageStruct) *Sync {
	if _, ok := stage.Syncs[sync]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutSync(sync)
		}
	}
	return sync
}

// for satisfaction of GongStruct interface
func (sync *Sync) GetName() (res string) {
	return sync.Name
}

// Stage puts system_dividers to the model stage
func (system_dividers *System_dividers) Stage(stage *StageStruct) *System_dividers {
	stage.System_dividerss[system_dividers] = __member
	stage.System_dividerss_mapString[system_dividers.Name] = system_dividers

	return system_dividers
}

// Unstage removes system_dividers off the model stage
func (system_dividers *System_dividers) Unstage(stage *StageStruct) *System_dividers {
	delete(stage.System_dividerss, system_dividers)
	delete(stage.System_dividerss_mapString, system_dividers.Name)
	return system_dividers
}

// UnstageVoid removes system_dividers off the model stage
func (system_dividers *System_dividers) UnstageVoid(stage *StageStruct) {
	delete(stage.System_dividerss, system_dividers)
	delete(stage.System_dividerss_mapString, system_dividers.Name)
}

// commit system_dividers to the back repo (if it is already staged)
func (system_dividers *System_dividers) Commit(stage *StageStruct) *System_dividers {
	if _, ok := stage.System_dividerss[system_dividers]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitSystem_dividers(system_dividers)
		}
	}
	return system_dividers
}

func (system_dividers *System_dividers) CommitVoid(stage *StageStruct) {
	system_dividers.Commit(stage)
}

// Checkout system_dividers to the back repo (if it is already staged)
func (system_dividers *System_dividers) Checkout(stage *StageStruct) *System_dividers {
	if _, ok := stage.System_dividerss[system_dividers]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutSystem_dividers(system_dividers)
		}
	}
	return system_dividers
}

// for satisfaction of GongStruct interface
func (system_dividers *System_dividers) GetName() (res string) {
	return system_dividers.Name
}

// Stage puts system_layout to the model stage
func (system_layout *System_layout) Stage(stage *StageStruct) *System_layout {
	stage.System_layouts[system_layout] = __member
	stage.System_layouts_mapString[system_layout.Name] = system_layout

	return system_layout
}

// Unstage removes system_layout off the model stage
func (system_layout *System_layout) Unstage(stage *StageStruct) *System_layout {
	delete(stage.System_layouts, system_layout)
	delete(stage.System_layouts_mapString, system_layout.Name)
	return system_layout
}

// UnstageVoid removes system_layout off the model stage
func (system_layout *System_layout) UnstageVoid(stage *StageStruct) {
	delete(stage.System_layouts, system_layout)
	delete(stage.System_layouts_mapString, system_layout.Name)
}

// commit system_layout to the back repo (if it is already staged)
func (system_layout *System_layout) Commit(stage *StageStruct) *System_layout {
	if _, ok := stage.System_layouts[system_layout]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitSystem_layout(system_layout)
		}
	}
	return system_layout
}

func (system_layout *System_layout) CommitVoid(stage *StageStruct) {
	system_layout.Commit(stage)
}

// Checkout system_layout to the back repo (if it is already staged)
func (system_layout *System_layout) Checkout(stage *StageStruct) *System_layout {
	if _, ok := stage.System_layouts[system_layout]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutSystem_layout(system_layout)
		}
	}
	return system_layout
}

// for satisfaction of GongStruct interface
func (system_layout *System_layout) GetName() (res string) {
	return system_layout.Name
}

// Stage puts system_margins to the model stage
func (system_margins *System_margins) Stage(stage *StageStruct) *System_margins {
	stage.System_marginss[system_margins] = __member
	stage.System_marginss_mapString[system_margins.Name] = system_margins

	return system_margins
}

// Unstage removes system_margins off the model stage
func (system_margins *System_margins) Unstage(stage *StageStruct) *System_margins {
	delete(stage.System_marginss, system_margins)
	delete(stage.System_marginss_mapString, system_margins.Name)
	return system_margins
}

// UnstageVoid removes system_margins off the model stage
func (system_margins *System_margins) UnstageVoid(stage *StageStruct) {
	delete(stage.System_marginss, system_margins)
	delete(stage.System_marginss_mapString, system_margins.Name)
}

// commit system_margins to the back repo (if it is already staged)
func (system_margins *System_margins) Commit(stage *StageStruct) *System_margins {
	if _, ok := stage.System_marginss[system_margins]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitSystem_margins(system_margins)
		}
	}
	return system_margins
}

func (system_margins *System_margins) CommitVoid(stage *StageStruct) {
	system_margins.Commit(stage)
}

// Checkout system_margins to the back repo (if it is already staged)
func (system_margins *System_margins) Checkout(stage *StageStruct) *System_margins {
	if _, ok := stage.System_marginss[system_margins]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutSystem_margins(system_margins)
		}
	}
	return system_margins
}

// for satisfaction of GongStruct interface
func (system_margins *System_margins) GetName() (res string) {
	return system_margins.Name
}

// Stage puts tap to the model stage
func (tap *Tap) Stage(stage *StageStruct) *Tap {
	stage.Taps[tap] = __member
	stage.Taps_mapString[tap.Name] = tap

	return tap
}

// Unstage removes tap off the model stage
func (tap *Tap) Unstage(stage *StageStruct) *Tap {
	delete(stage.Taps, tap)
	delete(stage.Taps_mapString, tap.Name)
	return tap
}

// UnstageVoid removes tap off the model stage
func (tap *Tap) UnstageVoid(stage *StageStruct) {
	delete(stage.Taps, tap)
	delete(stage.Taps_mapString, tap.Name)
}

// commit tap to the back repo (if it is already staged)
func (tap *Tap) Commit(stage *StageStruct) *Tap {
	if _, ok := stage.Taps[tap]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTap(tap)
		}
	}
	return tap
}

func (tap *Tap) CommitVoid(stage *StageStruct) {
	tap.Commit(stage)
}

// Checkout tap to the back repo (if it is already staged)
func (tap *Tap) Checkout(stage *StageStruct) *Tap {
	if _, ok := stage.Taps[tap]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTap(tap)
		}
	}
	return tap
}

// for satisfaction of GongStruct interface
func (tap *Tap) GetName() (res string) {
	return tap.Name
}

// Stage puts technical to the model stage
func (technical *Technical) Stage(stage *StageStruct) *Technical {
	stage.Technicals[technical] = __member
	stage.Technicals_mapString[technical.Name] = technical

	return technical
}

// Unstage removes technical off the model stage
func (technical *Technical) Unstage(stage *StageStruct) *Technical {
	delete(stage.Technicals, technical)
	delete(stage.Technicals_mapString, technical.Name)
	return technical
}

// UnstageVoid removes technical off the model stage
func (technical *Technical) UnstageVoid(stage *StageStruct) {
	delete(stage.Technicals, technical)
	delete(stage.Technicals_mapString, technical.Name)
}

// commit technical to the back repo (if it is already staged)
func (technical *Technical) Commit(stage *StageStruct) *Technical {
	if _, ok := stage.Technicals[technical]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTechnical(technical)
		}
	}
	return technical
}

func (technical *Technical) CommitVoid(stage *StageStruct) {
	technical.Commit(stage)
}

// Checkout technical to the back repo (if it is already staged)
func (technical *Technical) Checkout(stage *StageStruct) *Technical {
	if _, ok := stage.Technicals[technical]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTechnical(technical)
		}
	}
	return technical
}

// for satisfaction of GongStruct interface
func (technical *Technical) GetName() (res string) {
	return technical.Name
}

// Stage puts text_element_data to the model stage
func (text_element_data *Text_element_data) Stage(stage *StageStruct) *Text_element_data {
	stage.Text_element_datas[text_element_data] = __member
	stage.Text_element_datas_mapString[text_element_data.Name] = text_element_data

	return text_element_data
}

// Unstage removes text_element_data off the model stage
func (text_element_data *Text_element_data) Unstage(stage *StageStruct) *Text_element_data {
	delete(stage.Text_element_datas, text_element_data)
	delete(stage.Text_element_datas_mapString, text_element_data.Name)
	return text_element_data
}

// UnstageVoid removes text_element_data off the model stage
func (text_element_data *Text_element_data) UnstageVoid(stage *StageStruct) {
	delete(stage.Text_element_datas, text_element_data)
	delete(stage.Text_element_datas_mapString, text_element_data.Name)
}

// commit text_element_data to the back repo (if it is already staged)
func (text_element_data *Text_element_data) Commit(stage *StageStruct) *Text_element_data {
	if _, ok := stage.Text_element_datas[text_element_data]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitText_element_data(text_element_data)
		}
	}
	return text_element_data
}

func (text_element_data *Text_element_data) CommitVoid(stage *StageStruct) {
	text_element_data.Commit(stage)
}

// Checkout text_element_data to the back repo (if it is already staged)
func (text_element_data *Text_element_data) Checkout(stage *StageStruct) *Text_element_data {
	if _, ok := stage.Text_element_datas[text_element_data]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutText_element_data(text_element_data)
		}
	}
	return text_element_data
}

// for satisfaction of GongStruct interface
func (text_element_data *Text_element_data) GetName() (res string) {
	return text_element_data.Name
}

// Stage puts tie to the model stage
func (tie *Tie) Stage(stage *StageStruct) *Tie {
	stage.Ties[tie] = __member
	stage.Ties_mapString[tie.Name] = tie

	return tie
}

// Unstage removes tie off the model stage
func (tie *Tie) Unstage(stage *StageStruct) *Tie {
	delete(stage.Ties, tie)
	delete(stage.Ties_mapString, tie.Name)
	return tie
}

// UnstageVoid removes tie off the model stage
func (tie *Tie) UnstageVoid(stage *StageStruct) {
	delete(stage.Ties, tie)
	delete(stage.Ties_mapString, tie.Name)
}

// commit tie to the back repo (if it is already staged)
func (tie *Tie) Commit(stage *StageStruct) *Tie {
	if _, ok := stage.Ties[tie]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTie(tie)
		}
	}
	return tie
}

func (tie *Tie) CommitVoid(stage *StageStruct) {
	tie.Commit(stage)
}

// Checkout tie to the back repo (if it is already staged)
func (tie *Tie) Checkout(stage *StageStruct) *Tie {
	if _, ok := stage.Ties[tie]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTie(tie)
		}
	}
	return tie
}

// for satisfaction of GongStruct interface
func (tie *Tie) GetName() (res string) {
	return tie.Name
}

// Stage puts tied to the model stage
func (tied *Tied) Stage(stage *StageStruct) *Tied {
	stage.Tieds[tied] = __member
	stage.Tieds_mapString[tied.Name] = tied

	return tied
}

// Unstage removes tied off the model stage
func (tied *Tied) Unstage(stage *StageStruct) *Tied {
	delete(stage.Tieds, tied)
	delete(stage.Tieds_mapString, tied.Name)
	return tied
}

// UnstageVoid removes tied off the model stage
func (tied *Tied) UnstageVoid(stage *StageStruct) {
	delete(stage.Tieds, tied)
	delete(stage.Tieds_mapString, tied.Name)
}

// commit tied to the back repo (if it is already staged)
func (tied *Tied) Commit(stage *StageStruct) *Tied {
	if _, ok := stage.Tieds[tied]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTied(tied)
		}
	}
	return tied
}

func (tied *Tied) CommitVoid(stage *StageStruct) {
	tied.Commit(stage)
}

// Checkout tied to the back repo (if it is already staged)
func (tied *Tied) Checkout(stage *StageStruct) *Tied {
	if _, ok := stage.Tieds[tied]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTied(tied)
		}
	}
	return tied
}

// for satisfaction of GongStruct interface
func (tied *Tied) GetName() (res string) {
	return tied.Name
}

// Stage puts time to the model stage
func (time *Time) Stage(stage *StageStruct) *Time {
	stage.Times[time] = __member
	stage.Times_mapString[time.Name] = time

	return time
}

// Unstage removes time off the model stage
func (time *Time) Unstage(stage *StageStruct) *Time {
	delete(stage.Times, time)
	delete(stage.Times_mapString, time.Name)
	return time
}

// UnstageVoid removes time off the model stage
func (time *Time) UnstageVoid(stage *StageStruct) {
	delete(stage.Times, time)
	delete(stage.Times_mapString, time.Name)
}

// commit time to the back repo (if it is already staged)
func (time *Time) Commit(stage *StageStruct) *Time {
	if _, ok := stage.Times[time]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTime(time)
		}
	}
	return time
}

func (time *Time) CommitVoid(stage *StageStruct) {
	time.Commit(stage)
}

// Checkout time to the back repo (if it is already staged)
func (time *Time) Checkout(stage *StageStruct) *Time {
	if _, ok := stage.Times[time]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTime(time)
		}
	}
	return time
}

// for satisfaction of GongStruct interface
func (time *Time) GetName() (res string) {
	return time.Name
}

// Stage puts time_modification to the model stage
func (time_modification *Time_modification) Stage(stage *StageStruct) *Time_modification {
	stage.Time_modifications[time_modification] = __member
	stage.Time_modifications_mapString[time_modification.Name] = time_modification

	return time_modification
}

// Unstage removes time_modification off the model stage
func (time_modification *Time_modification) Unstage(stage *StageStruct) *Time_modification {
	delete(stage.Time_modifications, time_modification)
	delete(stage.Time_modifications_mapString, time_modification.Name)
	return time_modification
}

// UnstageVoid removes time_modification off the model stage
func (time_modification *Time_modification) UnstageVoid(stage *StageStruct) {
	delete(stage.Time_modifications, time_modification)
	delete(stage.Time_modifications_mapString, time_modification.Name)
}

// commit time_modification to the back repo (if it is already staged)
func (time_modification *Time_modification) Commit(stage *StageStruct) *Time_modification {
	if _, ok := stage.Time_modifications[time_modification]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTime_modification(time_modification)
		}
	}
	return time_modification
}

func (time_modification *Time_modification) CommitVoid(stage *StageStruct) {
	time_modification.Commit(stage)
}

// Checkout time_modification to the back repo (if it is already staged)
func (time_modification *Time_modification) Checkout(stage *StageStruct) *Time_modification {
	if _, ok := stage.Time_modifications[time_modification]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTime_modification(time_modification)
		}
	}
	return time_modification
}

// for satisfaction of GongStruct interface
func (time_modification *Time_modification) GetName() (res string) {
	return time_modification.Name
}

// Stage puts timpani to the model stage
func (timpani *Timpani) Stage(stage *StageStruct) *Timpani {
	stage.Timpanis[timpani] = __member
	stage.Timpanis_mapString[timpani.Name] = timpani

	return timpani
}

// Unstage removes timpani off the model stage
func (timpani *Timpani) Unstage(stage *StageStruct) *Timpani {
	delete(stage.Timpanis, timpani)
	delete(stage.Timpanis_mapString, timpani.Name)
	return timpani
}

// UnstageVoid removes timpani off the model stage
func (timpani *Timpani) UnstageVoid(stage *StageStruct) {
	delete(stage.Timpanis, timpani)
	delete(stage.Timpanis_mapString, timpani.Name)
}

// commit timpani to the back repo (if it is already staged)
func (timpani *Timpani) Commit(stage *StageStruct) *Timpani {
	if _, ok := stage.Timpanis[timpani]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTimpani(timpani)
		}
	}
	return timpani
}

func (timpani *Timpani) CommitVoid(stage *StageStruct) {
	timpani.Commit(stage)
}

// Checkout timpani to the back repo (if it is already staged)
func (timpani *Timpani) Checkout(stage *StageStruct) *Timpani {
	if _, ok := stage.Timpanis[timpani]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTimpani(timpani)
		}
	}
	return timpani
}

// for satisfaction of GongStruct interface
func (timpani *Timpani) GetName() (res string) {
	return timpani.Name
}

// Stage puts transpose to the model stage
func (transpose *Transpose) Stage(stage *StageStruct) *Transpose {
	stage.Transposes[transpose] = __member
	stage.Transposes_mapString[transpose.Name] = transpose

	return transpose
}

// Unstage removes transpose off the model stage
func (transpose *Transpose) Unstage(stage *StageStruct) *Transpose {
	delete(stage.Transposes, transpose)
	delete(stage.Transposes_mapString, transpose.Name)
	return transpose
}

// UnstageVoid removes transpose off the model stage
func (transpose *Transpose) UnstageVoid(stage *StageStruct) {
	delete(stage.Transposes, transpose)
	delete(stage.Transposes_mapString, transpose.Name)
}

// commit transpose to the back repo (if it is already staged)
func (transpose *Transpose) Commit(stage *StageStruct) *Transpose {
	if _, ok := stage.Transposes[transpose]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTranspose(transpose)
		}
	}
	return transpose
}

func (transpose *Transpose) CommitVoid(stage *StageStruct) {
	transpose.Commit(stage)
}

// Checkout transpose to the back repo (if it is already staged)
func (transpose *Transpose) Checkout(stage *StageStruct) *Transpose {
	if _, ok := stage.Transposes[transpose]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTranspose(transpose)
		}
	}
	return transpose
}

// for satisfaction of GongStruct interface
func (transpose *Transpose) GetName() (res string) {
	return transpose.Name
}

// Stage puts tremolo to the model stage
func (tremolo *Tremolo) Stage(stage *StageStruct) *Tremolo {
	stage.Tremolos[tremolo] = __member
	stage.Tremolos_mapString[tremolo.Name] = tremolo

	return tremolo
}

// Unstage removes tremolo off the model stage
func (tremolo *Tremolo) Unstage(stage *StageStruct) *Tremolo {
	delete(stage.Tremolos, tremolo)
	delete(stage.Tremolos_mapString, tremolo.Name)
	return tremolo
}

// UnstageVoid removes tremolo off the model stage
func (tremolo *Tremolo) UnstageVoid(stage *StageStruct) {
	delete(stage.Tremolos, tremolo)
	delete(stage.Tremolos_mapString, tremolo.Name)
}

// commit tremolo to the back repo (if it is already staged)
func (tremolo *Tremolo) Commit(stage *StageStruct) *Tremolo {
	if _, ok := stage.Tremolos[tremolo]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTremolo(tremolo)
		}
	}
	return tremolo
}

func (tremolo *Tremolo) CommitVoid(stage *StageStruct) {
	tremolo.Commit(stage)
}

// Checkout tremolo to the back repo (if it is already staged)
func (tremolo *Tremolo) Checkout(stage *StageStruct) *Tremolo {
	if _, ok := stage.Tremolos[tremolo]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTremolo(tremolo)
		}
	}
	return tremolo
}

// for satisfaction of GongStruct interface
func (tremolo *Tremolo) GetName() (res string) {
	return tremolo.Name
}

// Stage puts tuplet to the model stage
func (tuplet *Tuplet) Stage(stage *StageStruct) *Tuplet {
	stage.Tuplets[tuplet] = __member
	stage.Tuplets_mapString[tuplet.Name] = tuplet

	return tuplet
}

// Unstage removes tuplet off the model stage
func (tuplet *Tuplet) Unstage(stage *StageStruct) *Tuplet {
	delete(stage.Tuplets, tuplet)
	delete(stage.Tuplets_mapString, tuplet.Name)
	return tuplet
}

// UnstageVoid removes tuplet off the model stage
func (tuplet *Tuplet) UnstageVoid(stage *StageStruct) {
	delete(stage.Tuplets, tuplet)
	delete(stage.Tuplets_mapString, tuplet.Name)
}

// commit tuplet to the back repo (if it is already staged)
func (tuplet *Tuplet) Commit(stage *StageStruct) *Tuplet {
	if _, ok := stage.Tuplets[tuplet]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTuplet(tuplet)
		}
	}
	return tuplet
}

func (tuplet *Tuplet) CommitVoid(stage *StageStruct) {
	tuplet.Commit(stage)
}

// Checkout tuplet to the back repo (if it is already staged)
func (tuplet *Tuplet) Checkout(stage *StageStruct) *Tuplet {
	if _, ok := stage.Tuplets[tuplet]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTuplet(tuplet)
		}
	}
	return tuplet
}

// for satisfaction of GongStruct interface
func (tuplet *Tuplet) GetName() (res string) {
	return tuplet.Name
}

// Stage puts tuplet_dot to the model stage
func (tuplet_dot *Tuplet_dot) Stage(stage *StageStruct) *Tuplet_dot {
	stage.Tuplet_dots[tuplet_dot] = __member
	stage.Tuplet_dots_mapString[tuplet_dot.Name] = tuplet_dot

	return tuplet_dot
}

// Unstage removes tuplet_dot off the model stage
func (tuplet_dot *Tuplet_dot) Unstage(stage *StageStruct) *Tuplet_dot {
	delete(stage.Tuplet_dots, tuplet_dot)
	delete(stage.Tuplet_dots_mapString, tuplet_dot.Name)
	return tuplet_dot
}

// UnstageVoid removes tuplet_dot off the model stage
func (tuplet_dot *Tuplet_dot) UnstageVoid(stage *StageStruct) {
	delete(stage.Tuplet_dots, tuplet_dot)
	delete(stage.Tuplet_dots_mapString, tuplet_dot.Name)
}

// commit tuplet_dot to the back repo (if it is already staged)
func (tuplet_dot *Tuplet_dot) Commit(stage *StageStruct) *Tuplet_dot {
	if _, ok := stage.Tuplet_dots[tuplet_dot]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTuplet_dot(tuplet_dot)
		}
	}
	return tuplet_dot
}

func (tuplet_dot *Tuplet_dot) CommitVoid(stage *StageStruct) {
	tuplet_dot.Commit(stage)
}

// Checkout tuplet_dot to the back repo (if it is already staged)
func (tuplet_dot *Tuplet_dot) Checkout(stage *StageStruct) *Tuplet_dot {
	if _, ok := stage.Tuplet_dots[tuplet_dot]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTuplet_dot(tuplet_dot)
		}
	}
	return tuplet_dot
}

// for satisfaction of GongStruct interface
func (tuplet_dot *Tuplet_dot) GetName() (res string) {
	return tuplet_dot.Name
}

// Stage puts tuplet_number to the model stage
func (tuplet_number *Tuplet_number) Stage(stage *StageStruct) *Tuplet_number {
	stage.Tuplet_numbers[tuplet_number] = __member
	stage.Tuplet_numbers_mapString[tuplet_number.Name] = tuplet_number

	return tuplet_number
}

// Unstage removes tuplet_number off the model stage
func (tuplet_number *Tuplet_number) Unstage(stage *StageStruct) *Tuplet_number {
	delete(stage.Tuplet_numbers, tuplet_number)
	delete(stage.Tuplet_numbers_mapString, tuplet_number.Name)
	return tuplet_number
}

// UnstageVoid removes tuplet_number off the model stage
func (tuplet_number *Tuplet_number) UnstageVoid(stage *StageStruct) {
	delete(stage.Tuplet_numbers, tuplet_number)
	delete(stage.Tuplet_numbers_mapString, tuplet_number.Name)
}

// commit tuplet_number to the back repo (if it is already staged)
func (tuplet_number *Tuplet_number) Commit(stage *StageStruct) *Tuplet_number {
	if _, ok := stage.Tuplet_numbers[tuplet_number]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTuplet_number(tuplet_number)
		}
	}
	return tuplet_number
}

func (tuplet_number *Tuplet_number) CommitVoid(stage *StageStruct) {
	tuplet_number.Commit(stage)
}

// Checkout tuplet_number to the back repo (if it is already staged)
func (tuplet_number *Tuplet_number) Checkout(stage *StageStruct) *Tuplet_number {
	if _, ok := stage.Tuplet_numbers[tuplet_number]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTuplet_number(tuplet_number)
		}
	}
	return tuplet_number
}

// for satisfaction of GongStruct interface
func (tuplet_number *Tuplet_number) GetName() (res string) {
	return tuplet_number.Name
}

// Stage puts tuplet_portion to the model stage
func (tuplet_portion *Tuplet_portion) Stage(stage *StageStruct) *Tuplet_portion {
	stage.Tuplet_portions[tuplet_portion] = __member
	stage.Tuplet_portions_mapString[tuplet_portion.Name] = tuplet_portion

	return tuplet_portion
}

// Unstage removes tuplet_portion off the model stage
func (tuplet_portion *Tuplet_portion) Unstage(stage *StageStruct) *Tuplet_portion {
	delete(stage.Tuplet_portions, tuplet_portion)
	delete(stage.Tuplet_portions_mapString, tuplet_portion.Name)
	return tuplet_portion
}

// UnstageVoid removes tuplet_portion off the model stage
func (tuplet_portion *Tuplet_portion) UnstageVoid(stage *StageStruct) {
	delete(stage.Tuplet_portions, tuplet_portion)
	delete(stage.Tuplet_portions_mapString, tuplet_portion.Name)
}

// commit tuplet_portion to the back repo (if it is already staged)
func (tuplet_portion *Tuplet_portion) Commit(stage *StageStruct) *Tuplet_portion {
	if _, ok := stage.Tuplet_portions[tuplet_portion]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTuplet_portion(tuplet_portion)
		}
	}
	return tuplet_portion
}

func (tuplet_portion *Tuplet_portion) CommitVoid(stage *StageStruct) {
	tuplet_portion.Commit(stage)
}

// Checkout tuplet_portion to the back repo (if it is already staged)
func (tuplet_portion *Tuplet_portion) Checkout(stage *StageStruct) *Tuplet_portion {
	if _, ok := stage.Tuplet_portions[tuplet_portion]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTuplet_portion(tuplet_portion)
		}
	}
	return tuplet_portion
}

// for satisfaction of GongStruct interface
func (tuplet_portion *Tuplet_portion) GetName() (res string) {
	return tuplet_portion.Name
}

// Stage puts tuplet_type to the model stage
func (tuplet_type *Tuplet_type) Stage(stage *StageStruct) *Tuplet_type {
	stage.Tuplet_types[tuplet_type] = __member
	stage.Tuplet_types_mapString[tuplet_type.Name] = tuplet_type

	return tuplet_type
}

// Unstage removes tuplet_type off the model stage
func (tuplet_type *Tuplet_type) Unstage(stage *StageStruct) *Tuplet_type {
	delete(stage.Tuplet_types, tuplet_type)
	delete(stage.Tuplet_types_mapString, tuplet_type.Name)
	return tuplet_type
}

// UnstageVoid removes tuplet_type off the model stage
func (tuplet_type *Tuplet_type) UnstageVoid(stage *StageStruct) {
	delete(stage.Tuplet_types, tuplet_type)
	delete(stage.Tuplet_types_mapString, tuplet_type.Name)
}

// commit tuplet_type to the back repo (if it is already staged)
func (tuplet_type *Tuplet_type) Commit(stage *StageStruct) *Tuplet_type {
	if _, ok := stage.Tuplet_types[tuplet_type]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTuplet_type(tuplet_type)
		}
	}
	return tuplet_type
}

func (tuplet_type *Tuplet_type) CommitVoid(stage *StageStruct) {
	tuplet_type.Commit(stage)
}

// Checkout tuplet_type to the back repo (if it is already staged)
func (tuplet_type *Tuplet_type) Checkout(stage *StageStruct) *Tuplet_type {
	if _, ok := stage.Tuplet_types[tuplet_type]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTuplet_type(tuplet_type)
		}
	}
	return tuplet_type
}

// for satisfaction of GongStruct interface
func (tuplet_type *Tuplet_type) GetName() (res string) {
	return tuplet_type.Name
}

// Stage puts typed_text to the model stage
func (typed_text *Typed_text) Stage(stage *StageStruct) *Typed_text {
	stage.Typed_texts[typed_text] = __member
	stage.Typed_texts_mapString[typed_text.Name] = typed_text

	return typed_text
}

// Unstage removes typed_text off the model stage
func (typed_text *Typed_text) Unstage(stage *StageStruct) *Typed_text {
	delete(stage.Typed_texts, typed_text)
	delete(stage.Typed_texts_mapString, typed_text.Name)
	return typed_text
}

// UnstageVoid removes typed_text off the model stage
func (typed_text *Typed_text) UnstageVoid(stage *StageStruct) {
	delete(stage.Typed_texts, typed_text)
	delete(stage.Typed_texts_mapString, typed_text.Name)
}

// commit typed_text to the back repo (if it is already staged)
func (typed_text *Typed_text) Commit(stage *StageStruct) *Typed_text {
	if _, ok := stage.Typed_texts[typed_text]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitTyped_text(typed_text)
		}
	}
	return typed_text
}

func (typed_text *Typed_text) CommitVoid(stage *StageStruct) {
	typed_text.Commit(stage)
}

// Checkout typed_text to the back repo (if it is already staged)
func (typed_text *Typed_text) Checkout(stage *StageStruct) *Typed_text {
	if _, ok := stage.Typed_texts[typed_text]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutTyped_text(typed_text)
		}
	}
	return typed_text
}

// for satisfaction of GongStruct interface
func (typed_text *Typed_text) GetName() (res string) {
	return typed_text.Name
}

// Stage puts unpitched to the model stage
func (unpitched *Unpitched) Stage(stage *StageStruct) *Unpitched {
	stage.Unpitcheds[unpitched] = __member
	stage.Unpitcheds_mapString[unpitched.Name] = unpitched

	return unpitched
}

// Unstage removes unpitched off the model stage
func (unpitched *Unpitched) Unstage(stage *StageStruct) *Unpitched {
	delete(stage.Unpitcheds, unpitched)
	delete(stage.Unpitcheds_mapString, unpitched.Name)
	return unpitched
}

// UnstageVoid removes unpitched off the model stage
func (unpitched *Unpitched) UnstageVoid(stage *StageStruct) {
	delete(stage.Unpitcheds, unpitched)
	delete(stage.Unpitcheds_mapString, unpitched.Name)
}

// commit unpitched to the back repo (if it is already staged)
func (unpitched *Unpitched) Commit(stage *StageStruct) *Unpitched {
	if _, ok := stage.Unpitcheds[unpitched]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitUnpitched(unpitched)
		}
	}
	return unpitched
}

func (unpitched *Unpitched) CommitVoid(stage *StageStruct) {
	unpitched.Commit(stage)
}

// Checkout unpitched to the back repo (if it is already staged)
func (unpitched *Unpitched) Checkout(stage *StageStruct) *Unpitched {
	if _, ok := stage.Unpitcheds[unpitched]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutUnpitched(unpitched)
		}
	}
	return unpitched
}

// for satisfaction of GongStruct interface
func (unpitched *Unpitched) GetName() (res string) {
	return unpitched.Name
}

// Stage puts virtual_instrument to the model stage
func (virtual_instrument *Virtual_instrument) Stage(stage *StageStruct) *Virtual_instrument {
	stage.Virtual_instruments[virtual_instrument] = __member
	stage.Virtual_instruments_mapString[virtual_instrument.Name] = virtual_instrument

	return virtual_instrument
}

// Unstage removes virtual_instrument off the model stage
func (virtual_instrument *Virtual_instrument) Unstage(stage *StageStruct) *Virtual_instrument {
	delete(stage.Virtual_instruments, virtual_instrument)
	delete(stage.Virtual_instruments_mapString, virtual_instrument.Name)
	return virtual_instrument
}

// UnstageVoid removes virtual_instrument off the model stage
func (virtual_instrument *Virtual_instrument) UnstageVoid(stage *StageStruct) {
	delete(stage.Virtual_instruments, virtual_instrument)
	delete(stage.Virtual_instruments_mapString, virtual_instrument.Name)
}

// commit virtual_instrument to the back repo (if it is already staged)
func (virtual_instrument *Virtual_instrument) Commit(stage *StageStruct) *Virtual_instrument {
	if _, ok := stage.Virtual_instruments[virtual_instrument]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitVirtual_instrument(virtual_instrument)
		}
	}
	return virtual_instrument
}

func (virtual_instrument *Virtual_instrument) CommitVoid(stage *StageStruct) {
	virtual_instrument.Commit(stage)
}

// Checkout virtual_instrument to the back repo (if it is already staged)
func (virtual_instrument *Virtual_instrument) Checkout(stage *StageStruct) *Virtual_instrument {
	if _, ok := stage.Virtual_instruments[virtual_instrument]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutVirtual_instrument(virtual_instrument)
		}
	}
	return virtual_instrument
}

// for satisfaction of GongStruct interface
func (virtual_instrument *Virtual_instrument) GetName() (res string) {
	return virtual_instrument.Name
}

// Stage puts wait to the model stage
func (wait *Wait) Stage(stage *StageStruct) *Wait {
	stage.Waits[wait] = __member
	stage.Waits_mapString[wait.Name] = wait

	return wait
}

// Unstage removes wait off the model stage
func (wait *Wait) Unstage(stage *StageStruct) *Wait {
	delete(stage.Waits, wait)
	delete(stage.Waits_mapString, wait.Name)
	return wait
}

// UnstageVoid removes wait off the model stage
func (wait *Wait) UnstageVoid(stage *StageStruct) {
	delete(stage.Waits, wait)
	delete(stage.Waits_mapString, wait.Name)
}

// commit wait to the back repo (if it is already staged)
func (wait *Wait) Commit(stage *StageStruct) *Wait {
	if _, ok := stage.Waits[wait]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitWait(wait)
		}
	}
	return wait
}

func (wait *Wait) CommitVoid(stage *StageStruct) {
	wait.Commit(stage)
}

// Checkout wait to the back repo (if it is already staged)
func (wait *Wait) Checkout(stage *StageStruct) *Wait {
	if _, ok := stage.Waits[wait]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutWait(wait)
		}
	}
	return wait
}

// for satisfaction of GongStruct interface
func (wait *Wait) GetName() (res string) {
	return wait.Name
}

// Stage puts wavy_line to the model stage
func (wavy_line *Wavy_line) Stage(stage *StageStruct) *Wavy_line {
	stage.Wavy_lines[wavy_line] = __member
	stage.Wavy_lines_mapString[wavy_line.Name] = wavy_line

	return wavy_line
}

// Unstage removes wavy_line off the model stage
func (wavy_line *Wavy_line) Unstage(stage *StageStruct) *Wavy_line {
	delete(stage.Wavy_lines, wavy_line)
	delete(stage.Wavy_lines_mapString, wavy_line.Name)
	return wavy_line
}

// UnstageVoid removes wavy_line off the model stage
func (wavy_line *Wavy_line) UnstageVoid(stage *StageStruct) {
	delete(stage.Wavy_lines, wavy_line)
	delete(stage.Wavy_lines_mapString, wavy_line.Name)
}

// commit wavy_line to the back repo (if it is already staged)
func (wavy_line *Wavy_line) Commit(stage *StageStruct) *Wavy_line {
	if _, ok := stage.Wavy_lines[wavy_line]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitWavy_line(wavy_line)
		}
	}
	return wavy_line
}

func (wavy_line *Wavy_line) CommitVoid(stage *StageStruct) {
	wavy_line.Commit(stage)
}

// Checkout wavy_line to the back repo (if it is already staged)
func (wavy_line *Wavy_line) Checkout(stage *StageStruct) *Wavy_line {
	if _, ok := stage.Wavy_lines[wavy_line]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutWavy_line(wavy_line)
		}
	}
	return wavy_line
}

// for satisfaction of GongStruct interface
func (wavy_line *Wavy_line) GetName() (res string) {
	return wavy_line.Name
}

// Stage puts wedge to the model stage
func (wedge *Wedge) Stage(stage *StageStruct) *Wedge {
	stage.Wedges[wedge] = __member
	stage.Wedges_mapString[wedge.Name] = wedge

	return wedge
}

// Unstage removes wedge off the model stage
func (wedge *Wedge) Unstage(stage *StageStruct) *Wedge {
	delete(stage.Wedges, wedge)
	delete(stage.Wedges_mapString, wedge.Name)
	return wedge
}

// UnstageVoid removes wedge off the model stage
func (wedge *Wedge) UnstageVoid(stage *StageStruct) {
	delete(stage.Wedges, wedge)
	delete(stage.Wedges_mapString, wedge.Name)
}

// commit wedge to the back repo (if it is already staged)
func (wedge *Wedge) Commit(stage *StageStruct) *Wedge {
	if _, ok := stage.Wedges[wedge]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitWedge(wedge)
		}
	}
	return wedge
}

func (wedge *Wedge) CommitVoid(stage *StageStruct) {
	wedge.Commit(stage)
}

// Checkout wedge to the back repo (if it is already staged)
func (wedge *Wedge) Checkout(stage *StageStruct) *Wedge {
	if _, ok := stage.Wedges[wedge]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutWedge(wedge)
		}
	}
	return wedge
}

// for satisfaction of GongStruct interface
func (wedge *Wedge) GetName() (res string) {
	return wedge.Name
}

// Stage puts wood to the model stage
func (wood *Wood) Stage(stage *StageStruct) *Wood {
	stage.Woods[wood] = __member
	stage.Woods_mapString[wood.Name] = wood

	return wood
}

// Unstage removes wood off the model stage
func (wood *Wood) Unstage(stage *StageStruct) *Wood {
	delete(stage.Woods, wood)
	delete(stage.Woods_mapString, wood.Name)
	return wood
}

// UnstageVoid removes wood off the model stage
func (wood *Wood) UnstageVoid(stage *StageStruct) {
	delete(stage.Woods, wood)
	delete(stage.Woods_mapString, wood.Name)
}

// commit wood to the back repo (if it is already staged)
func (wood *Wood) Commit(stage *StageStruct) *Wood {
	if _, ok := stage.Woods[wood]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitWood(wood)
		}
	}
	return wood
}

func (wood *Wood) CommitVoid(stage *StageStruct) {
	wood.Commit(stage)
}

// Checkout wood to the back repo (if it is already staged)
func (wood *Wood) Checkout(stage *StageStruct) *Wood {
	if _, ok := stage.Woods[wood]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutWood(wood)
		}
	}
	return wood
}

// for satisfaction of GongStruct interface
func (wood *Wood) GetName() (res string) {
	return wood.Name
}

// Stage puts work to the model stage
func (work *Work) Stage(stage *StageStruct) *Work {
	stage.Works[work] = __member
	stage.Works_mapString[work.Name] = work

	return work
}

// Unstage removes work off the model stage
func (work *Work) Unstage(stage *StageStruct) *Work {
	delete(stage.Works, work)
	delete(stage.Works_mapString, work.Name)
	return work
}

// UnstageVoid removes work off the model stage
func (work *Work) UnstageVoid(stage *StageStruct) {
	delete(stage.Works, work)
	delete(stage.Works_mapString, work.Name)
}

// commit work to the back repo (if it is already staged)
func (work *Work) Commit(stage *StageStruct) *Work {
	if _, ok := stage.Works[work]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CommitWork(work)
		}
	}
	return work
}

func (work *Work) CommitVoid(stage *StageStruct) {
	work.Commit(stage)
}

// Checkout work to the back repo (if it is already staged)
func (work *Work) Checkout(stage *StageStruct) *Work {
	if _, ok := stage.Works[work]; ok {
		if stage.BackRepo != nil {
			stage.BackRepo.CheckoutWork(work)
		}
	}
	return work
}

// for satisfaction of GongStruct interface
func (work *Work) GetName() (res string) {
	return work.Name
}

// swagger:ignore
type AllModelsStructCreateInterface interface { // insertion point for Callbacks on creation
	CreateORMAccidental(Accidental *Accidental)
	CreateORMAccidental_mark(Accidental_mark *Accidental_mark)
	CreateORMAccidental_text(Accidental_text *Accidental_text)
	CreateORMAccord(Accord *Accord)
	CreateORMAccordion_registration(Accordion_registration *Accordion_registration)
	CreateORMAnyType(AnyType *AnyType)
	CreateORMAppearance(Appearance *Appearance)
	CreateORMArpeggiate(Arpeggiate *Arpeggiate)
	CreateORMArrow(Arrow *Arrow)
	CreateORMArticulations(Articulations *Articulations)
	CreateORMAssess(Assess *Assess)
	CreateORMAttributes(Attributes *Attributes)
	CreateORMBackup(Backup *Backup)
	CreateORMBar_style_color(Bar_style_color *Bar_style_color)
	CreateORMBarline(Barline *Barline)
	CreateORMBarre(Barre *Barre)
	CreateORMBass(Bass *Bass)
	CreateORMBass_step(Bass_step *Bass_step)
	CreateORMBeam(Beam *Beam)
	CreateORMBeat_repeat(Beat_repeat *Beat_repeat)
	CreateORMBeat_unit_tied(Beat_unit_tied *Beat_unit_tied)
	CreateORMBeater(Beater *Beater)
	CreateORMBend(Bend *Bend)
	CreateORMBookmark(Bookmark *Bookmark)
	CreateORMBracket(Bracket *Bracket)
	CreateORMBreath_mark(Breath_mark *Breath_mark)
	CreateORMCaesura(Caesura *Caesura)
	CreateORMCancel(Cancel *Cancel)
	CreateORMClef(Clef *Clef)
	CreateORMCoda(Coda *Coda)
	CreateORMCredit(Credit *Credit)
	CreateORMDashes(Dashes *Dashes)
	CreateORMDefaults(Defaults *Defaults)
	CreateORMDegree(Degree *Degree)
	CreateORMDegree_alter(Degree_alter *Degree_alter)
	CreateORMDegree_type(Degree_type *Degree_type)
	CreateORMDegree_value(Degree_value *Degree_value)
	CreateORMDirection(Direction *Direction)
	CreateORMDirection_type(Direction_type *Direction_type)
	CreateORMDistance(Distance *Distance)
	CreateORMDouble(Double *Double)
	CreateORMDynamics(Dynamics *Dynamics)
	CreateORMEffect(Effect *Effect)
	CreateORMElision(Elision *Elision)
	CreateORMEmpty(Empty *Empty)
	CreateORMEmpty_font(Empty_font *Empty_font)
	CreateORMEmpty_line(Empty_line *Empty_line)
	CreateORMEmpty_placement(Empty_placement *Empty_placement)
	CreateORMEmpty_placement_smufl(Empty_placement_smufl *Empty_placement_smufl)
	CreateORMEmpty_print_object_style_align(Empty_print_object_style_align *Empty_print_object_style_align)
	CreateORMEmpty_print_style(Empty_print_style *Empty_print_style)
	CreateORMEmpty_print_style_align(Empty_print_style_align *Empty_print_style_align)
	CreateORMEmpty_print_style_align_id(Empty_print_style_align_id *Empty_print_style_align_id)
	CreateORMEmpty_trill_sound(Empty_trill_sound *Empty_trill_sound)
	CreateORMEncoding(Encoding *Encoding)
	CreateORMEnding(Ending *Ending)
	CreateORMExtend(Extend *Extend)
	CreateORMFeature(Feature *Feature)
	CreateORMFermata(Fermata *Fermata)
	CreateORMFigure(Figure *Figure)
	CreateORMFigured_bass(Figured_bass *Figured_bass)
	CreateORMFingering(Fingering *Fingering)
	CreateORMFirst_fret(First_fret *First_fret)
	CreateORMFoo(Foo *Foo)
	CreateORMFor_part(For_part *For_part)
	CreateORMFormatted_symbol(Formatted_symbol *Formatted_symbol)
	CreateORMFormatted_symbol_id(Formatted_symbol_id *Formatted_symbol_id)
	CreateORMForward(Forward *Forward)
	CreateORMFrame(Frame *Frame)
	CreateORMFrame_note(Frame_note *Frame_note)
	CreateORMFret(Fret *Fret)
	CreateORMGlass(Glass *Glass)
	CreateORMGlissando(Glissando *Glissando)
	CreateORMGlyph(Glyph *Glyph)
	CreateORMGrace(Grace *Grace)
	CreateORMGroup_barline(Group_barline *Group_barline)
	CreateORMGroup_symbol(Group_symbol *Group_symbol)
	CreateORMGrouping(Grouping *Grouping)
	CreateORMHammer_on_pull_off(Hammer_on_pull_off *Hammer_on_pull_off)
	CreateORMHandbell(Handbell *Handbell)
	CreateORMHarmon_closed(Harmon_closed *Harmon_closed)
	CreateORMHarmon_mute(Harmon_mute *Harmon_mute)
	CreateORMHarmonic(Harmonic *Harmonic)
	CreateORMHarmony(Harmony *Harmony)
	CreateORMHarmony_alter(Harmony_alter *Harmony_alter)
	CreateORMHarp_pedals(Harp_pedals *Harp_pedals)
	CreateORMHeel_toe(Heel_toe *Heel_toe)
	CreateORMHole(Hole *Hole)
	CreateORMHole_closed(Hole_closed *Hole_closed)
	CreateORMHorizontal_turn(Horizontal_turn *Horizontal_turn)
	CreateORMIdentification(Identification *Identification)
	CreateORMImage(Image *Image)
	CreateORMInstrument(Instrument *Instrument)
	CreateORMInstrument_change(Instrument_change *Instrument_change)
	CreateORMInstrument_link(Instrument_link *Instrument_link)
	CreateORMInterchangeable(Interchangeable *Interchangeable)
	CreateORMInversion(Inversion *Inversion)
	CreateORMKey(Key *Key)
	CreateORMKey_accidental(Key_accidental *Key_accidental)
	CreateORMKey_octave(Key_octave *Key_octave)
	CreateORMKind(Kind *Kind)
	CreateORMLevel(Level *Level)
	CreateORMLine_detail(Line_detail *Line_detail)
	CreateORMLine_width(Line_width *Line_width)
	CreateORMLink(Link *Link)
	CreateORMListen(Listen *Listen)
	CreateORMListening(Listening *Listening)
	CreateORMLyric(Lyric *Lyric)
	CreateORMLyric_font(Lyric_font *Lyric_font)
	CreateORMLyric_language(Lyric_language *Lyric_language)
	CreateORMMeasure_layout(Measure_layout *Measure_layout)
	CreateORMMeasure_numbering(Measure_numbering *Measure_numbering)
	CreateORMMeasure_repeat(Measure_repeat *Measure_repeat)
	CreateORMMeasure_style(Measure_style *Measure_style)
	CreateORMMembrane(Membrane *Membrane)
	CreateORMMetal(Metal *Metal)
	CreateORMMetronome(Metronome *Metronome)
	CreateORMMetronome_beam(Metronome_beam *Metronome_beam)
	CreateORMMetronome_note(Metronome_note *Metronome_note)
	CreateORMMetronome_tied(Metronome_tied *Metronome_tied)
	CreateORMMetronome_tuplet(Metronome_tuplet *Metronome_tuplet)
	CreateORMMidi_device(Midi_device *Midi_device)
	CreateORMMidi_instrument(Midi_instrument *Midi_instrument)
	CreateORMMiscellaneous(Miscellaneous *Miscellaneous)
	CreateORMMiscellaneous_field(Miscellaneous_field *Miscellaneous_field)
	CreateORMMordent(Mordent *Mordent)
	CreateORMMultiple_rest(Multiple_rest *Multiple_rest)
	CreateORMName_display(Name_display *Name_display)
	CreateORMNon_arpeggiate(Non_arpeggiate *Non_arpeggiate)
	CreateORMNotations(Notations *Notations)
	CreateORMNote(Note *Note)
	CreateORMNote_size(Note_size *Note_size)
	CreateORMNote_type(Note_type *Note_type)
	CreateORMNotehead(Notehead *Notehead)
	CreateORMNotehead_text(Notehead_text *Notehead_text)
	CreateORMNumeral(Numeral *Numeral)
	CreateORMNumeral_key(Numeral_key *Numeral_key)
	CreateORMNumeral_root(Numeral_root *Numeral_root)
	CreateORMOctave_shift(Octave_shift *Octave_shift)
	CreateORMOffset(Offset *Offset)
	CreateORMOpus(Opus *Opus)
	CreateORMOrnaments(Ornaments *Ornaments)
	CreateORMOther_appearance(Other_appearance *Other_appearance)
	CreateORMOther_listening(Other_listening *Other_listening)
	CreateORMOther_notation(Other_notation *Other_notation)
	CreateORMOther_play(Other_play *Other_play)
	CreateORMPage_layout(Page_layout *Page_layout)
	CreateORMPage_margins(Page_margins *Page_margins)
	CreateORMPart_clef(Part_clef *Part_clef)
	CreateORMPart_group(Part_group *Part_group)
	CreateORMPart_link(Part_link *Part_link)
	CreateORMPart_list(Part_list *Part_list)
	CreateORMPart_symbol(Part_symbol *Part_symbol)
	CreateORMPart_transpose(Part_transpose *Part_transpose)
	CreateORMPedal(Pedal *Pedal)
	CreateORMPedal_tuning(Pedal_tuning *Pedal_tuning)
	CreateORMPercussion(Percussion *Percussion)
	CreateORMPitch(Pitch *Pitch)
	CreateORMPitched(Pitched *Pitched)
	CreateORMPlay(Play *Play)
	CreateORMPlayer(Player *Player)
	CreateORMPrincipal_voice(Principal_voice *Principal_voice)
	CreateORMPrint(Print *Print)
	CreateORMRelease(Release *Release)
	CreateORMRepeat(Repeat *Repeat)
	CreateORMRest(Rest *Rest)
	CreateORMRoot(Root *Root)
	CreateORMRoot_step(Root_step *Root_step)
	CreateORMScaling(Scaling *Scaling)
	CreateORMScordatura(Scordatura *Scordatura)
	CreateORMScore_instrument(Score_instrument *Score_instrument)
	CreateORMScore_part(Score_part *Score_part)
	CreateORMScore_partwise(Score_partwise *Score_partwise)
	CreateORMScore_timewise(Score_timewise *Score_timewise)
	CreateORMSegno(Segno *Segno)
	CreateORMSlash(Slash *Slash)
	CreateORMSlide(Slide *Slide)
	CreateORMSlur(Slur *Slur)
	CreateORMSound(Sound *Sound)
	CreateORMStaff_details(Staff_details *Staff_details)
	CreateORMStaff_divide(Staff_divide *Staff_divide)
	CreateORMStaff_layout(Staff_layout *Staff_layout)
	CreateORMStaff_size(Staff_size *Staff_size)
	CreateORMStaff_tuning(Staff_tuning *Staff_tuning)
	CreateORMStem(Stem *Stem)
	CreateORMStick(Stick *Stick)
	CreateORMString_mute(String_mute *String_mute)
	CreateORMStrong_accent(Strong_accent *Strong_accent)
	CreateORMSupports(Supports *Supports)
	CreateORMSwing(Swing *Swing)
	CreateORMSync(Sync *Sync)
	CreateORMSystem_dividers(System_dividers *System_dividers)
	CreateORMSystem_layout(System_layout *System_layout)
	CreateORMSystem_margins(System_margins *System_margins)
	CreateORMTap(Tap *Tap)
	CreateORMTechnical(Technical *Technical)
	CreateORMText_element_data(Text_element_data *Text_element_data)
	CreateORMTie(Tie *Tie)
	CreateORMTied(Tied *Tied)
	CreateORMTime(Time *Time)
	CreateORMTime_modification(Time_modification *Time_modification)
	CreateORMTimpani(Timpani *Timpani)
	CreateORMTranspose(Transpose *Transpose)
	CreateORMTremolo(Tremolo *Tremolo)
	CreateORMTuplet(Tuplet *Tuplet)
	CreateORMTuplet_dot(Tuplet_dot *Tuplet_dot)
	CreateORMTuplet_number(Tuplet_number *Tuplet_number)
	CreateORMTuplet_portion(Tuplet_portion *Tuplet_portion)
	CreateORMTuplet_type(Tuplet_type *Tuplet_type)
	CreateORMTyped_text(Typed_text *Typed_text)
	CreateORMUnpitched(Unpitched *Unpitched)
	CreateORMVirtual_instrument(Virtual_instrument *Virtual_instrument)
	CreateORMWait(Wait *Wait)
	CreateORMWavy_line(Wavy_line *Wavy_line)
	CreateORMWedge(Wedge *Wedge)
	CreateORMWood(Wood *Wood)
	CreateORMWork(Work *Work)
}

type AllModelsStructDeleteInterface interface { // insertion point for Callbacks on deletion
	DeleteORMAccidental(Accidental *Accidental)
	DeleteORMAccidental_mark(Accidental_mark *Accidental_mark)
	DeleteORMAccidental_text(Accidental_text *Accidental_text)
	DeleteORMAccord(Accord *Accord)
	DeleteORMAccordion_registration(Accordion_registration *Accordion_registration)
	DeleteORMAnyType(AnyType *AnyType)
	DeleteORMAppearance(Appearance *Appearance)
	DeleteORMArpeggiate(Arpeggiate *Arpeggiate)
	DeleteORMArrow(Arrow *Arrow)
	DeleteORMArticulations(Articulations *Articulations)
	DeleteORMAssess(Assess *Assess)
	DeleteORMAttributes(Attributes *Attributes)
	DeleteORMBackup(Backup *Backup)
	DeleteORMBar_style_color(Bar_style_color *Bar_style_color)
	DeleteORMBarline(Barline *Barline)
	DeleteORMBarre(Barre *Barre)
	DeleteORMBass(Bass *Bass)
	DeleteORMBass_step(Bass_step *Bass_step)
	DeleteORMBeam(Beam *Beam)
	DeleteORMBeat_repeat(Beat_repeat *Beat_repeat)
	DeleteORMBeat_unit_tied(Beat_unit_tied *Beat_unit_tied)
	DeleteORMBeater(Beater *Beater)
	DeleteORMBend(Bend *Bend)
	DeleteORMBookmark(Bookmark *Bookmark)
	DeleteORMBracket(Bracket *Bracket)
	DeleteORMBreath_mark(Breath_mark *Breath_mark)
	DeleteORMCaesura(Caesura *Caesura)
	DeleteORMCancel(Cancel *Cancel)
	DeleteORMClef(Clef *Clef)
	DeleteORMCoda(Coda *Coda)
	DeleteORMCredit(Credit *Credit)
	DeleteORMDashes(Dashes *Dashes)
	DeleteORMDefaults(Defaults *Defaults)
	DeleteORMDegree(Degree *Degree)
	DeleteORMDegree_alter(Degree_alter *Degree_alter)
	DeleteORMDegree_type(Degree_type *Degree_type)
	DeleteORMDegree_value(Degree_value *Degree_value)
	DeleteORMDirection(Direction *Direction)
	DeleteORMDirection_type(Direction_type *Direction_type)
	DeleteORMDistance(Distance *Distance)
	DeleteORMDouble(Double *Double)
	DeleteORMDynamics(Dynamics *Dynamics)
	DeleteORMEffect(Effect *Effect)
	DeleteORMElision(Elision *Elision)
	DeleteORMEmpty(Empty *Empty)
	DeleteORMEmpty_font(Empty_font *Empty_font)
	DeleteORMEmpty_line(Empty_line *Empty_line)
	DeleteORMEmpty_placement(Empty_placement *Empty_placement)
	DeleteORMEmpty_placement_smufl(Empty_placement_smufl *Empty_placement_smufl)
	DeleteORMEmpty_print_object_style_align(Empty_print_object_style_align *Empty_print_object_style_align)
	DeleteORMEmpty_print_style(Empty_print_style *Empty_print_style)
	DeleteORMEmpty_print_style_align(Empty_print_style_align *Empty_print_style_align)
	DeleteORMEmpty_print_style_align_id(Empty_print_style_align_id *Empty_print_style_align_id)
	DeleteORMEmpty_trill_sound(Empty_trill_sound *Empty_trill_sound)
	DeleteORMEncoding(Encoding *Encoding)
	DeleteORMEnding(Ending *Ending)
	DeleteORMExtend(Extend *Extend)
	DeleteORMFeature(Feature *Feature)
	DeleteORMFermata(Fermata *Fermata)
	DeleteORMFigure(Figure *Figure)
	DeleteORMFigured_bass(Figured_bass *Figured_bass)
	DeleteORMFingering(Fingering *Fingering)
	DeleteORMFirst_fret(First_fret *First_fret)
	DeleteORMFoo(Foo *Foo)
	DeleteORMFor_part(For_part *For_part)
	DeleteORMFormatted_symbol(Formatted_symbol *Formatted_symbol)
	DeleteORMFormatted_symbol_id(Formatted_symbol_id *Formatted_symbol_id)
	DeleteORMForward(Forward *Forward)
	DeleteORMFrame(Frame *Frame)
	DeleteORMFrame_note(Frame_note *Frame_note)
	DeleteORMFret(Fret *Fret)
	DeleteORMGlass(Glass *Glass)
	DeleteORMGlissando(Glissando *Glissando)
	DeleteORMGlyph(Glyph *Glyph)
	DeleteORMGrace(Grace *Grace)
	DeleteORMGroup_barline(Group_barline *Group_barline)
	DeleteORMGroup_symbol(Group_symbol *Group_symbol)
	DeleteORMGrouping(Grouping *Grouping)
	DeleteORMHammer_on_pull_off(Hammer_on_pull_off *Hammer_on_pull_off)
	DeleteORMHandbell(Handbell *Handbell)
	DeleteORMHarmon_closed(Harmon_closed *Harmon_closed)
	DeleteORMHarmon_mute(Harmon_mute *Harmon_mute)
	DeleteORMHarmonic(Harmonic *Harmonic)
	DeleteORMHarmony(Harmony *Harmony)
	DeleteORMHarmony_alter(Harmony_alter *Harmony_alter)
	DeleteORMHarp_pedals(Harp_pedals *Harp_pedals)
	DeleteORMHeel_toe(Heel_toe *Heel_toe)
	DeleteORMHole(Hole *Hole)
	DeleteORMHole_closed(Hole_closed *Hole_closed)
	DeleteORMHorizontal_turn(Horizontal_turn *Horizontal_turn)
	DeleteORMIdentification(Identification *Identification)
	DeleteORMImage(Image *Image)
	DeleteORMInstrument(Instrument *Instrument)
	DeleteORMInstrument_change(Instrument_change *Instrument_change)
	DeleteORMInstrument_link(Instrument_link *Instrument_link)
	DeleteORMInterchangeable(Interchangeable *Interchangeable)
	DeleteORMInversion(Inversion *Inversion)
	DeleteORMKey(Key *Key)
	DeleteORMKey_accidental(Key_accidental *Key_accidental)
	DeleteORMKey_octave(Key_octave *Key_octave)
	DeleteORMKind(Kind *Kind)
	DeleteORMLevel(Level *Level)
	DeleteORMLine_detail(Line_detail *Line_detail)
	DeleteORMLine_width(Line_width *Line_width)
	DeleteORMLink(Link *Link)
	DeleteORMListen(Listen *Listen)
	DeleteORMListening(Listening *Listening)
	DeleteORMLyric(Lyric *Lyric)
	DeleteORMLyric_font(Lyric_font *Lyric_font)
	DeleteORMLyric_language(Lyric_language *Lyric_language)
	DeleteORMMeasure_layout(Measure_layout *Measure_layout)
	DeleteORMMeasure_numbering(Measure_numbering *Measure_numbering)
	DeleteORMMeasure_repeat(Measure_repeat *Measure_repeat)
	DeleteORMMeasure_style(Measure_style *Measure_style)
	DeleteORMMembrane(Membrane *Membrane)
	DeleteORMMetal(Metal *Metal)
	DeleteORMMetronome(Metronome *Metronome)
	DeleteORMMetronome_beam(Metronome_beam *Metronome_beam)
	DeleteORMMetronome_note(Metronome_note *Metronome_note)
	DeleteORMMetronome_tied(Metronome_tied *Metronome_tied)
	DeleteORMMetronome_tuplet(Metronome_tuplet *Metronome_tuplet)
	DeleteORMMidi_device(Midi_device *Midi_device)
	DeleteORMMidi_instrument(Midi_instrument *Midi_instrument)
	DeleteORMMiscellaneous(Miscellaneous *Miscellaneous)
	DeleteORMMiscellaneous_field(Miscellaneous_field *Miscellaneous_field)
	DeleteORMMordent(Mordent *Mordent)
	DeleteORMMultiple_rest(Multiple_rest *Multiple_rest)
	DeleteORMName_display(Name_display *Name_display)
	DeleteORMNon_arpeggiate(Non_arpeggiate *Non_arpeggiate)
	DeleteORMNotations(Notations *Notations)
	DeleteORMNote(Note *Note)
	DeleteORMNote_size(Note_size *Note_size)
	DeleteORMNote_type(Note_type *Note_type)
	DeleteORMNotehead(Notehead *Notehead)
	DeleteORMNotehead_text(Notehead_text *Notehead_text)
	DeleteORMNumeral(Numeral *Numeral)
	DeleteORMNumeral_key(Numeral_key *Numeral_key)
	DeleteORMNumeral_root(Numeral_root *Numeral_root)
	DeleteORMOctave_shift(Octave_shift *Octave_shift)
	DeleteORMOffset(Offset *Offset)
	DeleteORMOpus(Opus *Opus)
	DeleteORMOrnaments(Ornaments *Ornaments)
	DeleteORMOther_appearance(Other_appearance *Other_appearance)
	DeleteORMOther_listening(Other_listening *Other_listening)
	DeleteORMOther_notation(Other_notation *Other_notation)
	DeleteORMOther_play(Other_play *Other_play)
	DeleteORMPage_layout(Page_layout *Page_layout)
	DeleteORMPage_margins(Page_margins *Page_margins)
	DeleteORMPart_clef(Part_clef *Part_clef)
	DeleteORMPart_group(Part_group *Part_group)
	DeleteORMPart_link(Part_link *Part_link)
	DeleteORMPart_list(Part_list *Part_list)
	DeleteORMPart_symbol(Part_symbol *Part_symbol)
	DeleteORMPart_transpose(Part_transpose *Part_transpose)
	DeleteORMPedal(Pedal *Pedal)
	DeleteORMPedal_tuning(Pedal_tuning *Pedal_tuning)
	DeleteORMPercussion(Percussion *Percussion)
	DeleteORMPitch(Pitch *Pitch)
	DeleteORMPitched(Pitched *Pitched)
	DeleteORMPlay(Play *Play)
	DeleteORMPlayer(Player *Player)
	DeleteORMPrincipal_voice(Principal_voice *Principal_voice)
	DeleteORMPrint(Print *Print)
	DeleteORMRelease(Release *Release)
	DeleteORMRepeat(Repeat *Repeat)
	DeleteORMRest(Rest *Rest)
	DeleteORMRoot(Root *Root)
	DeleteORMRoot_step(Root_step *Root_step)
	DeleteORMScaling(Scaling *Scaling)
	DeleteORMScordatura(Scordatura *Scordatura)
	DeleteORMScore_instrument(Score_instrument *Score_instrument)
	DeleteORMScore_part(Score_part *Score_part)
	DeleteORMScore_partwise(Score_partwise *Score_partwise)
	DeleteORMScore_timewise(Score_timewise *Score_timewise)
	DeleteORMSegno(Segno *Segno)
	DeleteORMSlash(Slash *Slash)
	DeleteORMSlide(Slide *Slide)
	DeleteORMSlur(Slur *Slur)
	DeleteORMSound(Sound *Sound)
	DeleteORMStaff_details(Staff_details *Staff_details)
	DeleteORMStaff_divide(Staff_divide *Staff_divide)
	DeleteORMStaff_layout(Staff_layout *Staff_layout)
	DeleteORMStaff_size(Staff_size *Staff_size)
	DeleteORMStaff_tuning(Staff_tuning *Staff_tuning)
	DeleteORMStem(Stem *Stem)
	DeleteORMStick(Stick *Stick)
	DeleteORMString_mute(String_mute *String_mute)
	DeleteORMStrong_accent(Strong_accent *Strong_accent)
	DeleteORMSupports(Supports *Supports)
	DeleteORMSwing(Swing *Swing)
	DeleteORMSync(Sync *Sync)
	DeleteORMSystem_dividers(System_dividers *System_dividers)
	DeleteORMSystem_layout(System_layout *System_layout)
	DeleteORMSystem_margins(System_margins *System_margins)
	DeleteORMTap(Tap *Tap)
	DeleteORMTechnical(Technical *Technical)
	DeleteORMText_element_data(Text_element_data *Text_element_data)
	DeleteORMTie(Tie *Tie)
	DeleteORMTied(Tied *Tied)
	DeleteORMTime(Time *Time)
	DeleteORMTime_modification(Time_modification *Time_modification)
	DeleteORMTimpani(Timpani *Timpani)
	DeleteORMTranspose(Transpose *Transpose)
	DeleteORMTremolo(Tremolo *Tremolo)
	DeleteORMTuplet(Tuplet *Tuplet)
	DeleteORMTuplet_dot(Tuplet_dot *Tuplet_dot)
	DeleteORMTuplet_number(Tuplet_number *Tuplet_number)
	DeleteORMTuplet_portion(Tuplet_portion *Tuplet_portion)
	DeleteORMTuplet_type(Tuplet_type *Tuplet_type)
	DeleteORMTyped_text(Typed_text *Typed_text)
	DeleteORMUnpitched(Unpitched *Unpitched)
	DeleteORMVirtual_instrument(Virtual_instrument *Virtual_instrument)
	DeleteORMWait(Wait *Wait)
	DeleteORMWavy_line(Wavy_line *Wavy_line)
	DeleteORMWedge(Wedge *Wedge)
	DeleteORMWood(Wood *Wood)
	DeleteORMWork(Work *Work)
}

func (stage *StageStruct) Reset() { // insertion point for array reset
	stage.Accidentals = make(map[*Accidental]any)
	stage.Accidentals_mapString = make(map[string]*Accidental)

	stage.Accidental_marks = make(map[*Accidental_mark]any)
	stage.Accidental_marks_mapString = make(map[string]*Accidental_mark)

	stage.Accidental_texts = make(map[*Accidental_text]any)
	stage.Accidental_texts_mapString = make(map[string]*Accidental_text)

	stage.Accords = make(map[*Accord]any)
	stage.Accords_mapString = make(map[string]*Accord)

	stage.Accordion_registrations = make(map[*Accordion_registration]any)
	stage.Accordion_registrations_mapString = make(map[string]*Accordion_registration)

	stage.AnyTypes = make(map[*AnyType]any)
	stage.AnyTypes_mapString = make(map[string]*AnyType)

	stage.Appearances = make(map[*Appearance]any)
	stage.Appearances_mapString = make(map[string]*Appearance)

	stage.Arpeggiates = make(map[*Arpeggiate]any)
	stage.Arpeggiates_mapString = make(map[string]*Arpeggiate)

	stage.Arrows = make(map[*Arrow]any)
	stage.Arrows_mapString = make(map[string]*Arrow)

	stage.Articulationss = make(map[*Articulations]any)
	stage.Articulationss_mapString = make(map[string]*Articulations)

	stage.Assesss = make(map[*Assess]any)
	stage.Assesss_mapString = make(map[string]*Assess)

	stage.Attributess = make(map[*Attributes]any)
	stage.Attributess_mapString = make(map[string]*Attributes)

	stage.Backups = make(map[*Backup]any)
	stage.Backups_mapString = make(map[string]*Backup)

	stage.Bar_style_colors = make(map[*Bar_style_color]any)
	stage.Bar_style_colors_mapString = make(map[string]*Bar_style_color)

	stage.Barlines = make(map[*Barline]any)
	stage.Barlines_mapString = make(map[string]*Barline)

	stage.Barres = make(map[*Barre]any)
	stage.Barres_mapString = make(map[string]*Barre)

	stage.Basss = make(map[*Bass]any)
	stage.Basss_mapString = make(map[string]*Bass)

	stage.Bass_steps = make(map[*Bass_step]any)
	stage.Bass_steps_mapString = make(map[string]*Bass_step)

	stage.Beams = make(map[*Beam]any)
	stage.Beams_mapString = make(map[string]*Beam)

	stage.Beat_repeats = make(map[*Beat_repeat]any)
	stage.Beat_repeats_mapString = make(map[string]*Beat_repeat)

	stage.Beat_unit_tieds = make(map[*Beat_unit_tied]any)
	stage.Beat_unit_tieds_mapString = make(map[string]*Beat_unit_tied)

	stage.Beaters = make(map[*Beater]any)
	stage.Beaters_mapString = make(map[string]*Beater)

	stage.Bends = make(map[*Bend]any)
	stage.Bends_mapString = make(map[string]*Bend)

	stage.Bookmarks = make(map[*Bookmark]any)
	stage.Bookmarks_mapString = make(map[string]*Bookmark)

	stage.Brackets = make(map[*Bracket]any)
	stage.Brackets_mapString = make(map[string]*Bracket)

	stage.Breath_marks = make(map[*Breath_mark]any)
	stage.Breath_marks_mapString = make(map[string]*Breath_mark)

	stage.Caesuras = make(map[*Caesura]any)
	stage.Caesuras_mapString = make(map[string]*Caesura)

	stage.Cancels = make(map[*Cancel]any)
	stage.Cancels_mapString = make(map[string]*Cancel)

	stage.Clefs = make(map[*Clef]any)
	stage.Clefs_mapString = make(map[string]*Clef)

	stage.Codas = make(map[*Coda]any)
	stage.Codas_mapString = make(map[string]*Coda)

	stage.Credits = make(map[*Credit]any)
	stage.Credits_mapString = make(map[string]*Credit)

	stage.Dashess = make(map[*Dashes]any)
	stage.Dashess_mapString = make(map[string]*Dashes)

	stage.Defaultss = make(map[*Defaults]any)
	stage.Defaultss_mapString = make(map[string]*Defaults)

	stage.Degrees = make(map[*Degree]any)
	stage.Degrees_mapString = make(map[string]*Degree)

	stage.Degree_alters = make(map[*Degree_alter]any)
	stage.Degree_alters_mapString = make(map[string]*Degree_alter)

	stage.Degree_types = make(map[*Degree_type]any)
	stage.Degree_types_mapString = make(map[string]*Degree_type)

	stage.Degree_values = make(map[*Degree_value]any)
	stage.Degree_values_mapString = make(map[string]*Degree_value)

	stage.Directions = make(map[*Direction]any)
	stage.Directions_mapString = make(map[string]*Direction)

	stage.Direction_types = make(map[*Direction_type]any)
	stage.Direction_types_mapString = make(map[string]*Direction_type)

	stage.Distances = make(map[*Distance]any)
	stage.Distances_mapString = make(map[string]*Distance)

	stage.Doubles = make(map[*Double]any)
	stage.Doubles_mapString = make(map[string]*Double)

	stage.Dynamicss = make(map[*Dynamics]any)
	stage.Dynamicss_mapString = make(map[string]*Dynamics)

	stage.Effects = make(map[*Effect]any)
	stage.Effects_mapString = make(map[string]*Effect)

	stage.Elisions = make(map[*Elision]any)
	stage.Elisions_mapString = make(map[string]*Elision)

	stage.Emptys = make(map[*Empty]any)
	stage.Emptys_mapString = make(map[string]*Empty)

	stage.Empty_fonts = make(map[*Empty_font]any)
	stage.Empty_fonts_mapString = make(map[string]*Empty_font)

	stage.Empty_lines = make(map[*Empty_line]any)
	stage.Empty_lines_mapString = make(map[string]*Empty_line)

	stage.Empty_placements = make(map[*Empty_placement]any)
	stage.Empty_placements_mapString = make(map[string]*Empty_placement)

	stage.Empty_placement_smufls = make(map[*Empty_placement_smufl]any)
	stage.Empty_placement_smufls_mapString = make(map[string]*Empty_placement_smufl)

	stage.Empty_print_object_style_aligns = make(map[*Empty_print_object_style_align]any)
	stage.Empty_print_object_style_aligns_mapString = make(map[string]*Empty_print_object_style_align)

	stage.Empty_print_styles = make(map[*Empty_print_style]any)
	stage.Empty_print_styles_mapString = make(map[string]*Empty_print_style)

	stage.Empty_print_style_aligns = make(map[*Empty_print_style_align]any)
	stage.Empty_print_style_aligns_mapString = make(map[string]*Empty_print_style_align)

	stage.Empty_print_style_align_ids = make(map[*Empty_print_style_align_id]any)
	stage.Empty_print_style_align_ids_mapString = make(map[string]*Empty_print_style_align_id)

	stage.Empty_trill_sounds = make(map[*Empty_trill_sound]any)
	stage.Empty_trill_sounds_mapString = make(map[string]*Empty_trill_sound)

	stage.Encodings = make(map[*Encoding]any)
	stage.Encodings_mapString = make(map[string]*Encoding)

	stage.Endings = make(map[*Ending]any)
	stage.Endings_mapString = make(map[string]*Ending)

	stage.Extends = make(map[*Extend]any)
	stage.Extends_mapString = make(map[string]*Extend)

	stage.Features = make(map[*Feature]any)
	stage.Features_mapString = make(map[string]*Feature)

	stage.Fermatas = make(map[*Fermata]any)
	stage.Fermatas_mapString = make(map[string]*Fermata)

	stage.Figures = make(map[*Figure]any)
	stage.Figures_mapString = make(map[string]*Figure)

	stage.Figured_basss = make(map[*Figured_bass]any)
	stage.Figured_basss_mapString = make(map[string]*Figured_bass)

	stage.Fingerings = make(map[*Fingering]any)
	stage.Fingerings_mapString = make(map[string]*Fingering)

	stage.First_frets = make(map[*First_fret]any)
	stage.First_frets_mapString = make(map[string]*First_fret)

	stage.Foos = make(map[*Foo]any)
	stage.Foos_mapString = make(map[string]*Foo)

	stage.For_parts = make(map[*For_part]any)
	stage.For_parts_mapString = make(map[string]*For_part)

	stage.Formatted_symbols = make(map[*Formatted_symbol]any)
	stage.Formatted_symbols_mapString = make(map[string]*Formatted_symbol)

	stage.Formatted_symbol_ids = make(map[*Formatted_symbol_id]any)
	stage.Formatted_symbol_ids_mapString = make(map[string]*Formatted_symbol_id)

	stage.Forwards = make(map[*Forward]any)
	stage.Forwards_mapString = make(map[string]*Forward)

	stage.Frames = make(map[*Frame]any)
	stage.Frames_mapString = make(map[string]*Frame)

	stage.Frame_notes = make(map[*Frame_note]any)
	stage.Frame_notes_mapString = make(map[string]*Frame_note)

	stage.Frets = make(map[*Fret]any)
	stage.Frets_mapString = make(map[string]*Fret)

	stage.Glasss = make(map[*Glass]any)
	stage.Glasss_mapString = make(map[string]*Glass)

	stage.Glissandos = make(map[*Glissando]any)
	stage.Glissandos_mapString = make(map[string]*Glissando)

	stage.Glyphs = make(map[*Glyph]any)
	stage.Glyphs_mapString = make(map[string]*Glyph)

	stage.Graces = make(map[*Grace]any)
	stage.Graces_mapString = make(map[string]*Grace)

	stage.Group_barlines = make(map[*Group_barline]any)
	stage.Group_barlines_mapString = make(map[string]*Group_barline)

	stage.Group_symbols = make(map[*Group_symbol]any)
	stage.Group_symbols_mapString = make(map[string]*Group_symbol)

	stage.Groupings = make(map[*Grouping]any)
	stage.Groupings_mapString = make(map[string]*Grouping)

	stage.Hammer_on_pull_offs = make(map[*Hammer_on_pull_off]any)
	stage.Hammer_on_pull_offs_mapString = make(map[string]*Hammer_on_pull_off)

	stage.Handbells = make(map[*Handbell]any)
	stage.Handbells_mapString = make(map[string]*Handbell)

	stage.Harmon_closeds = make(map[*Harmon_closed]any)
	stage.Harmon_closeds_mapString = make(map[string]*Harmon_closed)

	stage.Harmon_mutes = make(map[*Harmon_mute]any)
	stage.Harmon_mutes_mapString = make(map[string]*Harmon_mute)

	stage.Harmonics = make(map[*Harmonic]any)
	stage.Harmonics_mapString = make(map[string]*Harmonic)

	stage.Harmonys = make(map[*Harmony]any)
	stage.Harmonys_mapString = make(map[string]*Harmony)

	stage.Harmony_alters = make(map[*Harmony_alter]any)
	stage.Harmony_alters_mapString = make(map[string]*Harmony_alter)

	stage.Harp_pedalss = make(map[*Harp_pedals]any)
	stage.Harp_pedalss_mapString = make(map[string]*Harp_pedals)

	stage.Heel_toes = make(map[*Heel_toe]any)
	stage.Heel_toes_mapString = make(map[string]*Heel_toe)

	stage.Holes = make(map[*Hole]any)
	stage.Holes_mapString = make(map[string]*Hole)

	stage.Hole_closeds = make(map[*Hole_closed]any)
	stage.Hole_closeds_mapString = make(map[string]*Hole_closed)

	stage.Horizontal_turns = make(map[*Horizontal_turn]any)
	stage.Horizontal_turns_mapString = make(map[string]*Horizontal_turn)

	stage.Identifications = make(map[*Identification]any)
	stage.Identifications_mapString = make(map[string]*Identification)

	stage.Images = make(map[*Image]any)
	stage.Images_mapString = make(map[string]*Image)

	stage.Instruments = make(map[*Instrument]any)
	stage.Instruments_mapString = make(map[string]*Instrument)

	stage.Instrument_changes = make(map[*Instrument_change]any)
	stage.Instrument_changes_mapString = make(map[string]*Instrument_change)

	stage.Instrument_links = make(map[*Instrument_link]any)
	stage.Instrument_links_mapString = make(map[string]*Instrument_link)

	stage.Interchangeables = make(map[*Interchangeable]any)
	stage.Interchangeables_mapString = make(map[string]*Interchangeable)

	stage.Inversions = make(map[*Inversion]any)
	stage.Inversions_mapString = make(map[string]*Inversion)

	stage.Keys = make(map[*Key]any)
	stage.Keys_mapString = make(map[string]*Key)

	stage.Key_accidentals = make(map[*Key_accidental]any)
	stage.Key_accidentals_mapString = make(map[string]*Key_accidental)

	stage.Key_octaves = make(map[*Key_octave]any)
	stage.Key_octaves_mapString = make(map[string]*Key_octave)

	stage.Kinds = make(map[*Kind]any)
	stage.Kinds_mapString = make(map[string]*Kind)

	stage.Levels = make(map[*Level]any)
	stage.Levels_mapString = make(map[string]*Level)

	stage.Line_details = make(map[*Line_detail]any)
	stage.Line_details_mapString = make(map[string]*Line_detail)

	stage.Line_widths = make(map[*Line_width]any)
	stage.Line_widths_mapString = make(map[string]*Line_width)

	stage.Links = make(map[*Link]any)
	stage.Links_mapString = make(map[string]*Link)

	stage.Listens = make(map[*Listen]any)
	stage.Listens_mapString = make(map[string]*Listen)

	stage.Listenings = make(map[*Listening]any)
	stage.Listenings_mapString = make(map[string]*Listening)

	stage.Lyrics = make(map[*Lyric]any)
	stage.Lyrics_mapString = make(map[string]*Lyric)

	stage.Lyric_fonts = make(map[*Lyric_font]any)
	stage.Lyric_fonts_mapString = make(map[string]*Lyric_font)

	stage.Lyric_languages = make(map[*Lyric_language]any)
	stage.Lyric_languages_mapString = make(map[string]*Lyric_language)

	stage.Measure_layouts = make(map[*Measure_layout]any)
	stage.Measure_layouts_mapString = make(map[string]*Measure_layout)

	stage.Measure_numberings = make(map[*Measure_numbering]any)
	stage.Measure_numberings_mapString = make(map[string]*Measure_numbering)

	stage.Measure_repeats = make(map[*Measure_repeat]any)
	stage.Measure_repeats_mapString = make(map[string]*Measure_repeat)

	stage.Measure_styles = make(map[*Measure_style]any)
	stage.Measure_styles_mapString = make(map[string]*Measure_style)

	stage.Membranes = make(map[*Membrane]any)
	stage.Membranes_mapString = make(map[string]*Membrane)

	stage.Metals = make(map[*Metal]any)
	stage.Metals_mapString = make(map[string]*Metal)

	stage.Metronomes = make(map[*Metronome]any)
	stage.Metronomes_mapString = make(map[string]*Metronome)

	stage.Metronome_beams = make(map[*Metronome_beam]any)
	stage.Metronome_beams_mapString = make(map[string]*Metronome_beam)

	stage.Metronome_notes = make(map[*Metronome_note]any)
	stage.Metronome_notes_mapString = make(map[string]*Metronome_note)

	stage.Metronome_tieds = make(map[*Metronome_tied]any)
	stage.Metronome_tieds_mapString = make(map[string]*Metronome_tied)

	stage.Metronome_tuplets = make(map[*Metronome_tuplet]any)
	stage.Metronome_tuplets_mapString = make(map[string]*Metronome_tuplet)

	stage.Midi_devices = make(map[*Midi_device]any)
	stage.Midi_devices_mapString = make(map[string]*Midi_device)

	stage.Midi_instruments = make(map[*Midi_instrument]any)
	stage.Midi_instruments_mapString = make(map[string]*Midi_instrument)

	stage.Miscellaneouss = make(map[*Miscellaneous]any)
	stage.Miscellaneouss_mapString = make(map[string]*Miscellaneous)

	stage.Miscellaneous_fields = make(map[*Miscellaneous_field]any)
	stage.Miscellaneous_fields_mapString = make(map[string]*Miscellaneous_field)

	stage.Mordents = make(map[*Mordent]any)
	stage.Mordents_mapString = make(map[string]*Mordent)

	stage.Multiple_rests = make(map[*Multiple_rest]any)
	stage.Multiple_rests_mapString = make(map[string]*Multiple_rest)

	stage.Name_displays = make(map[*Name_display]any)
	stage.Name_displays_mapString = make(map[string]*Name_display)

	stage.Non_arpeggiates = make(map[*Non_arpeggiate]any)
	stage.Non_arpeggiates_mapString = make(map[string]*Non_arpeggiate)

	stage.Notationss = make(map[*Notations]any)
	stage.Notationss_mapString = make(map[string]*Notations)

	stage.Notes = make(map[*Note]any)
	stage.Notes_mapString = make(map[string]*Note)

	stage.Note_sizes = make(map[*Note_size]any)
	stage.Note_sizes_mapString = make(map[string]*Note_size)

	stage.Note_types = make(map[*Note_type]any)
	stage.Note_types_mapString = make(map[string]*Note_type)

	stage.Noteheads = make(map[*Notehead]any)
	stage.Noteheads_mapString = make(map[string]*Notehead)

	stage.Notehead_texts = make(map[*Notehead_text]any)
	stage.Notehead_texts_mapString = make(map[string]*Notehead_text)

	stage.Numerals = make(map[*Numeral]any)
	stage.Numerals_mapString = make(map[string]*Numeral)

	stage.Numeral_keys = make(map[*Numeral_key]any)
	stage.Numeral_keys_mapString = make(map[string]*Numeral_key)

	stage.Numeral_roots = make(map[*Numeral_root]any)
	stage.Numeral_roots_mapString = make(map[string]*Numeral_root)

	stage.Octave_shifts = make(map[*Octave_shift]any)
	stage.Octave_shifts_mapString = make(map[string]*Octave_shift)

	stage.Offsets = make(map[*Offset]any)
	stage.Offsets_mapString = make(map[string]*Offset)

	stage.Opuss = make(map[*Opus]any)
	stage.Opuss_mapString = make(map[string]*Opus)

	stage.Ornamentss = make(map[*Ornaments]any)
	stage.Ornamentss_mapString = make(map[string]*Ornaments)

	stage.Other_appearances = make(map[*Other_appearance]any)
	stage.Other_appearances_mapString = make(map[string]*Other_appearance)

	stage.Other_listenings = make(map[*Other_listening]any)
	stage.Other_listenings_mapString = make(map[string]*Other_listening)

	stage.Other_notations = make(map[*Other_notation]any)
	stage.Other_notations_mapString = make(map[string]*Other_notation)

	stage.Other_plays = make(map[*Other_play]any)
	stage.Other_plays_mapString = make(map[string]*Other_play)

	stage.Page_layouts = make(map[*Page_layout]any)
	stage.Page_layouts_mapString = make(map[string]*Page_layout)

	stage.Page_marginss = make(map[*Page_margins]any)
	stage.Page_marginss_mapString = make(map[string]*Page_margins)

	stage.Part_clefs = make(map[*Part_clef]any)
	stage.Part_clefs_mapString = make(map[string]*Part_clef)

	stage.Part_groups = make(map[*Part_group]any)
	stage.Part_groups_mapString = make(map[string]*Part_group)

	stage.Part_links = make(map[*Part_link]any)
	stage.Part_links_mapString = make(map[string]*Part_link)

	stage.Part_lists = make(map[*Part_list]any)
	stage.Part_lists_mapString = make(map[string]*Part_list)

	stage.Part_symbols = make(map[*Part_symbol]any)
	stage.Part_symbols_mapString = make(map[string]*Part_symbol)

	stage.Part_transposes = make(map[*Part_transpose]any)
	stage.Part_transposes_mapString = make(map[string]*Part_transpose)

	stage.Pedals = make(map[*Pedal]any)
	stage.Pedals_mapString = make(map[string]*Pedal)

	stage.Pedal_tunings = make(map[*Pedal_tuning]any)
	stage.Pedal_tunings_mapString = make(map[string]*Pedal_tuning)

	stage.Percussions = make(map[*Percussion]any)
	stage.Percussions_mapString = make(map[string]*Percussion)

	stage.Pitchs = make(map[*Pitch]any)
	stage.Pitchs_mapString = make(map[string]*Pitch)

	stage.Pitcheds = make(map[*Pitched]any)
	stage.Pitcheds_mapString = make(map[string]*Pitched)

	stage.Plays = make(map[*Play]any)
	stage.Plays_mapString = make(map[string]*Play)

	stage.Players = make(map[*Player]any)
	stage.Players_mapString = make(map[string]*Player)

	stage.Principal_voices = make(map[*Principal_voice]any)
	stage.Principal_voices_mapString = make(map[string]*Principal_voice)

	stage.Prints = make(map[*Print]any)
	stage.Prints_mapString = make(map[string]*Print)

	stage.Releases = make(map[*Release]any)
	stage.Releases_mapString = make(map[string]*Release)

	stage.Repeats = make(map[*Repeat]any)
	stage.Repeats_mapString = make(map[string]*Repeat)

	stage.Rests = make(map[*Rest]any)
	stage.Rests_mapString = make(map[string]*Rest)

	stage.Roots = make(map[*Root]any)
	stage.Roots_mapString = make(map[string]*Root)

	stage.Root_steps = make(map[*Root_step]any)
	stage.Root_steps_mapString = make(map[string]*Root_step)

	stage.Scalings = make(map[*Scaling]any)
	stage.Scalings_mapString = make(map[string]*Scaling)

	stage.Scordaturas = make(map[*Scordatura]any)
	stage.Scordaturas_mapString = make(map[string]*Scordatura)

	stage.Score_instruments = make(map[*Score_instrument]any)
	stage.Score_instruments_mapString = make(map[string]*Score_instrument)

	stage.Score_parts = make(map[*Score_part]any)
	stage.Score_parts_mapString = make(map[string]*Score_part)

	stage.Score_partwises = make(map[*Score_partwise]any)
	stage.Score_partwises_mapString = make(map[string]*Score_partwise)

	stage.Score_timewises = make(map[*Score_timewise]any)
	stage.Score_timewises_mapString = make(map[string]*Score_timewise)

	stage.Segnos = make(map[*Segno]any)
	stage.Segnos_mapString = make(map[string]*Segno)

	stage.Slashs = make(map[*Slash]any)
	stage.Slashs_mapString = make(map[string]*Slash)

	stage.Slides = make(map[*Slide]any)
	stage.Slides_mapString = make(map[string]*Slide)

	stage.Slurs = make(map[*Slur]any)
	stage.Slurs_mapString = make(map[string]*Slur)

	stage.Sounds = make(map[*Sound]any)
	stage.Sounds_mapString = make(map[string]*Sound)

	stage.Staff_detailss = make(map[*Staff_details]any)
	stage.Staff_detailss_mapString = make(map[string]*Staff_details)

	stage.Staff_divides = make(map[*Staff_divide]any)
	stage.Staff_divides_mapString = make(map[string]*Staff_divide)

	stage.Staff_layouts = make(map[*Staff_layout]any)
	stage.Staff_layouts_mapString = make(map[string]*Staff_layout)

	stage.Staff_sizes = make(map[*Staff_size]any)
	stage.Staff_sizes_mapString = make(map[string]*Staff_size)

	stage.Staff_tunings = make(map[*Staff_tuning]any)
	stage.Staff_tunings_mapString = make(map[string]*Staff_tuning)

	stage.Stems = make(map[*Stem]any)
	stage.Stems_mapString = make(map[string]*Stem)

	stage.Sticks = make(map[*Stick]any)
	stage.Sticks_mapString = make(map[string]*Stick)

	stage.String_mutes = make(map[*String_mute]any)
	stage.String_mutes_mapString = make(map[string]*String_mute)

	stage.Strong_accents = make(map[*Strong_accent]any)
	stage.Strong_accents_mapString = make(map[string]*Strong_accent)

	stage.Supportss = make(map[*Supports]any)
	stage.Supportss_mapString = make(map[string]*Supports)

	stage.Swings = make(map[*Swing]any)
	stage.Swings_mapString = make(map[string]*Swing)

	stage.Syncs = make(map[*Sync]any)
	stage.Syncs_mapString = make(map[string]*Sync)

	stage.System_dividerss = make(map[*System_dividers]any)
	stage.System_dividerss_mapString = make(map[string]*System_dividers)

	stage.System_layouts = make(map[*System_layout]any)
	stage.System_layouts_mapString = make(map[string]*System_layout)

	stage.System_marginss = make(map[*System_margins]any)
	stage.System_marginss_mapString = make(map[string]*System_margins)

	stage.Taps = make(map[*Tap]any)
	stage.Taps_mapString = make(map[string]*Tap)

	stage.Technicals = make(map[*Technical]any)
	stage.Technicals_mapString = make(map[string]*Technical)

	stage.Text_element_datas = make(map[*Text_element_data]any)
	stage.Text_element_datas_mapString = make(map[string]*Text_element_data)

	stage.Ties = make(map[*Tie]any)
	stage.Ties_mapString = make(map[string]*Tie)

	stage.Tieds = make(map[*Tied]any)
	stage.Tieds_mapString = make(map[string]*Tied)

	stage.Times = make(map[*Time]any)
	stage.Times_mapString = make(map[string]*Time)

	stage.Time_modifications = make(map[*Time_modification]any)
	stage.Time_modifications_mapString = make(map[string]*Time_modification)

	stage.Timpanis = make(map[*Timpani]any)
	stage.Timpanis_mapString = make(map[string]*Timpani)

	stage.Transposes = make(map[*Transpose]any)
	stage.Transposes_mapString = make(map[string]*Transpose)

	stage.Tremolos = make(map[*Tremolo]any)
	stage.Tremolos_mapString = make(map[string]*Tremolo)

	stage.Tuplets = make(map[*Tuplet]any)
	stage.Tuplets_mapString = make(map[string]*Tuplet)

	stage.Tuplet_dots = make(map[*Tuplet_dot]any)
	stage.Tuplet_dots_mapString = make(map[string]*Tuplet_dot)

	stage.Tuplet_numbers = make(map[*Tuplet_number]any)
	stage.Tuplet_numbers_mapString = make(map[string]*Tuplet_number)

	stage.Tuplet_portions = make(map[*Tuplet_portion]any)
	stage.Tuplet_portions_mapString = make(map[string]*Tuplet_portion)

	stage.Tuplet_types = make(map[*Tuplet_type]any)
	stage.Tuplet_types_mapString = make(map[string]*Tuplet_type)

	stage.Typed_texts = make(map[*Typed_text]any)
	stage.Typed_texts_mapString = make(map[string]*Typed_text)

	stage.Unpitcheds = make(map[*Unpitched]any)
	stage.Unpitcheds_mapString = make(map[string]*Unpitched)

	stage.Virtual_instruments = make(map[*Virtual_instrument]any)
	stage.Virtual_instruments_mapString = make(map[string]*Virtual_instrument)

	stage.Waits = make(map[*Wait]any)
	stage.Waits_mapString = make(map[string]*Wait)

	stage.Wavy_lines = make(map[*Wavy_line]any)
	stage.Wavy_lines_mapString = make(map[string]*Wavy_line)

	stage.Wedges = make(map[*Wedge]any)
	stage.Wedges_mapString = make(map[string]*Wedge)

	stage.Woods = make(map[*Wood]any)
	stage.Woods_mapString = make(map[string]*Wood)

	stage.Works = make(map[*Work]any)
	stage.Works_mapString = make(map[string]*Work)

}

func (stage *StageStruct) Nil() { // insertion point for array nil
	stage.Accidentals = nil
	stage.Accidentals_mapString = nil

	stage.Accidental_marks = nil
	stage.Accidental_marks_mapString = nil

	stage.Accidental_texts = nil
	stage.Accidental_texts_mapString = nil

	stage.Accords = nil
	stage.Accords_mapString = nil

	stage.Accordion_registrations = nil
	stage.Accordion_registrations_mapString = nil

	stage.AnyTypes = nil
	stage.AnyTypes_mapString = nil

	stage.Appearances = nil
	stage.Appearances_mapString = nil

	stage.Arpeggiates = nil
	stage.Arpeggiates_mapString = nil

	stage.Arrows = nil
	stage.Arrows_mapString = nil

	stage.Articulationss = nil
	stage.Articulationss_mapString = nil

	stage.Assesss = nil
	stage.Assesss_mapString = nil

	stage.Attributess = nil
	stage.Attributess_mapString = nil

	stage.Backups = nil
	stage.Backups_mapString = nil

	stage.Bar_style_colors = nil
	stage.Bar_style_colors_mapString = nil

	stage.Barlines = nil
	stage.Barlines_mapString = nil

	stage.Barres = nil
	stage.Barres_mapString = nil

	stage.Basss = nil
	stage.Basss_mapString = nil

	stage.Bass_steps = nil
	stage.Bass_steps_mapString = nil

	stage.Beams = nil
	stage.Beams_mapString = nil

	stage.Beat_repeats = nil
	stage.Beat_repeats_mapString = nil

	stage.Beat_unit_tieds = nil
	stage.Beat_unit_tieds_mapString = nil

	stage.Beaters = nil
	stage.Beaters_mapString = nil

	stage.Bends = nil
	stage.Bends_mapString = nil

	stage.Bookmarks = nil
	stage.Bookmarks_mapString = nil

	stage.Brackets = nil
	stage.Brackets_mapString = nil

	stage.Breath_marks = nil
	stage.Breath_marks_mapString = nil

	stage.Caesuras = nil
	stage.Caesuras_mapString = nil

	stage.Cancels = nil
	stage.Cancels_mapString = nil

	stage.Clefs = nil
	stage.Clefs_mapString = nil

	stage.Codas = nil
	stage.Codas_mapString = nil

	stage.Credits = nil
	stage.Credits_mapString = nil

	stage.Dashess = nil
	stage.Dashess_mapString = nil

	stage.Defaultss = nil
	stage.Defaultss_mapString = nil

	stage.Degrees = nil
	stage.Degrees_mapString = nil

	stage.Degree_alters = nil
	stage.Degree_alters_mapString = nil

	stage.Degree_types = nil
	stage.Degree_types_mapString = nil

	stage.Degree_values = nil
	stage.Degree_values_mapString = nil

	stage.Directions = nil
	stage.Directions_mapString = nil

	stage.Direction_types = nil
	stage.Direction_types_mapString = nil

	stage.Distances = nil
	stage.Distances_mapString = nil

	stage.Doubles = nil
	stage.Doubles_mapString = nil

	stage.Dynamicss = nil
	stage.Dynamicss_mapString = nil

	stage.Effects = nil
	stage.Effects_mapString = nil

	stage.Elisions = nil
	stage.Elisions_mapString = nil

	stage.Emptys = nil
	stage.Emptys_mapString = nil

	stage.Empty_fonts = nil
	stage.Empty_fonts_mapString = nil

	stage.Empty_lines = nil
	stage.Empty_lines_mapString = nil

	stage.Empty_placements = nil
	stage.Empty_placements_mapString = nil

	stage.Empty_placement_smufls = nil
	stage.Empty_placement_smufls_mapString = nil

	stage.Empty_print_object_style_aligns = nil
	stage.Empty_print_object_style_aligns_mapString = nil

	stage.Empty_print_styles = nil
	stage.Empty_print_styles_mapString = nil

	stage.Empty_print_style_aligns = nil
	stage.Empty_print_style_aligns_mapString = nil

	stage.Empty_print_style_align_ids = nil
	stage.Empty_print_style_align_ids_mapString = nil

	stage.Empty_trill_sounds = nil
	stage.Empty_trill_sounds_mapString = nil

	stage.Encodings = nil
	stage.Encodings_mapString = nil

	stage.Endings = nil
	stage.Endings_mapString = nil

	stage.Extends = nil
	stage.Extends_mapString = nil

	stage.Features = nil
	stage.Features_mapString = nil

	stage.Fermatas = nil
	stage.Fermatas_mapString = nil

	stage.Figures = nil
	stage.Figures_mapString = nil

	stage.Figured_basss = nil
	stage.Figured_basss_mapString = nil

	stage.Fingerings = nil
	stage.Fingerings_mapString = nil

	stage.First_frets = nil
	stage.First_frets_mapString = nil

	stage.Foos = nil
	stage.Foos_mapString = nil

	stage.For_parts = nil
	stage.For_parts_mapString = nil

	stage.Formatted_symbols = nil
	stage.Formatted_symbols_mapString = nil

	stage.Formatted_symbol_ids = nil
	stage.Formatted_symbol_ids_mapString = nil

	stage.Forwards = nil
	stage.Forwards_mapString = nil

	stage.Frames = nil
	stage.Frames_mapString = nil

	stage.Frame_notes = nil
	stage.Frame_notes_mapString = nil

	stage.Frets = nil
	stage.Frets_mapString = nil

	stage.Glasss = nil
	stage.Glasss_mapString = nil

	stage.Glissandos = nil
	stage.Glissandos_mapString = nil

	stage.Glyphs = nil
	stage.Glyphs_mapString = nil

	stage.Graces = nil
	stage.Graces_mapString = nil

	stage.Group_barlines = nil
	stage.Group_barlines_mapString = nil

	stage.Group_symbols = nil
	stage.Group_symbols_mapString = nil

	stage.Groupings = nil
	stage.Groupings_mapString = nil

	stage.Hammer_on_pull_offs = nil
	stage.Hammer_on_pull_offs_mapString = nil

	stage.Handbells = nil
	stage.Handbells_mapString = nil

	stage.Harmon_closeds = nil
	stage.Harmon_closeds_mapString = nil

	stage.Harmon_mutes = nil
	stage.Harmon_mutes_mapString = nil

	stage.Harmonics = nil
	stage.Harmonics_mapString = nil

	stage.Harmonys = nil
	stage.Harmonys_mapString = nil

	stage.Harmony_alters = nil
	stage.Harmony_alters_mapString = nil

	stage.Harp_pedalss = nil
	stage.Harp_pedalss_mapString = nil

	stage.Heel_toes = nil
	stage.Heel_toes_mapString = nil

	stage.Holes = nil
	stage.Holes_mapString = nil

	stage.Hole_closeds = nil
	stage.Hole_closeds_mapString = nil

	stage.Horizontal_turns = nil
	stage.Horizontal_turns_mapString = nil

	stage.Identifications = nil
	stage.Identifications_mapString = nil

	stage.Images = nil
	stage.Images_mapString = nil

	stage.Instruments = nil
	stage.Instruments_mapString = nil

	stage.Instrument_changes = nil
	stage.Instrument_changes_mapString = nil

	stage.Instrument_links = nil
	stage.Instrument_links_mapString = nil

	stage.Interchangeables = nil
	stage.Interchangeables_mapString = nil

	stage.Inversions = nil
	stage.Inversions_mapString = nil

	stage.Keys = nil
	stage.Keys_mapString = nil

	stage.Key_accidentals = nil
	stage.Key_accidentals_mapString = nil

	stage.Key_octaves = nil
	stage.Key_octaves_mapString = nil

	stage.Kinds = nil
	stage.Kinds_mapString = nil

	stage.Levels = nil
	stage.Levels_mapString = nil

	stage.Line_details = nil
	stage.Line_details_mapString = nil

	stage.Line_widths = nil
	stage.Line_widths_mapString = nil

	stage.Links = nil
	stage.Links_mapString = nil

	stage.Listens = nil
	stage.Listens_mapString = nil

	stage.Listenings = nil
	stage.Listenings_mapString = nil

	stage.Lyrics = nil
	stage.Lyrics_mapString = nil

	stage.Lyric_fonts = nil
	stage.Lyric_fonts_mapString = nil

	stage.Lyric_languages = nil
	stage.Lyric_languages_mapString = nil

	stage.Measure_layouts = nil
	stage.Measure_layouts_mapString = nil

	stage.Measure_numberings = nil
	stage.Measure_numberings_mapString = nil

	stage.Measure_repeats = nil
	stage.Measure_repeats_mapString = nil

	stage.Measure_styles = nil
	stage.Measure_styles_mapString = nil

	stage.Membranes = nil
	stage.Membranes_mapString = nil

	stage.Metals = nil
	stage.Metals_mapString = nil

	stage.Metronomes = nil
	stage.Metronomes_mapString = nil

	stage.Metronome_beams = nil
	stage.Metronome_beams_mapString = nil

	stage.Metronome_notes = nil
	stage.Metronome_notes_mapString = nil

	stage.Metronome_tieds = nil
	stage.Metronome_tieds_mapString = nil

	stage.Metronome_tuplets = nil
	stage.Metronome_tuplets_mapString = nil

	stage.Midi_devices = nil
	stage.Midi_devices_mapString = nil

	stage.Midi_instruments = nil
	stage.Midi_instruments_mapString = nil

	stage.Miscellaneouss = nil
	stage.Miscellaneouss_mapString = nil

	stage.Miscellaneous_fields = nil
	stage.Miscellaneous_fields_mapString = nil

	stage.Mordents = nil
	stage.Mordents_mapString = nil

	stage.Multiple_rests = nil
	stage.Multiple_rests_mapString = nil

	stage.Name_displays = nil
	stage.Name_displays_mapString = nil

	stage.Non_arpeggiates = nil
	stage.Non_arpeggiates_mapString = nil

	stage.Notationss = nil
	stage.Notationss_mapString = nil

	stage.Notes = nil
	stage.Notes_mapString = nil

	stage.Note_sizes = nil
	stage.Note_sizes_mapString = nil

	stage.Note_types = nil
	stage.Note_types_mapString = nil

	stage.Noteheads = nil
	stage.Noteheads_mapString = nil

	stage.Notehead_texts = nil
	stage.Notehead_texts_mapString = nil

	stage.Numerals = nil
	stage.Numerals_mapString = nil

	stage.Numeral_keys = nil
	stage.Numeral_keys_mapString = nil

	stage.Numeral_roots = nil
	stage.Numeral_roots_mapString = nil

	stage.Octave_shifts = nil
	stage.Octave_shifts_mapString = nil

	stage.Offsets = nil
	stage.Offsets_mapString = nil

	stage.Opuss = nil
	stage.Opuss_mapString = nil

	stage.Ornamentss = nil
	stage.Ornamentss_mapString = nil

	stage.Other_appearances = nil
	stage.Other_appearances_mapString = nil

	stage.Other_listenings = nil
	stage.Other_listenings_mapString = nil

	stage.Other_notations = nil
	stage.Other_notations_mapString = nil

	stage.Other_plays = nil
	stage.Other_plays_mapString = nil

	stage.Page_layouts = nil
	stage.Page_layouts_mapString = nil

	stage.Page_marginss = nil
	stage.Page_marginss_mapString = nil

	stage.Part_clefs = nil
	stage.Part_clefs_mapString = nil

	stage.Part_groups = nil
	stage.Part_groups_mapString = nil

	stage.Part_links = nil
	stage.Part_links_mapString = nil

	stage.Part_lists = nil
	stage.Part_lists_mapString = nil

	stage.Part_symbols = nil
	stage.Part_symbols_mapString = nil

	stage.Part_transposes = nil
	stage.Part_transposes_mapString = nil

	stage.Pedals = nil
	stage.Pedals_mapString = nil

	stage.Pedal_tunings = nil
	stage.Pedal_tunings_mapString = nil

	stage.Percussions = nil
	stage.Percussions_mapString = nil

	stage.Pitchs = nil
	stage.Pitchs_mapString = nil

	stage.Pitcheds = nil
	stage.Pitcheds_mapString = nil

	stage.Plays = nil
	stage.Plays_mapString = nil

	stage.Players = nil
	stage.Players_mapString = nil

	stage.Principal_voices = nil
	stage.Principal_voices_mapString = nil

	stage.Prints = nil
	stage.Prints_mapString = nil

	stage.Releases = nil
	stage.Releases_mapString = nil

	stage.Repeats = nil
	stage.Repeats_mapString = nil

	stage.Rests = nil
	stage.Rests_mapString = nil

	stage.Roots = nil
	stage.Roots_mapString = nil

	stage.Root_steps = nil
	stage.Root_steps_mapString = nil

	stage.Scalings = nil
	stage.Scalings_mapString = nil

	stage.Scordaturas = nil
	stage.Scordaturas_mapString = nil

	stage.Score_instruments = nil
	stage.Score_instruments_mapString = nil

	stage.Score_parts = nil
	stage.Score_parts_mapString = nil

	stage.Score_partwises = nil
	stage.Score_partwises_mapString = nil

	stage.Score_timewises = nil
	stage.Score_timewises_mapString = nil

	stage.Segnos = nil
	stage.Segnos_mapString = nil

	stage.Slashs = nil
	stage.Slashs_mapString = nil

	stage.Slides = nil
	stage.Slides_mapString = nil

	stage.Slurs = nil
	stage.Slurs_mapString = nil

	stage.Sounds = nil
	stage.Sounds_mapString = nil

	stage.Staff_detailss = nil
	stage.Staff_detailss_mapString = nil

	stage.Staff_divides = nil
	stage.Staff_divides_mapString = nil

	stage.Staff_layouts = nil
	stage.Staff_layouts_mapString = nil

	stage.Staff_sizes = nil
	stage.Staff_sizes_mapString = nil

	stage.Staff_tunings = nil
	stage.Staff_tunings_mapString = nil

	stage.Stems = nil
	stage.Stems_mapString = nil

	stage.Sticks = nil
	stage.Sticks_mapString = nil

	stage.String_mutes = nil
	stage.String_mutes_mapString = nil

	stage.Strong_accents = nil
	stage.Strong_accents_mapString = nil

	stage.Supportss = nil
	stage.Supportss_mapString = nil

	stage.Swings = nil
	stage.Swings_mapString = nil

	stage.Syncs = nil
	stage.Syncs_mapString = nil

	stage.System_dividerss = nil
	stage.System_dividerss_mapString = nil

	stage.System_layouts = nil
	stage.System_layouts_mapString = nil

	stage.System_marginss = nil
	stage.System_marginss_mapString = nil

	stage.Taps = nil
	stage.Taps_mapString = nil

	stage.Technicals = nil
	stage.Technicals_mapString = nil

	stage.Text_element_datas = nil
	stage.Text_element_datas_mapString = nil

	stage.Ties = nil
	stage.Ties_mapString = nil

	stage.Tieds = nil
	stage.Tieds_mapString = nil

	stage.Times = nil
	stage.Times_mapString = nil

	stage.Time_modifications = nil
	stage.Time_modifications_mapString = nil

	stage.Timpanis = nil
	stage.Timpanis_mapString = nil

	stage.Transposes = nil
	stage.Transposes_mapString = nil

	stage.Tremolos = nil
	stage.Tremolos_mapString = nil

	stage.Tuplets = nil
	stage.Tuplets_mapString = nil

	stage.Tuplet_dots = nil
	stage.Tuplet_dots_mapString = nil

	stage.Tuplet_numbers = nil
	stage.Tuplet_numbers_mapString = nil

	stage.Tuplet_portions = nil
	stage.Tuplet_portions_mapString = nil

	stage.Tuplet_types = nil
	stage.Tuplet_types_mapString = nil

	stage.Typed_texts = nil
	stage.Typed_texts_mapString = nil

	stage.Unpitcheds = nil
	stage.Unpitcheds_mapString = nil

	stage.Virtual_instruments = nil
	stage.Virtual_instruments_mapString = nil

	stage.Waits = nil
	stage.Waits_mapString = nil

	stage.Wavy_lines = nil
	stage.Wavy_lines_mapString = nil

	stage.Wedges = nil
	stage.Wedges_mapString = nil

	stage.Woods = nil
	stage.Woods_mapString = nil

	stage.Works = nil
	stage.Works_mapString = nil

}

func (stage *StageStruct) Unstage() { // insertion point for array nil
	for accidental := range stage.Accidentals {
		accidental.Unstage(stage)
	}

	for accidental_mark := range stage.Accidental_marks {
		accidental_mark.Unstage(stage)
	}

	for accidental_text := range stage.Accidental_texts {
		accidental_text.Unstage(stage)
	}

	for accord := range stage.Accords {
		accord.Unstage(stage)
	}

	for accordion_registration := range stage.Accordion_registrations {
		accordion_registration.Unstage(stage)
	}

	for anytype := range stage.AnyTypes {
		anytype.Unstage(stage)
	}

	for appearance := range stage.Appearances {
		appearance.Unstage(stage)
	}

	for arpeggiate := range stage.Arpeggiates {
		arpeggiate.Unstage(stage)
	}

	for arrow := range stage.Arrows {
		arrow.Unstage(stage)
	}

	for articulations := range stage.Articulationss {
		articulations.Unstage(stage)
	}

	for assess := range stage.Assesss {
		assess.Unstage(stage)
	}

	for attributes := range stage.Attributess {
		attributes.Unstage(stage)
	}

	for backup := range stage.Backups {
		backup.Unstage(stage)
	}

	for bar_style_color := range stage.Bar_style_colors {
		bar_style_color.Unstage(stage)
	}

	for barline := range stage.Barlines {
		barline.Unstage(stage)
	}

	for barre := range stage.Barres {
		barre.Unstage(stage)
	}

	for bass := range stage.Basss {
		bass.Unstage(stage)
	}

	for bass_step := range stage.Bass_steps {
		bass_step.Unstage(stage)
	}

	for beam := range stage.Beams {
		beam.Unstage(stage)
	}

	for beat_repeat := range stage.Beat_repeats {
		beat_repeat.Unstage(stage)
	}

	for beat_unit_tied := range stage.Beat_unit_tieds {
		beat_unit_tied.Unstage(stage)
	}

	for beater := range stage.Beaters {
		beater.Unstage(stage)
	}

	for bend := range stage.Bends {
		bend.Unstage(stage)
	}

	for bookmark := range stage.Bookmarks {
		bookmark.Unstage(stage)
	}

	for bracket := range stage.Brackets {
		bracket.Unstage(stage)
	}

	for breath_mark := range stage.Breath_marks {
		breath_mark.Unstage(stage)
	}

	for caesura := range stage.Caesuras {
		caesura.Unstage(stage)
	}

	for cancel := range stage.Cancels {
		cancel.Unstage(stage)
	}

	for clef := range stage.Clefs {
		clef.Unstage(stage)
	}

	for coda := range stage.Codas {
		coda.Unstage(stage)
	}

	for credit := range stage.Credits {
		credit.Unstage(stage)
	}

	for dashes := range stage.Dashess {
		dashes.Unstage(stage)
	}

	for defaults := range stage.Defaultss {
		defaults.Unstage(stage)
	}

	for degree := range stage.Degrees {
		degree.Unstage(stage)
	}

	for degree_alter := range stage.Degree_alters {
		degree_alter.Unstage(stage)
	}

	for degree_type := range stage.Degree_types {
		degree_type.Unstage(stage)
	}

	for degree_value := range stage.Degree_values {
		degree_value.Unstage(stage)
	}

	for direction := range stage.Directions {
		direction.Unstage(stage)
	}

	for direction_type := range stage.Direction_types {
		direction_type.Unstage(stage)
	}

	for distance := range stage.Distances {
		distance.Unstage(stage)
	}

	for double := range stage.Doubles {
		double.Unstage(stage)
	}

	for dynamics := range stage.Dynamicss {
		dynamics.Unstage(stage)
	}

	for effect := range stage.Effects {
		effect.Unstage(stage)
	}

	for elision := range stage.Elisions {
		elision.Unstage(stage)
	}

	for empty := range stage.Emptys {
		empty.Unstage(stage)
	}

	for empty_font := range stage.Empty_fonts {
		empty_font.Unstage(stage)
	}

	for empty_line := range stage.Empty_lines {
		empty_line.Unstage(stage)
	}

	for empty_placement := range stage.Empty_placements {
		empty_placement.Unstage(stage)
	}

	for empty_placement_smufl := range stage.Empty_placement_smufls {
		empty_placement_smufl.Unstage(stage)
	}

	for empty_print_object_style_align := range stage.Empty_print_object_style_aligns {
		empty_print_object_style_align.Unstage(stage)
	}

	for empty_print_style := range stage.Empty_print_styles {
		empty_print_style.Unstage(stage)
	}

	for empty_print_style_align := range stage.Empty_print_style_aligns {
		empty_print_style_align.Unstage(stage)
	}

	for empty_print_style_align_id := range stage.Empty_print_style_align_ids {
		empty_print_style_align_id.Unstage(stage)
	}

	for empty_trill_sound := range stage.Empty_trill_sounds {
		empty_trill_sound.Unstage(stage)
	}

	for encoding := range stage.Encodings {
		encoding.Unstage(stage)
	}

	for ending := range stage.Endings {
		ending.Unstage(stage)
	}

	for extend := range stage.Extends {
		extend.Unstage(stage)
	}

	for feature := range stage.Features {
		feature.Unstage(stage)
	}

	for fermata := range stage.Fermatas {
		fermata.Unstage(stage)
	}

	for figure := range stage.Figures {
		figure.Unstage(stage)
	}

	for figured_bass := range stage.Figured_basss {
		figured_bass.Unstage(stage)
	}

	for fingering := range stage.Fingerings {
		fingering.Unstage(stage)
	}

	for first_fret := range stage.First_frets {
		first_fret.Unstage(stage)
	}

	for foo := range stage.Foos {
		foo.Unstage(stage)
	}

	for for_part := range stage.For_parts {
		for_part.Unstage(stage)
	}

	for formatted_symbol := range stage.Formatted_symbols {
		formatted_symbol.Unstage(stage)
	}

	for formatted_symbol_id := range stage.Formatted_symbol_ids {
		formatted_symbol_id.Unstage(stage)
	}

	for forward := range stage.Forwards {
		forward.Unstage(stage)
	}

	for frame := range stage.Frames {
		frame.Unstage(stage)
	}

	for frame_note := range stage.Frame_notes {
		frame_note.Unstage(stage)
	}

	for fret := range stage.Frets {
		fret.Unstage(stage)
	}

	for glass := range stage.Glasss {
		glass.Unstage(stage)
	}

	for glissando := range stage.Glissandos {
		glissando.Unstage(stage)
	}

	for glyph := range stage.Glyphs {
		glyph.Unstage(stage)
	}

	for grace := range stage.Graces {
		grace.Unstage(stage)
	}

	for group_barline := range stage.Group_barlines {
		group_barline.Unstage(stage)
	}

	for group_symbol := range stage.Group_symbols {
		group_symbol.Unstage(stage)
	}

	for grouping := range stage.Groupings {
		grouping.Unstage(stage)
	}

	for hammer_on_pull_off := range stage.Hammer_on_pull_offs {
		hammer_on_pull_off.Unstage(stage)
	}

	for handbell := range stage.Handbells {
		handbell.Unstage(stage)
	}

	for harmon_closed := range stage.Harmon_closeds {
		harmon_closed.Unstage(stage)
	}

	for harmon_mute := range stage.Harmon_mutes {
		harmon_mute.Unstage(stage)
	}

	for harmonic := range stage.Harmonics {
		harmonic.Unstage(stage)
	}

	for harmony := range stage.Harmonys {
		harmony.Unstage(stage)
	}

	for harmony_alter := range stage.Harmony_alters {
		harmony_alter.Unstage(stage)
	}

	for harp_pedals := range stage.Harp_pedalss {
		harp_pedals.Unstage(stage)
	}

	for heel_toe := range stage.Heel_toes {
		heel_toe.Unstage(stage)
	}

	for hole := range stage.Holes {
		hole.Unstage(stage)
	}

	for hole_closed := range stage.Hole_closeds {
		hole_closed.Unstage(stage)
	}

	for horizontal_turn := range stage.Horizontal_turns {
		horizontal_turn.Unstage(stage)
	}

	for identification := range stage.Identifications {
		identification.Unstage(stage)
	}

	for image := range stage.Images {
		image.Unstage(stage)
	}

	for instrument := range stage.Instruments {
		instrument.Unstage(stage)
	}

	for instrument_change := range stage.Instrument_changes {
		instrument_change.Unstage(stage)
	}

	for instrument_link := range stage.Instrument_links {
		instrument_link.Unstage(stage)
	}

	for interchangeable := range stage.Interchangeables {
		interchangeable.Unstage(stage)
	}

	for inversion := range stage.Inversions {
		inversion.Unstage(stage)
	}

	for key := range stage.Keys {
		key.Unstage(stage)
	}

	for key_accidental := range stage.Key_accidentals {
		key_accidental.Unstage(stage)
	}

	for key_octave := range stage.Key_octaves {
		key_octave.Unstage(stage)
	}

	for kind := range stage.Kinds {
		kind.Unstage(stage)
	}

	for level := range stage.Levels {
		level.Unstage(stage)
	}

	for line_detail := range stage.Line_details {
		line_detail.Unstage(stage)
	}

	for line_width := range stage.Line_widths {
		line_width.Unstage(stage)
	}

	for link := range stage.Links {
		link.Unstage(stage)
	}

	for listen := range stage.Listens {
		listen.Unstage(stage)
	}

	for listening := range stage.Listenings {
		listening.Unstage(stage)
	}

	for lyric := range stage.Lyrics {
		lyric.Unstage(stage)
	}

	for lyric_font := range stage.Lyric_fonts {
		lyric_font.Unstage(stage)
	}

	for lyric_language := range stage.Lyric_languages {
		lyric_language.Unstage(stage)
	}

	for measure_layout := range stage.Measure_layouts {
		measure_layout.Unstage(stage)
	}

	for measure_numbering := range stage.Measure_numberings {
		measure_numbering.Unstage(stage)
	}

	for measure_repeat := range stage.Measure_repeats {
		measure_repeat.Unstage(stage)
	}

	for measure_style := range stage.Measure_styles {
		measure_style.Unstage(stage)
	}

	for membrane := range stage.Membranes {
		membrane.Unstage(stage)
	}

	for metal := range stage.Metals {
		metal.Unstage(stage)
	}

	for metronome := range stage.Metronomes {
		metronome.Unstage(stage)
	}

	for metronome_beam := range stage.Metronome_beams {
		metronome_beam.Unstage(stage)
	}

	for metronome_note := range stage.Metronome_notes {
		metronome_note.Unstage(stage)
	}

	for metronome_tied := range stage.Metronome_tieds {
		metronome_tied.Unstage(stage)
	}

	for metronome_tuplet := range stage.Metronome_tuplets {
		metronome_tuplet.Unstage(stage)
	}

	for midi_device := range stage.Midi_devices {
		midi_device.Unstage(stage)
	}

	for midi_instrument := range stage.Midi_instruments {
		midi_instrument.Unstage(stage)
	}

	for miscellaneous := range stage.Miscellaneouss {
		miscellaneous.Unstage(stage)
	}

	for miscellaneous_field := range stage.Miscellaneous_fields {
		miscellaneous_field.Unstage(stage)
	}

	for mordent := range stage.Mordents {
		mordent.Unstage(stage)
	}

	for multiple_rest := range stage.Multiple_rests {
		multiple_rest.Unstage(stage)
	}

	for name_display := range stage.Name_displays {
		name_display.Unstage(stage)
	}

	for non_arpeggiate := range stage.Non_arpeggiates {
		non_arpeggiate.Unstage(stage)
	}

	for notations := range stage.Notationss {
		notations.Unstage(stage)
	}

	for note := range stage.Notes {
		note.Unstage(stage)
	}

	for note_size := range stage.Note_sizes {
		note_size.Unstage(stage)
	}

	for note_type := range stage.Note_types {
		note_type.Unstage(stage)
	}

	for notehead := range stage.Noteheads {
		notehead.Unstage(stage)
	}

	for notehead_text := range stage.Notehead_texts {
		notehead_text.Unstage(stage)
	}

	for numeral := range stage.Numerals {
		numeral.Unstage(stage)
	}

	for numeral_key := range stage.Numeral_keys {
		numeral_key.Unstage(stage)
	}

	for numeral_root := range stage.Numeral_roots {
		numeral_root.Unstage(stage)
	}

	for octave_shift := range stage.Octave_shifts {
		octave_shift.Unstage(stage)
	}

	for offset := range stage.Offsets {
		offset.Unstage(stage)
	}

	for opus := range stage.Opuss {
		opus.Unstage(stage)
	}

	for ornaments := range stage.Ornamentss {
		ornaments.Unstage(stage)
	}

	for other_appearance := range stage.Other_appearances {
		other_appearance.Unstage(stage)
	}

	for other_listening := range stage.Other_listenings {
		other_listening.Unstage(stage)
	}

	for other_notation := range stage.Other_notations {
		other_notation.Unstage(stage)
	}

	for other_play := range stage.Other_plays {
		other_play.Unstage(stage)
	}

	for page_layout := range stage.Page_layouts {
		page_layout.Unstage(stage)
	}

	for page_margins := range stage.Page_marginss {
		page_margins.Unstage(stage)
	}

	for part_clef := range stage.Part_clefs {
		part_clef.Unstage(stage)
	}

	for part_group := range stage.Part_groups {
		part_group.Unstage(stage)
	}

	for part_link := range stage.Part_links {
		part_link.Unstage(stage)
	}

	for part_list := range stage.Part_lists {
		part_list.Unstage(stage)
	}

	for part_symbol := range stage.Part_symbols {
		part_symbol.Unstage(stage)
	}

	for part_transpose := range stage.Part_transposes {
		part_transpose.Unstage(stage)
	}

	for pedal := range stage.Pedals {
		pedal.Unstage(stage)
	}

	for pedal_tuning := range stage.Pedal_tunings {
		pedal_tuning.Unstage(stage)
	}

	for percussion := range stage.Percussions {
		percussion.Unstage(stage)
	}

	for pitch := range stage.Pitchs {
		pitch.Unstage(stage)
	}

	for pitched := range stage.Pitcheds {
		pitched.Unstage(stage)
	}

	for play := range stage.Plays {
		play.Unstage(stage)
	}

	for player := range stage.Players {
		player.Unstage(stage)
	}

	for principal_voice := range stage.Principal_voices {
		principal_voice.Unstage(stage)
	}

	for print := range stage.Prints {
		print.Unstage(stage)
	}

	for release := range stage.Releases {
		release.Unstage(stage)
	}

	for repeat := range stage.Repeats {
		repeat.Unstage(stage)
	}

	for rest := range stage.Rests {
		rest.Unstage(stage)
	}

	for root := range stage.Roots {
		root.Unstage(stage)
	}

	for root_step := range stage.Root_steps {
		root_step.Unstage(stage)
	}

	for scaling := range stage.Scalings {
		scaling.Unstage(stage)
	}

	for scordatura := range stage.Scordaturas {
		scordatura.Unstage(stage)
	}

	for score_instrument := range stage.Score_instruments {
		score_instrument.Unstage(stage)
	}

	for score_part := range stage.Score_parts {
		score_part.Unstage(stage)
	}

	for score_partwise := range stage.Score_partwises {
		score_partwise.Unstage(stage)
	}

	for score_timewise := range stage.Score_timewises {
		score_timewise.Unstage(stage)
	}

	for segno := range stage.Segnos {
		segno.Unstage(stage)
	}

	for slash := range stage.Slashs {
		slash.Unstage(stage)
	}

	for slide := range stage.Slides {
		slide.Unstage(stage)
	}

	for slur := range stage.Slurs {
		slur.Unstage(stage)
	}

	for sound := range stage.Sounds {
		sound.Unstage(stage)
	}

	for staff_details := range stage.Staff_detailss {
		staff_details.Unstage(stage)
	}

	for staff_divide := range stage.Staff_divides {
		staff_divide.Unstage(stage)
	}

	for staff_layout := range stage.Staff_layouts {
		staff_layout.Unstage(stage)
	}

	for staff_size := range stage.Staff_sizes {
		staff_size.Unstage(stage)
	}

	for staff_tuning := range stage.Staff_tunings {
		staff_tuning.Unstage(stage)
	}

	for stem := range stage.Stems {
		stem.Unstage(stage)
	}

	for stick := range stage.Sticks {
		stick.Unstage(stage)
	}

	for string_mute := range stage.String_mutes {
		string_mute.Unstage(stage)
	}

	for strong_accent := range stage.Strong_accents {
		strong_accent.Unstage(stage)
	}

	for supports := range stage.Supportss {
		supports.Unstage(stage)
	}

	for swing := range stage.Swings {
		swing.Unstage(stage)
	}

	for sync := range stage.Syncs {
		sync.Unstage(stage)
	}

	for system_dividers := range stage.System_dividerss {
		system_dividers.Unstage(stage)
	}

	for system_layout := range stage.System_layouts {
		system_layout.Unstage(stage)
	}

	for system_margins := range stage.System_marginss {
		system_margins.Unstage(stage)
	}

	for tap := range stage.Taps {
		tap.Unstage(stage)
	}

	for technical := range stage.Technicals {
		technical.Unstage(stage)
	}

	for text_element_data := range stage.Text_element_datas {
		text_element_data.Unstage(stage)
	}

	for tie := range stage.Ties {
		tie.Unstage(stage)
	}

	for tied := range stage.Tieds {
		tied.Unstage(stage)
	}

	for time := range stage.Times {
		time.Unstage(stage)
	}

	for time_modification := range stage.Time_modifications {
		time_modification.Unstage(stage)
	}

	for timpani := range stage.Timpanis {
		timpani.Unstage(stage)
	}

	for transpose := range stage.Transposes {
		transpose.Unstage(stage)
	}

	for tremolo := range stage.Tremolos {
		tremolo.Unstage(stage)
	}

	for tuplet := range stage.Tuplets {
		tuplet.Unstage(stage)
	}

	for tuplet_dot := range stage.Tuplet_dots {
		tuplet_dot.Unstage(stage)
	}

	for tuplet_number := range stage.Tuplet_numbers {
		tuplet_number.Unstage(stage)
	}

	for tuplet_portion := range stage.Tuplet_portions {
		tuplet_portion.Unstage(stage)
	}

	for tuplet_type := range stage.Tuplet_types {
		tuplet_type.Unstage(stage)
	}

	for typed_text := range stage.Typed_texts {
		typed_text.Unstage(stage)
	}

	for unpitched := range stage.Unpitcheds {
		unpitched.Unstage(stage)
	}

	for virtual_instrument := range stage.Virtual_instruments {
		virtual_instrument.Unstage(stage)
	}

	for wait := range stage.Waits {
		wait.Unstage(stage)
	}

	for wavy_line := range stage.Wavy_lines {
		wavy_line.Unstage(stage)
	}

	for wedge := range stage.Wedges {
		wedge.Unstage(stage)
	}

	for wood := range stage.Woods {
		wood.Unstage(stage)
	}

	for work := range stage.Works {
		work.Unstage(stage)
	}

}

// Gongstruct is the type parameter for generated generic function that allows
// - access to staged instances
// - navigation between staged instances by going backward association links between gongstruct
// - full refactoring of Gongstruct identifiers / fields
type Gongstruct interface {
	// insertion point for generic types
}

type GongtructBasicField interface {
	int | float64 | bool | string | time.Time | time.Duration
}

// Gongstruct is the type parameter for generated generic function that allows
// - access to staged instances
// - navigation between staged instances by going backward association links between gongstruct
// - full refactoring of Gongstruct identifiers / fields
type PointerToGongstruct interface {
	// insertion point for generic types
	GetName() string
	CommitVoid(*StageStruct)
	UnstageVoid(stage *StageStruct)
}

func CompareGongstructByName[T PointerToGongstruct](a, b T) int {
	return cmp.Compare(a.GetName(), b.GetName())
}

func SortGongstructSetByName[T interface {
	PointerToGongstruct
	comparable
}](set map[T]any) (sortedSlice []T) {

	for s := range set {
		sortedSlice = append(sortedSlice, s)
	}
	slices.SortFunc(sortedSlice, CompareGongstructByName)

	return
}

func GetGongstrucsSorted[T interface {
	PointerToGongstruct
	comparable
}](stage *StageStruct) (sortedSlice []T) {

	set := GetGongstructInstancesSetFromPointerType[T](stage)
	sortedSlice = SortGongstructSetByName(*set)

	return
}

type GongstructSet interface {
	map[any]any
}

type GongstructMapString interface {
	map[any]any
	// insertion point for generic types

}

// GongGetSet returns the set staged GongstructType instances
// it is usefull because it allows refactoring of gong struct identifier
func GongGetSet[Type GongstructSet](stage *StageStruct) *Type {
	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get functions
	case map[*Accidental]any:
		return any(&stage.Accidentals).(*Type)
	case map[*Accidental_mark]any:
		return any(&stage.Accidental_marks).(*Type)
	case map[*Accidental_text]any:
		return any(&stage.Accidental_texts).(*Type)
	case map[*Accord]any:
		return any(&stage.Accords).(*Type)
	case map[*Accordion_registration]any:
		return any(&stage.Accordion_registrations).(*Type)
	case map[*AnyType]any:
		return any(&stage.AnyTypes).(*Type)
	case map[*Appearance]any:
		return any(&stage.Appearances).(*Type)
	case map[*Arpeggiate]any:
		return any(&stage.Arpeggiates).(*Type)
	case map[*Arrow]any:
		return any(&stage.Arrows).(*Type)
	case map[*Articulations]any:
		return any(&stage.Articulationss).(*Type)
	case map[*Assess]any:
		return any(&stage.Assesss).(*Type)
	case map[*Attributes]any:
		return any(&stage.Attributess).(*Type)
	case map[*Backup]any:
		return any(&stage.Backups).(*Type)
	case map[*Bar_style_color]any:
		return any(&stage.Bar_style_colors).(*Type)
	case map[*Barline]any:
		return any(&stage.Barlines).(*Type)
	case map[*Barre]any:
		return any(&stage.Barres).(*Type)
	case map[*Bass]any:
		return any(&stage.Basss).(*Type)
	case map[*Bass_step]any:
		return any(&stage.Bass_steps).(*Type)
	case map[*Beam]any:
		return any(&stage.Beams).(*Type)
	case map[*Beat_repeat]any:
		return any(&stage.Beat_repeats).(*Type)
	case map[*Beat_unit_tied]any:
		return any(&stage.Beat_unit_tieds).(*Type)
	case map[*Beater]any:
		return any(&stage.Beaters).(*Type)
	case map[*Bend]any:
		return any(&stage.Bends).(*Type)
	case map[*Bookmark]any:
		return any(&stage.Bookmarks).(*Type)
	case map[*Bracket]any:
		return any(&stage.Brackets).(*Type)
	case map[*Breath_mark]any:
		return any(&stage.Breath_marks).(*Type)
	case map[*Caesura]any:
		return any(&stage.Caesuras).(*Type)
	case map[*Cancel]any:
		return any(&stage.Cancels).(*Type)
	case map[*Clef]any:
		return any(&stage.Clefs).(*Type)
	case map[*Coda]any:
		return any(&stage.Codas).(*Type)
	case map[*Credit]any:
		return any(&stage.Credits).(*Type)
	case map[*Dashes]any:
		return any(&stage.Dashess).(*Type)
	case map[*Defaults]any:
		return any(&stage.Defaultss).(*Type)
	case map[*Degree]any:
		return any(&stage.Degrees).(*Type)
	case map[*Degree_alter]any:
		return any(&stage.Degree_alters).(*Type)
	case map[*Degree_type]any:
		return any(&stage.Degree_types).(*Type)
	case map[*Degree_value]any:
		return any(&stage.Degree_values).(*Type)
	case map[*Direction]any:
		return any(&stage.Directions).(*Type)
	case map[*Direction_type]any:
		return any(&stage.Direction_types).(*Type)
	case map[*Distance]any:
		return any(&stage.Distances).(*Type)
	case map[*Double]any:
		return any(&stage.Doubles).(*Type)
	case map[*Dynamics]any:
		return any(&stage.Dynamicss).(*Type)
	case map[*Effect]any:
		return any(&stage.Effects).(*Type)
	case map[*Elision]any:
		return any(&stage.Elisions).(*Type)
	case map[*Empty]any:
		return any(&stage.Emptys).(*Type)
	case map[*Empty_font]any:
		return any(&stage.Empty_fonts).(*Type)
	case map[*Empty_line]any:
		return any(&stage.Empty_lines).(*Type)
	case map[*Empty_placement]any:
		return any(&stage.Empty_placements).(*Type)
	case map[*Empty_placement_smufl]any:
		return any(&stage.Empty_placement_smufls).(*Type)
	case map[*Empty_print_object_style_align]any:
		return any(&stage.Empty_print_object_style_aligns).(*Type)
	case map[*Empty_print_style]any:
		return any(&stage.Empty_print_styles).(*Type)
	case map[*Empty_print_style_align]any:
		return any(&stage.Empty_print_style_aligns).(*Type)
	case map[*Empty_print_style_align_id]any:
		return any(&stage.Empty_print_style_align_ids).(*Type)
	case map[*Empty_trill_sound]any:
		return any(&stage.Empty_trill_sounds).(*Type)
	case map[*Encoding]any:
		return any(&stage.Encodings).(*Type)
	case map[*Ending]any:
		return any(&stage.Endings).(*Type)
	case map[*Extend]any:
		return any(&stage.Extends).(*Type)
	case map[*Feature]any:
		return any(&stage.Features).(*Type)
	case map[*Fermata]any:
		return any(&stage.Fermatas).(*Type)
	case map[*Figure]any:
		return any(&stage.Figures).(*Type)
	case map[*Figured_bass]any:
		return any(&stage.Figured_basss).(*Type)
	case map[*Fingering]any:
		return any(&stage.Fingerings).(*Type)
	case map[*First_fret]any:
		return any(&stage.First_frets).(*Type)
	case map[*Foo]any:
		return any(&stage.Foos).(*Type)
	case map[*For_part]any:
		return any(&stage.For_parts).(*Type)
	case map[*Formatted_symbol]any:
		return any(&stage.Formatted_symbols).(*Type)
	case map[*Formatted_symbol_id]any:
		return any(&stage.Formatted_symbol_ids).(*Type)
	case map[*Forward]any:
		return any(&stage.Forwards).(*Type)
	case map[*Frame]any:
		return any(&stage.Frames).(*Type)
	case map[*Frame_note]any:
		return any(&stage.Frame_notes).(*Type)
	case map[*Fret]any:
		return any(&stage.Frets).(*Type)
	case map[*Glass]any:
		return any(&stage.Glasss).(*Type)
	case map[*Glissando]any:
		return any(&stage.Glissandos).(*Type)
	case map[*Glyph]any:
		return any(&stage.Glyphs).(*Type)
	case map[*Grace]any:
		return any(&stage.Graces).(*Type)
	case map[*Group_barline]any:
		return any(&stage.Group_barlines).(*Type)
	case map[*Group_symbol]any:
		return any(&stage.Group_symbols).(*Type)
	case map[*Grouping]any:
		return any(&stage.Groupings).(*Type)
	case map[*Hammer_on_pull_off]any:
		return any(&stage.Hammer_on_pull_offs).(*Type)
	case map[*Handbell]any:
		return any(&stage.Handbells).(*Type)
	case map[*Harmon_closed]any:
		return any(&stage.Harmon_closeds).(*Type)
	case map[*Harmon_mute]any:
		return any(&stage.Harmon_mutes).(*Type)
	case map[*Harmonic]any:
		return any(&stage.Harmonics).(*Type)
	case map[*Harmony]any:
		return any(&stage.Harmonys).(*Type)
	case map[*Harmony_alter]any:
		return any(&stage.Harmony_alters).(*Type)
	case map[*Harp_pedals]any:
		return any(&stage.Harp_pedalss).(*Type)
	case map[*Heel_toe]any:
		return any(&stage.Heel_toes).(*Type)
	case map[*Hole]any:
		return any(&stage.Holes).(*Type)
	case map[*Hole_closed]any:
		return any(&stage.Hole_closeds).(*Type)
	case map[*Horizontal_turn]any:
		return any(&stage.Horizontal_turns).(*Type)
	case map[*Identification]any:
		return any(&stage.Identifications).(*Type)
	case map[*Image]any:
		return any(&stage.Images).(*Type)
	case map[*Instrument]any:
		return any(&stage.Instruments).(*Type)
	case map[*Instrument_change]any:
		return any(&stage.Instrument_changes).(*Type)
	case map[*Instrument_link]any:
		return any(&stage.Instrument_links).(*Type)
	case map[*Interchangeable]any:
		return any(&stage.Interchangeables).(*Type)
	case map[*Inversion]any:
		return any(&stage.Inversions).(*Type)
	case map[*Key]any:
		return any(&stage.Keys).(*Type)
	case map[*Key_accidental]any:
		return any(&stage.Key_accidentals).(*Type)
	case map[*Key_octave]any:
		return any(&stage.Key_octaves).(*Type)
	case map[*Kind]any:
		return any(&stage.Kinds).(*Type)
	case map[*Level]any:
		return any(&stage.Levels).(*Type)
	case map[*Line_detail]any:
		return any(&stage.Line_details).(*Type)
	case map[*Line_width]any:
		return any(&stage.Line_widths).(*Type)
	case map[*Link]any:
		return any(&stage.Links).(*Type)
	case map[*Listen]any:
		return any(&stage.Listens).(*Type)
	case map[*Listening]any:
		return any(&stage.Listenings).(*Type)
	case map[*Lyric]any:
		return any(&stage.Lyrics).(*Type)
	case map[*Lyric_font]any:
		return any(&stage.Lyric_fonts).(*Type)
	case map[*Lyric_language]any:
		return any(&stage.Lyric_languages).(*Type)
	case map[*Measure_layout]any:
		return any(&stage.Measure_layouts).(*Type)
	case map[*Measure_numbering]any:
		return any(&stage.Measure_numberings).(*Type)
	case map[*Measure_repeat]any:
		return any(&stage.Measure_repeats).(*Type)
	case map[*Measure_style]any:
		return any(&stage.Measure_styles).(*Type)
	case map[*Membrane]any:
		return any(&stage.Membranes).(*Type)
	case map[*Metal]any:
		return any(&stage.Metals).(*Type)
	case map[*Metronome]any:
		return any(&stage.Metronomes).(*Type)
	case map[*Metronome_beam]any:
		return any(&stage.Metronome_beams).(*Type)
	case map[*Metronome_note]any:
		return any(&stage.Metronome_notes).(*Type)
	case map[*Metronome_tied]any:
		return any(&stage.Metronome_tieds).(*Type)
	case map[*Metronome_tuplet]any:
		return any(&stage.Metronome_tuplets).(*Type)
	case map[*Midi_device]any:
		return any(&stage.Midi_devices).(*Type)
	case map[*Midi_instrument]any:
		return any(&stage.Midi_instruments).(*Type)
	case map[*Miscellaneous]any:
		return any(&stage.Miscellaneouss).(*Type)
	case map[*Miscellaneous_field]any:
		return any(&stage.Miscellaneous_fields).(*Type)
	case map[*Mordent]any:
		return any(&stage.Mordents).(*Type)
	case map[*Multiple_rest]any:
		return any(&stage.Multiple_rests).(*Type)
	case map[*Name_display]any:
		return any(&stage.Name_displays).(*Type)
	case map[*Non_arpeggiate]any:
		return any(&stage.Non_arpeggiates).(*Type)
	case map[*Notations]any:
		return any(&stage.Notationss).(*Type)
	case map[*Note]any:
		return any(&stage.Notes).(*Type)
	case map[*Note_size]any:
		return any(&stage.Note_sizes).(*Type)
	case map[*Note_type]any:
		return any(&stage.Note_types).(*Type)
	case map[*Notehead]any:
		return any(&stage.Noteheads).(*Type)
	case map[*Notehead_text]any:
		return any(&stage.Notehead_texts).(*Type)
	case map[*Numeral]any:
		return any(&stage.Numerals).(*Type)
	case map[*Numeral_key]any:
		return any(&stage.Numeral_keys).(*Type)
	case map[*Numeral_root]any:
		return any(&stage.Numeral_roots).(*Type)
	case map[*Octave_shift]any:
		return any(&stage.Octave_shifts).(*Type)
	case map[*Offset]any:
		return any(&stage.Offsets).(*Type)
	case map[*Opus]any:
		return any(&stage.Opuss).(*Type)
	case map[*Ornaments]any:
		return any(&stage.Ornamentss).(*Type)
	case map[*Other_appearance]any:
		return any(&stage.Other_appearances).(*Type)
	case map[*Other_listening]any:
		return any(&stage.Other_listenings).(*Type)
	case map[*Other_notation]any:
		return any(&stage.Other_notations).(*Type)
	case map[*Other_play]any:
		return any(&stage.Other_plays).(*Type)
	case map[*Page_layout]any:
		return any(&stage.Page_layouts).(*Type)
	case map[*Page_margins]any:
		return any(&stage.Page_marginss).(*Type)
	case map[*Part_clef]any:
		return any(&stage.Part_clefs).(*Type)
	case map[*Part_group]any:
		return any(&stage.Part_groups).(*Type)
	case map[*Part_link]any:
		return any(&stage.Part_links).(*Type)
	case map[*Part_list]any:
		return any(&stage.Part_lists).(*Type)
	case map[*Part_symbol]any:
		return any(&stage.Part_symbols).(*Type)
	case map[*Part_transpose]any:
		return any(&stage.Part_transposes).(*Type)
	case map[*Pedal]any:
		return any(&stage.Pedals).(*Type)
	case map[*Pedal_tuning]any:
		return any(&stage.Pedal_tunings).(*Type)
	case map[*Percussion]any:
		return any(&stage.Percussions).(*Type)
	case map[*Pitch]any:
		return any(&stage.Pitchs).(*Type)
	case map[*Pitched]any:
		return any(&stage.Pitcheds).(*Type)
	case map[*Play]any:
		return any(&stage.Plays).(*Type)
	case map[*Player]any:
		return any(&stage.Players).(*Type)
	case map[*Principal_voice]any:
		return any(&stage.Principal_voices).(*Type)
	case map[*Print]any:
		return any(&stage.Prints).(*Type)
	case map[*Release]any:
		return any(&stage.Releases).(*Type)
	case map[*Repeat]any:
		return any(&stage.Repeats).(*Type)
	case map[*Rest]any:
		return any(&stage.Rests).(*Type)
	case map[*Root]any:
		return any(&stage.Roots).(*Type)
	case map[*Root_step]any:
		return any(&stage.Root_steps).(*Type)
	case map[*Scaling]any:
		return any(&stage.Scalings).(*Type)
	case map[*Scordatura]any:
		return any(&stage.Scordaturas).(*Type)
	case map[*Score_instrument]any:
		return any(&stage.Score_instruments).(*Type)
	case map[*Score_part]any:
		return any(&stage.Score_parts).(*Type)
	case map[*Score_partwise]any:
		return any(&stage.Score_partwises).(*Type)
	case map[*Score_timewise]any:
		return any(&stage.Score_timewises).(*Type)
	case map[*Segno]any:
		return any(&stage.Segnos).(*Type)
	case map[*Slash]any:
		return any(&stage.Slashs).(*Type)
	case map[*Slide]any:
		return any(&stage.Slides).(*Type)
	case map[*Slur]any:
		return any(&stage.Slurs).(*Type)
	case map[*Sound]any:
		return any(&stage.Sounds).(*Type)
	case map[*Staff_details]any:
		return any(&stage.Staff_detailss).(*Type)
	case map[*Staff_divide]any:
		return any(&stage.Staff_divides).(*Type)
	case map[*Staff_layout]any:
		return any(&stage.Staff_layouts).(*Type)
	case map[*Staff_size]any:
		return any(&stage.Staff_sizes).(*Type)
	case map[*Staff_tuning]any:
		return any(&stage.Staff_tunings).(*Type)
	case map[*Stem]any:
		return any(&stage.Stems).(*Type)
	case map[*Stick]any:
		return any(&stage.Sticks).(*Type)
	case map[*String_mute]any:
		return any(&stage.String_mutes).(*Type)
	case map[*Strong_accent]any:
		return any(&stage.Strong_accents).(*Type)
	case map[*Supports]any:
		return any(&stage.Supportss).(*Type)
	case map[*Swing]any:
		return any(&stage.Swings).(*Type)
	case map[*Sync]any:
		return any(&stage.Syncs).(*Type)
	case map[*System_dividers]any:
		return any(&stage.System_dividerss).(*Type)
	case map[*System_layout]any:
		return any(&stage.System_layouts).(*Type)
	case map[*System_margins]any:
		return any(&stage.System_marginss).(*Type)
	case map[*Tap]any:
		return any(&stage.Taps).(*Type)
	case map[*Technical]any:
		return any(&stage.Technicals).(*Type)
	case map[*Text_element_data]any:
		return any(&stage.Text_element_datas).(*Type)
	case map[*Tie]any:
		return any(&stage.Ties).(*Type)
	case map[*Tied]any:
		return any(&stage.Tieds).(*Type)
	case map[*Time]any:
		return any(&stage.Times).(*Type)
	case map[*Time_modification]any:
		return any(&stage.Time_modifications).(*Type)
	case map[*Timpani]any:
		return any(&stage.Timpanis).(*Type)
	case map[*Transpose]any:
		return any(&stage.Transposes).(*Type)
	case map[*Tremolo]any:
		return any(&stage.Tremolos).(*Type)
	case map[*Tuplet]any:
		return any(&stage.Tuplets).(*Type)
	case map[*Tuplet_dot]any:
		return any(&stage.Tuplet_dots).(*Type)
	case map[*Tuplet_number]any:
		return any(&stage.Tuplet_numbers).(*Type)
	case map[*Tuplet_portion]any:
		return any(&stage.Tuplet_portions).(*Type)
	case map[*Tuplet_type]any:
		return any(&stage.Tuplet_types).(*Type)
	case map[*Typed_text]any:
		return any(&stage.Typed_texts).(*Type)
	case map[*Unpitched]any:
		return any(&stage.Unpitcheds).(*Type)
	case map[*Virtual_instrument]any:
		return any(&stage.Virtual_instruments).(*Type)
	case map[*Wait]any:
		return any(&stage.Waits).(*Type)
	case map[*Wavy_line]any:
		return any(&stage.Wavy_lines).(*Type)
	case map[*Wedge]any:
		return any(&stage.Wedges).(*Type)
	case map[*Wood]any:
		return any(&stage.Woods).(*Type)
	case map[*Work]any:
		return any(&stage.Works).(*Type)
	default:
		return nil
	}
}

// GongGetMap returns the map of staged GongstructType instances
// it is usefull because it allows refactoring of gong struct identifier
func GongGetMap[Type GongstructMapString](stage *StageStruct) *Type {
	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get functions
	case map[string]*Accidental:
		return any(&stage.Accidentals_mapString).(*Type)
	case map[string]*Accidental_mark:
		return any(&stage.Accidental_marks_mapString).(*Type)
	case map[string]*Accidental_text:
		return any(&stage.Accidental_texts_mapString).(*Type)
	case map[string]*Accord:
		return any(&stage.Accords_mapString).(*Type)
	case map[string]*Accordion_registration:
		return any(&stage.Accordion_registrations_mapString).(*Type)
	case map[string]*AnyType:
		return any(&stage.AnyTypes_mapString).(*Type)
	case map[string]*Appearance:
		return any(&stage.Appearances_mapString).(*Type)
	case map[string]*Arpeggiate:
		return any(&stage.Arpeggiates_mapString).(*Type)
	case map[string]*Arrow:
		return any(&stage.Arrows_mapString).(*Type)
	case map[string]*Articulations:
		return any(&stage.Articulationss_mapString).(*Type)
	case map[string]*Assess:
		return any(&stage.Assesss_mapString).(*Type)
	case map[string]*Attributes:
		return any(&stage.Attributess_mapString).(*Type)
	case map[string]*Backup:
		return any(&stage.Backups_mapString).(*Type)
	case map[string]*Bar_style_color:
		return any(&stage.Bar_style_colors_mapString).(*Type)
	case map[string]*Barline:
		return any(&stage.Barlines_mapString).(*Type)
	case map[string]*Barre:
		return any(&stage.Barres_mapString).(*Type)
	case map[string]*Bass:
		return any(&stage.Basss_mapString).(*Type)
	case map[string]*Bass_step:
		return any(&stage.Bass_steps_mapString).(*Type)
	case map[string]*Beam:
		return any(&stage.Beams_mapString).(*Type)
	case map[string]*Beat_repeat:
		return any(&stage.Beat_repeats_mapString).(*Type)
	case map[string]*Beat_unit_tied:
		return any(&stage.Beat_unit_tieds_mapString).(*Type)
	case map[string]*Beater:
		return any(&stage.Beaters_mapString).(*Type)
	case map[string]*Bend:
		return any(&stage.Bends_mapString).(*Type)
	case map[string]*Bookmark:
		return any(&stage.Bookmarks_mapString).(*Type)
	case map[string]*Bracket:
		return any(&stage.Brackets_mapString).(*Type)
	case map[string]*Breath_mark:
		return any(&stage.Breath_marks_mapString).(*Type)
	case map[string]*Caesura:
		return any(&stage.Caesuras_mapString).(*Type)
	case map[string]*Cancel:
		return any(&stage.Cancels_mapString).(*Type)
	case map[string]*Clef:
		return any(&stage.Clefs_mapString).(*Type)
	case map[string]*Coda:
		return any(&stage.Codas_mapString).(*Type)
	case map[string]*Credit:
		return any(&stage.Credits_mapString).(*Type)
	case map[string]*Dashes:
		return any(&stage.Dashess_mapString).(*Type)
	case map[string]*Defaults:
		return any(&stage.Defaultss_mapString).(*Type)
	case map[string]*Degree:
		return any(&stage.Degrees_mapString).(*Type)
	case map[string]*Degree_alter:
		return any(&stage.Degree_alters_mapString).(*Type)
	case map[string]*Degree_type:
		return any(&stage.Degree_types_mapString).(*Type)
	case map[string]*Degree_value:
		return any(&stage.Degree_values_mapString).(*Type)
	case map[string]*Direction:
		return any(&stage.Directions_mapString).(*Type)
	case map[string]*Direction_type:
		return any(&stage.Direction_types_mapString).(*Type)
	case map[string]*Distance:
		return any(&stage.Distances_mapString).(*Type)
	case map[string]*Double:
		return any(&stage.Doubles_mapString).(*Type)
	case map[string]*Dynamics:
		return any(&stage.Dynamicss_mapString).(*Type)
	case map[string]*Effect:
		return any(&stage.Effects_mapString).(*Type)
	case map[string]*Elision:
		return any(&stage.Elisions_mapString).(*Type)
	case map[string]*Empty:
		return any(&stage.Emptys_mapString).(*Type)
	case map[string]*Empty_font:
		return any(&stage.Empty_fonts_mapString).(*Type)
	case map[string]*Empty_line:
		return any(&stage.Empty_lines_mapString).(*Type)
	case map[string]*Empty_placement:
		return any(&stage.Empty_placements_mapString).(*Type)
	case map[string]*Empty_placement_smufl:
		return any(&stage.Empty_placement_smufls_mapString).(*Type)
	case map[string]*Empty_print_object_style_align:
		return any(&stage.Empty_print_object_style_aligns_mapString).(*Type)
	case map[string]*Empty_print_style:
		return any(&stage.Empty_print_styles_mapString).(*Type)
	case map[string]*Empty_print_style_align:
		return any(&stage.Empty_print_style_aligns_mapString).(*Type)
	case map[string]*Empty_print_style_align_id:
		return any(&stage.Empty_print_style_align_ids_mapString).(*Type)
	case map[string]*Empty_trill_sound:
		return any(&stage.Empty_trill_sounds_mapString).(*Type)
	case map[string]*Encoding:
		return any(&stage.Encodings_mapString).(*Type)
	case map[string]*Ending:
		return any(&stage.Endings_mapString).(*Type)
	case map[string]*Extend:
		return any(&stage.Extends_mapString).(*Type)
	case map[string]*Feature:
		return any(&stage.Features_mapString).(*Type)
	case map[string]*Fermata:
		return any(&stage.Fermatas_mapString).(*Type)
	case map[string]*Figure:
		return any(&stage.Figures_mapString).(*Type)
	case map[string]*Figured_bass:
		return any(&stage.Figured_basss_mapString).(*Type)
	case map[string]*Fingering:
		return any(&stage.Fingerings_mapString).(*Type)
	case map[string]*First_fret:
		return any(&stage.First_frets_mapString).(*Type)
	case map[string]*Foo:
		return any(&stage.Foos_mapString).(*Type)
	case map[string]*For_part:
		return any(&stage.For_parts_mapString).(*Type)
	case map[string]*Formatted_symbol:
		return any(&stage.Formatted_symbols_mapString).(*Type)
	case map[string]*Formatted_symbol_id:
		return any(&stage.Formatted_symbol_ids_mapString).(*Type)
	case map[string]*Forward:
		return any(&stage.Forwards_mapString).(*Type)
	case map[string]*Frame:
		return any(&stage.Frames_mapString).(*Type)
	case map[string]*Frame_note:
		return any(&stage.Frame_notes_mapString).(*Type)
	case map[string]*Fret:
		return any(&stage.Frets_mapString).(*Type)
	case map[string]*Glass:
		return any(&stage.Glasss_mapString).(*Type)
	case map[string]*Glissando:
		return any(&stage.Glissandos_mapString).(*Type)
	case map[string]*Glyph:
		return any(&stage.Glyphs_mapString).(*Type)
	case map[string]*Grace:
		return any(&stage.Graces_mapString).(*Type)
	case map[string]*Group_barline:
		return any(&stage.Group_barlines_mapString).(*Type)
	case map[string]*Group_symbol:
		return any(&stage.Group_symbols_mapString).(*Type)
	case map[string]*Grouping:
		return any(&stage.Groupings_mapString).(*Type)
	case map[string]*Hammer_on_pull_off:
		return any(&stage.Hammer_on_pull_offs_mapString).(*Type)
	case map[string]*Handbell:
		return any(&stage.Handbells_mapString).(*Type)
	case map[string]*Harmon_closed:
		return any(&stage.Harmon_closeds_mapString).(*Type)
	case map[string]*Harmon_mute:
		return any(&stage.Harmon_mutes_mapString).(*Type)
	case map[string]*Harmonic:
		return any(&stage.Harmonics_mapString).(*Type)
	case map[string]*Harmony:
		return any(&stage.Harmonys_mapString).(*Type)
	case map[string]*Harmony_alter:
		return any(&stage.Harmony_alters_mapString).(*Type)
	case map[string]*Harp_pedals:
		return any(&stage.Harp_pedalss_mapString).(*Type)
	case map[string]*Heel_toe:
		return any(&stage.Heel_toes_mapString).(*Type)
	case map[string]*Hole:
		return any(&stage.Holes_mapString).(*Type)
	case map[string]*Hole_closed:
		return any(&stage.Hole_closeds_mapString).(*Type)
	case map[string]*Horizontal_turn:
		return any(&stage.Horizontal_turns_mapString).(*Type)
	case map[string]*Identification:
		return any(&stage.Identifications_mapString).(*Type)
	case map[string]*Image:
		return any(&stage.Images_mapString).(*Type)
	case map[string]*Instrument:
		return any(&stage.Instruments_mapString).(*Type)
	case map[string]*Instrument_change:
		return any(&stage.Instrument_changes_mapString).(*Type)
	case map[string]*Instrument_link:
		return any(&stage.Instrument_links_mapString).(*Type)
	case map[string]*Interchangeable:
		return any(&stage.Interchangeables_mapString).(*Type)
	case map[string]*Inversion:
		return any(&stage.Inversions_mapString).(*Type)
	case map[string]*Key:
		return any(&stage.Keys_mapString).(*Type)
	case map[string]*Key_accidental:
		return any(&stage.Key_accidentals_mapString).(*Type)
	case map[string]*Key_octave:
		return any(&stage.Key_octaves_mapString).(*Type)
	case map[string]*Kind:
		return any(&stage.Kinds_mapString).(*Type)
	case map[string]*Level:
		return any(&stage.Levels_mapString).(*Type)
	case map[string]*Line_detail:
		return any(&stage.Line_details_mapString).(*Type)
	case map[string]*Line_width:
		return any(&stage.Line_widths_mapString).(*Type)
	case map[string]*Link:
		return any(&stage.Links_mapString).(*Type)
	case map[string]*Listen:
		return any(&stage.Listens_mapString).(*Type)
	case map[string]*Listening:
		return any(&stage.Listenings_mapString).(*Type)
	case map[string]*Lyric:
		return any(&stage.Lyrics_mapString).(*Type)
	case map[string]*Lyric_font:
		return any(&stage.Lyric_fonts_mapString).(*Type)
	case map[string]*Lyric_language:
		return any(&stage.Lyric_languages_mapString).(*Type)
	case map[string]*Measure_layout:
		return any(&stage.Measure_layouts_mapString).(*Type)
	case map[string]*Measure_numbering:
		return any(&stage.Measure_numberings_mapString).(*Type)
	case map[string]*Measure_repeat:
		return any(&stage.Measure_repeats_mapString).(*Type)
	case map[string]*Measure_style:
		return any(&stage.Measure_styles_mapString).(*Type)
	case map[string]*Membrane:
		return any(&stage.Membranes_mapString).(*Type)
	case map[string]*Metal:
		return any(&stage.Metals_mapString).(*Type)
	case map[string]*Metronome:
		return any(&stage.Metronomes_mapString).(*Type)
	case map[string]*Metronome_beam:
		return any(&stage.Metronome_beams_mapString).(*Type)
	case map[string]*Metronome_note:
		return any(&stage.Metronome_notes_mapString).(*Type)
	case map[string]*Metronome_tied:
		return any(&stage.Metronome_tieds_mapString).(*Type)
	case map[string]*Metronome_tuplet:
		return any(&stage.Metronome_tuplets_mapString).(*Type)
	case map[string]*Midi_device:
		return any(&stage.Midi_devices_mapString).(*Type)
	case map[string]*Midi_instrument:
		return any(&stage.Midi_instruments_mapString).(*Type)
	case map[string]*Miscellaneous:
		return any(&stage.Miscellaneouss_mapString).(*Type)
	case map[string]*Miscellaneous_field:
		return any(&stage.Miscellaneous_fields_mapString).(*Type)
	case map[string]*Mordent:
		return any(&stage.Mordents_mapString).(*Type)
	case map[string]*Multiple_rest:
		return any(&stage.Multiple_rests_mapString).(*Type)
	case map[string]*Name_display:
		return any(&stage.Name_displays_mapString).(*Type)
	case map[string]*Non_arpeggiate:
		return any(&stage.Non_arpeggiates_mapString).(*Type)
	case map[string]*Notations:
		return any(&stage.Notationss_mapString).(*Type)
	case map[string]*Note:
		return any(&stage.Notes_mapString).(*Type)
	case map[string]*Note_size:
		return any(&stage.Note_sizes_mapString).(*Type)
	case map[string]*Note_type:
		return any(&stage.Note_types_mapString).(*Type)
	case map[string]*Notehead:
		return any(&stage.Noteheads_mapString).(*Type)
	case map[string]*Notehead_text:
		return any(&stage.Notehead_texts_mapString).(*Type)
	case map[string]*Numeral:
		return any(&stage.Numerals_mapString).(*Type)
	case map[string]*Numeral_key:
		return any(&stage.Numeral_keys_mapString).(*Type)
	case map[string]*Numeral_root:
		return any(&stage.Numeral_roots_mapString).(*Type)
	case map[string]*Octave_shift:
		return any(&stage.Octave_shifts_mapString).(*Type)
	case map[string]*Offset:
		return any(&stage.Offsets_mapString).(*Type)
	case map[string]*Opus:
		return any(&stage.Opuss_mapString).(*Type)
	case map[string]*Ornaments:
		return any(&stage.Ornamentss_mapString).(*Type)
	case map[string]*Other_appearance:
		return any(&stage.Other_appearances_mapString).(*Type)
	case map[string]*Other_listening:
		return any(&stage.Other_listenings_mapString).(*Type)
	case map[string]*Other_notation:
		return any(&stage.Other_notations_mapString).(*Type)
	case map[string]*Other_play:
		return any(&stage.Other_plays_mapString).(*Type)
	case map[string]*Page_layout:
		return any(&stage.Page_layouts_mapString).(*Type)
	case map[string]*Page_margins:
		return any(&stage.Page_marginss_mapString).(*Type)
	case map[string]*Part_clef:
		return any(&stage.Part_clefs_mapString).(*Type)
	case map[string]*Part_group:
		return any(&stage.Part_groups_mapString).(*Type)
	case map[string]*Part_link:
		return any(&stage.Part_links_mapString).(*Type)
	case map[string]*Part_list:
		return any(&stage.Part_lists_mapString).(*Type)
	case map[string]*Part_symbol:
		return any(&stage.Part_symbols_mapString).(*Type)
	case map[string]*Part_transpose:
		return any(&stage.Part_transposes_mapString).(*Type)
	case map[string]*Pedal:
		return any(&stage.Pedals_mapString).(*Type)
	case map[string]*Pedal_tuning:
		return any(&stage.Pedal_tunings_mapString).(*Type)
	case map[string]*Percussion:
		return any(&stage.Percussions_mapString).(*Type)
	case map[string]*Pitch:
		return any(&stage.Pitchs_mapString).(*Type)
	case map[string]*Pitched:
		return any(&stage.Pitcheds_mapString).(*Type)
	case map[string]*Play:
		return any(&stage.Plays_mapString).(*Type)
	case map[string]*Player:
		return any(&stage.Players_mapString).(*Type)
	case map[string]*Principal_voice:
		return any(&stage.Principal_voices_mapString).(*Type)
	case map[string]*Print:
		return any(&stage.Prints_mapString).(*Type)
	case map[string]*Release:
		return any(&stage.Releases_mapString).(*Type)
	case map[string]*Repeat:
		return any(&stage.Repeats_mapString).(*Type)
	case map[string]*Rest:
		return any(&stage.Rests_mapString).(*Type)
	case map[string]*Root:
		return any(&stage.Roots_mapString).(*Type)
	case map[string]*Root_step:
		return any(&stage.Root_steps_mapString).(*Type)
	case map[string]*Scaling:
		return any(&stage.Scalings_mapString).(*Type)
	case map[string]*Scordatura:
		return any(&stage.Scordaturas_mapString).(*Type)
	case map[string]*Score_instrument:
		return any(&stage.Score_instruments_mapString).(*Type)
	case map[string]*Score_part:
		return any(&stage.Score_parts_mapString).(*Type)
	case map[string]*Score_partwise:
		return any(&stage.Score_partwises_mapString).(*Type)
	case map[string]*Score_timewise:
		return any(&stage.Score_timewises_mapString).(*Type)
	case map[string]*Segno:
		return any(&stage.Segnos_mapString).(*Type)
	case map[string]*Slash:
		return any(&stage.Slashs_mapString).(*Type)
	case map[string]*Slide:
		return any(&stage.Slides_mapString).(*Type)
	case map[string]*Slur:
		return any(&stage.Slurs_mapString).(*Type)
	case map[string]*Sound:
		return any(&stage.Sounds_mapString).(*Type)
	case map[string]*Staff_details:
		return any(&stage.Staff_detailss_mapString).(*Type)
	case map[string]*Staff_divide:
		return any(&stage.Staff_divides_mapString).(*Type)
	case map[string]*Staff_layout:
		return any(&stage.Staff_layouts_mapString).(*Type)
	case map[string]*Staff_size:
		return any(&stage.Staff_sizes_mapString).(*Type)
	case map[string]*Staff_tuning:
		return any(&stage.Staff_tunings_mapString).(*Type)
	case map[string]*Stem:
		return any(&stage.Stems_mapString).(*Type)
	case map[string]*Stick:
		return any(&stage.Sticks_mapString).(*Type)
	case map[string]*String_mute:
		return any(&stage.String_mutes_mapString).(*Type)
	case map[string]*Strong_accent:
		return any(&stage.Strong_accents_mapString).(*Type)
	case map[string]*Supports:
		return any(&stage.Supportss_mapString).(*Type)
	case map[string]*Swing:
		return any(&stage.Swings_mapString).(*Type)
	case map[string]*Sync:
		return any(&stage.Syncs_mapString).(*Type)
	case map[string]*System_dividers:
		return any(&stage.System_dividerss_mapString).(*Type)
	case map[string]*System_layout:
		return any(&stage.System_layouts_mapString).(*Type)
	case map[string]*System_margins:
		return any(&stage.System_marginss_mapString).(*Type)
	case map[string]*Tap:
		return any(&stage.Taps_mapString).(*Type)
	case map[string]*Technical:
		return any(&stage.Technicals_mapString).(*Type)
	case map[string]*Text_element_data:
		return any(&stage.Text_element_datas_mapString).(*Type)
	case map[string]*Tie:
		return any(&stage.Ties_mapString).(*Type)
	case map[string]*Tied:
		return any(&stage.Tieds_mapString).(*Type)
	case map[string]*Time:
		return any(&stage.Times_mapString).(*Type)
	case map[string]*Time_modification:
		return any(&stage.Time_modifications_mapString).(*Type)
	case map[string]*Timpani:
		return any(&stage.Timpanis_mapString).(*Type)
	case map[string]*Transpose:
		return any(&stage.Transposes_mapString).(*Type)
	case map[string]*Tremolo:
		return any(&stage.Tremolos_mapString).(*Type)
	case map[string]*Tuplet:
		return any(&stage.Tuplets_mapString).(*Type)
	case map[string]*Tuplet_dot:
		return any(&stage.Tuplet_dots_mapString).(*Type)
	case map[string]*Tuplet_number:
		return any(&stage.Tuplet_numbers_mapString).(*Type)
	case map[string]*Tuplet_portion:
		return any(&stage.Tuplet_portions_mapString).(*Type)
	case map[string]*Tuplet_type:
		return any(&stage.Tuplet_types_mapString).(*Type)
	case map[string]*Typed_text:
		return any(&stage.Typed_texts_mapString).(*Type)
	case map[string]*Unpitched:
		return any(&stage.Unpitcheds_mapString).(*Type)
	case map[string]*Virtual_instrument:
		return any(&stage.Virtual_instruments_mapString).(*Type)
	case map[string]*Wait:
		return any(&stage.Waits_mapString).(*Type)
	case map[string]*Wavy_line:
		return any(&stage.Wavy_lines_mapString).(*Type)
	case map[string]*Wedge:
		return any(&stage.Wedges_mapString).(*Type)
	case map[string]*Wood:
		return any(&stage.Woods_mapString).(*Type)
	case map[string]*Work:
		return any(&stage.Works_mapString).(*Type)
	default:
		return nil
	}
}

// GetGongstructInstancesSet returns the set staged GongstructType instances
// it is usefull because it allows refactoring of gongstruct identifier
func GetGongstructInstancesSet[Type Gongstruct](stage *StageStruct) *map[*Type]any {
	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get functions
	case Accidental:
		return any(&stage.Accidentals).(*map[*Type]any)
	case Accidental_mark:
		return any(&stage.Accidental_marks).(*map[*Type]any)
	case Accidental_text:
		return any(&stage.Accidental_texts).(*map[*Type]any)
	case Accord:
		return any(&stage.Accords).(*map[*Type]any)
	case Accordion_registration:
		return any(&stage.Accordion_registrations).(*map[*Type]any)
	case AnyType:
		return any(&stage.AnyTypes).(*map[*Type]any)
	case Appearance:
		return any(&stage.Appearances).(*map[*Type]any)
	case Arpeggiate:
		return any(&stage.Arpeggiates).(*map[*Type]any)
	case Arrow:
		return any(&stage.Arrows).(*map[*Type]any)
	case Articulations:
		return any(&stage.Articulationss).(*map[*Type]any)
	case Assess:
		return any(&stage.Assesss).(*map[*Type]any)
	case Attributes:
		return any(&stage.Attributess).(*map[*Type]any)
	case Backup:
		return any(&stage.Backups).(*map[*Type]any)
	case Bar_style_color:
		return any(&stage.Bar_style_colors).(*map[*Type]any)
	case Barline:
		return any(&stage.Barlines).(*map[*Type]any)
	case Barre:
		return any(&stage.Barres).(*map[*Type]any)
	case Bass:
		return any(&stage.Basss).(*map[*Type]any)
	case Bass_step:
		return any(&stage.Bass_steps).(*map[*Type]any)
	case Beam:
		return any(&stage.Beams).(*map[*Type]any)
	case Beat_repeat:
		return any(&stage.Beat_repeats).(*map[*Type]any)
	case Beat_unit_tied:
		return any(&stage.Beat_unit_tieds).(*map[*Type]any)
	case Beater:
		return any(&stage.Beaters).(*map[*Type]any)
	case Bend:
		return any(&stage.Bends).(*map[*Type]any)
	case Bookmark:
		return any(&stage.Bookmarks).(*map[*Type]any)
	case Bracket:
		return any(&stage.Brackets).(*map[*Type]any)
	case Breath_mark:
		return any(&stage.Breath_marks).(*map[*Type]any)
	case Caesura:
		return any(&stage.Caesuras).(*map[*Type]any)
	case Cancel:
		return any(&stage.Cancels).(*map[*Type]any)
	case Clef:
		return any(&stage.Clefs).(*map[*Type]any)
	case Coda:
		return any(&stage.Codas).(*map[*Type]any)
	case Credit:
		return any(&stage.Credits).(*map[*Type]any)
	case Dashes:
		return any(&stage.Dashess).(*map[*Type]any)
	case Defaults:
		return any(&stage.Defaultss).(*map[*Type]any)
	case Degree:
		return any(&stage.Degrees).(*map[*Type]any)
	case Degree_alter:
		return any(&stage.Degree_alters).(*map[*Type]any)
	case Degree_type:
		return any(&stage.Degree_types).(*map[*Type]any)
	case Degree_value:
		return any(&stage.Degree_values).(*map[*Type]any)
	case Direction:
		return any(&stage.Directions).(*map[*Type]any)
	case Direction_type:
		return any(&stage.Direction_types).(*map[*Type]any)
	case Distance:
		return any(&stage.Distances).(*map[*Type]any)
	case Double:
		return any(&stage.Doubles).(*map[*Type]any)
	case Dynamics:
		return any(&stage.Dynamicss).(*map[*Type]any)
	case Effect:
		return any(&stage.Effects).(*map[*Type]any)
	case Elision:
		return any(&stage.Elisions).(*map[*Type]any)
	case Empty:
		return any(&stage.Emptys).(*map[*Type]any)
	case Empty_font:
		return any(&stage.Empty_fonts).(*map[*Type]any)
	case Empty_line:
		return any(&stage.Empty_lines).(*map[*Type]any)
	case Empty_placement:
		return any(&stage.Empty_placements).(*map[*Type]any)
	case Empty_placement_smufl:
		return any(&stage.Empty_placement_smufls).(*map[*Type]any)
	case Empty_print_object_style_align:
		return any(&stage.Empty_print_object_style_aligns).(*map[*Type]any)
	case Empty_print_style:
		return any(&stage.Empty_print_styles).(*map[*Type]any)
	case Empty_print_style_align:
		return any(&stage.Empty_print_style_aligns).(*map[*Type]any)
	case Empty_print_style_align_id:
		return any(&stage.Empty_print_style_align_ids).(*map[*Type]any)
	case Empty_trill_sound:
		return any(&stage.Empty_trill_sounds).(*map[*Type]any)
	case Encoding:
		return any(&stage.Encodings).(*map[*Type]any)
	case Ending:
		return any(&stage.Endings).(*map[*Type]any)
	case Extend:
		return any(&stage.Extends).(*map[*Type]any)
	case Feature:
		return any(&stage.Features).(*map[*Type]any)
	case Fermata:
		return any(&stage.Fermatas).(*map[*Type]any)
	case Figure:
		return any(&stage.Figures).(*map[*Type]any)
	case Figured_bass:
		return any(&stage.Figured_basss).(*map[*Type]any)
	case Fingering:
		return any(&stage.Fingerings).(*map[*Type]any)
	case First_fret:
		return any(&stage.First_frets).(*map[*Type]any)
	case Foo:
		return any(&stage.Foos).(*map[*Type]any)
	case For_part:
		return any(&stage.For_parts).(*map[*Type]any)
	case Formatted_symbol:
		return any(&stage.Formatted_symbols).(*map[*Type]any)
	case Formatted_symbol_id:
		return any(&stage.Formatted_symbol_ids).(*map[*Type]any)
	case Forward:
		return any(&stage.Forwards).(*map[*Type]any)
	case Frame:
		return any(&stage.Frames).(*map[*Type]any)
	case Frame_note:
		return any(&stage.Frame_notes).(*map[*Type]any)
	case Fret:
		return any(&stage.Frets).(*map[*Type]any)
	case Glass:
		return any(&stage.Glasss).(*map[*Type]any)
	case Glissando:
		return any(&stage.Glissandos).(*map[*Type]any)
	case Glyph:
		return any(&stage.Glyphs).(*map[*Type]any)
	case Grace:
		return any(&stage.Graces).(*map[*Type]any)
	case Group_barline:
		return any(&stage.Group_barlines).(*map[*Type]any)
	case Group_symbol:
		return any(&stage.Group_symbols).(*map[*Type]any)
	case Grouping:
		return any(&stage.Groupings).(*map[*Type]any)
	case Hammer_on_pull_off:
		return any(&stage.Hammer_on_pull_offs).(*map[*Type]any)
	case Handbell:
		return any(&stage.Handbells).(*map[*Type]any)
	case Harmon_closed:
		return any(&stage.Harmon_closeds).(*map[*Type]any)
	case Harmon_mute:
		return any(&stage.Harmon_mutes).(*map[*Type]any)
	case Harmonic:
		return any(&stage.Harmonics).(*map[*Type]any)
	case Harmony:
		return any(&stage.Harmonys).(*map[*Type]any)
	case Harmony_alter:
		return any(&stage.Harmony_alters).(*map[*Type]any)
	case Harp_pedals:
		return any(&stage.Harp_pedalss).(*map[*Type]any)
	case Heel_toe:
		return any(&stage.Heel_toes).(*map[*Type]any)
	case Hole:
		return any(&stage.Holes).(*map[*Type]any)
	case Hole_closed:
		return any(&stage.Hole_closeds).(*map[*Type]any)
	case Horizontal_turn:
		return any(&stage.Horizontal_turns).(*map[*Type]any)
	case Identification:
		return any(&stage.Identifications).(*map[*Type]any)
	case Image:
		return any(&stage.Images).(*map[*Type]any)
	case Instrument:
		return any(&stage.Instruments).(*map[*Type]any)
	case Instrument_change:
		return any(&stage.Instrument_changes).(*map[*Type]any)
	case Instrument_link:
		return any(&stage.Instrument_links).(*map[*Type]any)
	case Interchangeable:
		return any(&stage.Interchangeables).(*map[*Type]any)
	case Inversion:
		return any(&stage.Inversions).(*map[*Type]any)
	case Key:
		return any(&stage.Keys).(*map[*Type]any)
	case Key_accidental:
		return any(&stage.Key_accidentals).(*map[*Type]any)
	case Key_octave:
		return any(&stage.Key_octaves).(*map[*Type]any)
	case Kind:
		return any(&stage.Kinds).(*map[*Type]any)
	case Level:
		return any(&stage.Levels).(*map[*Type]any)
	case Line_detail:
		return any(&stage.Line_details).(*map[*Type]any)
	case Line_width:
		return any(&stage.Line_widths).(*map[*Type]any)
	case Link:
		return any(&stage.Links).(*map[*Type]any)
	case Listen:
		return any(&stage.Listens).(*map[*Type]any)
	case Listening:
		return any(&stage.Listenings).(*map[*Type]any)
	case Lyric:
		return any(&stage.Lyrics).(*map[*Type]any)
	case Lyric_font:
		return any(&stage.Lyric_fonts).(*map[*Type]any)
	case Lyric_language:
		return any(&stage.Lyric_languages).(*map[*Type]any)
	case Measure_layout:
		return any(&stage.Measure_layouts).(*map[*Type]any)
	case Measure_numbering:
		return any(&stage.Measure_numberings).(*map[*Type]any)
	case Measure_repeat:
		return any(&stage.Measure_repeats).(*map[*Type]any)
	case Measure_style:
		return any(&stage.Measure_styles).(*map[*Type]any)
	case Membrane:
		return any(&stage.Membranes).(*map[*Type]any)
	case Metal:
		return any(&stage.Metals).(*map[*Type]any)
	case Metronome:
		return any(&stage.Metronomes).(*map[*Type]any)
	case Metronome_beam:
		return any(&stage.Metronome_beams).(*map[*Type]any)
	case Metronome_note:
		return any(&stage.Metronome_notes).(*map[*Type]any)
	case Metronome_tied:
		return any(&stage.Metronome_tieds).(*map[*Type]any)
	case Metronome_tuplet:
		return any(&stage.Metronome_tuplets).(*map[*Type]any)
	case Midi_device:
		return any(&stage.Midi_devices).(*map[*Type]any)
	case Midi_instrument:
		return any(&stage.Midi_instruments).(*map[*Type]any)
	case Miscellaneous:
		return any(&stage.Miscellaneouss).(*map[*Type]any)
	case Miscellaneous_field:
		return any(&stage.Miscellaneous_fields).(*map[*Type]any)
	case Mordent:
		return any(&stage.Mordents).(*map[*Type]any)
	case Multiple_rest:
		return any(&stage.Multiple_rests).(*map[*Type]any)
	case Name_display:
		return any(&stage.Name_displays).(*map[*Type]any)
	case Non_arpeggiate:
		return any(&stage.Non_arpeggiates).(*map[*Type]any)
	case Notations:
		return any(&stage.Notationss).(*map[*Type]any)
	case Note:
		return any(&stage.Notes).(*map[*Type]any)
	case Note_size:
		return any(&stage.Note_sizes).(*map[*Type]any)
	case Note_type:
		return any(&stage.Note_types).(*map[*Type]any)
	case Notehead:
		return any(&stage.Noteheads).(*map[*Type]any)
	case Notehead_text:
		return any(&stage.Notehead_texts).(*map[*Type]any)
	case Numeral:
		return any(&stage.Numerals).(*map[*Type]any)
	case Numeral_key:
		return any(&stage.Numeral_keys).(*map[*Type]any)
	case Numeral_root:
		return any(&stage.Numeral_roots).(*map[*Type]any)
	case Octave_shift:
		return any(&stage.Octave_shifts).(*map[*Type]any)
	case Offset:
		return any(&stage.Offsets).(*map[*Type]any)
	case Opus:
		return any(&stage.Opuss).(*map[*Type]any)
	case Ornaments:
		return any(&stage.Ornamentss).(*map[*Type]any)
	case Other_appearance:
		return any(&stage.Other_appearances).(*map[*Type]any)
	case Other_listening:
		return any(&stage.Other_listenings).(*map[*Type]any)
	case Other_notation:
		return any(&stage.Other_notations).(*map[*Type]any)
	case Other_play:
		return any(&stage.Other_plays).(*map[*Type]any)
	case Page_layout:
		return any(&stage.Page_layouts).(*map[*Type]any)
	case Page_margins:
		return any(&stage.Page_marginss).(*map[*Type]any)
	case Part_clef:
		return any(&stage.Part_clefs).(*map[*Type]any)
	case Part_group:
		return any(&stage.Part_groups).(*map[*Type]any)
	case Part_link:
		return any(&stage.Part_links).(*map[*Type]any)
	case Part_list:
		return any(&stage.Part_lists).(*map[*Type]any)
	case Part_symbol:
		return any(&stage.Part_symbols).(*map[*Type]any)
	case Part_transpose:
		return any(&stage.Part_transposes).(*map[*Type]any)
	case Pedal:
		return any(&stage.Pedals).(*map[*Type]any)
	case Pedal_tuning:
		return any(&stage.Pedal_tunings).(*map[*Type]any)
	case Percussion:
		return any(&stage.Percussions).(*map[*Type]any)
	case Pitch:
		return any(&stage.Pitchs).(*map[*Type]any)
	case Pitched:
		return any(&stage.Pitcheds).(*map[*Type]any)
	case Play:
		return any(&stage.Plays).(*map[*Type]any)
	case Player:
		return any(&stage.Players).(*map[*Type]any)
	case Principal_voice:
		return any(&stage.Principal_voices).(*map[*Type]any)
	case Print:
		return any(&stage.Prints).(*map[*Type]any)
	case Release:
		return any(&stage.Releases).(*map[*Type]any)
	case Repeat:
		return any(&stage.Repeats).(*map[*Type]any)
	case Rest:
		return any(&stage.Rests).(*map[*Type]any)
	case Root:
		return any(&stage.Roots).(*map[*Type]any)
	case Root_step:
		return any(&stage.Root_steps).(*map[*Type]any)
	case Scaling:
		return any(&stage.Scalings).(*map[*Type]any)
	case Scordatura:
		return any(&stage.Scordaturas).(*map[*Type]any)
	case Score_instrument:
		return any(&stage.Score_instruments).(*map[*Type]any)
	case Score_part:
		return any(&stage.Score_parts).(*map[*Type]any)
	case Score_partwise:
		return any(&stage.Score_partwises).(*map[*Type]any)
	case Score_timewise:
		return any(&stage.Score_timewises).(*map[*Type]any)
	case Segno:
		return any(&stage.Segnos).(*map[*Type]any)
	case Slash:
		return any(&stage.Slashs).(*map[*Type]any)
	case Slide:
		return any(&stage.Slides).(*map[*Type]any)
	case Slur:
		return any(&stage.Slurs).(*map[*Type]any)
	case Sound:
		return any(&stage.Sounds).(*map[*Type]any)
	case Staff_details:
		return any(&stage.Staff_detailss).(*map[*Type]any)
	case Staff_divide:
		return any(&stage.Staff_divides).(*map[*Type]any)
	case Staff_layout:
		return any(&stage.Staff_layouts).(*map[*Type]any)
	case Staff_size:
		return any(&stage.Staff_sizes).(*map[*Type]any)
	case Staff_tuning:
		return any(&stage.Staff_tunings).(*map[*Type]any)
	case Stem:
		return any(&stage.Stems).(*map[*Type]any)
	case Stick:
		return any(&stage.Sticks).(*map[*Type]any)
	case String_mute:
		return any(&stage.String_mutes).(*map[*Type]any)
	case Strong_accent:
		return any(&stage.Strong_accents).(*map[*Type]any)
	case Supports:
		return any(&stage.Supportss).(*map[*Type]any)
	case Swing:
		return any(&stage.Swings).(*map[*Type]any)
	case Sync:
		return any(&stage.Syncs).(*map[*Type]any)
	case System_dividers:
		return any(&stage.System_dividerss).(*map[*Type]any)
	case System_layout:
		return any(&stage.System_layouts).(*map[*Type]any)
	case System_margins:
		return any(&stage.System_marginss).(*map[*Type]any)
	case Tap:
		return any(&stage.Taps).(*map[*Type]any)
	case Technical:
		return any(&stage.Technicals).(*map[*Type]any)
	case Text_element_data:
		return any(&stage.Text_element_datas).(*map[*Type]any)
	case Tie:
		return any(&stage.Ties).(*map[*Type]any)
	case Tied:
		return any(&stage.Tieds).(*map[*Type]any)
	case Time:
		return any(&stage.Times).(*map[*Type]any)
	case Time_modification:
		return any(&stage.Time_modifications).(*map[*Type]any)
	case Timpani:
		return any(&stage.Timpanis).(*map[*Type]any)
	case Transpose:
		return any(&stage.Transposes).(*map[*Type]any)
	case Tremolo:
		return any(&stage.Tremolos).(*map[*Type]any)
	case Tuplet:
		return any(&stage.Tuplets).(*map[*Type]any)
	case Tuplet_dot:
		return any(&stage.Tuplet_dots).(*map[*Type]any)
	case Tuplet_number:
		return any(&stage.Tuplet_numbers).(*map[*Type]any)
	case Tuplet_portion:
		return any(&stage.Tuplet_portions).(*map[*Type]any)
	case Tuplet_type:
		return any(&stage.Tuplet_types).(*map[*Type]any)
	case Typed_text:
		return any(&stage.Typed_texts).(*map[*Type]any)
	case Unpitched:
		return any(&stage.Unpitcheds).(*map[*Type]any)
	case Virtual_instrument:
		return any(&stage.Virtual_instruments).(*map[*Type]any)
	case Wait:
		return any(&stage.Waits).(*map[*Type]any)
	case Wavy_line:
		return any(&stage.Wavy_lines).(*map[*Type]any)
	case Wedge:
		return any(&stage.Wedges).(*map[*Type]any)
	case Wood:
		return any(&stage.Woods).(*map[*Type]any)
	case Work:
		return any(&stage.Works).(*map[*Type]any)
	default:
		return nil
	}
}

// GetGongstructInstancesSetFromPointerType returns the set staged GongstructType instances
// it is usefull because it allows refactoring of gongstruct identifier
func GetGongstructInstancesSetFromPointerType[Type interface {
	PointerToGongstruct
	comparable
}](stage *StageStruct) *map[Type]any {
	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get functions
	case *Accidental:
		return any(&stage.Accidentals).(*map[Type]any)
	case *Accidental_mark:
		return any(&stage.Accidental_marks).(*map[Type]any)
	case *Accidental_text:
		return any(&stage.Accidental_texts).(*map[Type]any)
	case *Accord:
		return any(&stage.Accords).(*map[Type]any)
	case *Accordion_registration:
		return any(&stage.Accordion_registrations).(*map[Type]any)
	case *AnyType:
		return any(&stage.AnyTypes).(*map[Type]any)
	case *Appearance:
		return any(&stage.Appearances).(*map[Type]any)
	case *Arpeggiate:
		return any(&stage.Arpeggiates).(*map[Type]any)
	case *Arrow:
		return any(&stage.Arrows).(*map[Type]any)
	case *Articulations:
		return any(&stage.Articulationss).(*map[Type]any)
	case *Assess:
		return any(&stage.Assesss).(*map[Type]any)
	case *Attributes:
		return any(&stage.Attributess).(*map[Type]any)
	case *Backup:
		return any(&stage.Backups).(*map[Type]any)
	case *Bar_style_color:
		return any(&stage.Bar_style_colors).(*map[Type]any)
	case *Barline:
		return any(&stage.Barlines).(*map[Type]any)
	case *Barre:
		return any(&stage.Barres).(*map[Type]any)
	case *Bass:
		return any(&stage.Basss).(*map[Type]any)
	case *Bass_step:
		return any(&stage.Bass_steps).(*map[Type]any)
	case *Beam:
		return any(&stage.Beams).(*map[Type]any)
	case *Beat_repeat:
		return any(&stage.Beat_repeats).(*map[Type]any)
	case *Beat_unit_tied:
		return any(&stage.Beat_unit_tieds).(*map[Type]any)
	case *Beater:
		return any(&stage.Beaters).(*map[Type]any)
	case *Bend:
		return any(&stage.Bends).(*map[Type]any)
	case *Bookmark:
		return any(&stage.Bookmarks).(*map[Type]any)
	case *Bracket:
		return any(&stage.Brackets).(*map[Type]any)
	case *Breath_mark:
		return any(&stage.Breath_marks).(*map[Type]any)
	case *Caesura:
		return any(&stage.Caesuras).(*map[Type]any)
	case *Cancel:
		return any(&stage.Cancels).(*map[Type]any)
	case *Clef:
		return any(&stage.Clefs).(*map[Type]any)
	case *Coda:
		return any(&stage.Codas).(*map[Type]any)
	case *Credit:
		return any(&stage.Credits).(*map[Type]any)
	case *Dashes:
		return any(&stage.Dashess).(*map[Type]any)
	case *Defaults:
		return any(&stage.Defaultss).(*map[Type]any)
	case *Degree:
		return any(&stage.Degrees).(*map[Type]any)
	case *Degree_alter:
		return any(&stage.Degree_alters).(*map[Type]any)
	case *Degree_type:
		return any(&stage.Degree_types).(*map[Type]any)
	case *Degree_value:
		return any(&stage.Degree_values).(*map[Type]any)
	case *Direction:
		return any(&stage.Directions).(*map[Type]any)
	case *Direction_type:
		return any(&stage.Direction_types).(*map[Type]any)
	case *Distance:
		return any(&stage.Distances).(*map[Type]any)
	case *Double:
		return any(&stage.Doubles).(*map[Type]any)
	case *Dynamics:
		return any(&stage.Dynamicss).(*map[Type]any)
	case *Effect:
		return any(&stage.Effects).(*map[Type]any)
	case *Elision:
		return any(&stage.Elisions).(*map[Type]any)
	case *Empty:
		return any(&stage.Emptys).(*map[Type]any)
	case *Empty_font:
		return any(&stage.Empty_fonts).(*map[Type]any)
	case *Empty_line:
		return any(&stage.Empty_lines).(*map[Type]any)
	case *Empty_placement:
		return any(&stage.Empty_placements).(*map[Type]any)
	case *Empty_placement_smufl:
		return any(&stage.Empty_placement_smufls).(*map[Type]any)
	case *Empty_print_object_style_align:
		return any(&stage.Empty_print_object_style_aligns).(*map[Type]any)
	case *Empty_print_style:
		return any(&stage.Empty_print_styles).(*map[Type]any)
	case *Empty_print_style_align:
		return any(&stage.Empty_print_style_aligns).(*map[Type]any)
	case *Empty_print_style_align_id:
		return any(&stage.Empty_print_style_align_ids).(*map[Type]any)
	case *Empty_trill_sound:
		return any(&stage.Empty_trill_sounds).(*map[Type]any)
	case *Encoding:
		return any(&stage.Encodings).(*map[Type]any)
	case *Ending:
		return any(&stage.Endings).(*map[Type]any)
	case *Extend:
		return any(&stage.Extends).(*map[Type]any)
	case *Feature:
		return any(&stage.Features).(*map[Type]any)
	case *Fermata:
		return any(&stage.Fermatas).(*map[Type]any)
	case *Figure:
		return any(&stage.Figures).(*map[Type]any)
	case *Figured_bass:
		return any(&stage.Figured_basss).(*map[Type]any)
	case *Fingering:
		return any(&stage.Fingerings).(*map[Type]any)
	case *First_fret:
		return any(&stage.First_frets).(*map[Type]any)
	case *Foo:
		return any(&stage.Foos).(*map[Type]any)
	case *For_part:
		return any(&stage.For_parts).(*map[Type]any)
	case *Formatted_symbol:
		return any(&stage.Formatted_symbols).(*map[Type]any)
	case *Formatted_symbol_id:
		return any(&stage.Formatted_symbol_ids).(*map[Type]any)
	case *Forward:
		return any(&stage.Forwards).(*map[Type]any)
	case *Frame:
		return any(&stage.Frames).(*map[Type]any)
	case *Frame_note:
		return any(&stage.Frame_notes).(*map[Type]any)
	case *Fret:
		return any(&stage.Frets).(*map[Type]any)
	case *Glass:
		return any(&stage.Glasss).(*map[Type]any)
	case *Glissando:
		return any(&stage.Glissandos).(*map[Type]any)
	case *Glyph:
		return any(&stage.Glyphs).(*map[Type]any)
	case *Grace:
		return any(&stage.Graces).(*map[Type]any)
	case *Group_barline:
		return any(&stage.Group_barlines).(*map[Type]any)
	case *Group_symbol:
		return any(&stage.Group_symbols).(*map[Type]any)
	case *Grouping:
		return any(&stage.Groupings).(*map[Type]any)
	case *Hammer_on_pull_off:
		return any(&stage.Hammer_on_pull_offs).(*map[Type]any)
	case *Handbell:
		return any(&stage.Handbells).(*map[Type]any)
	case *Harmon_closed:
		return any(&stage.Harmon_closeds).(*map[Type]any)
	case *Harmon_mute:
		return any(&stage.Harmon_mutes).(*map[Type]any)
	case *Harmonic:
		return any(&stage.Harmonics).(*map[Type]any)
	case *Harmony:
		return any(&stage.Harmonys).(*map[Type]any)
	case *Harmony_alter:
		return any(&stage.Harmony_alters).(*map[Type]any)
	case *Harp_pedals:
		return any(&stage.Harp_pedalss).(*map[Type]any)
	case *Heel_toe:
		return any(&stage.Heel_toes).(*map[Type]any)
	case *Hole:
		return any(&stage.Holes).(*map[Type]any)
	case *Hole_closed:
		return any(&stage.Hole_closeds).(*map[Type]any)
	case *Horizontal_turn:
		return any(&stage.Horizontal_turns).(*map[Type]any)
	case *Identification:
		return any(&stage.Identifications).(*map[Type]any)
	case *Image:
		return any(&stage.Images).(*map[Type]any)
	case *Instrument:
		return any(&stage.Instruments).(*map[Type]any)
	case *Instrument_change:
		return any(&stage.Instrument_changes).(*map[Type]any)
	case *Instrument_link:
		return any(&stage.Instrument_links).(*map[Type]any)
	case *Interchangeable:
		return any(&stage.Interchangeables).(*map[Type]any)
	case *Inversion:
		return any(&stage.Inversions).(*map[Type]any)
	case *Key:
		return any(&stage.Keys).(*map[Type]any)
	case *Key_accidental:
		return any(&stage.Key_accidentals).(*map[Type]any)
	case *Key_octave:
		return any(&stage.Key_octaves).(*map[Type]any)
	case *Kind:
		return any(&stage.Kinds).(*map[Type]any)
	case *Level:
		return any(&stage.Levels).(*map[Type]any)
	case *Line_detail:
		return any(&stage.Line_details).(*map[Type]any)
	case *Line_width:
		return any(&stage.Line_widths).(*map[Type]any)
	case *Link:
		return any(&stage.Links).(*map[Type]any)
	case *Listen:
		return any(&stage.Listens).(*map[Type]any)
	case *Listening:
		return any(&stage.Listenings).(*map[Type]any)
	case *Lyric:
		return any(&stage.Lyrics).(*map[Type]any)
	case *Lyric_font:
		return any(&stage.Lyric_fonts).(*map[Type]any)
	case *Lyric_language:
		return any(&stage.Lyric_languages).(*map[Type]any)
	case *Measure_layout:
		return any(&stage.Measure_layouts).(*map[Type]any)
	case *Measure_numbering:
		return any(&stage.Measure_numberings).(*map[Type]any)
	case *Measure_repeat:
		return any(&stage.Measure_repeats).(*map[Type]any)
	case *Measure_style:
		return any(&stage.Measure_styles).(*map[Type]any)
	case *Membrane:
		return any(&stage.Membranes).(*map[Type]any)
	case *Metal:
		return any(&stage.Metals).(*map[Type]any)
	case *Metronome:
		return any(&stage.Metronomes).(*map[Type]any)
	case *Metronome_beam:
		return any(&stage.Metronome_beams).(*map[Type]any)
	case *Metronome_note:
		return any(&stage.Metronome_notes).(*map[Type]any)
	case *Metronome_tied:
		return any(&stage.Metronome_tieds).(*map[Type]any)
	case *Metronome_tuplet:
		return any(&stage.Metronome_tuplets).(*map[Type]any)
	case *Midi_device:
		return any(&stage.Midi_devices).(*map[Type]any)
	case *Midi_instrument:
		return any(&stage.Midi_instruments).(*map[Type]any)
	case *Miscellaneous:
		return any(&stage.Miscellaneouss).(*map[Type]any)
	case *Miscellaneous_field:
		return any(&stage.Miscellaneous_fields).(*map[Type]any)
	case *Mordent:
		return any(&stage.Mordents).(*map[Type]any)
	case *Multiple_rest:
		return any(&stage.Multiple_rests).(*map[Type]any)
	case *Name_display:
		return any(&stage.Name_displays).(*map[Type]any)
	case *Non_arpeggiate:
		return any(&stage.Non_arpeggiates).(*map[Type]any)
	case *Notations:
		return any(&stage.Notationss).(*map[Type]any)
	case *Note:
		return any(&stage.Notes).(*map[Type]any)
	case *Note_size:
		return any(&stage.Note_sizes).(*map[Type]any)
	case *Note_type:
		return any(&stage.Note_types).(*map[Type]any)
	case *Notehead:
		return any(&stage.Noteheads).(*map[Type]any)
	case *Notehead_text:
		return any(&stage.Notehead_texts).(*map[Type]any)
	case *Numeral:
		return any(&stage.Numerals).(*map[Type]any)
	case *Numeral_key:
		return any(&stage.Numeral_keys).(*map[Type]any)
	case *Numeral_root:
		return any(&stage.Numeral_roots).(*map[Type]any)
	case *Octave_shift:
		return any(&stage.Octave_shifts).(*map[Type]any)
	case *Offset:
		return any(&stage.Offsets).(*map[Type]any)
	case *Opus:
		return any(&stage.Opuss).(*map[Type]any)
	case *Ornaments:
		return any(&stage.Ornamentss).(*map[Type]any)
	case *Other_appearance:
		return any(&stage.Other_appearances).(*map[Type]any)
	case *Other_listening:
		return any(&stage.Other_listenings).(*map[Type]any)
	case *Other_notation:
		return any(&stage.Other_notations).(*map[Type]any)
	case *Other_play:
		return any(&stage.Other_plays).(*map[Type]any)
	case *Page_layout:
		return any(&stage.Page_layouts).(*map[Type]any)
	case *Page_margins:
		return any(&stage.Page_marginss).(*map[Type]any)
	case *Part_clef:
		return any(&stage.Part_clefs).(*map[Type]any)
	case *Part_group:
		return any(&stage.Part_groups).(*map[Type]any)
	case *Part_link:
		return any(&stage.Part_links).(*map[Type]any)
	case *Part_list:
		return any(&stage.Part_lists).(*map[Type]any)
	case *Part_symbol:
		return any(&stage.Part_symbols).(*map[Type]any)
	case *Part_transpose:
		return any(&stage.Part_transposes).(*map[Type]any)
	case *Pedal:
		return any(&stage.Pedals).(*map[Type]any)
	case *Pedal_tuning:
		return any(&stage.Pedal_tunings).(*map[Type]any)
	case *Percussion:
		return any(&stage.Percussions).(*map[Type]any)
	case *Pitch:
		return any(&stage.Pitchs).(*map[Type]any)
	case *Pitched:
		return any(&stage.Pitcheds).(*map[Type]any)
	case *Play:
		return any(&stage.Plays).(*map[Type]any)
	case *Player:
		return any(&stage.Players).(*map[Type]any)
	case *Principal_voice:
		return any(&stage.Principal_voices).(*map[Type]any)
	case *Print:
		return any(&stage.Prints).(*map[Type]any)
	case *Release:
		return any(&stage.Releases).(*map[Type]any)
	case *Repeat:
		return any(&stage.Repeats).(*map[Type]any)
	case *Rest:
		return any(&stage.Rests).(*map[Type]any)
	case *Root:
		return any(&stage.Roots).(*map[Type]any)
	case *Root_step:
		return any(&stage.Root_steps).(*map[Type]any)
	case *Scaling:
		return any(&stage.Scalings).(*map[Type]any)
	case *Scordatura:
		return any(&stage.Scordaturas).(*map[Type]any)
	case *Score_instrument:
		return any(&stage.Score_instruments).(*map[Type]any)
	case *Score_part:
		return any(&stage.Score_parts).(*map[Type]any)
	case *Score_partwise:
		return any(&stage.Score_partwises).(*map[Type]any)
	case *Score_timewise:
		return any(&stage.Score_timewises).(*map[Type]any)
	case *Segno:
		return any(&stage.Segnos).(*map[Type]any)
	case *Slash:
		return any(&stage.Slashs).(*map[Type]any)
	case *Slide:
		return any(&stage.Slides).(*map[Type]any)
	case *Slur:
		return any(&stage.Slurs).(*map[Type]any)
	case *Sound:
		return any(&stage.Sounds).(*map[Type]any)
	case *Staff_details:
		return any(&stage.Staff_detailss).(*map[Type]any)
	case *Staff_divide:
		return any(&stage.Staff_divides).(*map[Type]any)
	case *Staff_layout:
		return any(&stage.Staff_layouts).(*map[Type]any)
	case *Staff_size:
		return any(&stage.Staff_sizes).(*map[Type]any)
	case *Staff_tuning:
		return any(&stage.Staff_tunings).(*map[Type]any)
	case *Stem:
		return any(&stage.Stems).(*map[Type]any)
	case *Stick:
		return any(&stage.Sticks).(*map[Type]any)
	case *String_mute:
		return any(&stage.String_mutes).(*map[Type]any)
	case *Strong_accent:
		return any(&stage.Strong_accents).(*map[Type]any)
	case *Supports:
		return any(&stage.Supportss).(*map[Type]any)
	case *Swing:
		return any(&stage.Swings).(*map[Type]any)
	case *Sync:
		return any(&stage.Syncs).(*map[Type]any)
	case *System_dividers:
		return any(&stage.System_dividerss).(*map[Type]any)
	case *System_layout:
		return any(&stage.System_layouts).(*map[Type]any)
	case *System_margins:
		return any(&stage.System_marginss).(*map[Type]any)
	case *Tap:
		return any(&stage.Taps).(*map[Type]any)
	case *Technical:
		return any(&stage.Technicals).(*map[Type]any)
	case *Text_element_data:
		return any(&stage.Text_element_datas).(*map[Type]any)
	case *Tie:
		return any(&stage.Ties).(*map[Type]any)
	case *Tied:
		return any(&stage.Tieds).(*map[Type]any)
	case *Time:
		return any(&stage.Times).(*map[Type]any)
	case *Time_modification:
		return any(&stage.Time_modifications).(*map[Type]any)
	case *Timpani:
		return any(&stage.Timpanis).(*map[Type]any)
	case *Transpose:
		return any(&stage.Transposes).(*map[Type]any)
	case *Tremolo:
		return any(&stage.Tremolos).(*map[Type]any)
	case *Tuplet:
		return any(&stage.Tuplets).(*map[Type]any)
	case *Tuplet_dot:
		return any(&stage.Tuplet_dots).(*map[Type]any)
	case *Tuplet_number:
		return any(&stage.Tuplet_numbers).(*map[Type]any)
	case *Tuplet_portion:
		return any(&stage.Tuplet_portions).(*map[Type]any)
	case *Tuplet_type:
		return any(&stage.Tuplet_types).(*map[Type]any)
	case *Typed_text:
		return any(&stage.Typed_texts).(*map[Type]any)
	case *Unpitched:
		return any(&stage.Unpitcheds).(*map[Type]any)
	case *Virtual_instrument:
		return any(&stage.Virtual_instruments).(*map[Type]any)
	case *Wait:
		return any(&stage.Waits).(*map[Type]any)
	case *Wavy_line:
		return any(&stage.Wavy_lines).(*map[Type]any)
	case *Wedge:
		return any(&stage.Wedges).(*map[Type]any)
	case *Wood:
		return any(&stage.Woods).(*map[Type]any)
	case *Work:
		return any(&stage.Works).(*map[Type]any)
	default:
		return nil
	}
}

// GetGongstructInstancesMap returns the map of staged GongstructType instances
// it is usefull because it allows refactoring of gong struct identifier
func GetGongstructInstancesMap[Type Gongstruct](stage *StageStruct) *map[string]*Type {
	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get functions
	case Accidental:
		return any(&stage.Accidentals_mapString).(*map[string]*Type)
	case Accidental_mark:
		return any(&stage.Accidental_marks_mapString).(*map[string]*Type)
	case Accidental_text:
		return any(&stage.Accidental_texts_mapString).(*map[string]*Type)
	case Accord:
		return any(&stage.Accords_mapString).(*map[string]*Type)
	case Accordion_registration:
		return any(&stage.Accordion_registrations_mapString).(*map[string]*Type)
	case AnyType:
		return any(&stage.AnyTypes_mapString).(*map[string]*Type)
	case Appearance:
		return any(&stage.Appearances_mapString).(*map[string]*Type)
	case Arpeggiate:
		return any(&stage.Arpeggiates_mapString).(*map[string]*Type)
	case Arrow:
		return any(&stage.Arrows_mapString).(*map[string]*Type)
	case Articulations:
		return any(&stage.Articulationss_mapString).(*map[string]*Type)
	case Assess:
		return any(&stage.Assesss_mapString).(*map[string]*Type)
	case Attributes:
		return any(&stage.Attributess_mapString).(*map[string]*Type)
	case Backup:
		return any(&stage.Backups_mapString).(*map[string]*Type)
	case Bar_style_color:
		return any(&stage.Bar_style_colors_mapString).(*map[string]*Type)
	case Barline:
		return any(&stage.Barlines_mapString).(*map[string]*Type)
	case Barre:
		return any(&stage.Barres_mapString).(*map[string]*Type)
	case Bass:
		return any(&stage.Basss_mapString).(*map[string]*Type)
	case Bass_step:
		return any(&stage.Bass_steps_mapString).(*map[string]*Type)
	case Beam:
		return any(&stage.Beams_mapString).(*map[string]*Type)
	case Beat_repeat:
		return any(&stage.Beat_repeats_mapString).(*map[string]*Type)
	case Beat_unit_tied:
		return any(&stage.Beat_unit_tieds_mapString).(*map[string]*Type)
	case Beater:
		return any(&stage.Beaters_mapString).(*map[string]*Type)
	case Bend:
		return any(&stage.Bends_mapString).(*map[string]*Type)
	case Bookmark:
		return any(&stage.Bookmarks_mapString).(*map[string]*Type)
	case Bracket:
		return any(&stage.Brackets_mapString).(*map[string]*Type)
	case Breath_mark:
		return any(&stage.Breath_marks_mapString).(*map[string]*Type)
	case Caesura:
		return any(&stage.Caesuras_mapString).(*map[string]*Type)
	case Cancel:
		return any(&stage.Cancels_mapString).(*map[string]*Type)
	case Clef:
		return any(&stage.Clefs_mapString).(*map[string]*Type)
	case Coda:
		return any(&stage.Codas_mapString).(*map[string]*Type)
	case Credit:
		return any(&stage.Credits_mapString).(*map[string]*Type)
	case Dashes:
		return any(&stage.Dashess_mapString).(*map[string]*Type)
	case Defaults:
		return any(&stage.Defaultss_mapString).(*map[string]*Type)
	case Degree:
		return any(&stage.Degrees_mapString).(*map[string]*Type)
	case Degree_alter:
		return any(&stage.Degree_alters_mapString).(*map[string]*Type)
	case Degree_type:
		return any(&stage.Degree_types_mapString).(*map[string]*Type)
	case Degree_value:
		return any(&stage.Degree_values_mapString).(*map[string]*Type)
	case Direction:
		return any(&stage.Directions_mapString).(*map[string]*Type)
	case Direction_type:
		return any(&stage.Direction_types_mapString).(*map[string]*Type)
	case Distance:
		return any(&stage.Distances_mapString).(*map[string]*Type)
	case Double:
		return any(&stage.Doubles_mapString).(*map[string]*Type)
	case Dynamics:
		return any(&stage.Dynamicss_mapString).(*map[string]*Type)
	case Effect:
		return any(&stage.Effects_mapString).(*map[string]*Type)
	case Elision:
		return any(&stage.Elisions_mapString).(*map[string]*Type)
	case Empty:
		return any(&stage.Emptys_mapString).(*map[string]*Type)
	case Empty_font:
		return any(&stage.Empty_fonts_mapString).(*map[string]*Type)
	case Empty_line:
		return any(&stage.Empty_lines_mapString).(*map[string]*Type)
	case Empty_placement:
		return any(&stage.Empty_placements_mapString).(*map[string]*Type)
	case Empty_placement_smufl:
		return any(&stage.Empty_placement_smufls_mapString).(*map[string]*Type)
	case Empty_print_object_style_align:
		return any(&stage.Empty_print_object_style_aligns_mapString).(*map[string]*Type)
	case Empty_print_style:
		return any(&stage.Empty_print_styles_mapString).(*map[string]*Type)
	case Empty_print_style_align:
		return any(&stage.Empty_print_style_aligns_mapString).(*map[string]*Type)
	case Empty_print_style_align_id:
		return any(&stage.Empty_print_style_align_ids_mapString).(*map[string]*Type)
	case Empty_trill_sound:
		return any(&stage.Empty_trill_sounds_mapString).(*map[string]*Type)
	case Encoding:
		return any(&stage.Encodings_mapString).(*map[string]*Type)
	case Ending:
		return any(&stage.Endings_mapString).(*map[string]*Type)
	case Extend:
		return any(&stage.Extends_mapString).(*map[string]*Type)
	case Feature:
		return any(&stage.Features_mapString).(*map[string]*Type)
	case Fermata:
		return any(&stage.Fermatas_mapString).(*map[string]*Type)
	case Figure:
		return any(&stage.Figures_mapString).(*map[string]*Type)
	case Figured_bass:
		return any(&stage.Figured_basss_mapString).(*map[string]*Type)
	case Fingering:
		return any(&stage.Fingerings_mapString).(*map[string]*Type)
	case First_fret:
		return any(&stage.First_frets_mapString).(*map[string]*Type)
	case Foo:
		return any(&stage.Foos_mapString).(*map[string]*Type)
	case For_part:
		return any(&stage.For_parts_mapString).(*map[string]*Type)
	case Formatted_symbol:
		return any(&stage.Formatted_symbols_mapString).(*map[string]*Type)
	case Formatted_symbol_id:
		return any(&stage.Formatted_symbol_ids_mapString).(*map[string]*Type)
	case Forward:
		return any(&stage.Forwards_mapString).(*map[string]*Type)
	case Frame:
		return any(&stage.Frames_mapString).(*map[string]*Type)
	case Frame_note:
		return any(&stage.Frame_notes_mapString).(*map[string]*Type)
	case Fret:
		return any(&stage.Frets_mapString).(*map[string]*Type)
	case Glass:
		return any(&stage.Glasss_mapString).(*map[string]*Type)
	case Glissando:
		return any(&stage.Glissandos_mapString).(*map[string]*Type)
	case Glyph:
		return any(&stage.Glyphs_mapString).(*map[string]*Type)
	case Grace:
		return any(&stage.Graces_mapString).(*map[string]*Type)
	case Group_barline:
		return any(&stage.Group_barlines_mapString).(*map[string]*Type)
	case Group_symbol:
		return any(&stage.Group_symbols_mapString).(*map[string]*Type)
	case Grouping:
		return any(&stage.Groupings_mapString).(*map[string]*Type)
	case Hammer_on_pull_off:
		return any(&stage.Hammer_on_pull_offs_mapString).(*map[string]*Type)
	case Handbell:
		return any(&stage.Handbells_mapString).(*map[string]*Type)
	case Harmon_closed:
		return any(&stage.Harmon_closeds_mapString).(*map[string]*Type)
	case Harmon_mute:
		return any(&stage.Harmon_mutes_mapString).(*map[string]*Type)
	case Harmonic:
		return any(&stage.Harmonics_mapString).(*map[string]*Type)
	case Harmony:
		return any(&stage.Harmonys_mapString).(*map[string]*Type)
	case Harmony_alter:
		return any(&stage.Harmony_alters_mapString).(*map[string]*Type)
	case Harp_pedals:
		return any(&stage.Harp_pedalss_mapString).(*map[string]*Type)
	case Heel_toe:
		return any(&stage.Heel_toes_mapString).(*map[string]*Type)
	case Hole:
		return any(&stage.Holes_mapString).(*map[string]*Type)
	case Hole_closed:
		return any(&stage.Hole_closeds_mapString).(*map[string]*Type)
	case Horizontal_turn:
		return any(&stage.Horizontal_turns_mapString).(*map[string]*Type)
	case Identification:
		return any(&stage.Identifications_mapString).(*map[string]*Type)
	case Image:
		return any(&stage.Images_mapString).(*map[string]*Type)
	case Instrument:
		return any(&stage.Instruments_mapString).(*map[string]*Type)
	case Instrument_change:
		return any(&stage.Instrument_changes_mapString).(*map[string]*Type)
	case Instrument_link:
		return any(&stage.Instrument_links_mapString).(*map[string]*Type)
	case Interchangeable:
		return any(&stage.Interchangeables_mapString).(*map[string]*Type)
	case Inversion:
		return any(&stage.Inversions_mapString).(*map[string]*Type)
	case Key:
		return any(&stage.Keys_mapString).(*map[string]*Type)
	case Key_accidental:
		return any(&stage.Key_accidentals_mapString).(*map[string]*Type)
	case Key_octave:
		return any(&stage.Key_octaves_mapString).(*map[string]*Type)
	case Kind:
		return any(&stage.Kinds_mapString).(*map[string]*Type)
	case Level:
		return any(&stage.Levels_mapString).(*map[string]*Type)
	case Line_detail:
		return any(&stage.Line_details_mapString).(*map[string]*Type)
	case Line_width:
		return any(&stage.Line_widths_mapString).(*map[string]*Type)
	case Link:
		return any(&stage.Links_mapString).(*map[string]*Type)
	case Listen:
		return any(&stage.Listens_mapString).(*map[string]*Type)
	case Listening:
		return any(&stage.Listenings_mapString).(*map[string]*Type)
	case Lyric:
		return any(&stage.Lyrics_mapString).(*map[string]*Type)
	case Lyric_font:
		return any(&stage.Lyric_fonts_mapString).(*map[string]*Type)
	case Lyric_language:
		return any(&stage.Lyric_languages_mapString).(*map[string]*Type)
	case Measure_layout:
		return any(&stage.Measure_layouts_mapString).(*map[string]*Type)
	case Measure_numbering:
		return any(&stage.Measure_numberings_mapString).(*map[string]*Type)
	case Measure_repeat:
		return any(&stage.Measure_repeats_mapString).(*map[string]*Type)
	case Measure_style:
		return any(&stage.Measure_styles_mapString).(*map[string]*Type)
	case Membrane:
		return any(&stage.Membranes_mapString).(*map[string]*Type)
	case Metal:
		return any(&stage.Metals_mapString).(*map[string]*Type)
	case Metronome:
		return any(&stage.Metronomes_mapString).(*map[string]*Type)
	case Metronome_beam:
		return any(&stage.Metronome_beams_mapString).(*map[string]*Type)
	case Metronome_note:
		return any(&stage.Metronome_notes_mapString).(*map[string]*Type)
	case Metronome_tied:
		return any(&stage.Metronome_tieds_mapString).(*map[string]*Type)
	case Metronome_tuplet:
		return any(&stage.Metronome_tuplets_mapString).(*map[string]*Type)
	case Midi_device:
		return any(&stage.Midi_devices_mapString).(*map[string]*Type)
	case Midi_instrument:
		return any(&stage.Midi_instruments_mapString).(*map[string]*Type)
	case Miscellaneous:
		return any(&stage.Miscellaneouss_mapString).(*map[string]*Type)
	case Miscellaneous_field:
		return any(&stage.Miscellaneous_fields_mapString).(*map[string]*Type)
	case Mordent:
		return any(&stage.Mordents_mapString).(*map[string]*Type)
	case Multiple_rest:
		return any(&stage.Multiple_rests_mapString).(*map[string]*Type)
	case Name_display:
		return any(&stage.Name_displays_mapString).(*map[string]*Type)
	case Non_arpeggiate:
		return any(&stage.Non_arpeggiates_mapString).(*map[string]*Type)
	case Notations:
		return any(&stage.Notationss_mapString).(*map[string]*Type)
	case Note:
		return any(&stage.Notes_mapString).(*map[string]*Type)
	case Note_size:
		return any(&stage.Note_sizes_mapString).(*map[string]*Type)
	case Note_type:
		return any(&stage.Note_types_mapString).(*map[string]*Type)
	case Notehead:
		return any(&stage.Noteheads_mapString).(*map[string]*Type)
	case Notehead_text:
		return any(&stage.Notehead_texts_mapString).(*map[string]*Type)
	case Numeral:
		return any(&stage.Numerals_mapString).(*map[string]*Type)
	case Numeral_key:
		return any(&stage.Numeral_keys_mapString).(*map[string]*Type)
	case Numeral_root:
		return any(&stage.Numeral_roots_mapString).(*map[string]*Type)
	case Octave_shift:
		return any(&stage.Octave_shifts_mapString).(*map[string]*Type)
	case Offset:
		return any(&stage.Offsets_mapString).(*map[string]*Type)
	case Opus:
		return any(&stage.Opuss_mapString).(*map[string]*Type)
	case Ornaments:
		return any(&stage.Ornamentss_mapString).(*map[string]*Type)
	case Other_appearance:
		return any(&stage.Other_appearances_mapString).(*map[string]*Type)
	case Other_listening:
		return any(&stage.Other_listenings_mapString).(*map[string]*Type)
	case Other_notation:
		return any(&stage.Other_notations_mapString).(*map[string]*Type)
	case Other_play:
		return any(&stage.Other_plays_mapString).(*map[string]*Type)
	case Page_layout:
		return any(&stage.Page_layouts_mapString).(*map[string]*Type)
	case Page_margins:
		return any(&stage.Page_marginss_mapString).(*map[string]*Type)
	case Part_clef:
		return any(&stage.Part_clefs_mapString).(*map[string]*Type)
	case Part_group:
		return any(&stage.Part_groups_mapString).(*map[string]*Type)
	case Part_link:
		return any(&stage.Part_links_mapString).(*map[string]*Type)
	case Part_list:
		return any(&stage.Part_lists_mapString).(*map[string]*Type)
	case Part_symbol:
		return any(&stage.Part_symbols_mapString).(*map[string]*Type)
	case Part_transpose:
		return any(&stage.Part_transposes_mapString).(*map[string]*Type)
	case Pedal:
		return any(&stage.Pedals_mapString).(*map[string]*Type)
	case Pedal_tuning:
		return any(&stage.Pedal_tunings_mapString).(*map[string]*Type)
	case Percussion:
		return any(&stage.Percussions_mapString).(*map[string]*Type)
	case Pitch:
		return any(&stage.Pitchs_mapString).(*map[string]*Type)
	case Pitched:
		return any(&stage.Pitcheds_mapString).(*map[string]*Type)
	case Play:
		return any(&stage.Plays_mapString).(*map[string]*Type)
	case Player:
		return any(&stage.Players_mapString).(*map[string]*Type)
	case Principal_voice:
		return any(&stage.Principal_voices_mapString).(*map[string]*Type)
	case Print:
		return any(&stage.Prints_mapString).(*map[string]*Type)
	case Release:
		return any(&stage.Releases_mapString).(*map[string]*Type)
	case Repeat:
		return any(&stage.Repeats_mapString).(*map[string]*Type)
	case Rest:
		return any(&stage.Rests_mapString).(*map[string]*Type)
	case Root:
		return any(&stage.Roots_mapString).(*map[string]*Type)
	case Root_step:
		return any(&stage.Root_steps_mapString).(*map[string]*Type)
	case Scaling:
		return any(&stage.Scalings_mapString).(*map[string]*Type)
	case Scordatura:
		return any(&stage.Scordaturas_mapString).(*map[string]*Type)
	case Score_instrument:
		return any(&stage.Score_instruments_mapString).(*map[string]*Type)
	case Score_part:
		return any(&stage.Score_parts_mapString).(*map[string]*Type)
	case Score_partwise:
		return any(&stage.Score_partwises_mapString).(*map[string]*Type)
	case Score_timewise:
		return any(&stage.Score_timewises_mapString).(*map[string]*Type)
	case Segno:
		return any(&stage.Segnos_mapString).(*map[string]*Type)
	case Slash:
		return any(&stage.Slashs_mapString).(*map[string]*Type)
	case Slide:
		return any(&stage.Slides_mapString).(*map[string]*Type)
	case Slur:
		return any(&stage.Slurs_mapString).(*map[string]*Type)
	case Sound:
		return any(&stage.Sounds_mapString).(*map[string]*Type)
	case Staff_details:
		return any(&stage.Staff_detailss_mapString).(*map[string]*Type)
	case Staff_divide:
		return any(&stage.Staff_divides_mapString).(*map[string]*Type)
	case Staff_layout:
		return any(&stage.Staff_layouts_mapString).(*map[string]*Type)
	case Staff_size:
		return any(&stage.Staff_sizes_mapString).(*map[string]*Type)
	case Staff_tuning:
		return any(&stage.Staff_tunings_mapString).(*map[string]*Type)
	case Stem:
		return any(&stage.Stems_mapString).(*map[string]*Type)
	case Stick:
		return any(&stage.Sticks_mapString).(*map[string]*Type)
	case String_mute:
		return any(&stage.String_mutes_mapString).(*map[string]*Type)
	case Strong_accent:
		return any(&stage.Strong_accents_mapString).(*map[string]*Type)
	case Supports:
		return any(&stage.Supportss_mapString).(*map[string]*Type)
	case Swing:
		return any(&stage.Swings_mapString).(*map[string]*Type)
	case Sync:
		return any(&stage.Syncs_mapString).(*map[string]*Type)
	case System_dividers:
		return any(&stage.System_dividerss_mapString).(*map[string]*Type)
	case System_layout:
		return any(&stage.System_layouts_mapString).(*map[string]*Type)
	case System_margins:
		return any(&stage.System_marginss_mapString).(*map[string]*Type)
	case Tap:
		return any(&stage.Taps_mapString).(*map[string]*Type)
	case Technical:
		return any(&stage.Technicals_mapString).(*map[string]*Type)
	case Text_element_data:
		return any(&stage.Text_element_datas_mapString).(*map[string]*Type)
	case Tie:
		return any(&stage.Ties_mapString).(*map[string]*Type)
	case Tied:
		return any(&stage.Tieds_mapString).(*map[string]*Type)
	case Time:
		return any(&stage.Times_mapString).(*map[string]*Type)
	case Time_modification:
		return any(&stage.Time_modifications_mapString).(*map[string]*Type)
	case Timpani:
		return any(&stage.Timpanis_mapString).(*map[string]*Type)
	case Transpose:
		return any(&stage.Transposes_mapString).(*map[string]*Type)
	case Tremolo:
		return any(&stage.Tremolos_mapString).(*map[string]*Type)
	case Tuplet:
		return any(&stage.Tuplets_mapString).(*map[string]*Type)
	case Tuplet_dot:
		return any(&stage.Tuplet_dots_mapString).(*map[string]*Type)
	case Tuplet_number:
		return any(&stage.Tuplet_numbers_mapString).(*map[string]*Type)
	case Tuplet_portion:
		return any(&stage.Tuplet_portions_mapString).(*map[string]*Type)
	case Tuplet_type:
		return any(&stage.Tuplet_types_mapString).(*map[string]*Type)
	case Typed_text:
		return any(&stage.Typed_texts_mapString).(*map[string]*Type)
	case Unpitched:
		return any(&stage.Unpitcheds_mapString).(*map[string]*Type)
	case Virtual_instrument:
		return any(&stage.Virtual_instruments_mapString).(*map[string]*Type)
	case Wait:
		return any(&stage.Waits_mapString).(*map[string]*Type)
	case Wavy_line:
		return any(&stage.Wavy_lines_mapString).(*map[string]*Type)
	case Wedge:
		return any(&stage.Wedges_mapString).(*map[string]*Type)
	case Wood:
		return any(&stage.Woods_mapString).(*map[string]*Type)
	case Work:
		return any(&stage.Works_mapString).(*map[string]*Type)
	default:
		return nil
	}
}

// GetAssociationName is a generic function that returns an instance of Type
// where each association is filled with an instance whose name is the name of the association
//
// This function can be handy for generating navigation function that are refactorable
func GetAssociationName[Type Gongstruct]() *Type {
	var ret Type

	switch any(ret).(type) {
	// insertion point for instance with special fields
	case Accidental:
		return any(&Accidental{
			// Initialisation of associations
		}).(*Type)
	case Accidental_mark:
		return any(&Accidental_mark{
			// Initialisation of associations
		}).(*Type)
	case Accidental_text:
		return any(&Accidental_text{
			// Initialisation of associations
		}).(*Type)
	case Accord:
		return any(&Accord{
			// Initialisation of associations
		}).(*Type)
	case Accordion_registration:
		return any(&Accordion_registration{
			// Initialisation of associations
			// field is initialized with an instance of Empty with the name of the field
			Accordion_high: &Empty{Name: "Accordion_high"},
			// field is initialized with an instance of Empty with the name of the field
			Accordion_low: &Empty{Name: "Accordion_low"},
		}).(*Type)
	case AnyType:
		return any(&AnyType{
			// Initialisation of associations
		}).(*Type)
	case Appearance:
		return any(&Appearance{
			// Initialisation of associations
			// field is initialized with an instance of Line_width with the name of the field
			Line_width: []*Line_width{{Name: "Line_width"}},
			// field is initialized with an instance of Note_size with the name of the field
			Note_size: []*Note_size{{Name: "Note_size"}},
			// field is initialized with an instance of Distance with the name of the field
			Distance: []*Distance{{Name: "Distance"}},
			// field is initialized with an instance of Glyph with the name of the field
			Glyph: []*Glyph{{Name: "Glyph"}},
			// field is initialized with an instance of Other_appearance with the name of the field
			Other_appearance: []*Other_appearance{{Name: "Other_appearance"}},
		}).(*Type)
	case Arpeggiate:
		return any(&Arpeggiate{
			// Initialisation of associations
		}).(*Type)
	case Arrow:
		return any(&Arrow{
			// Initialisation of associations
		}).(*Type)
	case Articulations:
		return any(&Articulations{
			// Initialisation of associations
			// field is initialized with an instance of Empty_placement with the name of the field
			Accent: &Empty_placement{Name: "Accent"},
			// field is initialized with an instance of Strong_accent with the name of the field
			Strong_accent: &Strong_accent{Name: "Strong_accent"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Staccato: &Empty_placement{Name: "Staccato"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Tenuto: &Empty_placement{Name: "Tenuto"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Detached_legato: &Empty_placement{Name: "Detached_legato"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Staccatissimo: &Empty_placement{Name: "Staccatissimo"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Spiccato: &Empty_placement{Name: "Spiccato"},
			// field is initialized with an instance of Empty_line with the name of the field
			Scoop: &Empty_line{Name: "Scoop"},
			// field is initialized with an instance of Empty_line with the name of the field
			Plop: &Empty_line{Name: "Plop"},
			// field is initialized with an instance of Empty_line with the name of the field
			Doit: &Empty_line{Name: "Doit"},
			// field is initialized with an instance of Empty_line with the name of the field
			Falloff: &Empty_line{Name: "Falloff"},
			// field is initialized with an instance of Breath_mark with the name of the field
			Breath_mark: &Breath_mark{Name: "Breath_mark"},
			// field is initialized with an instance of Caesura with the name of the field
			Caesura: &Caesura{Name: "Caesura"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Stress: &Empty_placement{Name: "Stress"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Unstress: &Empty_placement{Name: "Unstress"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Soft_accent: &Empty_placement{Name: "Soft_accent"},
		}).(*Type)
	case Assess:
		return any(&Assess{
			// Initialisation of associations
		}).(*Type)
	case Attributes:
		return any(&Attributes{
			// Initialisation of associations
			// field is initialized with an instance of Key with the name of the field
			Key: []*Key{{Name: "Key"}},
			// field is initialized with an instance of Part_symbol with the name of the field
			Part_symbol: &Part_symbol{Name: "Part_symbol"},
			// field is initialized with an instance of Clef with the name of the field
			Clef: []*Clef{{Name: "Clef"}},
			// field is initialized with an instance of Staff_details with the name of the field
			Staff_details: []*Staff_details{{Name: "Staff_details"}},
			// field is initialized with an instance of Measure_style with the name of the field
			Measure_style: []*Measure_style{{Name: "Measure_style"}},
			// field is initialized with an instance of Transpose with the name of the field
			Transpose: []*Transpose{{Name: "Transpose"}},
			// field is initialized with an instance of For_part with the name of the field
			For_part: []*For_part{{Name: "For_part"}},
		}).(*Type)
	case Backup:
		return any(&Backup{
			// Initialisation of associations
		}).(*Type)
	case Bar_style_color:
		return any(&Bar_style_color{
			// Initialisation of associations
		}).(*Type)
	case Barline:
		return any(&Barline{
			// Initialisation of associations
			// field is initialized with an instance of Bar_style_color with the name of the field
			Bar_style: &Bar_style_color{Name: "Bar_style"},
			// field is initialized with an instance of Wavy_line with the name of the field
			Wavy_line: &Wavy_line{Name: "Wavy_line"},
			// field is initialized with an instance of Fermata with the name of the field
			Fermata: &Fermata{Name: "Fermata"},
			// field is initialized with an instance of Ending with the name of the field
			Ending: &Ending{Name: "Ending"},
			// field is initialized with an instance of Repeat with the name of the field
			Repeat: &Repeat{Name: "Repeat"},
		}).(*Type)
	case Barre:
		return any(&Barre{
			// Initialisation of associations
		}).(*Type)
	case Bass:
		return any(&Bass{
			// Initialisation of associations
			// field is initialized with an instance of Bass_step with the name of the field
			Bass_step: &Bass_step{Name: "Bass_step"},
			// field is initialized with an instance of Harmony_alter with the name of the field
			Bass_alter: &Harmony_alter{Name: "Bass_alter"},
		}).(*Type)
	case Bass_step:
		return any(&Bass_step{
			// Initialisation of associations
		}).(*Type)
	case Beam:
		return any(&Beam{
			// Initialisation of associations
		}).(*Type)
	case Beat_repeat:
		return any(&Beat_repeat{
			// Initialisation of associations
		}).(*Type)
	case Beat_unit_tied:
		return any(&Beat_unit_tied{
			// Initialisation of associations
		}).(*Type)
	case Beater:
		return any(&Beater{
			// Initialisation of associations
		}).(*Type)
	case Bend:
		return any(&Bend{
			// Initialisation of associations
			// field is initialized with an instance of Empty with the name of the field
			Pre_bend: &Empty{Name: "Pre_bend"},
			// field is initialized with an instance of Release with the name of the field
			Release: &Release{Name: "Release"},
		}).(*Type)
	case Bookmark:
		return any(&Bookmark{
			// Initialisation of associations
		}).(*Type)
	case Bracket:
		return any(&Bracket{
			// Initialisation of associations
		}).(*Type)
	case Breath_mark:
		return any(&Breath_mark{
			// Initialisation of associations
		}).(*Type)
	case Caesura:
		return any(&Caesura{
			// Initialisation of associations
		}).(*Type)
	case Cancel:
		return any(&Cancel{
			// Initialisation of associations
		}).(*Type)
	case Clef:
		return any(&Clef{
			// Initialisation of associations
		}).(*Type)
	case Coda:
		return any(&Coda{
			// Initialisation of associations
		}).(*Type)
	case Credit:
		return any(&Credit{
			// Initialisation of associations
			// field is initialized with an instance of Link with the name of the field
			Link: []*Link{{Name: "Link"}},
			// field is initialized with an instance of Bookmark with the name of the field
			Bookmark: []*Bookmark{{Name: "Bookmark"}},
			// field is initialized with an instance of Image with the name of the field
			Credit_image: &Image{Name: "Credit_image"},
		}).(*Type)
	case Dashes:
		return any(&Dashes{
			// Initialisation of associations
		}).(*Type)
	case Defaults:
		return any(&Defaults{
			// Initialisation of associations
			// field is initialized with an instance of Scaling with the name of the field
			Scaling: &Scaling{Name: "Scaling"},
			// field is initialized with an instance of Empty with the name of the field
			Concert_score: &Empty{Name: "Concert_score"},
			// field is initialized with an instance of Appearance with the name of the field
			Appearance: &Appearance{Name: "Appearance"},
			// field is initialized with an instance of Empty_font with the name of the field
			Music_font: &Empty_font{Name: "Music_font"},
			// field is initialized with an instance of Empty_font with the name of the field
			Word_font: &Empty_font{Name: "Word_font"},
			// field is initialized with an instance of Lyric_font with the name of the field
			Lyric_font: []*Lyric_font{{Name: "Lyric_font"}},
			// field is initialized with an instance of Lyric_language with the name of the field
			Lyric_language: []*Lyric_language{{Name: "Lyric_language"}},
		}).(*Type)
	case Degree:
		return any(&Degree{
			// Initialisation of associations
			// field is initialized with an instance of Degree_value with the name of the field
			Degree_value: &Degree_value{Name: "Degree_value"},
			// field is initialized with an instance of Degree_alter with the name of the field
			Degree_alter: &Degree_alter{Name: "Degree_alter"},
			// field is initialized with an instance of Degree_type with the name of the field
			Degree_type: &Degree_type{Name: "Degree_type"},
		}).(*Type)
	case Degree_alter:
		return any(&Degree_alter{
			// Initialisation of associations
		}).(*Type)
	case Degree_type:
		return any(&Degree_type{
			// Initialisation of associations
		}).(*Type)
	case Degree_value:
		return any(&Degree_value{
			// Initialisation of associations
		}).(*Type)
	case Direction:
		return any(&Direction{
			// Initialisation of associations
			// field is initialized with an instance of Direction_type with the name of the field
			Direction_type: []*Direction_type{{Name: "Direction_type"}},
			// field is initialized with an instance of Offset with the name of the field
			Offset: &Offset{Name: "Offset"},
			// field is initialized with an instance of Sound with the name of the field
			Sound: &Sound{Name: "Sound"},
			// field is initialized with an instance of Listening with the name of the field
			Listening: &Listening{Name: "Listening"},
		}).(*Type)
	case Direction_type:
		return any(&Direction_type{
			// Initialisation of associations
			// field is initialized with an instance of Segno with the name of the field
			Segno: []*Segno{{Name: "Segno"}},
			// field is initialized with an instance of Coda with the name of the field
			Coda: []*Coda{{Name: "Coda"}},
			// field is initialized with an instance of Wedge with the name of the field
			Wedge: &Wedge{Name: "Wedge"},
			// field is initialized with an instance of Dynamics with the name of the field
			Dynamics: []*Dynamics{{Name: "Dynamics"}},
			// field is initialized with an instance of Dashes with the name of the field
			Dashes: &Dashes{Name: "Dashes"},
			// field is initialized with an instance of Bracket with the name of the field
			Bracket: &Bracket{Name: "Bracket"},
			// field is initialized with an instance of Pedal with the name of the field
			Pedal: &Pedal{Name: "Pedal"},
			// field is initialized with an instance of Metronome with the name of the field
			Metronome: &Metronome{Name: "Metronome"},
			// field is initialized with an instance of Octave_shift with the name of the field
			Octave_shift: &Octave_shift{Name: "Octave_shift"},
			// field is initialized with an instance of Harp_pedals with the name of the field
			Harp_pedals: &Harp_pedals{Name: "Harp_pedals"},
			// field is initialized with an instance of Empty_print_style_align_id with the name of the field
			Damp: &Empty_print_style_align_id{Name: "Damp"},
			// field is initialized with an instance of Empty_print_style_align_id with the name of the field
			Damp_all: &Empty_print_style_align_id{Name: "Damp_all"},
			// field is initialized with an instance of Empty_print_style_align_id with the name of the field
			Eyeglasses: &Empty_print_style_align_id{Name: "Eyeglasses"},
			// field is initialized with an instance of String_mute with the name of the field
			String_mute: &String_mute{Name: "String_mute"},
			// field is initialized with an instance of Scordatura with the name of the field
			Scordatura: &Scordatura{Name: "Scordatura"},
			// field is initialized with an instance of Image with the name of the field
			Image: &Image{Name: "Image"},
			// field is initialized with an instance of Principal_voice with the name of the field
			Principal_voice: &Principal_voice{Name: "Principal_voice"},
			// field is initialized with an instance of Percussion with the name of the field
			Percussion: []*Percussion{{Name: "Percussion"}},
			// field is initialized with an instance of Accordion_registration with the name of the field
			Accordion_registration: &Accordion_registration{Name: "Accordion_registration"},
			// field is initialized with an instance of Staff_divide with the name of the field
			Staff_divide: &Staff_divide{Name: "Staff_divide"},
		}).(*Type)
	case Distance:
		return any(&Distance{
			// Initialisation of associations
		}).(*Type)
	case Double:
		return any(&Double{
			// Initialisation of associations
		}).(*Type)
	case Dynamics:
		return any(&Dynamics{
			// Initialisation of associations
			// field is initialized with an instance of Empty with the name of the field
			P: &Empty{Name: "P"},
			// field is initialized with an instance of Empty with the name of the field
			Pp: &Empty{Name: "Pp"},
			// field is initialized with an instance of Empty with the name of the field
			Ppp: &Empty{Name: "Ppp"},
			// field is initialized with an instance of Empty with the name of the field
			Pppp: &Empty{Name: "Pppp"},
			// field is initialized with an instance of Empty with the name of the field
			Ppppp: &Empty{Name: "Ppppp"},
			// field is initialized with an instance of Empty with the name of the field
			Pppppp: &Empty{Name: "Pppppp"},
			// field is initialized with an instance of Empty with the name of the field
			F: &Empty{Name: "F"},
			// field is initialized with an instance of Empty with the name of the field
			Ff: &Empty{Name: "Ff"},
			// field is initialized with an instance of Empty with the name of the field
			Fff: &Empty{Name: "Fff"},
			// field is initialized with an instance of Empty with the name of the field
			Ffff: &Empty{Name: "Ffff"},
			// field is initialized with an instance of Empty with the name of the field
			Fffff: &Empty{Name: "Fffff"},
			// field is initialized with an instance of Empty with the name of the field
			Ffffff: &Empty{Name: "Ffffff"},
			// field is initialized with an instance of Empty with the name of the field
			Mp: &Empty{Name: "Mp"},
			// field is initialized with an instance of Empty with the name of the field
			Mf: &Empty{Name: "Mf"},
			// field is initialized with an instance of Empty with the name of the field
			Sf: &Empty{Name: "Sf"},
			// field is initialized with an instance of Empty with the name of the field
			Sfp: &Empty{Name: "Sfp"},
			// field is initialized with an instance of Empty with the name of the field
			Sfpp: &Empty{Name: "Sfpp"},
			// field is initialized with an instance of Empty with the name of the field
			Fp: &Empty{Name: "Fp"},
			// field is initialized with an instance of Empty with the name of the field
			Rf: &Empty{Name: "Rf"},
			// field is initialized with an instance of Empty with the name of the field
			Rfz: &Empty{Name: "Rfz"},
			// field is initialized with an instance of Empty with the name of the field
			Sfz: &Empty{Name: "Sfz"},
			// field is initialized with an instance of Empty with the name of the field
			Sffz: &Empty{Name: "Sffz"},
			// field is initialized with an instance of Empty with the name of the field
			Fz: &Empty{Name: "Fz"},
			// field is initialized with an instance of Empty with the name of the field
			N: &Empty{Name: "N"},
			// field is initialized with an instance of Empty with the name of the field
			Pf: &Empty{Name: "Pf"},
			// field is initialized with an instance of Empty with the name of the field
			Sfzp: &Empty{Name: "Sfzp"},
		}).(*Type)
	case Effect:
		return any(&Effect{
			// Initialisation of associations
		}).(*Type)
	case Elision:
		return any(&Elision{
			// Initialisation of associations
		}).(*Type)
	case Empty:
		return any(&Empty{
			// Initialisation of associations
		}).(*Type)
	case Empty_font:
		return any(&Empty_font{
			// Initialisation of associations
		}).(*Type)
	case Empty_line:
		return any(&Empty_line{
			// Initialisation of associations
		}).(*Type)
	case Empty_placement:
		return any(&Empty_placement{
			// Initialisation of associations
		}).(*Type)
	case Empty_placement_smufl:
		return any(&Empty_placement_smufl{
			// Initialisation of associations
		}).(*Type)
	case Empty_print_object_style_align:
		return any(&Empty_print_object_style_align{
			// Initialisation of associations
		}).(*Type)
	case Empty_print_style:
		return any(&Empty_print_style{
			// Initialisation of associations
		}).(*Type)
	case Empty_print_style_align:
		return any(&Empty_print_style_align{
			// Initialisation of associations
		}).(*Type)
	case Empty_print_style_align_id:
		return any(&Empty_print_style_align_id{
			// Initialisation of associations
		}).(*Type)
	case Empty_trill_sound:
		return any(&Empty_trill_sound{
			// Initialisation of associations
		}).(*Type)
	case Encoding:
		return any(&Encoding{
			// Initialisation of associations
			// field is initialized with an instance of Typed_text with the name of the field
			Encoder: &Typed_text{Name: "Encoder"},
			// field is initialized with an instance of Supports with the name of the field
			Supports: &Supports{Name: "Supports"},
		}).(*Type)
	case Ending:
		return any(&Ending{
			// Initialisation of associations
		}).(*Type)
	case Extend:
		return any(&Extend{
			// Initialisation of associations
		}).(*Type)
	case Feature:
		return any(&Feature{
			// Initialisation of associations
		}).(*Type)
	case Fermata:
		return any(&Fermata{
			// Initialisation of associations
		}).(*Type)
	case Figure:
		return any(&Figure{
			// Initialisation of associations
			// field is initialized with an instance of Extend with the name of the field
			Extend: &Extend{Name: "Extend"},
		}).(*Type)
	case Figured_bass:
		return any(&Figured_bass{
			// Initialisation of associations
			// field is initialized with an instance of Figure with the name of the field
			Figure: []*Figure{{Name: "Figure"}},
		}).(*Type)
	case Fingering:
		return any(&Fingering{
			// Initialisation of associations
		}).(*Type)
	case First_fret:
		return any(&First_fret{
			// Initialisation of associations
		}).(*Type)
	case Foo:
		return any(&Foo{
			// Initialisation of associations
		}).(*Type)
	case For_part:
		return any(&For_part{
			// Initialisation of associations
			// field is initialized with an instance of Part_clef with the name of the field
			Part_clef: &Part_clef{Name: "Part_clef"},
			// field is initialized with an instance of Part_transpose with the name of the field
			Part_transpose: &Part_transpose{Name: "Part_transpose"},
		}).(*Type)
	case Formatted_symbol:
		return any(&Formatted_symbol{
			// Initialisation of associations
		}).(*Type)
	case Formatted_symbol_id:
		return any(&Formatted_symbol_id{
			// Initialisation of associations
		}).(*Type)
	case Forward:
		return any(&Forward{
			// Initialisation of associations
		}).(*Type)
	case Frame:
		return any(&Frame{
			// Initialisation of associations
			// field is initialized with an instance of First_fret with the name of the field
			First_fret: &First_fret{Name: "First_fret"},
			// field is initialized with an instance of Frame_note with the name of the field
			Frame_note: []*Frame_note{{Name: "Frame_note"}},
		}).(*Type)
	case Frame_note:
		return any(&Frame_note{
			// Initialisation of associations
			// field is initialized with an instance of Fret with the name of the field
			Fret: &Fret{Name: "Fret"},
			// field is initialized with an instance of Fingering with the name of the field
			Fingering: &Fingering{Name: "Fingering"},
			// field is initialized with an instance of Barre with the name of the field
			Barre: &Barre{Name: "Barre"},
		}).(*Type)
	case Fret:
		return any(&Fret{
			// Initialisation of associations
		}).(*Type)
	case Glass:
		return any(&Glass{
			// Initialisation of associations
		}).(*Type)
	case Glissando:
		return any(&Glissando{
			// Initialisation of associations
		}).(*Type)
	case Glyph:
		return any(&Glyph{
			// Initialisation of associations
		}).(*Type)
	case Grace:
		return any(&Grace{
			// Initialisation of associations
		}).(*Type)
	case Group_barline:
		return any(&Group_barline{
			// Initialisation of associations
		}).(*Type)
	case Group_symbol:
		return any(&Group_symbol{
			// Initialisation of associations
		}).(*Type)
	case Grouping:
		return any(&Grouping{
			// Initialisation of associations
			// field is initialized with an instance of Feature with the name of the field
			Feature: []*Feature{{Name: "Feature"}},
		}).(*Type)
	case Hammer_on_pull_off:
		return any(&Hammer_on_pull_off{
			// Initialisation of associations
		}).(*Type)
	case Handbell:
		return any(&Handbell{
			// Initialisation of associations
		}).(*Type)
	case Harmon_closed:
		return any(&Harmon_closed{
			// Initialisation of associations
		}).(*Type)
	case Harmon_mute:
		return any(&Harmon_mute{
			// Initialisation of associations
			// field is initialized with an instance of Harmon_closed with the name of the field
			Harmon_closed: &Harmon_closed{Name: "Harmon_closed"},
		}).(*Type)
	case Harmonic:
		return any(&Harmonic{
			// Initialisation of associations
			// field is initialized with an instance of Empty with the name of the field
			Natural: &Empty{Name: "Natural"},
			// field is initialized with an instance of Empty with the name of the field
			Artificial: &Empty{Name: "Artificial"},
			// field is initialized with an instance of Empty with the name of the field
			Base_pitch: &Empty{Name: "Base_pitch"},
			// field is initialized with an instance of Empty with the name of the field
			Touching_pitch: &Empty{Name: "Touching_pitch"},
			// field is initialized with an instance of Empty with the name of the field
			Sounding_pitch: &Empty{Name: "Sounding_pitch"},
		}).(*Type)
	case Harmony:
		return any(&Harmony{
			// Initialisation of associations
			// field is initialized with an instance of Frame with the name of the field
			Frame: &Frame{Name: "Frame"},
			// field is initialized with an instance of Offset with the name of the field
			Offset: &Offset{Name: "Offset"},
		}).(*Type)
	case Harmony_alter:
		return any(&Harmony_alter{
			// Initialisation of associations
		}).(*Type)
	case Harp_pedals:
		return any(&Harp_pedals{
			// Initialisation of associations
			// field is initialized with an instance of Pedal_tuning with the name of the field
			Pedal_tuning: []*Pedal_tuning{{Name: "Pedal_tuning"}},
		}).(*Type)
	case Heel_toe:
		return any(&Heel_toe{
			// Initialisation of associations
		}).(*Type)
	case Hole:
		return any(&Hole{
			// Initialisation of associations
			// field is initialized with an instance of Hole_closed with the name of the field
			Hole_closed: &Hole_closed{Name: "Hole_closed"},
		}).(*Type)
	case Hole_closed:
		return any(&Hole_closed{
			// Initialisation of associations
		}).(*Type)
	case Horizontal_turn:
		return any(&Horizontal_turn{
			// Initialisation of associations
		}).(*Type)
	case Identification:
		return any(&Identification{
			// Initialisation of associations
			// field is initialized with an instance of Typed_text with the name of the field
			Creator: []*Typed_text{{Name: "Creator"}},
			// field is initialized with an instance of Typed_text with the name of the field
			Rights: []*Typed_text{{Name: "Rights"}},
			// field is initialized with an instance of Encoding with the name of the field
			Encoding: &Encoding{Name: "Encoding"},
			// field is initialized with an instance of Typed_text with the name of the field
			Relation: []*Typed_text{{Name: "Relation"}},
			// field is initialized with an instance of Miscellaneous with the name of the field
			Miscellaneous: &Miscellaneous{Name: "Miscellaneous"},
		}).(*Type)
	case Image:
		return any(&Image{
			// Initialisation of associations
		}).(*Type)
	case Instrument:
		return any(&Instrument{
			// Initialisation of associations
		}).(*Type)
	case Instrument_change:
		return any(&Instrument_change{
			// Initialisation of associations
		}).(*Type)
	case Instrument_link:
		return any(&Instrument_link{
			// Initialisation of associations
		}).(*Type)
	case Interchangeable:
		return any(&Interchangeable{
			// Initialisation of associations
		}).(*Type)
	case Inversion:
		return any(&Inversion{
			// Initialisation of associations
		}).(*Type)
	case Key:
		return any(&Key{
			// Initialisation of associations
			// field is initialized with an instance of Key_octave with the name of the field
			Key_octave: []*Key_octave{{Name: "Key_octave"}},
		}).(*Type)
	case Key_accidental:
		return any(&Key_accidental{
			// Initialisation of associations
		}).(*Type)
	case Key_octave:
		return any(&Key_octave{
			// Initialisation of associations
		}).(*Type)
	case Kind:
		return any(&Kind{
			// Initialisation of associations
		}).(*Type)
	case Level:
		return any(&Level{
			// Initialisation of associations
		}).(*Type)
	case Line_detail:
		return any(&Line_detail{
			// Initialisation of associations
		}).(*Type)
	case Line_width:
		return any(&Line_width{
			// Initialisation of associations
		}).(*Type)
	case Link:
		return any(&Link{
			// Initialisation of associations
		}).(*Type)
	case Listen:
		return any(&Listen{
			// Initialisation of associations
			// field is initialized with an instance of Assess with the name of the field
			Assess: &Assess{Name: "Assess"},
			// field is initialized with an instance of Wait with the name of the field
			Wait: &Wait{Name: "Wait"},
			// field is initialized with an instance of Other_listening with the name of the field
			Other_listen: &Other_listening{Name: "Other_listen"},
		}).(*Type)
	case Listening:
		return any(&Listening{
			// Initialisation of associations
			// field is initialized with an instance of Offset with the name of the field
			Offset: &Offset{Name: "Offset"},
			// field is initialized with an instance of Sync with the name of the field
			Sync: &Sync{Name: "Sync"},
			// field is initialized with an instance of Other_listening with the name of the field
			Other_listening: &Other_listening{Name: "Other_listening"},
		}).(*Type)
	case Lyric:
		return any(&Lyric{
			// Initialisation of associations
			// field is initialized with an instance of Empty with the name of the field
			End_line: &Empty{Name: "End_line"},
			// field is initialized with an instance of Empty with the name of the field
			End_paragraph: &Empty{Name: "End_paragraph"},
			// field is initialized with an instance of Extend with the name of the field
			Extend: &Extend{Name: "Extend"},
			// field is initialized with an instance of Empty with the name of the field
			Laughing: &Empty{Name: "Laughing"},
			// field is initialized with an instance of Empty with the name of the field
			Humming: &Empty{Name: "Humming"},
		}).(*Type)
	case Lyric_font:
		return any(&Lyric_font{
			// Initialisation of associations
		}).(*Type)
	case Lyric_language:
		return any(&Lyric_language{
			// Initialisation of associations
		}).(*Type)
	case Measure_layout:
		return any(&Measure_layout{
			// Initialisation of associations
		}).(*Type)
	case Measure_numbering:
		return any(&Measure_numbering{
			// Initialisation of associations
		}).(*Type)
	case Measure_repeat:
		return any(&Measure_repeat{
			// Initialisation of associations
		}).(*Type)
	case Measure_style:
		return any(&Measure_style{
			// Initialisation of associations
			// field is initialized with an instance of Multiple_rest with the name of the field
			Multiple_rest: &Multiple_rest{Name: "Multiple_rest"},
			// field is initialized with an instance of Measure_repeat with the name of the field
			Measure_repeat: &Measure_repeat{Name: "Measure_repeat"},
			// field is initialized with an instance of Beat_repeat with the name of the field
			Beat_repeat: &Beat_repeat{Name: "Beat_repeat"},
			// field is initialized with an instance of Slash with the name of the field
			Slash: &Slash{Name: "Slash"},
		}).(*Type)
	case Membrane:
		return any(&Membrane{
			// Initialisation of associations
		}).(*Type)
	case Metal:
		return any(&Metal{
			// Initialisation of associations
		}).(*Type)
	case Metronome:
		return any(&Metronome{
			// Initialisation of associations
		}).(*Type)
	case Metronome_beam:
		return any(&Metronome_beam{
			// Initialisation of associations
		}).(*Type)
	case Metronome_note:
		return any(&Metronome_note{
			// Initialisation of associations
			// field is initialized with an instance of Empty with the name of the field
			Metronome_dot: []*Empty{{Name: "Metronome_dot"}},
			// field is initialized with an instance of Metronome_beam with the name of the field
			Metronome_beam: []*Metronome_beam{{Name: "Metronome_beam"}},
			// field is initialized with an instance of Metronome_tied with the name of the field
			Metronome_tied: &Metronome_tied{Name: "Metronome_tied"},
			// field is initialized with an instance of Metronome_tuplet with the name of the field
			Metronome_tuplet: &Metronome_tuplet{Name: "Metronome_tuplet"},
		}).(*Type)
	case Metronome_tied:
		return any(&Metronome_tied{
			// Initialisation of associations
		}).(*Type)
	case Metronome_tuplet:
		return any(&Metronome_tuplet{
			// Initialisation of associations
		}).(*Type)
	case Midi_device:
		return any(&Midi_device{
			// Initialisation of associations
		}).(*Type)
	case Midi_instrument:
		return any(&Midi_instrument{
			// Initialisation of associations
		}).(*Type)
	case Miscellaneous:
		return any(&Miscellaneous{
			// Initialisation of associations
			// field is initialized with an instance of Miscellaneous_field with the name of the field
			Miscellaneous_field: []*Miscellaneous_field{{Name: "Miscellaneous_field"}},
		}).(*Type)
	case Miscellaneous_field:
		return any(&Miscellaneous_field{
			// Initialisation of associations
		}).(*Type)
	case Mordent:
		return any(&Mordent{
			// Initialisation of associations
		}).(*Type)
	case Multiple_rest:
		return any(&Multiple_rest{
			// Initialisation of associations
		}).(*Type)
	case Name_display:
		return any(&Name_display{
			// Initialisation of associations
			// field is initialized with an instance of Accidental_text with the name of the field
			Accidental_text: &Accidental_text{Name: "Accidental_text"},
		}).(*Type)
	case Non_arpeggiate:
		return any(&Non_arpeggiate{
			// Initialisation of associations
		}).(*Type)
	case Notations:
		return any(&Notations{
			// Initialisation of associations
			// field is initialized with an instance of Tied with the name of the field
			Tied: &Tied{Name: "Tied"},
			// field is initialized with an instance of Slur with the name of the field
			Slur: &Slur{Name: "Slur"},
			// field is initialized with an instance of Tuplet with the name of the field
			Tuplet: &Tuplet{Name: "Tuplet"},
			// field is initialized with an instance of Glissando with the name of the field
			Glissando: &Glissando{Name: "Glissando"},
			// field is initialized with an instance of Slide with the name of the field
			Slide: &Slide{Name: "Slide"},
			// field is initialized with an instance of Ornaments with the name of the field
			Ornaments: &Ornaments{Name: "Ornaments"},
			// field is initialized with an instance of Technical with the name of the field
			Technical: &Technical{Name: "Technical"},
			// field is initialized with an instance of Articulations with the name of the field
			Articulations: &Articulations{Name: "Articulations"},
			// field is initialized with an instance of Dynamics with the name of the field
			Dynamics: &Dynamics{Name: "Dynamics"},
			// field is initialized with an instance of Fermata with the name of the field
			Fermata: &Fermata{Name: "Fermata"},
			// field is initialized with an instance of Arpeggiate with the name of the field
			Arpeggiate: &Arpeggiate{Name: "Arpeggiate"},
			// field is initialized with an instance of Non_arpeggiate with the name of the field
			Non_arpeggiate: &Non_arpeggiate{Name: "Non_arpeggiate"},
			// field is initialized with an instance of Accidental_mark with the name of the field
			Accidental_mark: &Accidental_mark{Name: "Accidental_mark"},
			// field is initialized with an instance of Other_notation with the name of the field
			Other_notation: &Other_notation{Name: "Other_notation"},
		}).(*Type)
	case Note:
		return any(&Note{
			// Initialisation of associations
			// field is initialized with an instance of Instrument with the name of the field
			Instrument: []*Instrument{{Name: "Instrument"}},
			// field is initialized with an instance of Note_type with the name of the field
			Type_: &Note_type{Name: "Type_"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Dot: []*Empty_placement{{Name: "Dot"}},
			// field is initialized with an instance of Accidental with the name of the field
			Accidental: &Accidental{Name: "Accidental"},
			// field is initialized with an instance of Time_modification with the name of the field
			Time_modification: &Time_modification{Name: "Time_modification"},
			// field is initialized with an instance of Stem with the name of the field
			Stem: &Stem{Name: "Stem"},
			// field is initialized with an instance of Notehead with the name of the field
			Notehead: &Notehead{Name: "Notehead"},
			// field is initialized with an instance of Notehead_text with the name of the field
			Notehead_text: &Notehead_text{Name: "Notehead_text"},
			// field is initialized with an instance of Beam with the name of the field
			Beam: &Beam{Name: "Beam"},
			// field is initialized with an instance of Notations with the name of the field
			Notations: []*Notations{{Name: "Notations"}},
			// field is initialized with an instance of Lyric with the name of the field
			Lyric: []*Lyric{{Name: "Lyric"}},
			// field is initialized with an instance of Play with the name of the field
			Play: &Play{Name: "Play"},
			// field is initialized with an instance of Listen with the name of the field
			Listen: &Listen{Name: "Listen"},
		}).(*Type)
	case Note_size:
		return any(&Note_size{
			// Initialisation of associations
		}).(*Type)
	case Note_type:
		return any(&Note_type{
			// Initialisation of associations
		}).(*Type)
	case Notehead:
		return any(&Notehead{
			// Initialisation of associations
		}).(*Type)
	case Notehead_text:
		return any(&Notehead_text{
			// Initialisation of associations
			// field is initialized with an instance of Accidental_text with the name of the field
			Accidental_text: &Accidental_text{Name: "Accidental_text"},
		}).(*Type)
	case Numeral:
		return any(&Numeral{
			// Initialisation of associations
			// field is initialized with an instance of Numeral_root with the name of the field
			Numeral_root: &Numeral_root{Name: "Numeral_root"},
			// field is initialized with an instance of Harmony_alter with the name of the field
			Numeral_alter: &Harmony_alter{Name: "Numeral_alter"},
			// field is initialized with an instance of Numeral_key with the name of the field
			Numeral_key: &Numeral_key{Name: "Numeral_key"},
		}).(*Type)
	case Numeral_key:
		return any(&Numeral_key{
			// Initialisation of associations
		}).(*Type)
	case Numeral_root:
		return any(&Numeral_root{
			// Initialisation of associations
		}).(*Type)
	case Octave_shift:
		return any(&Octave_shift{
			// Initialisation of associations
		}).(*Type)
	case Offset:
		return any(&Offset{
			// Initialisation of associations
		}).(*Type)
	case Opus:
		return any(&Opus{
			// Initialisation of associations
		}).(*Type)
	case Ornaments:
		return any(&Ornaments{
			// Initialisation of associations
			// field is initialized with an instance of Accidental_mark with the name of the field
			Accidental_mark: []*Accidental_mark{{Name: "Accidental_mark"}},
			// field is initialized with an instance of Empty_trill_sound with the name of the field
			Trill_mark: &Empty_trill_sound{Name: "Trill_mark"},
			// field is initialized with an instance of Horizontal_turn with the name of the field
			Turn: &Horizontal_turn{Name: "Turn"},
			// field is initialized with an instance of Horizontal_turn with the name of the field
			Delayed_turn: &Horizontal_turn{Name: "Delayed_turn"},
			// field is initialized with an instance of Horizontal_turn with the name of the field
			Inverted_turn: &Horizontal_turn{Name: "Inverted_turn"},
			// field is initialized with an instance of Horizontal_turn with the name of the field
			Delayed_inverted_turn: &Horizontal_turn{Name: "Delayed_inverted_turn"},
			// field is initialized with an instance of Empty_trill_sound with the name of the field
			Vertical_turn: &Empty_trill_sound{Name: "Vertical_turn"},
			// field is initialized with an instance of Empty_trill_sound with the name of the field
			Inverted_vertical_turn: &Empty_trill_sound{Name: "Inverted_vertical_turn"},
			// field is initialized with an instance of Empty_trill_sound with the name of the field
			Shake: &Empty_trill_sound{Name: "Shake"},
			// field is initialized with an instance of Wavy_line with the name of the field
			Wavy_line: &Wavy_line{Name: "Wavy_line"},
			// field is initialized with an instance of Mordent with the name of the field
			Mordent: &Mordent{Name: "Mordent"},
			// field is initialized with an instance of Mordent with the name of the field
			Inverted_mordent: &Mordent{Name: "Inverted_mordent"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Schleifer: &Empty_placement{Name: "Schleifer"},
			// field is initialized with an instance of Tremolo with the name of the field
			Tremolo: &Tremolo{Name: "Tremolo"},
			// field is initialized with an instance of Empty_trill_sound with the name of the field
			Haydn: &Empty_trill_sound{Name: "Haydn"},
		}).(*Type)
	case Other_appearance:
		return any(&Other_appearance{
			// Initialisation of associations
		}).(*Type)
	case Other_listening:
		return any(&Other_listening{
			// Initialisation of associations
		}).(*Type)
	case Other_notation:
		return any(&Other_notation{
			// Initialisation of associations
		}).(*Type)
	case Other_play:
		return any(&Other_play{
			// Initialisation of associations
		}).(*Type)
	case Page_layout:
		return any(&Page_layout{
			// Initialisation of associations
			// field is initialized with an instance of Page_margins with the name of the field
			Page_margins: &Page_margins{Name: "Page_margins"},
		}).(*Type)
	case Page_margins:
		return any(&Page_margins{
			// Initialisation of associations
		}).(*Type)
	case Part_clef:
		return any(&Part_clef{
			// Initialisation of associations
		}).(*Type)
	case Part_group:
		return any(&Part_group{
			// Initialisation of associations
			// field is initialized with an instance of Name_display with the name of the field
			Group_name_display: &Name_display{Name: "Group_name_display"},
			// field is initialized with an instance of Name_display with the name of the field
			Group_abbreviation_display: &Name_display{Name: "Group_abbreviation_display"},
			// field is initialized with an instance of Group_symbol with the name of the field
			Group_symbol: &Group_symbol{Name: "Group_symbol"},
			// field is initialized with an instance of Group_barline with the name of the field
			Group_barline: &Group_barline{Name: "Group_barline"},
			// field is initialized with an instance of Empty with the name of the field
			Group_time: &Empty{Name: "Group_time"},
		}).(*Type)
	case Part_link:
		return any(&Part_link{
			// Initialisation of associations
			// field is initialized with an instance of Instrument_link with the name of the field
			Instrument_link: []*Instrument_link{{Name: "Instrument_link"}},
		}).(*Type)
	case Part_list:
		return any(&Part_list{
			// Initialisation of associations
		}).(*Type)
	case Part_symbol:
		return any(&Part_symbol{
			// Initialisation of associations
		}).(*Type)
	case Part_transpose:
		return any(&Part_transpose{
			// Initialisation of associations
		}).(*Type)
	case Pedal:
		return any(&Pedal{
			// Initialisation of associations
		}).(*Type)
	case Pedal_tuning:
		return any(&Pedal_tuning{
			// Initialisation of associations
		}).(*Type)
	case Percussion:
		return any(&Percussion{
			// Initialisation of associations
			// field is initialized with an instance of Glass with the name of the field
			Glass: &Glass{Name: "Glass"},
			// field is initialized with an instance of Metal with the name of the field
			Metal: &Metal{Name: "Metal"},
			// field is initialized with an instance of Wood with the name of the field
			Wood: &Wood{Name: "Wood"},
			// field is initialized with an instance of Pitched with the name of the field
			Pitched: &Pitched{Name: "Pitched"},
			// field is initialized with an instance of Membrane with the name of the field
			Membrane: &Membrane{Name: "Membrane"},
			// field is initialized with an instance of Effect with the name of the field
			Effect: &Effect{Name: "Effect"},
			// field is initialized with an instance of Timpani with the name of the field
			Timpani: &Timpani{Name: "Timpani"},
			// field is initialized with an instance of Beater with the name of the field
			Beater: &Beater{Name: "Beater"},
			// field is initialized with an instance of Stick with the name of the field
			Stick: &Stick{Name: "Stick"},
		}).(*Type)
	case Pitch:
		return any(&Pitch{
			// Initialisation of associations
		}).(*Type)
	case Pitched:
		return any(&Pitched{
			// Initialisation of associations
		}).(*Type)
	case Play:
		return any(&Play{
			// Initialisation of associations
			// field is initialized with an instance of Other_play with the name of the field
			Other_play: &Other_play{Name: "Other_play"},
		}).(*Type)
	case Player:
		return any(&Player{
			// Initialisation of associations
		}).(*Type)
	case Principal_voice:
		return any(&Principal_voice{
			// Initialisation of associations
		}).(*Type)
	case Print:
		return any(&Print{
			// Initialisation of associations
			// field is initialized with an instance of Measure_layout with the name of the field
			Measure_layout: &Measure_layout{Name: "Measure_layout"},
			// field is initialized with an instance of Measure_numbering with the name of the field
			Measure_numbering: &Measure_numbering{Name: "Measure_numbering"},
			// field is initialized with an instance of Name_display with the name of the field
			Part_name_display: &Name_display{Name: "Part_name_display"},
			// field is initialized with an instance of Name_display with the name of the field
			Part_abbreviation_display: &Name_display{Name: "Part_abbreviation_display"},
		}).(*Type)
	case Release:
		return any(&Release{
			// Initialisation of associations
		}).(*Type)
	case Repeat:
		return any(&Repeat{
			// Initialisation of associations
		}).(*Type)
	case Rest:
		return any(&Rest{
			// Initialisation of associations
		}).(*Type)
	case Root:
		return any(&Root{
			// Initialisation of associations
			// field is initialized with an instance of Root_step with the name of the field
			Root_step: &Root_step{Name: "Root_step"},
			// field is initialized with an instance of Harmony_alter with the name of the field
			Root_alter: &Harmony_alter{Name: "Root_alter"},
		}).(*Type)
	case Root_step:
		return any(&Root_step{
			// Initialisation of associations
		}).(*Type)
	case Scaling:
		return any(&Scaling{
			// Initialisation of associations
		}).(*Type)
	case Scordatura:
		return any(&Scordatura{
			// Initialisation of associations
			// field is initialized with an instance of Accord with the name of the field
			Accord: []*Accord{{Name: "Accord"}},
		}).(*Type)
	case Score_instrument:
		return any(&Score_instrument{
			// Initialisation of associations
		}).(*Type)
	case Score_part:
		return any(&Score_part{
			// Initialisation of associations
			// field is initialized with an instance of Identification with the name of the field
			Identification: &Identification{Name: "Identification"},
			// field is initialized with an instance of Part_link with the name of the field
			Part_link: []*Part_link{{Name: "Part_link"}},
			// field is initialized with an instance of Name_display with the name of the field
			Part_name_display: &Name_display{Name: "Part_name_display"},
			// field is initialized with an instance of Name_display with the name of the field
			Part_abbreviation_display: &Name_display{Name: "Part_abbreviation_display"},
			// field is initialized with an instance of Score_instrument with the name of the field
			Score_instrument: []*Score_instrument{{Name: "Score_instrument"}},
			// field is initialized with an instance of Player with the name of the field
			Player: []*Player{{Name: "Player"}},
		}).(*Type)
	case Score_partwise:
		return any(&Score_partwise{
			// Initialisation of associations
		}).(*Type)
	case Score_timewise:
		return any(&Score_timewise{
			// Initialisation of associations
		}).(*Type)
	case Segno:
		return any(&Segno{
			// Initialisation of associations
		}).(*Type)
	case Slash:
		return any(&Slash{
			// Initialisation of associations
		}).(*Type)
	case Slide:
		return any(&Slide{
			// Initialisation of associations
		}).(*Type)
	case Slur:
		return any(&Slur{
			// Initialisation of associations
		}).(*Type)
	case Sound:
		return any(&Sound{
			// Initialisation of associations
			// field is initialized with an instance of Swing with the name of the field
			Swing: &Swing{Name: "Swing"},
			// field is initialized with an instance of Offset with the name of the field
			Offset: &Offset{Name: "Offset"},
		}).(*Type)
	case Staff_details:
		return any(&Staff_details{
			// Initialisation of associations
			// field is initialized with an instance of Staff_tuning with the name of the field
			Staff_tuning: []*Staff_tuning{{Name: "Staff_tuning"}},
			// field is initialized with an instance of Staff_size with the name of the field
			Staff_size: &Staff_size{Name: "Staff_size"},
		}).(*Type)
	case Staff_divide:
		return any(&Staff_divide{
			// Initialisation of associations
		}).(*Type)
	case Staff_layout:
		return any(&Staff_layout{
			// Initialisation of associations
		}).(*Type)
	case Staff_size:
		return any(&Staff_size{
			// Initialisation of associations
		}).(*Type)
	case Staff_tuning:
		return any(&Staff_tuning{
			// Initialisation of associations
		}).(*Type)
	case Stem:
		return any(&Stem{
			// Initialisation of associations
		}).(*Type)
	case Stick:
		return any(&Stick{
			// Initialisation of associations
		}).(*Type)
	case String_mute:
		return any(&String_mute{
			// Initialisation of associations
		}).(*Type)
	case Strong_accent:
		return any(&Strong_accent{
			// Initialisation of associations
		}).(*Type)
	case Supports:
		return any(&Supports{
			// Initialisation of associations
		}).(*Type)
	case Swing:
		return any(&Swing{
			// Initialisation of associations
			// field is initialized with an instance of Empty with the name of the field
			Straight: &Empty{Name: "Straight"},
		}).(*Type)
	case Sync:
		return any(&Sync{
			// Initialisation of associations
		}).(*Type)
	case System_dividers:
		return any(&System_dividers{
			// Initialisation of associations
			// field is initialized with an instance of Empty_print_object_style_align with the name of the field
			Left_divider: &Empty_print_object_style_align{Name: "Left_divider"},
			// field is initialized with an instance of Empty_print_object_style_align with the name of the field
			Right_divider: &Empty_print_object_style_align{Name: "Right_divider"},
		}).(*Type)
	case System_layout:
		return any(&System_layout{
			// Initialisation of associations
			// field is initialized with an instance of System_margins with the name of the field
			System_margins: &System_margins{Name: "System_margins"},
			// field is initialized with an instance of System_dividers with the name of the field
			System_dividers: &System_dividers{Name: "System_dividers"},
		}).(*Type)
	case System_margins:
		return any(&System_margins{
			// Initialisation of associations
		}).(*Type)
	case Tap:
		return any(&Tap{
			// Initialisation of associations
		}).(*Type)
	case Technical:
		return any(&Technical{
			// Initialisation of associations
			// field is initialized with an instance of Empty_placement with the name of the field
			Up_bow: &Empty_placement{Name: "Up_bow"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Down_bow: &Empty_placement{Name: "Down_bow"},
			// field is initialized with an instance of Harmonic with the name of the field
			Harmonic: &Harmonic{Name: "Harmonic"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Open_string: &Empty_placement{Name: "Open_string"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Thumb_position: &Empty_placement{Name: "Thumb_position"},
			// field is initialized with an instance of Fingering with the name of the field
			Fingering: &Fingering{Name: "Fingering"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Double_tongue: &Empty_placement{Name: "Double_tongue"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Triple_tongue: &Empty_placement{Name: "Triple_tongue"},
			// field is initialized with an instance of Empty_placement_smufl with the name of the field
			Stopped: &Empty_placement_smufl{Name: "Stopped"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Snap_pizzicato: &Empty_placement{Name: "Snap_pizzicato"},
			// field is initialized with an instance of Fret with the name of the field
			Fret: &Fret{Name: "Fret"},
			// field is initialized with an instance of Hammer_on_pull_off with the name of the field
			Hammer_on: &Hammer_on_pull_off{Name: "Hammer_on"},
			// field is initialized with an instance of Hammer_on_pull_off with the name of the field
			Pull_off: &Hammer_on_pull_off{Name: "Pull_off"},
			// field is initialized with an instance of Bend with the name of the field
			Bend: &Bend{Name: "Bend"},
			// field is initialized with an instance of Tap with the name of the field
			Tap: &Tap{Name: "Tap"},
			// field is initialized with an instance of Heel_toe with the name of the field
			Heel: &Heel_toe{Name: "Heel"},
			// field is initialized with an instance of Heel_toe with the name of the field
			Toe: &Heel_toe{Name: "Toe"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Fingernails: &Empty_placement{Name: "Fingernails"},
			// field is initialized with an instance of Hole with the name of the field
			Hole: &Hole{Name: "Hole"},
			// field is initialized with an instance of Arrow with the name of the field
			Arrow: &Arrow{Name: "Arrow"},
			// field is initialized with an instance of Handbell with the name of the field
			Handbell: &Handbell{Name: "Handbell"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Brass_bend: &Empty_placement{Name: "Brass_bend"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Flip: &Empty_placement{Name: "Flip"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Smear: &Empty_placement{Name: "Smear"},
			// field is initialized with an instance of Empty_placement_smufl with the name of the field
			Open: &Empty_placement_smufl{Name: "Open"},
			// field is initialized with an instance of Empty_placement_smufl with the name of the field
			Half_muted: &Empty_placement_smufl{Name: "Half_muted"},
			// field is initialized with an instance of Harmon_mute with the name of the field
			Harmon_mute: &Harmon_mute{Name: "Harmon_mute"},
			// field is initialized with an instance of Empty_placement with the name of the field
			Golpe: &Empty_placement{Name: "Golpe"},
		}).(*Type)
	case Text_element_data:
		return any(&Text_element_data{
			// Initialisation of associations
		}).(*Type)
	case Tie:
		return any(&Tie{
			// Initialisation of associations
		}).(*Type)
	case Tied:
		return any(&Tied{
			// Initialisation of associations
		}).(*Type)
	case Time:
		return any(&Time{
			// Initialisation of associations
		}).(*Type)
	case Time_modification:
		return any(&Time_modification{
			// Initialisation of associations
		}).(*Type)
	case Timpani:
		return any(&Timpani{
			// Initialisation of associations
		}).(*Type)
	case Transpose:
		return any(&Transpose{
			// Initialisation of associations
		}).(*Type)
	case Tremolo:
		return any(&Tremolo{
			// Initialisation of associations
		}).(*Type)
	case Tuplet:
		return any(&Tuplet{
			// Initialisation of associations
			// field is initialized with an instance of Tuplet_portion with the name of the field
			Tuplet_actual: &Tuplet_portion{Name: "Tuplet_actual"},
			// field is initialized with an instance of Tuplet_portion with the name of the field
			Tuplet_normal: &Tuplet_portion{Name: "Tuplet_normal"},
		}).(*Type)
	case Tuplet_dot:
		return any(&Tuplet_dot{
			// Initialisation of associations
		}).(*Type)
	case Tuplet_number:
		return any(&Tuplet_number{
			// Initialisation of associations
		}).(*Type)
	case Tuplet_portion:
		return any(&Tuplet_portion{
			// Initialisation of associations
			// field is initialized with an instance of Tuplet_number with the name of the field
			Tuplet_number: &Tuplet_number{Name: "Tuplet_number"},
			// field is initialized with an instance of Tuplet_type with the name of the field
			Tuplet_type: &Tuplet_type{Name: "Tuplet_type"},
			// field is initialized with an instance of Tuplet_dot with the name of the field
			Tuplet_dot: []*Tuplet_dot{{Name: "Tuplet_dot"}},
		}).(*Type)
	case Tuplet_type:
		return any(&Tuplet_type{
			// Initialisation of associations
		}).(*Type)
	case Typed_text:
		return any(&Typed_text{
			// Initialisation of associations
		}).(*Type)
	case Unpitched:
		return any(&Unpitched{
			// Initialisation of associations
		}).(*Type)
	case Virtual_instrument:
		return any(&Virtual_instrument{
			// Initialisation of associations
		}).(*Type)
	case Wait:
		return any(&Wait{
			// Initialisation of associations
		}).(*Type)
	case Wavy_line:
		return any(&Wavy_line{
			// Initialisation of associations
		}).(*Type)
	case Wedge:
		return any(&Wedge{
			// Initialisation of associations
		}).(*Type)
	case Wood:
		return any(&Wood{
			// Initialisation of associations
		}).(*Type)
	case Work:
		return any(&Work{
			// Initialisation of associations
			// field is initialized with an instance of Opus with the name of the field
			Opus: &Opus{Name: "Opus"},
		}).(*Type)
	default:
		return nil
	}
}

// GetPointerReverseMap allows backtrack navigation of any Start.Fieldname
// associations (0..1) that is a pointer from one staged Gongstruct (type Start)
// instances to another (type End)
//
// The function provides a map with keys as instances of End and values to arrays of *Start
// the map is construed by iterating over all Start instances and populationg keys with End instances
// and values with slice of Start instances
func GetPointerReverseMap[Start, End Gongstruct](fieldname string, stage *StageStruct) map[*End][]*Start {

	var ret Start

	switch any(ret).(type) {
	// insertion point of functions that provide maps for reverse associations
	// reverse maps of direct associations of Accidental
	case Accidental:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Accidental_mark
	case Accidental_mark:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Accidental_text
	case Accidental_text:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Accord
	case Accord:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Accordion_registration
	case Accordion_registration:
		switch fieldname {
		// insertion point for per direct association field
		case "Accordion_high":
			res := make(map[*Empty][]*Accordion_registration)
			for accordion_registration := range stage.Accordion_registrations {
				if accordion_registration.Accordion_high != nil {
					empty_ := accordion_registration.Accordion_high
					var accordion_registrations []*Accordion_registration
					_, ok := res[empty_]
					if ok {
						accordion_registrations = res[empty_]
					} else {
						accordion_registrations = make([]*Accordion_registration, 0)
					}
					accordion_registrations = append(accordion_registrations, accordion_registration)
					res[empty_] = accordion_registrations
				}
			}
			return any(res).(map[*End][]*Start)
		case "Accordion_low":
			res := make(map[*Empty][]*Accordion_registration)
			for accordion_registration := range stage.Accordion_registrations {
				if accordion_registration.Accordion_low != nil {
					empty_ := accordion_registration.Accordion_low
					var accordion_registrations []*Accordion_registration
					_, ok := res[empty_]
					if ok {
						accordion_registrations = res[empty_]
					} else {
						accordion_registrations = make([]*Accordion_registration, 0)
					}
					accordion_registrations = append(accordion_registrations, accordion_registration)
					res[empty_] = accordion_registrations
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of AnyType
	case AnyType:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Appearance
	case Appearance:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Arpeggiate
	case Arpeggiate:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Arrow
	case Arrow:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Articulations
	case Articulations:
		switch fieldname {
		// insertion point for per direct association field
		case "Accent":
			res := make(map[*Empty_placement][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Accent != nil {
					empty_placement_ := articulations.Accent
					var articulationss []*Articulations
					_, ok := res[empty_placement_]
					if ok {
						articulationss = res[empty_placement_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_placement_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Strong_accent":
			res := make(map[*Strong_accent][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Strong_accent != nil {
					strong_accent_ := articulations.Strong_accent
					var articulationss []*Articulations
					_, ok := res[strong_accent_]
					if ok {
						articulationss = res[strong_accent_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[strong_accent_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Staccato":
			res := make(map[*Empty_placement][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Staccato != nil {
					empty_placement_ := articulations.Staccato
					var articulationss []*Articulations
					_, ok := res[empty_placement_]
					if ok {
						articulationss = res[empty_placement_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_placement_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Tenuto":
			res := make(map[*Empty_placement][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Tenuto != nil {
					empty_placement_ := articulations.Tenuto
					var articulationss []*Articulations
					_, ok := res[empty_placement_]
					if ok {
						articulationss = res[empty_placement_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_placement_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Detached_legato":
			res := make(map[*Empty_placement][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Detached_legato != nil {
					empty_placement_ := articulations.Detached_legato
					var articulationss []*Articulations
					_, ok := res[empty_placement_]
					if ok {
						articulationss = res[empty_placement_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_placement_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Staccatissimo":
			res := make(map[*Empty_placement][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Staccatissimo != nil {
					empty_placement_ := articulations.Staccatissimo
					var articulationss []*Articulations
					_, ok := res[empty_placement_]
					if ok {
						articulationss = res[empty_placement_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_placement_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Spiccato":
			res := make(map[*Empty_placement][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Spiccato != nil {
					empty_placement_ := articulations.Spiccato
					var articulationss []*Articulations
					_, ok := res[empty_placement_]
					if ok {
						articulationss = res[empty_placement_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_placement_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Scoop":
			res := make(map[*Empty_line][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Scoop != nil {
					empty_line_ := articulations.Scoop
					var articulationss []*Articulations
					_, ok := res[empty_line_]
					if ok {
						articulationss = res[empty_line_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_line_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Plop":
			res := make(map[*Empty_line][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Plop != nil {
					empty_line_ := articulations.Plop
					var articulationss []*Articulations
					_, ok := res[empty_line_]
					if ok {
						articulationss = res[empty_line_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_line_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Doit":
			res := make(map[*Empty_line][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Doit != nil {
					empty_line_ := articulations.Doit
					var articulationss []*Articulations
					_, ok := res[empty_line_]
					if ok {
						articulationss = res[empty_line_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_line_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Falloff":
			res := make(map[*Empty_line][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Falloff != nil {
					empty_line_ := articulations.Falloff
					var articulationss []*Articulations
					_, ok := res[empty_line_]
					if ok {
						articulationss = res[empty_line_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_line_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Breath_mark":
			res := make(map[*Breath_mark][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Breath_mark != nil {
					breath_mark_ := articulations.Breath_mark
					var articulationss []*Articulations
					_, ok := res[breath_mark_]
					if ok {
						articulationss = res[breath_mark_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[breath_mark_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Caesura":
			res := make(map[*Caesura][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Caesura != nil {
					caesura_ := articulations.Caesura
					var articulationss []*Articulations
					_, ok := res[caesura_]
					if ok {
						articulationss = res[caesura_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[caesura_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Stress":
			res := make(map[*Empty_placement][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Stress != nil {
					empty_placement_ := articulations.Stress
					var articulationss []*Articulations
					_, ok := res[empty_placement_]
					if ok {
						articulationss = res[empty_placement_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_placement_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Unstress":
			res := make(map[*Empty_placement][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Unstress != nil {
					empty_placement_ := articulations.Unstress
					var articulationss []*Articulations
					_, ok := res[empty_placement_]
					if ok {
						articulationss = res[empty_placement_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_placement_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Soft_accent":
			res := make(map[*Empty_placement][]*Articulations)
			for articulations := range stage.Articulationss {
				if articulations.Soft_accent != nil {
					empty_placement_ := articulations.Soft_accent
					var articulationss []*Articulations
					_, ok := res[empty_placement_]
					if ok {
						articulationss = res[empty_placement_]
					} else {
						articulationss = make([]*Articulations, 0)
					}
					articulationss = append(articulationss, articulations)
					res[empty_placement_] = articulationss
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Assess
	case Assess:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Attributes
	case Attributes:
		switch fieldname {
		// insertion point for per direct association field
		case "Part_symbol":
			res := make(map[*Part_symbol][]*Attributes)
			for attributes := range stage.Attributess {
				if attributes.Part_symbol != nil {
					part_symbol_ := attributes.Part_symbol
					var attributess []*Attributes
					_, ok := res[part_symbol_]
					if ok {
						attributess = res[part_symbol_]
					} else {
						attributess = make([]*Attributes, 0)
					}
					attributess = append(attributess, attributes)
					res[part_symbol_] = attributess
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Backup
	case Backup:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Bar_style_color
	case Bar_style_color:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Barline
	case Barline:
		switch fieldname {
		// insertion point for per direct association field
		case "Bar_style":
			res := make(map[*Bar_style_color][]*Barline)
			for barline := range stage.Barlines {
				if barline.Bar_style != nil {
					bar_style_color_ := barline.Bar_style
					var barlines []*Barline
					_, ok := res[bar_style_color_]
					if ok {
						barlines = res[bar_style_color_]
					} else {
						barlines = make([]*Barline, 0)
					}
					barlines = append(barlines, barline)
					res[bar_style_color_] = barlines
				}
			}
			return any(res).(map[*End][]*Start)
		case "Wavy_line":
			res := make(map[*Wavy_line][]*Barline)
			for barline := range stage.Barlines {
				if barline.Wavy_line != nil {
					wavy_line_ := barline.Wavy_line
					var barlines []*Barline
					_, ok := res[wavy_line_]
					if ok {
						barlines = res[wavy_line_]
					} else {
						barlines = make([]*Barline, 0)
					}
					barlines = append(barlines, barline)
					res[wavy_line_] = barlines
				}
			}
			return any(res).(map[*End][]*Start)
		case "Fermata":
			res := make(map[*Fermata][]*Barline)
			for barline := range stage.Barlines {
				if barline.Fermata != nil {
					fermata_ := barline.Fermata
					var barlines []*Barline
					_, ok := res[fermata_]
					if ok {
						barlines = res[fermata_]
					} else {
						barlines = make([]*Barline, 0)
					}
					barlines = append(barlines, barline)
					res[fermata_] = barlines
				}
			}
			return any(res).(map[*End][]*Start)
		case "Ending":
			res := make(map[*Ending][]*Barline)
			for barline := range stage.Barlines {
				if barline.Ending != nil {
					ending_ := barline.Ending
					var barlines []*Barline
					_, ok := res[ending_]
					if ok {
						barlines = res[ending_]
					} else {
						barlines = make([]*Barline, 0)
					}
					barlines = append(barlines, barline)
					res[ending_] = barlines
				}
			}
			return any(res).(map[*End][]*Start)
		case "Repeat":
			res := make(map[*Repeat][]*Barline)
			for barline := range stage.Barlines {
				if barline.Repeat != nil {
					repeat_ := barline.Repeat
					var barlines []*Barline
					_, ok := res[repeat_]
					if ok {
						barlines = res[repeat_]
					} else {
						barlines = make([]*Barline, 0)
					}
					barlines = append(barlines, barline)
					res[repeat_] = barlines
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Barre
	case Barre:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Bass
	case Bass:
		switch fieldname {
		// insertion point for per direct association field
		case "Bass_step":
			res := make(map[*Bass_step][]*Bass)
			for bass := range stage.Basss {
				if bass.Bass_step != nil {
					bass_step_ := bass.Bass_step
					var basss []*Bass
					_, ok := res[bass_step_]
					if ok {
						basss = res[bass_step_]
					} else {
						basss = make([]*Bass, 0)
					}
					basss = append(basss, bass)
					res[bass_step_] = basss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Bass_alter":
			res := make(map[*Harmony_alter][]*Bass)
			for bass := range stage.Basss {
				if bass.Bass_alter != nil {
					harmony_alter_ := bass.Bass_alter
					var basss []*Bass
					_, ok := res[harmony_alter_]
					if ok {
						basss = res[harmony_alter_]
					} else {
						basss = make([]*Bass, 0)
					}
					basss = append(basss, bass)
					res[harmony_alter_] = basss
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Bass_step
	case Bass_step:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Beam
	case Beam:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Beat_repeat
	case Beat_repeat:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Beat_unit_tied
	case Beat_unit_tied:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Beater
	case Beater:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Bend
	case Bend:
		switch fieldname {
		// insertion point for per direct association field
		case "Pre_bend":
			res := make(map[*Empty][]*Bend)
			for bend := range stage.Bends {
				if bend.Pre_bend != nil {
					empty_ := bend.Pre_bend
					var bends []*Bend
					_, ok := res[empty_]
					if ok {
						bends = res[empty_]
					} else {
						bends = make([]*Bend, 0)
					}
					bends = append(bends, bend)
					res[empty_] = bends
				}
			}
			return any(res).(map[*End][]*Start)
		case "Release":
			res := make(map[*Release][]*Bend)
			for bend := range stage.Bends {
				if bend.Release != nil {
					release_ := bend.Release
					var bends []*Bend
					_, ok := res[release_]
					if ok {
						bends = res[release_]
					} else {
						bends = make([]*Bend, 0)
					}
					bends = append(bends, bend)
					res[release_] = bends
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Bookmark
	case Bookmark:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Bracket
	case Bracket:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Breath_mark
	case Breath_mark:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Caesura
	case Caesura:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Cancel
	case Cancel:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Clef
	case Clef:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Coda
	case Coda:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Credit
	case Credit:
		switch fieldname {
		// insertion point for per direct association field
		case "Credit_image":
			res := make(map[*Image][]*Credit)
			for credit := range stage.Credits {
				if credit.Credit_image != nil {
					image_ := credit.Credit_image
					var credits []*Credit
					_, ok := res[image_]
					if ok {
						credits = res[image_]
					} else {
						credits = make([]*Credit, 0)
					}
					credits = append(credits, credit)
					res[image_] = credits
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Dashes
	case Dashes:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Defaults
	case Defaults:
		switch fieldname {
		// insertion point for per direct association field
		case "Scaling":
			res := make(map[*Scaling][]*Defaults)
			for defaults := range stage.Defaultss {
				if defaults.Scaling != nil {
					scaling_ := defaults.Scaling
					var defaultss []*Defaults
					_, ok := res[scaling_]
					if ok {
						defaultss = res[scaling_]
					} else {
						defaultss = make([]*Defaults, 0)
					}
					defaultss = append(defaultss, defaults)
					res[scaling_] = defaultss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Concert_score":
			res := make(map[*Empty][]*Defaults)
			for defaults := range stage.Defaultss {
				if defaults.Concert_score != nil {
					empty_ := defaults.Concert_score
					var defaultss []*Defaults
					_, ok := res[empty_]
					if ok {
						defaultss = res[empty_]
					} else {
						defaultss = make([]*Defaults, 0)
					}
					defaultss = append(defaultss, defaults)
					res[empty_] = defaultss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Appearance":
			res := make(map[*Appearance][]*Defaults)
			for defaults := range stage.Defaultss {
				if defaults.Appearance != nil {
					appearance_ := defaults.Appearance
					var defaultss []*Defaults
					_, ok := res[appearance_]
					if ok {
						defaultss = res[appearance_]
					} else {
						defaultss = make([]*Defaults, 0)
					}
					defaultss = append(defaultss, defaults)
					res[appearance_] = defaultss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Music_font":
			res := make(map[*Empty_font][]*Defaults)
			for defaults := range stage.Defaultss {
				if defaults.Music_font != nil {
					empty_font_ := defaults.Music_font
					var defaultss []*Defaults
					_, ok := res[empty_font_]
					if ok {
						defaultss = res[empty_font_]
					} else {
						defaultss = make([]*Defaults, 0)
					}
					defaultss = append(defaultss, defaults)
					res[empty_font_] = defaultss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Word_font":
			res := make(map[*Empty_font][]*Defaults)
			for defaults := range stage.Defaultss {
				if defaults.Word_font != nil {
					empty_font_ := defaults.Word_font
					var defaultss []*Defaults
					_, ok := res[empty_font_]
					if ok {
						defaultss = res[empty_font_]
					} else {
						defaultss = make([]*Defaults, 0)
					}
					defaultss = append(defaultss, defaults)
					res[empty_font_] = defaultss
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Degree
	case Degree:
		switch fieldname {
		// insertion point for per direct association field
		case "Degree_value":
			res := make(map[*Degree_value][]*Degree)
			for degree := range stage.Degrees {
				if degree.Degree_value != nil {
					degree_value_ := degree.Degree_value
					var degrees []*Degree
					_, ok := res[degree_value_]
					if ok {
						degrees = res[degree_value_]
					} else {
						degrees = make([]*Degree, 0)
					}
					degrees = append(degrees, degree)
					res[degree_value_] = degrees
				}
			}
			return any(res).(map[*End][]*Start)
		case "Degree_alter":
			res := make(map[*Degree_alter][]*Degree)
			for degree := range stage.Degrees {
				if degree.Degree_alter != nil {
					degree_alter_ := degree.Degree_alter
					var degrees []*Degree
					_, ok := res[degree_alter_]
					if ok {
						degrees = res[degree_alter_]
					} else {
						degrees = make([]*Degree, 0)
					}
					degrees = append(degrees, degree)
					res[degree_alter_] = degrees
				}
			}
			return any(res).(map[*End][]*Start)
		case "Degree_type":
			res := make(map[*Degree_type][]*Degree)
			for degree := range stage.Degrees {
				if degree.Degree_type != nil {
					degree_type_ := degree.Degree_type
					var degrees []*Degree
					_, ok := res[degree_type_]
					if ok {
						degrees = res[degree_type_]
					} else {
						degrees = make([]*Degree, 0)
					}
					degrees = append(degrees, degree)
					res[degree_type_] = degrees
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Degree_alter
	case Degree_alter:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Degree_type
	case Degree_type:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Degree_value
	case Degree_value:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Direction
	case Direction:
		switch fieldname {
		// insertion point for per direct association field
		case "Offset":
			res := make(map[*Offset][]*Direction)
			for direction := range stage.Directions {
				if direction.Offset != nil {
					offset_ := direction.Offset
					var directions []*Direction
					_, ok := res[offset_]
					if ok {
						directions = res[offset_]
					} else {
						directions = make([]*Direction, 0)
					}
					directions = append(directions, direction)
					res[offset_] = directions
				}
			}
			return any(res).(map[*End][]*Start)
		case "Sound":
			res := make(map[*Sound][]*Direction)
			for direction := range stage.Directions {
				if direction.Sound != nil {
					sound_ := direction.Sound
					var directions []*Direction
					_, ok := res[sound_]
					if ok {
						directions = res[sound_]
					} else {
						directions = make([]*Direction, 0)
					}
					directions = append(directions, direction)
					res[sound_] = directions
				}
			}
			return any(res).(map[*End][]*Start)
		case "Listening":
			res := make(map[*Listening][]*Direction)
			for direction := range stage.Directions {
				if direction.Listening != nil {
					listening_ := direction.Listening
					var directions []*Direction
					_, ok := res[listening_]
					if ok {
						directions = res[listening_]
					} else {
						directions = make([]*Direction, 0)
					}
					directions = append(directions, direction)
					res[listening_] = directions
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Direction_type
	case Direction_type:
		switch fieldname {
		// insertion point for per direct association field
		case "Wedge":
			res := make(map[*Wedge][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Wedge != nil {
					wedge_ := direction_type.Wedge
					var direction_types []*Direction_type
					_, ok := res[wedge_]
					if ok {
						direction_types = res[wedge_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[wedge_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Dashes":
			res := make(map[*Dashes][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Dashes != nil {
					dashes_ := direction_type.Dashes
					var direction_types []*Direction_type
					_, ok := res[dashes_]
					if ok {
						direction_types = res[dashes_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[dashes_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Bracket":
			res := make(map[*Bracket][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Bracket != nil {
					bracket_ := direction_type.Bracket
					var direction_types []*Direction_type
					_, ok := res[bracket_]
					if ok {
						direction_types = res[bracket_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[bracket_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Pedal":
			res := make(map[*Pedal][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Pedal != nil {
					pedal_ := direction_type.Pedal
					var direction_types []*Direction_type
					_, ok := res[pedal_]
					if ok {
						direction_types = res[pedal_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[pedal_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Metronome":
			res := make(map[*Metronome][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Metronome != nil {
					metronome_ := direction_type.Metronome
					var direction_types []*Direction_type
					_, ok := res[metronome_]
					if ok {
						direction_types = res[metronome_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[metronome_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Octave_shift":
			res := make(map[*Octave_shift][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Octave_shift != nil {
					octave_shift_ := direction_type.Octave_shift
					var direction_types []*Direction_type
					_, ok := res[octave_shift_]
					if ok {
						direction_types = res[octave_shift_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[octave_shift_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Harp_pedals":
			res := make(map[*Harp_pedals][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Harp_pedals != nil {
					harp_pedals_ := direction_type.Harp_pedals
					var direction_types []*Direction_type
					_, ok := res[harp_pedals_]
					if ok {
						direction_types = res[harp_pedals_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[harp_pedals_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Damp":
			res := make(map[*Empty_print_style_align_id][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Damp != nil {
					empty_print_style_align_id_ := direction_type.Damp
					var direction_types []*Direction_type
					_, ok := res[empty_print_style_align_id_]
					if ok {
						direction_types = res[empty_print_style_align_id_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[empty_print_style_align_id_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Damp_all":
			res := make(map[*Empty_print_style_align_id][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Damp_all != nil {
					empty_print_style_align_id_ := direction_type.Damp_all
					var direction_types []*Direction_type
					_, ok := res[empty_print_style_align_id_]
					if ok {
						direction_types = res[empty_print_style_align_id_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[empty_print_style_align_id_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Eyeglasses":
			res := make(map[*Empty_print_style_align_id][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Eyeglasses != nil {
					empty_print_style_align_id_ := direction_type.Eyeglasses
					var direction_types []*Direction_type
					_, ok := res[empty_print_style_align_id_]
					if ok {
						direction_types = res[empty_print_style_align_id_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[empty_print_style_align_id_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "String_mute":
			res := make(map[*String_mute][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.String_mute != nil {
					string_mute_ := direction_type.String_mute
					var direction_types []*Direction_type
					_, ok := res[string_mute_]
					if ok {
						direction_types = res[string_mute_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[string_mute_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Scordatura":
			res := make(map[*Scordatura][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Scordatura != nil {
					scordatura_ := direction_type.Scordatura
					var direction_types []*Direction_type
					_, ok := res[scordatura_]
					if ok {
						direction_types = res[scordatura_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[scordatura_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Image":
			res := make(map[*Image][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Image != nil {
					image_ := direction_type.Image
					var direction_types []*Direction_type
					_, ok := res[image_]
					if ok {
						direction_types = res[image_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[image_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Principal_voice":
			res := make(map[*Principal_voice][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Principal_voice != nil {
					principal_voice_ := direction_type.Principal_voice
					var direction_types []*Direction_type
					_, ok := res[principal_voice_]
					if ok {
						direction_types = res[principal_voice_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[principal_voice_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Accordion_registration":
			res := make(map[*Accordion_registration][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Accordion_registration != nil {
					accordion_registration_ := direction_type.Accordion_registration
					var direction_types []*Direction_type
					_, ok := res[accordion_registration_]
					if ok {
						direction_types = res[accordion_registration_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[accordion_registration_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		case "Staff_divide":
			res := make(map[*Staff_divide][]*Direction_type)
			for direction_type := range stage.Direction_types {
				if direction_type.Staff_divide != nil {
					staff_divide_ := direction_type.Staff_divide
					var direction_types []*Direction_type
					_, ok := res[staff_divide_]
					if ok {
						direction_types = res[staff_divide_]
					} else {
						direction_types = make([]*Direction_type, 0)
					}
					direction_types = append(direction_types, direction_type)
					res[staff_divide_] = direction_types
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Distance
	case Distance:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Double
	case Double:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Dynamics
	case Dynamics:
		switch fieldname {
		// insertion point for per direct association field
		case "P":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.P != nil {
					empty_ := dynamics.P
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Pp":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Pp != nil {
					empty_ := dynamics.Pp
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Ppp":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Ppp != nil {
					empty_ := dynamics.Ppp
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Pppp":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Pppp != nil {
					empty_ := dynamics.Pppp
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Ppppp":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Ppppp != nil {
					empty_ := dynamics.Ppppp
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Pppppp":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Pppppp != nil {
					empty_ := dynamics.Pppppp
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "F":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.F != nil {
					empty_ := dynamics.F
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Ff":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Ff != nil {
					empty_ := dynamics.Ff
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Fff":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Fff != nil {
					empty_ := dynamics.Fff
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Ffff":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Ffff != nil {
					empty_ := dynamics.Ffff
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Fffff":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Fffff != nil {
					empty_ := dynamics.Fffff
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Ffffff":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Ffffff != nil {
					empty_ := dynamics.Ffffff
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Mp":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Mp != nil {
					empty_ := dynamics.Mp
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Mf":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Mf != nil {
					empty_ := dynamics.Mf
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Sf":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Sf != nil {
					empty_ := dynamics.Sf
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Sfp":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Sfp != nil {
					empty_ := dynamics.Sfp
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Sfpp":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Sfpp != nil {
					empty_ := dynamics.Sfpp
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Fp":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Fp != nil {
					empty_ := dynamics.Fp
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Rf":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Rf != nil {
					empty_ := dynamics.Rf
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Rfz":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Rfz != nil {
					empty_ := dynamics.Rfz
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Sfz":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Sfz != nil {
					empty_ := dynamics.Sfz
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Sffz":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Sffz != nil {
					empty_ := dynamics.Sffz
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Fz":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Fz != nil {
					empty_ := dynamics.Fz
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "N":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.N != nil {
					empty_ := dynamics.N
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Pf":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Pf != nil {
					empty_ := dynamics.Pf
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Sfzp":
			res := make(map[*Empty][]*Dynamics)
			for dynamics := range stage.Dynamicss {
				if dynamics.Sfzp != nil {
					empty_ := dynamics.Sfzp
					var dynamicss []*Dynamics
					_, ok := res[empty_]
					if ok {
						dynamicss = res[empty_]
					} else {
						dynamicss = make([]*Dynamics, 0)
					}
					dynamicss = append(dynamicss, dynamics)
					res[empty_] = dynamicss
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Effect
	case Effect:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Elision
	case Elision:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty
	case Empty:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_font
	case Empty_font:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_line
	case Empty_line:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_placement
	case Empty_placement:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_placement_smufl
	case Empty_placement_smufl:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_print_object_style_align
	case Empty_print_object_style_align:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_print_style
	case Empty_print_style:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_print_style_align
	case Empty_print_style_align:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_print_style_align_id
	case Empty_print_style_align_id:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_trill_sound
	case Empty_trill_sound:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Encoding
	case Encoding:
		switch fieldname {
		// insertion point for per direct association field
		case "Encoder":
			res := make(map[*Typed_text][]*Encoding)
			for encoding := range stage.Encodings {
				if encoding.Encoder != nil {
					typed_text_ := encoding.Encoder
					var encodings []*Encoding
					_, ok := res[typed_text_]
					if ok {
						encodings = res[typed_text_]
					} else {
						encodings = make([]*Encoding, 0)
					}
					encodings = append(encodings, encoding)
					res[typed_text_] = encodings
				}
			}
			return any(res).(map[*End][]*Start)
		case "Supports":
			res := make(map[*Supports][]*Encoding)
			for encoding := range stage.Encodings {
				if encoding.Supports != nil {
					supports_ := encoding.Supports
					var encodings []*Encoding
					_, ok := res[supports_]
					if ok {
						encodings = res[supports_]
					} else {
						encodings = make([]*Encoding, 0)
					}
					encodings = append(encodings, encoding)
					res[supports_] = encodings
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Ending
	case Ending:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Extend
	case Extend:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Feature
	case Feature:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Fermata
	case Fermata:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Figure
	case Figure:
		switch fieldname {
		// insertion point for per direct association field
		case "Extend":
			res := make(map[*Extend][]*Figure)
			for figure := range stage.Figures {
				if figure.Extend != nil {
					extend_ := figure.Extend
					var figures []*Figure
					_, ok := res[extend_]
					if ok {
						figures = res[extend_]
					} else {
						figures = make([]*Figure, 0)
					}
					figures = append(figures, figure)
					res[extend_] = figures
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Figured_bass
	case Figured_bass:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Fingering
	case Fingering:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of First_fret
	case First_fret:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Foo
	case Foo:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of For_part
	case For_part:
		switch fieldname {
		// insertion point for per direct association field
		case "Part_clef":
			res := make(map[*Part_clef][]*For_part)
			for for_part := range stage.For_parts {
				if for_part.Part_clef != nil {
					part_clef_ := for_part.Part_clef
					var for_parts []*For_part
					_, ok := res[part_clef_]
					if ok {
						for_parts = res[part_clef_]
					} else {
						for_parts = make([]*For_part, 0)
					}
					for_parts = append(for_parts, for_part)
					res[part_clef_] = for_parts
				}
			}
			return any(res).(map[*End][]*Start)
		case "Part_transpose":
			res := make(map[*Part_transpose][]*For_part)
			for for_part := range stage.For_parts {
				if for_part.Part_transpose != nil {
					part_transpose_ := for_part.Part_transpose
					var for_parts []*For_part
					_, ok := res[part_transpose_]
					if ok {
						for_parts = res[part_transpose_]
					} else {
						for_parts = make([]*For_part, 0)
					}
					for_parts = append(for_parts, for_part)
					res[part_transpose_] = for_parts
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Formatted_symbol
	case Formatted_symbol:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Formatted_symbol_id
	case Formatted_symbol_id:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Forward
	case Forward:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Frame
	case Frame:
		switch fieldname {
		// insertion point for per direct association field
		case "First_fret":
			res := make(map[*First_fret][]*Frame)
			for frame := range stage.Frames {
				if frame.First_fret != nil {
					first_fret_ := frame.First_fret
					var frames []*Frame
					_, ok := res[first_fret_]
					if ok {
						frames = res[first_fret_]
					} else {
						frames = make([]*Frame, 0)
					}
					frames = append(frames, frame)
					res[first_fret_] = frames
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Frame_note
	case Frame_note:
		switch fieldname {
		// insertion point for per direct association field
		case "Fret":
			res := make(map[*Fret][]*Frame_note)
			for frame_note := range stage.Frame_notes {
				if frame_note.Fret != nil {
					fret_ := frame_note.Fret
					var frame_notes []*Frame_note
					_, ok := res[fret_]
					if ok {
						frame_notes = res[fret_]
					} else {
						frame_notes = make([]*Frame_note, 0)
					}
					frame_notes = append(frame_notes, frame_note)
					res[fret_] = frame_notes
				}
			}
			return any(res).(map[*End][]*Start)
		case "Fingering":
			res := make(map[*Fingering][]*Frame_note)
			for frame_note := range stage.Frame_notes {
				if frame_note.Fingering != nil {
					fingering_ := frame_note.Fingering
					var frame_notes []*Frame_note
					_, ok := res[fingering_]
					if ok {
						frame_notes = res[fingering_]
					} else {
						frame_notes = make([]*Frame_note, 0)
					}
					frame_notes = append(frame_notes, frame_note)
					res[fingering_] = frame_notes
				}
			}
			return any(res).(map[*End][]*Start)
		case "Barre":
			res := make(map[*Barre][]*Frame_note)
			for frame_note := range stage.Frame_notes {
				if frame_note.Barre != nil {
					barre_ := frame_note.Barre
					var frame_notes []*Frame_note
					_, ok := res[barre_]
					if ok {
						frame_notes = res[barre_]
					} else {
						frame_notes = make([]*Frame_note, 0)
					}
					frame_notes = append(frame_notes, frame_note)
					res[barre_] = frame_notes
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Fret
	case Fret:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Glass
	case Glass:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Glissando
	case Glissando:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Glyph
	case Glyph:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Grace
	case Grace:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Group_barline
	case Group_barline:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Group_symbol
	case Group_symbol:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Grouping
	case Grouping:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Hammer_on_pull_off
	case Hammer_on_pull_off:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Handbell
	case Handbell:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Harmon_closed
	case Harmon_closed:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Harmon_mute
	case Harmon_mute:
		switch fieldname {
		// insertion point for per direct association field
		case "Harmon_closed":
			res := make(map[*Harmon_closed][]*Harmon_mute)
			for harmon_mute := range stage.Harmon_mutes {
				if harmon_mute.Harmon_closed != nil {
					harmon_closed_ := harmon_mute.Harmon_closed
					var harmon_mutes []*Harmon_mute
					_, ok := res[harmon_closed_]
					if ok {
						harmon_mutes = res[harmon_closed_]
					} else {
						harmon_mutes = make([]*Harmon_mute, 0)
					}
					harmon_mutes = append(harmon_mutes, harmon_mute)
					res[harmon_closed_] = harmon_mutes
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Harmonic
	case Harmonic:
		switch fieldname {
		// insertion point for per direct association field
		case "Natural":
			res := make(map[*Empty][]*Harmonic)
			for harmonic := range stage.Harmonics {
				if harmonic.Natural != nil {
					empty_ := harmonic.Natural
					var harmonics []*Harmonic
					_, ok := res[empty_]
					if ok {
						harmonics = res[empty_]
					} else {
						harmonics = make([]*Harmonic, 0)
					}
					harmonics = append(harmonics, harmonic)
					res[empty_] = harmonics
				}
			}
			return any(res).(map[*End][]*Start)
		case "Artificial":
			res := make(map[*Empty][]*Harmonic)
			for harmonic := range stage.Harmonics {
				if harmonic.Artificial != nil {
					empty_ := harmonic.Artificial
					var harmonics []*Harmonic
					_, ok := res[empty_]
					if ok {
						harmonics = res[empty_]
					} else {
						harmonics = make([]*Harmonic, 0)
					}
					harmonics = append(harmonics, harmonic)
					res[empty_] = harmonics
				}
			}
			return any(res).(map[*End][]*Start)
		case "Base_pitch":
			res := make(map[*Empty][]*Harmonic)
			for harmonic := range stage.Harmonics {
				if harmonic.Base_pitch != nil {
					empty_ := harmonic.Base_pitch
					var harmonics []*Harmonic
					_, ok := res[empty_]
					if ok {
						harmonics = res[empty_]
					} else {
						harmonics = make([]*Harmonic, 0)
					}
					harmonics = append(harmonics, harmonic)
					res[empty_] = harmonics
				}
			}
			return any(res).(map[*End][]*Start)
		case "Touching_pitch":
			res := make(map[*Empty][]*Harmonic)
			for harmonic := range stage.Harmonics {
				if harmonic.Touching_pitch != nil {
					empty_ := harmonic.Touching_pitch
					var harmonics []*Harmonic
					_, ok := res[empty_]
					if ok {
						harmonics = res[empty_]
					} else {
						harmonics = make([]*Harmonic, 0)
					}
					harmonics = append(harmonics, harmonic)
					res[empty_] = harmonics
				}
			}
			return any(res).(map[*End][]*Start)
		case "Sounding_pitch":
			res := make(map[*Empty][]*Harmonic)
			for harmonic := range stage.Harmonics {
				if harmonic.Sounding_pitch != nil {
					empty_ := harmonic.Sounding_pitch
					var harmonics []*Harmonic
					_, ok := res[empty_]
					if ok {
						harmonics = res[empty_]
					} else {
						harmonics = make([]*Harmonic, 0)
					}
					harmonics = append(harmonics, harmonic)
					res[empty_] = harmonics
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Harmony
	case Harmony:
		switch fieldname {
		// insertion point for per direct association field
		case "Frame":
			res := make(map[*Frame][]*Harmony)
			for harmony := range stage.Harmonys {
				if harmony.Frame != nil {
					frame_ := harmony.Frame
					var harmonys []*Harmony
					_, ok := res[frame_]
					if ok {
						harmonys = res[frame_]
					} else {
						harmonys = make([]*Harmony, 0)
					}
					harmonys = append(harmonys, harmony)
					res[frame_] = harmonys
				}
			}
			return any(res).(map[*End][]*Start)
		case "Offset":
			res := make(map[*Offset][]*Harmony)
			for harmony := range stage.Harmonys {
				if harmony.Offset != nil {
					offset_ := harmony.Offset
					var harmonys []*Harmony
					_, ok := res[offset_]
					if ok {
						harmonys = res[offset_]
					} else {
						harmonys = make([]*Harmony, 0)
					}
					harmonys = append(harmonys, harmony)
					res[offset_] = harmonys
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Harmony_alter
	case Harmony_alter:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Harp_pedals
	case Harp_pedals:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Heel_toe
	case Heel_toe:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Hole
	case Hole:
		switch fieldname {
		// insertion point for per direct association field
		case "Hole_closed":
			res := make(map[*Hole_closed][]*Hole)
			for hole := range stage.Holes {
				if hole.Hole_closed != nil {
					hole_closed_ := hole.Hole_closed
					var holes []*Hole
					_, ok := res[hole_closed_]
					if ok {
						holes = res[hole_closed_]
					} else {
						holes = make([]*Hole, 0)
					}
					holes = append(holes, hole)
					res[hole_closed_] = holes
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Hole_closed
	case Hole_closed:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Horizontal_turn
	case Horizontal_turn:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Identification
	case Identification:
		switch fieldname {
		// insertion point for per direct association field
		case "Encoding":
			res := make(map[*Encoding][]*Identification)
			for identification := range stage.Identifications {
				if identification.Encoding != nil {
					encoding_ := identification.Encoding
					var identifications []*Identification
					_, ok := res[encoding_]
					if ok {
						identifications = res[encoding_]
					} else {
						identifications = make([]*Identification, 0)
					}
					identifications = append(identifications, identification)
					res[encoding_] = identifications
				}
			}
			return any(res).(map[*End][]*Start)
		case "Miscellaneous":
			res := make(map[*Miscellaneous][]*Identification)
			for identification := range stage.Identifications {
				if identification.Miscellaneous != nil {
					miscellaneous_ := identification.Miscellaneous
					var identifications []*Identification
					_, ok := res[miscellaneous_]
					if ok {
						identifications = res[miscellaneous_]
					} else {
						identifications = make([]*Identification, 0)
					}
					identifications = append(identifications, identification)
					res[miscellaneous_] = identifications
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Image
	case Image:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Instrument
	case Instrument:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Instrument_change
	case Instrument_change:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Instrument_link
	case Instrument_link:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Interchangeable
	case Interchangeable:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Inversion
	case Inversion:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Key
	case Key:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Key_accidental
	case Key_accidental:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Key_octave
	case Key_octave:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Kind
	case Kind:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Level
	case Level:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Line_detail
	case Line_detail:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Line_width
	case Line_width:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Link
	case Link:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Listen
	case Listen:
		switch fieldname {
		// insertion point for per direct association field
		case "Assess":
			res := make(map[*Assess][]*Listen)
			for listen := range stage.Listens {
				if listen.Assess != nil {
					assess_ := listen.Assess
					var listens []*Listen
					_, ok := res[assess_]
					if ok {
						listens = res[assess_]
					} else {
						listens = make([]*Listen, 0)
					}
					listens = append(listens, listen)
					res[assess_] = listens
				}
			}
			return any(res).(map[*End][]*Start)
		case "Wait":
			res := make(map[*Wait][]*Listen)
			for listen := range stage.Listens {
				if listen.Wait != nil {
					wait_ := listen.Wait
					var listens []*Listen
					_, ok := res[wait_]
					if ok {
						listens = res[wait_]
					} else {
						listens = make([]*Listen, 0)
					}
					listens = append(listens, listen)
					res[wait_] = listens
				}
			}
			return any(res).(map[*End][]*Start)
		case "Other_listen":
			res := make(map[*Other_listening][]*Listen)
			for listen := range stage.Listens {
				if listen.Other_listen != nil {
					other_listening_ := listen.Other_listen
					var listens []*Listen
					_, ok := res[other_listening_]
					if ok {
						listens = res[other_listening_]
					} else {
						listens = make([]*Listen, 0)
					}
					listens = append(listens, listen)
					res[other_listening_] = listens
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Listening
	case Listening:
		switch fieldname {
		// insertion point for per direct association field
		case "Offset":
			res := make(map[*Offset][]*Listening)
			for listening := range stage.Listenings {
				if listening.Offset != nil {
					offset_ := listening.Offset
					var listenings []*Listening
					_, ok := res[offset_]
					if ok {
						listenings = res[offset_]
					} else {
						listenings = make([]*Listening, 0)
					}
					listenings = append(listenings, listening)
					res[offset_] = listenings
				}
			}
			return any(res).(map[*End][]*Start)
		case "Sync":
			res := make(map[*Sync][]*Listening)
			for listening := range stage.Listenings {
				if listening.Sync != nil {
					sync_ := listening.Sync
					var listenings []*Listening
					_, ok := res[sync_]
					if ok {
						listenings = res[sync_]
					} else {
						listenings = make([]*Listening, 0)
					}
					listenings = append(listenings, listening)
					res[sync_] = listenings
				}
			}
			return any(res).(map[*End][]*Start)
		case "Other_listening":
			res := make(map[*Other_listening][]*Listening)
			for listening := range stage.Listenings {
				if listening.Other_listening != nil {
					other_listening_ := listening.Other_listening
					var listenings []*Listening
					_, ok := res[other_listening_]
					if ok {
						listenings = res[other_listening_]
					} else {
						listenings = make([]*Listening, 0)
					}
					listenings = append(listenings, listening)
					res[other_listening_] = listenings
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Lyric
	case Lyric:
		switch fieldname {
		// insertion point for per direct association field
		case "End_line":
			res := make(map[*Empty][]*Lyric)
			for lyric := range stage.Lyrics {
				if lyric.End_line != nil {
					empty_ := lyric.End_line
					var lyrics []*Lyric
					_, ok := res[empty_]
					if ok {
						lyrics = res[empty_]
					} else {
						lyrics = make([]*Lyric, 0)
					}
					lyrics = append(lyrics, lyric)
					res[empty_] = lyrics
				}
			}
			return any(res).(map[*End][]*Start)
		case "End_paragraph":
			res := make(map[*Empty][]*Lyric)
			for lyric := range stage.Lyrics {
				if lyric.End_paragraph != nil {
					empty_ := lyric.End_paragraph
					var lyrics []*Lyric
					_, ok := res[empty_]
					if ok {
						lyrics = res[empty_]
					} else {
						lyrics = make([]*Lyric, 0)
					}
					lyrics = append(lyrics, lyric)
					res[empty_] = lyrics
				}
			}
			return any(res).(map[*End][]*Start)
		case "Extend":
			res := make(map[*Extend][]*Lyric)
			for lyric := range stage.Lyrics {
				if lyric.Extend != nil {
					extend_ := lyric.Extend
					var lyrics []*Lyric
					_, ok := res[extend_]
					if ok {
						lyrics = res[extend_]
					} else {
						lyrics = make([]*Lyric, 0)
					}
					lyrics = append(lyrics, lyric)
					res[extend_] = lyrics
				}
			}
			return any(res).(map[*End][]*Start)
		case "Laughing":
			res := make(map[*Empty][]*Lyric)
			for lyric := range stage.Lyrics {
				if lyric.Laughing != nil {
					empty_ := lyric.Laughing
					var lyrics []*Lyric
					_, ok := res[empty_]
					if ok {
						lyrics = res[empty_]
					} else {
						lyrics = make([]*Lyric, 0)
					}
					lyrics = append(lyrics, lyric)
					res[empty_] = lyrics
				}
			}
			return any(res).(map[*End][]*Start)
		case "Humming":
			res := make(map[*Empty][]*Lyric)
			for lyric := range stage.Lyrics {
				if lyric.Humming != nil {
					empty_ := lyric.Humming
					var lyrics []*Lyric
					_, ok := res[empty_]
					if ok {
						lyrics = res[empty_]
					} else {
						lyrics = make([]*Lyric, 0)
					}
					lyrics = append(lyrics, lyric)
					res[empty_] = lyrics
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Lyric_font
	case Lyric_font:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Lyric_language
	case Lyric_language:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Measure_layout
	case Measure_layout:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Measure_numbering
	case Measure_numbering:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Measure_repeat
	case Measure_repeat:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Measure_style
	case Measure_style:
		switch fieldname {
		// insertion point for per direct association field
		case "Multiple_rest":
			res := make(map[*Multiple_rest][]*Measure_style)
			for measure_style := range stage.Measure_styles {
				if measure_style.Multiple_rest != nil {
					multiple_rest_ := measure_style.Multiple_rest
					var measure_styles []*Measure_style
					_, ok := res[multiple_rest_]
					if ok {
						measure_styles = res[multiple_rest_]
					} else {
						measure_styles = make([]*Measure_style, 0)
					}
					measure_styles = append(measure_styles, measure_style)
					res[multiple_rest_] = measure_styles
				}
			}
			return any(res).(map[*End][]*Start)
		case "Measure_repeat":
			res := make(map[*Measure_repeat][]*Measure_style)
			for measure_style := range stage.Measure_styles {
				if measure_style.Measure_repeat != nil {
					measure_repeat_ := measure_style.Measure_repeat
					var measure_styles []*Measure_style
					_, ok := res[measure_repeat_]
					if ok {
						measure_styles = res[measure_repeat_]
					} else {
						measure_styles = make([]*Measure_style, 0)
					}
					measure_styles = append(measure_styles, measure_style)
					res[measure_repeat_] = measure_styles
				}
			}
			return any(res).(map[*End][]*Start)
		case "Beat_repeat":
			res := make(map[*Beat_repeat][]*Measure_style)
			for measure_style := range stage.Measure_styles {
				if measure_style.Beat_repeat != nil {
					beat_repeat_ := measure_style.Beat_repeat
					var measure_styles []*Measure_style
					_, ok := res[beat_repeat_]
					if ok {
						measure_styles = res[beat_repeat_]
					} else {
						measure_styles = make([]*Measure_style, 0)
					}
					measure_styles = append(measure_styles, measure_style)
					res[beat_repeat_] = measure_styles
				}
			}
			return any(res).(map[*End][]*Start)
		case "Slash":
			res := make(map[*Slash][]*Measure_style)
			for measure_style := range stage.Measure_styles {
				if measure_style.Slash != nil {
					slash_ := measure_style.Slash
					var measure_styles []*Measure_style
					_, ok := res[slash_]
					if ok {
						measure_styles = res[slash_]
					} else {
						measure_styles = make([]*Measure_style, 0)
					}
					measure_styles = append(measure_styles, measure_style)
					res[slash_] = measure_styles
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Membrane
	case Membrane:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Metal
	case Metal:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Metronome
	case Metronome:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Metronome_beam
	case Metronome_beam:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Metronome_note
	case Metronome_note:
		switch fieldname {
		// insertion point for per direct association field
		case "Metronome_tied":
			res := make(map[*Metronome_tied][]*Metronome_note)
			for metronome_note := range stage.Metronome_notes {
				if metronome_note.Metronome_tied != nil {
					metronome_tied_ := metronome_note.Metronome_tied
					var metronome_notes []*Metronome_note
					_, ok := res[metronome_tied_]
					if ok {
						metronome_notes = res[metronome_tied_]
					} else {
						metronome_notes = make([]*Metronome_note, 0)
					}
					metronome_notes = append(metronome_notes, metronome_note)
					res[metronome_tied_] = metronome_notes
				}
			}
			return any(res).(map[*End][]*Start)
		case "Metronome_tuplet":
			res := make(map[*Metronome_tuplet][]*Metronome_note)
			for metronome_note := range stage.Metronome_notes {
				if metronome_note.Metronome_tuplet != nil {
					metronome_tuplet_ := metronome_note.Metronome_tuplet
					var metronome_notes []*Metronome_note
					_, ok := res[metronome_tuplet_]
					if ok {
						metronome_notes = res[metronome_tuplet_]
					} else {
						metronome_notes = make([]*Metronome_note, 0)
					}
					metronome_notes = append(metronome_notes, metronome_note)
					res[metronome_tuplet_] = metronome_notes
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Metronome_tied
	case Metronome_tied:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Metronome_tuplet
	case Metronome_tuplet:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Midi_device
	case Midi_device:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Midi_instrument
	case Midi_instrument:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Miscellaneous
	case Miscellaneous:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Miscellaneous_field
	case Miscellaneous_field:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Mordent
	case Mordent:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Multiple_rest
	case Multiple_rest:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Name_display
	case Name_display:
		switch fieldname {
		// insertion point for per direct association field
		case "Accidental_text":
			res := make(map[*Accidental_text][]*Name_display)
			for name_display := range stage.Name_displays {
				if name_display.Accidental_text != nil {
					accidental_text_ := name_display.Accidental_text
					var name_displays []*Name_display
					_, ok := res[accidental_text_]
					if ok {
						name_displays = res[accidental_text_]
					} else {
						name_displays = make([]*Name_display, 0)
					}
					name_displays = append(name_displays, name_display)
					res[accidental_text_] = name_displays
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Non_arpeggiate
	case Non_arpeggiate:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Notations
	case Notations:
		switch fieldname {
		// insertion point for per direct association field
		case "Tied":
			res := make(map[*Tied][]*Notations)
			for notations := range stage.Notationss {
				if notations.Tied != nil {
					tied_ := notations.Tied
					var notationss []*Notations
					_, ok := res[tied_]
					if ok {
						notationss = res[tied_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[tied_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Slur":
			res := make(map[*Slur][]*Notations)
			for notations := range stage.Notationss {
				if notations.Slur != nil {
					slur_ := notations.Slur
					var notationss []*Notations
					_, ok := res[slur_]
					if ok {
						notationss = res[slur_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[slur_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Tuplet":
			res := make(map[*Tuplet][]*Notations)
			for notations := range stage.Notationss {
				if notations.Tuplet != nil {
					tuplet_ := notations.Tuplet
					var notationss []*Notations
					_, ok := res[tuplet_]
					if ok {
						notationss = res[tuplet_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[tuplet_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Glissando":
			res := make(map[*Glissando][]*Notations)
			for notations := range stage.Notationss {
				if notations.Glissando != nil {
					glissando_ := notations.Glissando
					var notationss []*Notations
					_, ok := res[glissando_]
					if ok {
						notationss = res[glissando_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[glissando_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Slide":
			res := make(map[*Slide][]*Notations)
			for notations := range stage.Notationss {
				if notations.Slide != nil {
					slide_ := notations.Slide
					var notationss []*Notations
					_, ok := res[slide_]
					if ok {
						notationss = res[slide_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[slide_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Ornaments":
			res := make(map[*Ornaments][]*Notations)
			for notations := range stage.Notationss {
				if notations.Ornaments != nil {
					ornaments_ := notations.Ornaments
					var notationss []*Notations
					_, ok := res[ornaments_]
					if ok {
						notationss = res[ornaments_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[ornaments_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Technical":
			res := make(map[*Technical][]*Notations)
			for notations := range stage.Notationss {
				if notations.Technical != nil {
					technical_ := notations.Technical
					var notationss []*Notations
					_, ok := res[technical_]
					if ok {
						notationss = res[technical_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[technical_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Articulations":
			res := make(map[*Articulations][]*Notations)
			for notations := range stage.Notationss {
				if notations.Articulations != nil {
					articulations_ := notations.Articulations
					var notationss []*Notations
					_, ok := res[articulations_]
					if ok {
						notationss = res[articulations_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[articulations_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Dynamics":
			res := make(map[*Dynamics][]*Notations)
			for notations := range stage.Notationss {
				if notations.Dynamics != nil {
					dynamics_ := notations.Dynamics
					var notationss []*Notations
					_, ok := res[dynamics_]
					if ok {
						notationss = res[dynamics_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[dynamics_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Fermata":
			res := make(map[*Fermata][]*Notations)
			for notations := range stage.Notationss {
				if notations.Fermata != nil {
					fermata_ := notations.Fermata
					var notationss []*Notations
					_, ok := res[fermata_]
					if ok {
						notationss = res[fermata_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[fermata_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Arpeggiate":
			res := make(map[*Arpeggiate][]*Notations)
			for notations := range stage.Notationss {
				if notations.Arpeggiate != nil {
					arpeggiate_ := notations.Arpeggiate
					var notationss []*Notations
					_, ok := res[arpeggiate_]
					if ok {
						notationss = res[arpeggiate_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[arpeggiate_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Non_arpeggiate":
			res := make(map[*Non_arpeggiate][]*Notations)
			for notations := range stage.Notationss {
				if notations.Non_arpeggiate != nil {
					non_arpeggiate_ := notations.Non_arpeggiate
					var notationss []*Notations
					_, ok := res[non_arpeggiate_]
					if ok {
						notationss = res[non_arpeggiate_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[non_arpeggiate_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Accidental_mark":
			res := make(map[*Accidental_mark][]*Notations)
			for notations := range stage.Notationss {
				if notations.Accidental_mark != nil {
					accidental_mark_ := notations.Accidental_mark
					var notationss []*Notations
					_, ok := res[accidental_mark_]
					if ok {
						notationss = res[accidental_mark_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[accidental_mark_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Other_notation":
			res := make(map[*Other_notation][]*Notations)
			for notations := range stage.Notationss {
				if notations.Other_notation != nil {
					other_notation_ := notations.Other_notation
					var notationss []*Notations
					_, ok := res[other_notation_]
					if ok {
						notationss = res[other_notation_]
					} else {
						notationss = make([]*Notations, 0)
					}
					notationss = append(notationss, notations)
					res[other_notation_] = notationss
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Note
	case Note:
		switch fieldname {
		// insertion point for per direct association field
		case "Type_":
			res := make(map[*Note_type][]*Note)
			for note := range stage.Notes {
				if note.Type_ != nil {
					note_type_ := note.Type_
					var notes []*Note
					_, ok := res[note_type_]
					if ok {
						notes = res[note_type_]
					} else {
						notes = make([]*Note, 0)
					}
					notes = append(notes, note)
					res[note_type_] = notes
				}
			}
			return any(res).(map[*End][]*Start)
		case "Accidental":
			res := make(map[*Accidental][]*Note)
			for note := range stage.Notes {
				if note.Accidental != nil {
					accidental_ := note.Accidental
					var notes []*Note
					_, ok := res[accidental_]
					if ok {
						notes = res[accidental_]
					} else {
						notes = make([]*Note, 0)
					}
					notes = append(notes, note)
					res[accidental_] = notes
				}
			}
			return any(res).(map[*End][]*Start)
		case "Time_modification":
			res := make(map[*Time_modification][]*Note)
			for note := range stage.Notes {
				if note.Time_modification != nil {
					time_modification_ := note.Time_modification
					var notes []*Note
					_, ok := res[time_modification_]
					if ok {
						notes = res[time_modification_]
					} else {
						notes = make([]*Note, 0)
					}
					notes = append(notes, note)
					res[time_modification_] = notes
				}
			}
			return any(res).(map[*End][]*Start)
		case "Stem":
			res := make(map[*Stem][]*Note)
			for note := range stage.Notes {
				if note.Stem != nil {
					stem_ := note.Stem
					var notes []*Note
					_, ok := res[stem_]
					if ok {
						notes = res[stem_]
					} else {
						notes = make([]*Note, 0)
					}
					notes = append(notes, note)
					res[stem_] = notes
				}
			}
			return any(res).(map[*End][]*Start)
		case "Notehead":
			res := make(map[*Notehead][]*Note)
			for note := range stage.Notes {
				if note.Notehead != nil {
					notehead_ := note.Notehead
					var notes []*Note
					_, ok := res[notehead_]
					if ok {
						notes = res[notehead_]
					} else {
						notes = make([]*Note, 0)
					}
					notes = append(notes, note)
					res[notehead_] = notes
				}
			}
			return any(res).(map[*End][]*Start)
		case "Notehead_text":
			res := make(map[*Notehead_text][]*Note)
			for note := range stage.Notes {
				if note.Notehead_text != nil {
					notehead_text_ := note.Notehead_text
					var notes []*Note
					_, ok := res[notehead_text_]
					if ok {
						notes = res[notehead_text_]
					} else {
						notes = make([]*Note, 0)
					}
					notes = append(notes, note)
					res[notehead_text_] = notes
				}
			}
			return any(res).(map[*End][]*Start)
		case "Beam":
			res := make(map[*Beam][]*Note)
			for note := range stage.Notes {
				if note.Beam != nil {
					beam_ := note.Beam
					var notes []*Note
					_, ok := res[beam_]
					if ok {
						notes = res[beam_]
					} else {
						notes = make([]*Note, 0)
					}
					notes = append(notes, note)
					res[beam_] = notes
				}
			}
			return any(res).(map[*End][]*Start)
		case "Play":
			res := make(map[*Play][]*Note)
			for note := range stage.Notes {
				if note.Play != nil {
					play_ := note.Play
					var notes []*Note
					_, ok := res[play_]
					if ok {
						notes = res[play_]
					} else {
						notes = make([]*Note, 0)
					}
					notes = append(notes, note)
					res[play_] = notes
				}
			}
			return any(res).(map[*End][]*Start)
		case "Listen":
			res := make(map[*Listen][]*Note)
			for note := range stage.Notes {
				if note.Listen != nil {
					listen_ := note.Listen
					var notes []*Note
					_, ok := res[listen_]
					if ok {
						notes = res[listen_]
					} else {
						notes = make([]*Note, 0)
					}
					notes = append(notes, note)
					res[listen_] = notes
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Note_size
	case Note_size:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Note_type
	case Note_type:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Notehead
	case Notehead:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Notehead_text
	case Notehead_text:
		switch fieldname {
		// insertion point for per direct association field
		case "Accidental_text":
			res := make(map[*Accidental_text][]*Notehead_text)
			for notehead_text := range stage.Notehead_texts {
				if notehead_text.Accidental_text != nil {
					accidental_text_ := notehead_text.Accidental_text
					var notehead_texts []*Notehead_text
					_, ok := res[accidental_text_]
					if ok {
						notehead_texts = res[accidental_text_]
					} else {
						notehead_texts = make([]*Notehead_text, 0)
					}
					notehead_texts = append(notehead_texts, notehead_text)
					res[accidental_text_] = notehead_texts
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Numeral
	case Numeral:
		switch fieldname {
		// insertion point for per direct association field
		case "Numeral_root":
			res := make(map[*Numeral_root][]*Numeral)
			for numeral := range stage.Numerals {
				if numeral.Numeral_root != nil {
					numeral_root_ := numeral.Numeral_root
					var numerals []*Numeral
					_, ok := res[numeral_root_]
					if ok {
						numerals = res[numeral_root_]
					} else {
						numerals = make([]*Numeral, 0)
					}
					numerals = append(numerals, numeral)
					res[numeral_root_] = numerals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Numeral_alter":
			res := make(map[*Harmony_alter][]*Numeral)
			for numeral := range stage.Numerals {
				if numeral.Numeral_alter != nil {
					harmony_alter_ := numeral.Numeral_alter
					var numerals []*Numeral
					_, ok := res[harmony_alter_]
					if ok {
						numerals = res[harmony_alter_]
					} else {
						numerals = make([]*Numeral, 0)
					}
					numerals = append(numerals, numeral)
					res[harmony_alter_] = numerals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Numeral_key":
			res := make(map[*Numeral_key][]*Numeral)
			for numeral := range stage.Numerals {
				if numeral.Numeral_key != nil {
					numeral_key_ := numeral.Numeral_key
					var numerals []*Numeral
					_, ok := res[numeral_key_]
					if ok {
						numerals = res[numeral_key_]
					} else {
						numerals = make([]*Numeral, 0)
					}
					numerals = append(numerals, numeral)
					res[numeral_key_] = numerals
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Numeral_key
	case Numeral_key:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Numeral_root
	case Numeral_root:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Octave_shift
	case Octave_shift:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Offset
	case Offset:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Opus
	case Opus:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Ornaments
	case Ornaments:
		switch fieldname {
		// insertion point for per direct association field
		case "Trill_mark":
			res := make(map[*Empty_trill_sound][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Trill_mark != nil {
					empty_trill_sound_ := ornaments.Trill_mark
					var ornamentss []*Ornaments
					_, ok := res[empty_trill_sound_]
					if ok {
						ornamentss = res[empty_trill_sound_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[empty_trill_sound_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Turn":
			res := make(map[*Horizontal_turn][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Turn != nil {
					horizontal_turn_ := ornaments.Turn
					var ornamentss []*Ornaments
					_, ok := res[horizontal_turn_]
					if ok {
						ornamentss = res[horizontal_turn_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[horizontal_turn_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Delayed_turn":
			res := make(map[*Horizontal_turn][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Delayed_turn != nil {
					horizontal_turn_ := ornaments.Delayed_turn
					var ornamentss []*Ornaments
					_, ok := res[horizontal_turn_]
					if ok {
						ornamentss = res[horizontal_turn_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[horizontal_turn_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Inverted_turn":
			res := make(map[*Horizontal_turn][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Inverted_turn != nil {
					horizontal_turn_ := ornaments.Inverted_turn
					var ornamentss []*Ornaments
					_, ok := res[horizontal_turn_]
					if ok {
						ornamentss = res[horizontal_turn_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[horizontal_turn_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Delayed_inverted_turn":
			res := make(map[*Horizontal_turn][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Delayed_inverted_turn != nil {
					horizontal_turn_ := ornaments.Delayed_inverted_turn
					var ornamentss []*Ornaments
					_, ok := res[horizontal_turn_]
					if ok {
						ornamentss = res[horizontal_turn_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[horizontal_turn_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Vertical_turn":
			res := make(map[*Empty_trill_sound][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Vertical_turn != nil {
					empty_trill_sound_ := ornaments.Vertical_turn
					var ornamentss []*Ornaments
					_, ok := res[empty_trill_sound_]
					if ok {
						ornamentss = res[empty_trill_sound_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[empty_trill_sound_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Inverted_vertical_turn":
			res := make(map[*Empty_trill_sound][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Inverted_vertical_turn != nil {
					empty_trill_sound_ := ornaments.Inverted_vertical_turn
					var ornamentss []*Ornaments
					_, ok := res[empty_trill_sound_]
					if ok {
						ornamentss = res[empty_trill_sound_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[empty_trill_sound_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Shake":
			res := make(map[*Empty_trill_sound][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Shake != nil {
					empty_trill_sound_ := ornaments.Shake
					var ornamentss []*Ornaments
					_, ok := res[empty_trill_sound_]
					if ok {
						ornamentss = res[empty_trill_sound_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[empty_trill_sound_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Wavy_line":
			res := make(map[*Wavy_line][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Wavy_line != nil {
					wavy_line_ := ornaments.Wavy_line
					var ornamentss []*Ornaments
					_, ok := res[wavy_line_]
					if ok {
						ornamentss = res[wavy_line_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[wavy_line_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Mordent":
			res := make(map[*Mordent][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Mordent != nil {
					mordent_ := ornaments.Mordent
					var ornamentss []*Ornaments
					_, ok := res[mordent_]
					if ok {
						ornamentss = res[mordent_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[mordent_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Inverted_mordent":
			res := make(map[*Mordent][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Inverted_mordent != nil {
					mordent_ := ornaments.Inverted_mordent
					var ornamentss []*Ornaments
					_, ok := res[mordent_]
					if ok {
						ornamentss = res[mordent_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[mordent_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Schleifer":
			res := make(map[*Empty_placement][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Schleifer != nil {
					empty_placement_ := ornaments.Schleifer
					var ornamentss []*Ornaments
					_, ok := res[empty_placement_]
					if ok {
						ornamentss = res[empty_placement_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[empty_placement_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Tremolo":
			res := make(map[*Tremolo][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Tremolo != nil {
					tremolo_ := ornaments.Tremolo
					var ornamentss []*Ornaments
					_, ok := res[tremolo_]
					if ok {
						ornamentss = res[tremolo_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[tremolo_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Haydn":
			res := make(map[*Empty_trill_sound][]*Ornaments)
			for ornaments := range stage.Ornamentss {
				if ornaments.Haydn != nil {
					empty_trill_sound_ := ornaments.Haydn
					var ornamentss []*Ornaments
					_, ok := res[empty_trill_sound_]
					if ok {
						ornamentss = res[empty_trill_sound_]
					} else {
						ornamentss = make([]*Ornaments, 0)
					}
					ornamentss = append(ornamentss, ornaments)
					res[empty_trill_sound_] = ornamentss
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Other_appearance
	case Other_appearance:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Other_listening
	case Other_listening:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Other_notation
	case Other_notation:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Other_play
	case Other_play:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Page_layout
	case Page_layout:
		switch fieldname {
		// insertion point for per direct association field
		case "Page_margins":
			res := make(map[*Page_margins][]*Page_layout)
			for page_layout := range stage.Page_layouts {
				if page_layout.Page_margins != nil {
					page_margins_ := page_layout.Page_margins
					var page_layouts []*Page_layout
					_, ok := res[page_margins_]
					if ok {
						page_layouts = res[page_margins_]
					} else {
						page_layouts = make([]*Page_layout, 0)
					}
					page_layouts = append(page_layouts, page_layout)
					res[page_margins_] = page_layouts
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Page_margins
	case Page_margins:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Part_clef
	case Part_clef:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Part_group
	case Part_group:
		switch fieldname {
		// insertion point for per direct association field
		case "Group_name_display":
			res := make(map[*Name_display][]*Part_group)
			for part_group := range stage.Part_groups {
				if part_group.Group_name_display != nil {
					name_display_ := part_group.Group_name_display
					var part_groups []*Part_group
					_, ok := res[name_display_]
					if ok {
						part_groups = res[name_display_]
					} else {
						part_groups = make([]*Part_group, 0)
					}
					part_groups = append(part_groups, part_group)
					res[name_display_] = part_groups
				}
			}
			return any(res).(map[*End][]*Start)
		case "Group_abbreviation_display":
			res := make(map[*Name_display][]*Part_group)
			for part_group := range stage.Part_groups {
				if part_group.Group_abbreviation_display != nil {
					name_display_ := part_group.Group_abbreviation_display
					var part_groups []*Part_group
					_, ok := res[name_display_]
					if ok {
						part_groups = res[name_display_]
					} else {
						part_groups = make([]*Part_group, 0)
					}
					part_groups = append(part_groups, part_group)
					res[name_display_] = part_groups
				}
			}
			return any(res).(map[*End][]*Start)
		case "Group_symbol":
			res := make(map[*Group_symbol][]*Part_group)
			for part_group := range stage.Part_groups {
				if part_group.Group_symbol != nil {
					group_symbol_ := part_group.Group_symbol
					var part_groups []*Part_group
					_, ok := res[group_symbol_]
					if ok {
						part_groups = res[group_symbol_]
					} else {
						part_groups = make([]*Part_group, 0)
					}
					part_groups = append(part_groups, part_group)
					res[group_symbol_] = part_groups
				}
			}
			return any(res).(map[*End][]*Start)
		case "Group_barline":
			res := make(map[*Group_barline][]*Part_group)
			for part_group := range stage.Part_groups {
				if part_group.Group_barline != nil {
					group_barline_ := part_group.Group_barline
					var part_groups []*Part_group
					_, ok := res[group_barline_]
					if ok {
						part_groups = res[group_barline_]
					} else {
						part_groups = make([]*Part_group, 0)
					}
					part_groups = append(part_groups, part_group)
					res[group_barline_] = part_groups
				}
			}
			return any(res).(map[*End][]*Start)
		case "Group_time":
			res := make(map[*Empty][]*Part_group)
			for part_group := range stage.Part_groups {
				if part_group.Group_time != nil {
					empty_ := part_group.Group_time
					var part_groups []*Part_group
					_, ok := res[empty_]
					if ok {
						part_groups = res[empty_]
					} else {
						part_groups = make([]*Part_group, 0)
					}
					part_groups = append(part_groups, part_group)
					res[empty_] = part_groups
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Part_link
	case Part_link:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Part_list
	case Part_list:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Part_symbol
	case Part_symbol:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Part_transpose
	case Part_transpose:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Pedal
	case Pedal:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Pedal_tuning
	case Pedal_tuning:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Percussion
	case Percussion:
		switch fieldname {
		// insertion point for per direct association field
		case "Glass":
			res := make(map[*Glass][]*Percussion)
			for percussion := range stage.Percussions {
				if percussion.Glass != nil {
					glass_ := percussion.Glass
					var percussions []*Percussion
					_, ok := res[glass_]
					if ok {
						percussions = res[glass_]
					} else {
						percussions = make([]*Percussion, 0)
					}
					percussions = append(percussions, percussion)
					res[glass_] = percussions
				}
			}
			return any(res).(map[*End][]*Start)
		case "Metal":
			res := make(map[*Metal][]*Percussion)
			for percussion := range stage.Percussions {
				if percussion.Metal != nil {
					metal_ := percussion.Metal
					var percussions []*Percussion
					_, ok := res[metal_]
					if ok {
						percussions = res[metal_]
					} else {
						percussions = make([]*Percussion, 0)
					}
					percussions = append(percussions, percussion)
					res[metal_] = percussions
				}
			}
			return any(res).(map[*End][]*Start)
		case "Wood":
			res := make(map[*Wood][]*Percussion)
			for percussion := range stage.Percussions {
				if percussion.Wood != nil {
					wood_ := percussion.Wood
					var percussions []*Percussion
					_, ok := res[wood_]
					if ok {
						percussions = res[wood_]
					} else {
						percussions = make([]*Percussion, 0)
					}
					percussions = append(percussions, percussion)
					res[wood_] = percussions
				}
			}
			return any(res).(map[*End][]*Start)
		case "Pitched":
			res := make(map[*Pitched][]*Percussion)
			for percussion := range stage.Percussions {
				if percussion.Pitched != nil {
					pitched_ := percussion.Pitched
					var percussions []*Percussion
					_, ok := res[pitched_]
					if ok {
						percussions = res[pitched_]
					} else {
						percussions = make([]*Percussion, 0)
					}
					percussions = append(percussions, percussion)
					res[pitched_] = percussions
				}
			}
			return any(res).(map[*End][]*Start)
		case "Membrane":
			res := make(map[*Membrane][]*Percussion)
			for percussion := range stage.Percussions {
				if percussion.Membrane != nil {
					membrane_ := percussion.Membrane
					var percussions []*Percussion
					_, ok := res[membrane_]
					if ok {
						percussions = res[membrane_]
					} else {
						percussions = make([]*Percussion, 0)
					}
					percussions = append(percussions, percussion)
					res[membrane_] = percussions
				}
			}
			return any(res).(map[*End][]*Start)
		case "Effect":
			res := make(map[*Effect][]*Percussion)
			for percussion := range stage.Percussions {
				if percussion.Effect != nil {
					effect_ := percussion.Effect
					var percussions []*Percussion
					_, ok := res[effect_]
					if ok {
						percussions = res[effect_]
					} else {
						percussions = make([]*Percussion, 0)
					}
					percussions = append(percussions, percussion)
					res[effect_] = percussions
				}
			}
			return any(res).(map[*End][]*Start)
		case "Timpani":
			res := make(map[*Timpani][]*Percussion)
			for percussion := range stage.Percussions {
				if percussion.Timpani != nil {
					timpani_ := percussion.Timpani
					var percussions []*Percussion
					_, ok := res[timpani_]
					if ok {
						percussions = res[timpani_]
					} else {
						percussions = make([]*Percussion, 0)
					}
					percussions = append(percussions, percussion)
					res[timpani_] = percussions
				}
			}
			return any(res).(map[*End][]*Start)
		case "Beater":
			res := make(map[*Beater][]*Percussion)
			for percussion := range stage.Percussions {
				if percussion.Beater != nil {
					beater_ := percussion.Beater
					var percussions []*Percussion
					_, ok := res[beater_]
					if ok {
						percussions = res[beater_]
					} else {
						percussions = make([]*Percussion, 0)
					}
					percussions = append(percussions, percussion)
					res[beater_] = percussions
				}
			}
			return any(res).(map[*End][]*Start)
		case "Stick":
			res := make(map[*Stick][]*Percussion)
			for percussion := range stage.Percussions {
				if percussion.Stick != nil {
					stick_ := percussion.Stick
					var percussions []*Percussion
					_, ok := res[stick_]
					if ok {
						percussions = res[stick_]
					} else {
						percussions = make([]*Percussion, 0)
					}
					percussions = append(percussions, percussion)
					res[stick_] = percussions
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Pitch
	case Pitch:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Pitched
	case Pitched:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Play
	case Play:
		switch fieldname {
		// insertion point for per direct association field
		case "Other_play":
			res := make(map[*Other_play][]*Play)
			for play := range stage.Plays {
				if play.Other_play != nil {
					other_play_ := play.Other_play
					var plays []*Play
					_, ok := res[other_play_]
					if ok {
						plays = res[other_play_]
					} else {
						plays = make([]*Play, 0)
					}
					plays = append(plays, play)
					res[other_play_] = plays
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Player
	case Player:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Principal_voice
	case Principal_voice:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Print
	case Print:
		switch fieldname {
		// insertion point for per direct association field
		case "Measure_layout":
			res := make(map[*Measure_layout][]*Print)
			for print := range stage.Prints {
				if print.Measure_layout != nil {
					measure_layout_ := print.Measure_layout
					var prints []*Print
					_, ok := res[measure_layout_]
					if ok {
						prints = res[measure_layout_]
					} else {
						prints = make([]*Print, 0)
					}
					prints = append(prints, print)
					res[measure_layout_] = prints
				}
			}
			return any(res).(map[*End][]*Start)
		case "Measure_numbering":
			res := make(map[*Measure_numbering][]*Print)
			for print := range stage.Prints {
				if print.Measure_numbering != nil {
					measure_numbering_ := print.Measure_numbering
					var prints []*Print
					_, ok := res[measure_numbering_]
					if ok {
						prints = res[measure_numbering_]
					} else {
						prints = make([]*Print, 0)
					}
					prints = append(prints, print)
					res[measure_numbering_] = prints
				}
			}
			return any(res).(map[*End][]*Start)
		case "Part_name_display":
			res := make(map[*Name_display][]*Print)
			for print := range stage.Prints {
				if print.Part_name_display != nil {
					name_display_ := print.Part_name_display
					var prints []*Print
					_, ok := res[name_display_]
					if ok {
						prints = res[name_display_]
					} else {
						prints = make([]*Print, 0)
					}
					prints = append(prints, print)
					res[name_display_] = prints
				}
			}
			return any(res).(map[*End][]*Start)
		case "Part_abbreviation_display":
			res := make(map[*Name_display][]*Print)
			for print := range stage.Prints {
				if print.Part_abbreviation_display != nil {
					name_display_ := print.Part_abbreviation_display
					var prints []*Print
					_, ok := res[name_display_]
					if ok {
						prints = res[name_display_]
					} else {
						prints = make([]*Print, 0)
					}
					prints = append(prints, print)
					res[name_display_] = prints
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Release
	case Release:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Repeat
	case Repeat:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Rest
	case Rest:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Root
	case Root:
		switch fieldname {
		// insertion point for per direct association field
		case "Root_step":
			res := make(map[*Root_step][]*Root)
			for root := range stage.Roots {
				if root.Root_step != nil {
					root_step_ := root.Root_step
					var roots []*Root
					_, ok := res[root_step_]
					if ok {
						roots = res[root_step_]
					} else {
						roots = make([]*Root, 0)
					}
					roots = append(roots, root)
					res[root_step_] = roots
				}
			}
			return any(res).(map[*End][]*Start)
		case "Root_alter":
			res := make(map[*Harmony_alter][]*Root)
			for root := range stage.Roots {
				if root.Root_alter != nil {
					harmony_alter_ := root.Root_alter
					var roots []*Root
					_, ok := res[harmony_alter_]
					if ok {
						roots = res[harmony_alter_]
					} else {
						roots = make([]*Root, 0)
					}
					roots = append(roots, root)
					res[harmony_alter_] = roots
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Root_step
	case Root_step:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Scaling
	case Scaling:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Scordatura
	case Scordatura:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Score_instrument
	case Score_instrument:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Score_part
	case Score_part:
		switch fieldname {
		// insertion point for per direct association field
		case "Identification":
			res := make(map[*Identification][]*Score_part)
			for score_part := range stage.Score_parts {
				if score_part.Identification != nil {
					identification_ := score_part.Identification
					var score_parts []*Score_part
					_, ok := res[identification_]
					if ok {
						score_parts = res[identification_]
					} else {
						score_parts = make([]*Score_part, 0)
					}
					score_parts = append(score_parts, score_part)
					res[identification_] = score_parts
				}
			}
			return any(res).(map[*End][]*Start)
		case "Part_name_display":
			res := make(map[*Name_display][]*Score_part)
			for score_part := range stage.Score_parts {
				if score_part.Part_name_display != nil {
					name_display_ := score_part.Part_name_display
					var score_parts []*Score_part
					_, ok := res[name_display_]
					if ok {
						score_parts = res[name_display_]
					} else {
						score_parts = make([]*Score_part, 0)
					}
					score_parts = append(score_parts, score_part)
					res[name_display_] = score_parts
				}
			}
			return any(res).(map[*End][]*Start)
		case "Part_abbreviation_display":
			res := make(map[*Name_display][]*Score_part)
			for score_part := range stage.Score_parts {
				if score_part.Part_abbreviation_display != nil {
					name_display_ := score_part.Part_abbreviation_display
					var score_parts []*Score_part
					_, ok := res[name_display_]
					if ok {
						score_parts = res[name_display_]
					} else {
						score_parts = make([]*Score_part, 0)
					}
					score_parts = append(score_parts, score_part)
					res[name_display_] = score_parts
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Score_partwise
	case Score_partwise:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Score_timewise
	case Score_timewise:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Segno
	case Segno:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Slash
	case Slash:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Slide
	case Slide:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Slur
	case Slur:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Sound
	case Sound:
		switch fieldname {
		// insertion point for per direct association field
		case "Swing":
			res := make(map[*Swing][]*Sound)
			for sound := range stage.Sounds {
				if sound.Swing != nil {
					swing_ := sound.Swing
					var sounds []*Sound
					_, ok := res[swing_]
					if ok {
						sounds = res[swing_]
					} else {
						sounds = make([]*Sound, 0)
					}
					sounds = append(sounds, sound)
					res[swing_] = sounds
				}
			}
			return any(res).(map[*End][]*Start)
		case "Offset":
			res := make(map[*Offset][]*Sound)
			for sound := range stage.Sounds {
				if sound.Offset != nil {
					offset_ := sound.Offset
					var sounds []*Sound
					_, ok := res[offset_]
					if ok {
						sounds = res[offset_]
					} else {
						sounds = make([]*Sound, 0)
					}
					sounds = append(sounds, sound)
					res[offset_] = sounds
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Staff_details
	case Staff_details:
		switch fieldname {
		// insertion point for per direct association field
		case "Staff_size":
			res := make(map[*Staff_size][]*Staff_details)
			for staff_details := range stage.Staff_detailss {
				if staff_details.Staff_size != nil {
					staff_size_ := staff_details.Staff_size
					var staff_detailss []*Staff_details
					_, ok := res[staff_size_]
					if ok {
						staff_detailss = res[staff_size_]
					} else {
						staff_detailss = make([]*Staff_details, 0)
					}
					staff_detailss = append(staff_detailss, staff_details)
					res[staff_size_] = staff_detailss
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Staff_divide
	case Staff_divide:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Staff_layout
	case Staff_layout:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Staff_size
	case Staff_size:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Staff_tuning
	case Staff_tuning:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Stem
	case Stem:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Stick
	case Stick:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of String_mute
	case String_mute:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Strong_accent
	case Strong_accent:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Supports
	case Supports:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Swing
	case Swing:
		switch fieldname {
		// insertion point for per direct association field
		case "Straight":
			res := make(map[*Empty][]*Swing)
			for swing := range stage.Swings {
				if swing.Straight != nil {
					empty_ := swing.Straight
					var swings []*Swing
					_, ok := res[empty_]
					if ok {
						swings = res[empty_]
					} else {
						swings = make([]*Swing, 0)
					}
					swings = append(swings, swing)
					res[empty_] = swings
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Sync
	case Sync:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of System_dividers
	case System_dividers:
		switch fieldname {
		// insertion point for per direct association field
		case "Left_divider":
			res := make(map[*Empty_print_object_style_align][]*System_dividers)
			for system_dividers := range stage.System_dividerss {
				if system_dividers.Left_divider != nil {
					empty_print_object_style_align_ := system_dividers.Left_divider
					var system_dividerss []*System_dividers
					_, ok := res[empty_print_object_style_align_]
					if ok {
						system_dividerss = res[empty_print_object_style_align_]
					} else {
						system_dividerss = make([]*System_dividers, 0)
					}
					system_dividerss = append(system_dividerss, system_dividers)
					res[empty_print_object_style_align_] = system_dividerss
				}
			}
			return any(res).(map[*End][]*Start)
		case "Right_divider":
			res := make(map[*Empty_print_object_style_align][]*System_dividers)
			for system_dividers := range stage.System_dividerss {
				if system_dividers.Right_divider != nil {
					empty_print_object_style_align_ := system_dividers.Right_divider
					var system_dividerss []*System_dividers
					_, ok := res[empty_print_object_style_align_]
					if ok {
						system_dividerss = res[empty_print_object_style_align_]
					} else {
						system_dividerss = make([]*System_dividers, 0)
					}
					system_dividerss = append(system_dividerss, system_dividers)
					res[empty_print_object_style_align_] = system_dividerss
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of System_layout
	case System_layout:
		switch fieldname {
		// insertion point for per direct association field
		case "System_margins":
			res := make(map[*System_margins][]*System_layout)
			for system_layout := range stage.System_layouts {
				if system_layout.System_margins != nil {
					system_margins_ := system_layout.System_margins
					var system_layouts []*System_layout
					_, ok := res[system_margins_]
					if ok {
						system_layouts = res[system_margins_]
					} else {
						system_layouts = make([]*System_layout, 0)
					}
					system_layouts = append(system_layouts, system_layout)
					res[system_margins_] = system_layouts
				}
			}
			return any(res).(map[*End][]*Start)
		case "System_dividers":
			res := make(map[*System_dividers][]*System_layout)
			for system_layout := range stage.System_layouts {
				if system_layout.System_dividers != nil {
					system_dividers_ := system_layout.System_dividers
					var system_layouts []*System_layout
					_, ok := res[system_dividers_]
					if ok {
						system_layouts = res[system_dividers_]
					} else {
						system_layouts = make([]*System_layout, 0)
					}
					system_layouts = append(system_layouts, system_layout)
					res[system_dividers_] = system_layouts
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of System_margins
	case System_margins:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tap
	case Tap:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Technical
	case Technical:
		switch fieldname {
		// insertion point for per direct association field
		case "Up_bow":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Up_bow != nil {
					empty_placement_ := technical.Up_bow
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Down_bow":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Down_bow != nil {
					empty_placement_ := technical.Down_bow
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Harmonic":
			res := make(map[*Harmonic][]*Technical)
			for technical := range stage.Technicals {
				if technical.Harmonic != nil {
					harmonic_ := technical.Harmonic
					var technicals []*Technical
					_, ok := res[harmonic_]
					if ok {
						technicals = res[harmonic_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[harmonic_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Open_string":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Open_string != nil {
					empty_placement_ := technical.Open_string
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Thumb_position":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Thumb_position != nil {
					empty_placement_ := technical.Thumb_position
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Fingering":
			res := make(map[*Fingering][]*Technical)
			for technical := range stage.Technicals {
				if technical.Fingering != nil {
					fingering_ := technical.Fingering
					var technicals []*Technical
					_, ok := res[fingering_]
					if ok {
						technicals = res[fingering_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[fingering_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Double_tongue":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Double_tongue != nil {
					empty_placement_ := technical.Double_tongue
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Triple_tongue":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Triple_tongue != nil {
					empty_placement_ := technical.Triple_tongue
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Stopped":
			res := make(map[*Empty_placement_smufl][]*Technical)
			for technical := range stage.Technicals {
				if technical.Stopped != nil {
					empty_placement_smufl_ := technical.Stopped
					var technicals []*Technical
					_, ok := res[empty_placement_smufl_]
					if ok {
						technicals = res[empty_placement_smufl_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_smufl_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Snap_pizzicato":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Snap_pizzicato != nil {
					empty_placement_ := technical.Snap_pizzicato
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Fret":
			res := make(map[*Fret][]*Technical)
			for technical := range stage.Technicals {
				if technical.Fret != nil {
					fret_ := technical.Fret
					var technicals []*Technical
					_, ok := res[fret_]
					if ok {
						technicals = res[fret_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[fret_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Hammer_on":
			res := make(map[*Hammer_on_pull_off][]*Technical)
			for technical := range stage.Technicals {
				if technical.Hammer_on != nil {
					hammer_on_pull_off_ := technical.Hammer_on
					var technicals []*Technical
					_, ok := res[hammer_on_pull_off_]
					if ok {
						technicals = res[hammer_on_pull_off_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[hammer_on_pull_off_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Pull_off":
			res := make(map[*Hammer_on_pull_off][]*Technical)
			for technical := range stage.Technicals {
				if technical.Pull_off != nil {
					hammer_on_pull_off_ := technical.Pull_off
					var technicals []*Technical
					_, ok := res[hammer_on_pull_off_]
					if ok {
						technicals = res[hammer_on_pull_off_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[hammer_on_pull_off_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Bend":
			res := make(map[*Bend][]*Technical)
			for technical := range stage.Technicals {
				if technical.Bend != nil {
					bend_ := technical.Bend
					var technicals []*Technical
					_, ok := res[bend_]
					if ok {
						technicals = res[bend_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[bend_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Tap":
			res := make(map[*Tap][]*Technical)
			for technical := range stage.Technicals {
				if technical.Tap != nil {
					tap_ := technical.Tap
					var technicals []*Technical
					_, ok := res[tap_]
					if ok {
						technicals = res[tap_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[tap_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Heel":
			res := make(map[*Heel_toe][]*Technical)
			for technical := range stage.Technicals {
				if technical.Heel != nil {
					heel_toe_ := technical.Heel
					var technicals []*Technical
					_, ok := res[heel_toe_]
					if ok {
						technicals = res[heel_toe_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[heel_toe_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Toe":
			res := make(map[*Heel_toe][]*Technical)
			for technical := range stage.Technicals {
				if technical.Toe != nil {
					heel_toe_ := technical.Toe
					var technicals []*Technical
					_, ok := res[heel_toe_]
					if ok {
						technicals = res[heel_toe_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[heel_toe_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Fingernails":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Fingernails != nil {
					empty_placement_ := technical.Fingernails
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Hole":
			res := make(map[*Hole][]*Technical)
			for technical := range stage.Technicals {
				if technical.Hole != nil {
					hole_ := technical.Hole
					var technicals []*Technical
					_, ok := res[hole_]
					if ok {
						technicals = res[hole_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[hole_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Arrow":
			res := make(map[*Arrow][]*Technical)
			for technical := range stage.Technicals {
				if technical.Arrow != nil {
					arrow_ := technical.Arrow
					var technicals []*Technical
					_, ok := res[arrow_]
					if ok {
						technicals = res[arrow_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[arrow_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Handbell":
			res := make(map[*Handbell][]*Technical)
			for technical := range stage.Technicals {
				if technical.Handbell != nil {
					handbell_ := technical.Handbell
					var technicals []*Technical
					_, ok := res[handbell_]
					if ok {
						technicals = res[handbell_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[handbell_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Brass_bend":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Brass_bend != nil {
					empty_placement_ := technical.Brass_bend
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Flip":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Flip != nil {
					empty_placement_ := technical.Flip
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Smear":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Smear != nil {
					empty_placement_ := technical.Smear
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Open":
			res := make(map[*Empty_placement_smufl][]*Technical)
			for technical := range stage.Technicals {
				if technical.Open != nil {
					empty_placement_smufl_ := technical.Open
					var technicals []*Technical
					_, ok := res[empty_placement_smufl_]
					if ok {
						technicals = res[empty_placement_smufl_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_smufl_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Half_muted":
			res := make(map[*Empty_placement_smufl][]*Technical)
			for technical := range stage.Technicals {
				if technical.Half_muted != nil {
					empty_placement_smufl_ := technical.Half_muted
					var technicals []*Technical
					_, ok := res[empty_placement_smufl_]
					if ok {
						technicals = res[empty_placement_smufl_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_smufl_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Harmon_mute":
			res := make(map[*Harmon_mute][]*Technical)
			for technical := range stage.Technicals {
				if technical.Harmon_mute != nil {
					harmon_mute_ := technical.Harmon_mute
					var technicals []*Technical
					_, ok := res[harmon_mute_]
					if ok {
						technicals = res[harmon_mute_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[harmon_mute_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		case "Golpe":
			res := make(map[*Empty_placement][]*Technical)
			for technical := range stage.Technicals {
				if technical.Golpe != nil {
					empty_placement_ := technical.Golpe
					var technicals []*Technical
					_, ok := res[empty_placement_]
					if ok {
						technicals = res[empty_placement_]
					} else {
						technicals = make([]*Technical, 0)
					}
					technicals = append(technicals, technical)
					res[empty_placement_] = technicals
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Text_element_data
	case Text_element_data:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tie
	case Tie:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tied
	case Tied:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Time
	case Time:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Time_modification
	case Time_modification:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Timpani
	case Timpani:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Transpose
	case Transpose:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tremolo
	case Tremolo:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tuplet
	case Tuplet:
		switch fieldname {
		// insertion point for per direct association field
		case "Tuplet_actual":
			res := make(map[*Tuplet_portion][]*Tuplet)
			for tuplet := range stage.Tuplets {
				if tuplet.Tuplet_actual != nil {
					tuplet_portion_ := tuplet.Tuplet_actual
					var tuplets []*Tuplet
					_, ok := res[tuplet_portion_]
					if ok {
						tuplets = res[tuplet_portion_]
					} else {
						tuplets = make([]*Tuplet, 0)
					}
					tuplets = append(tuplets, tuplet)
					res[tuplet_portion_] = tuplets
				}
			}
			return any(res).(map[*End][]*Start)
		case "Tuplet_normal":
			res := make(map[*Tuplet_portion][]*Tuplet)
			for tuplet := range stage.Tuplets {
				if tuplet.Tuplet_normal != nil {
					tuplet_portion_ := tuplet.Tuplet_normal
					var tuplets []*Tuplet
					_, ok := res[tuplet_portion_]
					if ok {
						tuplets = res[tuplet_portion_]
					} else {
						tuplets = make([]*Tuplet, 0)
					}
					tuplets = append(tuplets, tuplet)
					res[tuplet_portion_] = tuplets
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Tuplet_dot
	case Tuplet_dot:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tuplet_number
	case Tuplet_number:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tuplet_portion
	case Tuplet_portion:
		switch fieldname {
		// insertion point for per direct association field
		case "Tuplet_number":
			res := make(map[*Tuplet_number][]*Tuplet_portion)
			for tuplet_portion := range stage.Tuplet_portions {
				if tuplet_portion.Tuplet_number != nil {
					tuplet_number_ := tuplet_portion.Tuplet_number
					var tuplet_portions []*Tuplet_portion
					_, ok := res[tuplet_number_]
					if ok {
						tuplet_portions = res[tuplet_number_]
					} else {
						tuplet_portions = make([]*Tuplet_portion, 0)
					}
					tuplet_portions = append(tuplet_portions, tuplet_portion)
					res[tuplet_number_] = tuplet_portions
				}
			}
			return any(res).(map[*End][]*Start)
		case "Tuplet_type":
			res := make(map[*Tuplet_type][]*Tuplet_portion)
			for tuplet_portion := range stage.Tuplet_portions {
				if tuplet_portion.Tuplet_type != nil {
					tuplet_type_ := tuplet_portion.Tuplet_type
					var tuplet_portions []*Tuplet_portion
					_, ok := res[tuplet_type_]
					if ok {
						tuplet_portions = res[tuplet_type_]
					} else {
						tuplet_portions = make([]*Tuplet_portion, 0)
					}
					tuplet_portions = append(tuplet_portions, tuplet_portion)
					res[tuplet_type_] = tuplet_portions
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Tuplet_type
	case Tuplet_type:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Typed_text
	case Typed_text:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Unpitched
	case Unpitched:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Virtual_instrument
	case Virtual_instrument:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Wait
	case Wait:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Wavy_line
	case Wavy_line:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Wedge
	case Wedge:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Wood
	case Wood:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Work
	case Work:
		switch fieldname {
		// insertion point for per direct association field
		case "Opus":
			res := make(map[*Opus][]*Work)
			for work := range stage.Works {
				if work.Opus != nil {
					opus_ := work.Opus
					var works []*Work
					_, ok := res[opus_]
					if ok {
						works = res[opus_]
					} else {
						works = make([]*Work, 0)
					}
					works = append(works, work)
					res[opus_] = works
				}
			}
			return any(res).(map[*End][]*Start)
		}
	}
	return nil
}

// GetSliceOfPointersReverseMap allows backtrack navigation of any Start.Fieldname
// associations (0..N) between one staged Gongstruct instances and many others
//
// The function provides a map with keys as instances of End and values to *Start instances
// the map is construed by iterating over all Start instances and populating keys with End instances
// and values with the Start instances
func GetSliceOfPointersReverseMap[Start, End Gongstruct](fieldname string, stage *StageStruct) map[*End]*Start {

	var ret Start

	switch any(ret).(type) {
	// insertion point of functions that provide maps for reverse associations
	// reverse maps of direct associations of Accidental
	case Accidental:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Accidental_mark
	case Accidental_mark:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Accidental_text
	case Accidental_text:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Accord
	case Accord:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Accordion_registration
	case Accordion_registration:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of AnyType
	case AnyType:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Appearance
	case Appearance:
		switch fieldname {
		// insertion point for per direct association field
		case "Line_width":
			res := make(map[*Line_width]*Appearance)
			for appearance := range stage.Appearances {
				for _, line_width_ := range appearance.Line_width {
					res[line_width_] = appearance
				}
			}
			return any(res).(map[*End]*Start)
		case "Note_size":
			res := make(map[*Note_size]*Appearance)
			for appearance := range stage.Appearances {
				for _, note_size_ := range appearance.Note_size {
					res[note_size_] = appearance
				}
			}
			return any(res).(map[*End]*Start)
		case "Distance":
			res := make(map[*Distance]*Appearance)
			for appearance := range stage.Appearances {
				for _, distance_ := range appearance.Distance {
					res[distance_] = appearance
				}
			}
			return any(res).(map[*End]*Start)
		case "Glyph":
			res := make(map[*Glyph]*Appearance)
			for appearance := range stage.Appearances {
				for _, glyph_ := range appearance.Glyph {
					res[glyph_] = appearance
				}
			}
			return any(res).(map[*End]*Start)
		case "Other_appearance":
			res := make(map[*Other_appearance]*Appearance)
			for appearance := range stage.Appearances {
				for _, other_appearance_ := range appearance.Other_appearance {
					res[other_appearance_] = appearance
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Arpeggiate
	case Arpeggiate:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Arrow
	case Arrow:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Articulations
	case Articulations:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Assess
	case Assess:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Attributes
	case Attributes:
		switch fieldname {
		// insertion point for per direct association field
		case "Key":
			res := make(map[*Key]*Attributes)
			for attributes := range stage.Attributess {
				for _, key_ := range attributes.Key {
					res[key_] = attributes
				}
			}
			return any(res).(map[*End]*Start)
		case "Clef":
			res := make(map[*Clef]*Attributes)
			for attributes := range stage.Attributess {
				for _, clef_ := range attributes.Clef {
					res[clef_] = attributes
				}
			}
			return any(res).(map[*End]*Start)
		case "Staff_details":
			res := make(map[*Staff_details]*Attributes)
			for attributes := range stage.Attributess {
				for _, staff_details_ := range attributes.Staff_details {
					res[staff_details_] = attributes
				}
			}
			return any(res).(map[*End]*Start)
		case "Measure_style":
			res := make(map[*Measure_style]*Attributes)
			for attributes := range stage.Attributess {
				for _, measure_style_ := range attributes.Measure_style {
					res[measure_style_] = attributes
				}
			}
			return any(res).(map[*End]*Start)
		case "Transpose":
			res := make(map[*Transpose]*Attributes)
			for attributes := range stage.Attributess {
				for _, transpose_ := range attributes.Transpose {
					res[transpose_] = attributes
				}
			}
			return any(res).(map[*End]*Start)
		case "For_part":
			res := make(map[*For_part]*Attributes)
			for attributes := range stage.Attributess {
				for _, for_part_ := range attributes.For_part {
					res[for_part_] = attributes
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Backup
	case Backup:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Bar_style_color
	case Bar_style_color:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Barline
	case Barline:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Barre
	case Barre:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Bass
	case Bass:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Bass_step
	case Bass_step:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Beam
	case Beam:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Beat_repeat
	case Beat_repeat:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Beat_unit_tied
	case Beat_unit_tied:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Beater
	case Beater:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Bend
	case Bend:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Bookmark
	case Bookmark:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Bracket
	case Bracket:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Breath_mark
	case Breath_mark:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Caesura
	case Caesura:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Cancel
	case Cancel:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Clef
	case Clef:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Coda
	case Coda:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Credit
	case Credit:
		switch fieldname {
		// insertion point for per direct association field
		case "Link":
			res := make(map[*Link]*Credit)
			for credit := range stage.Credits {
				for _, link_ := range credit.Link {
					res[link_] = credit
				}
			}
			return any(res).(map[*End]*Start)
		case "Bookmark":
			res := make(map[*Bookmark]*Credit)
			for credit := range stage.Credits {
				for _, bookmark_ := range credit.Bookmark {
					res[bookmark_] = credit
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Dashes
	case Dashes:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Defaults
	case Defaults:
		switch fieldname {
		// insertion point for per direct association field
		case "Lyric_font":
			res := make(map[*Lyric_font]*Defaults)
			for defaults := range stage.Defaultss {
				for _, lyric_font_ := range defaults.Lyric_font {
					res[lyric_font_] = defaults
				}
			}
			return any(res).(map[*End]*Start)
		case "Lyric_language":
			res := make(map[*Lyric_language]*Defaults)
			for defaults := range stage.Defaultss {
				for _, lyric_language_ := range defaults.Lyric_language {
					res[lyric_language_] = defaults
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Degree
	case Degree:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Degree_alter
	case Degree_alter:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Degree_type
	case Degree_type:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Degree_value
	case Degree_value:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Direction
	case Direction:
		switch fieldname {
		// insertion point for per direct association field
		case "Direction_type":
			res := make(map[*Direction_type]*Direction)
			for direction := range stage.Directions {
				for _, direction_type_ := range direction.Direction_type {
					res[direction_type_] = direction
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Direction_type
	case Direction_type:
		switch fieldname {
		// insertion point for per direct association field
		case "Segno":
			res := make(map[*Segno]*Direction_type)
			for direction_type := range stage.Direction_types {
				for _, segno_ := range direction_type.Segno {
					res[segno_] = direction_type
				}
			}
			return any(res).(map[*End]*Start)
		case "Coda":
			res := make(map[*Coda]*Direction_type)
			for direction_type := range stage.Direction_types {
				for _, coda_ := range direction_type.Coda {
					res[coda_] = direction_type
				}
			}
			return any(res).(map[*End]*Start)
		case "Dynamics":
			res := make(map[*Dynamics]*Direction_type)
			for direction_type := range stage.Direction_types {
				for _, dynamics_ := range direction_type.Dynamics {
					res[dynamics_] = direction_type
				}
			}
			return any(res).(map[*End]*Start)
		case "Percussion":
			res := make(map[*Percussion]*Direction_type)
			for direction_type := range stage.Direction_types {
				for _, percussion_ := range direction_type.Percussion {
					res[percussion_] = direction_type
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Distance
	case Distance:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Double
	case Double:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Dynamics
	case Dynamics:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Effect
	case Effect:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Elision
	case Elision:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty
	case Empty:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_font
	case Empty_font:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_line
	case Empty_line:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_placement
	case Empty_placement:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_placement_smufl
	case Empty_placement_smufl:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_print_object_style_align
	case Empty_print_object_style_align:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_print_style
	case Empty_print_style:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_print_style_align
	case Empty_print_style_align:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_print_style_align_id
	case Empty_print_style_align_id:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Empty_trill_sound
	case Empty_trill_sound:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Encoding
	case Encoding:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Ending
	case Ending:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Extend
	case Extend:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Feature
	case Feature:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Fermata
	case Fermata:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Figure
	case Figure:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Figured_bass
	case Figured_bass:
		switch fieldname {
		// insertion point for per direct association field
		case "Figure":
			res := make(map[*Figure]*Figured_bass)
			for figured_bass := range stage.Figured_basss {
				for _, figure_ := range figured_bass.Figure {
					res[figure_] = figured_bass
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Fingering
	case Fingering:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of First_fret
	case First_fret:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Foo
	case Foo:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of For_part
	case For_part:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Formatted_symbol
	case Formatted_symbol:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Formatted_symbol_id
	case Formatted_symbol_id:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Forward
	case Forward:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Frame
	case Frame:
		switch fieldname {
		// insertion point for per direct association field
		case "Frame_note":
			res := make(map[*Frame_note]*Frame)
			for frame := range stage.Frames {
				for _, frame_note_ := range frame.Frame_note {
					res[frame_note_] = frame
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Frame_note
	case Frame_note:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Fret
	case Fret:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Glass
	case Glass:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Glissando
	case Glissando:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Glyph
	case Glyph:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Grace
	case Grace:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Group_barline
	case Group_barline:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Group_symbol
	case Group_symbol:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Grouping
	case Grouping:
		switch fieldname {
		// insertion point for per direct association field
		case "Feature":
			res := make(map[*Feature]*Grouping)
			for grouping := range stage.Groupings {
				for _, feature_ := range grouping.Feature {
					res[feature_] = grouping
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Hammer_on_pull_off
	case Hammer_on_pull_off:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Handbell
	case Handbell:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Harmon_closed
	case Harmon_closed:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Harmon_mute
	case Harmon_mute:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Harmonic
	case Harmonic:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Harmony
	case Harmony:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Harmony_alter
	case Harmony_alter:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Harp_pedals
	case Harp_pedals:
		switch fieldname {
		// insertion point for per direct association field
		case "Pedal_tuning":
			res := make(map[*Pedal_tuning]*Harp_pedals)
			for harp_pedals := range stage.Harp_pedalss {
				for _, pedal_tuning_ := range harp_pedals.Pedal_tuning {
					res[pedal_tuning_] = harp_pedals
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Heel_toe
	case Heel_toe:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Hole
	case Hole:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Hole_closed
	case Hole_closed:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Horizontal_turn
	case Horizontal_turn:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Identification
	case Identification:
		switch fieldname {
		// insertion point for per direct association field
		case "Creator":
			res := make(map[*Typed_text]*Identification)
			for identification := range stage.Identifications {
				for _, typed_text_ := range identification.Creator {
					res[typed_text_] = identification
				}
			}
			return any(res).(map[*End]*Start)
		case "Rights":
			res := make(map[*Typed_text]*Identification)
			for identification := range stage.Identifications {
				for _, typed_text_ := range identification.Rights {
					res[typed_text_] = identification
				}
			}
			return any(res).(map[*End]*Start)
		case "Relation":
			res := make(map[*Typed_text]*Identification)
			for identification := range stage.Identifications {
				for _, typed_text_ := range identification.Relation {
					res[typed_text_] = identification
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Image
	case Image:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Instrument
	case Instrument:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Instrument_change
	case Instrument_change:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Instrument_link
	case Instrument_link:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Interchangeable
	case Interchangeable:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Inversion
	case Inversion:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Key
	case Key:
		switch fieldname {
		// insertion point for per direct association field
		case "Key_octave":
			res := make(map[*Key_octave]*Key)
			for key := range stage.Keys {
				for _, key_octave_ := range key.Key_octave {
					res[key_octave_] = key
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Key_accidental
	case Key_accidental:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Key_octave
	case Key_octave:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Kind
	case Kind:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Level
	case Level:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Line_detail
	case Line_detail:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Line_width
	case Line_width:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Link
	case Link:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Listen
	case Listen:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Listening
	case Listening:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Lyric
	case Lyric:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Lyric_font
	case Lyric_font:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Lyric_language
	case Lyric_language:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Measure_layout
	case Measure_layout:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Measure_numbering
	case Measure_numbering:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Measure_repeat
	case Measure_repeat:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Measure_style
	case Measure_style:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Membrane
	case Membrane:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Metal
	case Metal:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Metronome
	case Metronome:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Metronome_beam
	case Metronome_beam:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Metronome_note
	case Metronome_note:
		switch fieldname {
		// insertion point for per direct association field
		case "Metronome_dot":
			res := make(map[*Empty]*Metronome_note)
			for metronome_note := range stage.Metronome_notes {
				for _, empty_ := range metronome_note.Metronome_dot {
					res[empty_] = metronome_note
				}
			}
			return any(res).(map[*End]*Start)
		case "Metronome_beam":
			res := make(map[*Metronome_beam]*Metronome_note)
			for metronome_note := range stage.Metronome_notes {
				for _, metronome_beam_ := range metronome_note.Metronome_beam {
					res[metronome_beam_] = metronome_note
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Metronome_tied
	case Metronome_tied:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Metronome_tuplet
	case Metronome_tuplet:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Midi_device
	case Midi_device:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Midi_instrument
	case Midi_instrument:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Miscellaneous
	case Miscellaneous:
		switch fieldname {
		// insertion point for per direct association field
		case "Miscellaneous_field":
			res := make(map[*Miscellaneous_field]*Miscellaneous)
			for miscellaneous := range stage.Miscellaneouss {
				for _, miscellaneous_field_ := range miscellaneous.Miscellaneous_field {
					res[miscellaneous_field_] = miscellaneous
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Miscellaneous_field
	case Miscellaneous_field:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Mordent
	case Mordent:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Multiple_rest
	case Multiple_rest:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Name_display
	case Name_display:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Non_arpeggiate
	case Non_arpeggiate:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Notations
	case Notations:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Note
	case Note:
		switch fieldname {
		// insertion point for per direct association field
		case "Instrument":
			res := make(map[*Instrument]*Note)
			for note := range stage.Notes {
				for _, instrument_ := range note.Instrument {
					res[instrument_] = note
				}
			}
			return any(res).(map[*End]*Start)
		case "Dot":
			res := make(map[*Empty_placement]*Note)
			for note := range stage.Notes {
				for _, empty_placement_ := range note.Dot {
					res[empty_placement_] = note
				}
			}
			return any(res).(map[*End]*Start)
		case "Notations":
			res := make(map[*Notations]*Note)
			for note := range stage.Notes {
				for _, notations_ := range note.Notations {
					res[notations_] = note
				}
			}
			return any(res).(map[*End]*Start)
		case "Lyric":
			res := make(map[*Lyric]*Note)
			for note := range stage.Notes {
				for _, lyric_ := range note.Lyric {
					res[lyric_] = note
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Note_size
	case Note_size:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Note_type
	case Note_type:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Notehead
	case Notehead:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Notehead_text
	case Notehead_text:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Numeral
	case Numeral:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Numeral_key
	case Numeral_key:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Numeral_root
	case Numeral_root:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Octave_shift
	case Octave_shift:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Offset
	case Offset:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Opus
	case Opus:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Ornaments
	case Ornaments:
		switch fieldname {
		// insertion point for per direct association field
		case "Accidental_mark":
			res := make(map[*Accidental_mark]*Ornaments)
			for ornaments := range stage.Ornamentss {
				for _, accidental_mark_ := range ornaments.Accidental_mark {
					res[accidental_mark_] = ornaments
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Other_appearance
	case Other_appearance:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Other_listening
	case Other_listening:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Other_notation
	case Other_notation:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Other_play
	case Other_play:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Page_layout
	case Page_layout:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Page_margins
	case Page_margins:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Part_clef
	case Part_clef:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Part_group
	case Part_group:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Part_link
	case Part_link:
		switch fieldname {
		// insertion point for per direct association field
		case "Instrument_link":
			res := make(map[*Instrument_link]*Part_link)
			for part_link := range stage.Part_links {
				for _, instrument_link_ := range part_link.Instrument_link {
					res[instrument_link_] = part_link
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Part_list
	case Part_list:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Part_symbol
	case Part_symbol:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Part_transpose
	case Part_transpose:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Pedal
	case Pedal:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Pedal_tuning
	case Pedal_tuning:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Percussion
	case Percussion:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Pitch
	case Pitch:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Pitched
	case Pitched:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Play
	case Play:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Player
	case Player:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Principal_voice
	case Principal_voice:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Print
	case Print:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Release
	case Release:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Repeat
	case Repeat:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Rest
	case Rest:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Root
	case Root:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Root_step
	case Root_step:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Scaling
	case Scaling:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Scordatura
	case Scordatura:
		switch fieldname {
		// insertion point for per direct association field
		case "Accord":
			res := make(map[*Accord]*Scordatura)
			for scordatura := range stage.Scordaturas {
				for _, accord_ := range scordatura.Accord {
					res[accord_] = scordatura
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Score_instrument
	case Score_instrument:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Score_part
	case Score_part:
		switch fieldname {
		// insertion point for per direct association field
		case "Part_link":
			res := make(map[*Part_link]*Score_part)
			for score_part := range stage.Score_parts {
				for _, part_link_ := range score_part.Part_link {
					res[part_link_] = score_part
				}
			}
			return any(res).(map[*End]*Start)
		case "Score_instrument":
			res := make(map[*Score_instrument]*Score_part)
			for score_part := range stage.Score_parts {
				for _, score_instrument_ := range score_part.Score_instrument {
					res[score_instrument_] = score_part
				}
			}
			return any(res).(map[*End]*Start)
		case "Player":
			res := make(map[*Player]*Score_part)
			for score_part := range stage.Score_parts {
				for _, player_ := range score_part.Player {
					res[player_] = score_part
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Score_partwise
	case Score_partwise:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Score_timewise
	case Score_timewise:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Segno
	case Segno:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Slash
	case Slash:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Slide
	case Slide:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Slur
	case Slur:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Sound
	case Sound:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Staff_details
	case Staff_details:
		switch fieldname {
		// insertion point for per direct association field
		case "Staff_tuning":
			res := make(map[*Staff_tuning]*Staff_details)
			for staff_details := range stage.Staff_detailss {
				for _, staff_tuning_ := range staff_details.Staff_tuning {
					res[staff_tuning_] = staff_details
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Staff_divide
	case Staff_divide:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Staff_layout
	case Staff_layout:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Staff_size
	case Staff_size:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Staff_tuning
	case Staff_tuning:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Stem
	case Stem:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Stick
	case Stick:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of String_mute
	case String_mute:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Strong_accent
	case Strong_accent:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Supports
	case Supports:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Swing
	case Swing:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Sync
	case Sync:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of System_dividers
	case System_dividers:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of System_layout
	case System_layout:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of System_margins
	case System_margins:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tap
	case Tap:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Technical
	case Technical:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Text_element_data
	case Text_element_data:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tie
	case Tie:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tied
	case Tied:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Time
	case Time:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Time_modification
	case Time_modification:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Timpani
	case Timpani:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Transpose
	case Transpose:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tremolo
	case Tremolo:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tuplet
	case Tuplet:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tuplet_dot
	case Tuplet_dot:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tuplet_number
	case Tuplet_number:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Tuplet_portion
	case Tuplet_portion:
		switch fieldname {
		// insertion point for per direct association field
		case "Tuplet_dot":
			res := make(map[*Tuplet_dot]*Tuplet_portion)
			for tuplet_portion := range stage.Tuplet_portions {
				for _, tuplet_dot_ := range tuplet_portion.Tuplet_dot {
					res[tuplet_dot_] = tuplet_portion
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Tuplet_type
	case Tuplet_type:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Typed_text
	case Typed_text:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Unpitched
	case Unpitched:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Virtual_instrument
	case Virtual_instrument:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Wait
	case Wait:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Wavy_line
	case Wavy_line:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Wedge
	case Wedge:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Wood
	case Wood:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Work
	case Work:
		switch fieldname {
		// insertion point for per direct association field
		}
	}
	return nil
}

// GetGongstructName returns the name of the Gongstruct
// this can be usefull if one want program robust to refactoring
func GetGongstructName[Type Gongstruct]() (res string) {

	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get gongstruct name
	case Accidental:
		res = "Accidental"
	case Accidental_mark:
		res = "Accidental_mark"
	case Accidental_text:
		res = "Accidental_text"
	case Accord:
		res = "Accord"
	case Accordion_registration:
		res = "Accordion_registration"
	case AnyType:
		res = "AnyType"
	case Appearance:
		res = "Appearance"
	case Arpeggiate:
		res = "Arpeggiate"
	case Arrow:
		res = "Arrow"
	case Articulations:
		res = "Articulations"
	case Assess:
		res = "Assess"
	case Attributes:
		res = "Attributes"
	case Backup:
		res = "Backup"
	case Bar_style_color:
		res = "Bar_style_color"
	case Barline:
		res = "Barline"
	case Barre:
		res = "Barre"
	case Bass:
		res = "Bass"
	case Bass_step:
		res = "Bass_step"
	case Beam:
		res = "Beam"
	case Beat_repeat:
		res = "Beat_repeat"
	case Beat_unit_tied:
		res = "Beat_unit_tied"
	case Beater:
		res = "Beater"
	case Bend:
		res = "Bend"
	case Bookmark:
		res = "Bookmark"
	case Bracket:
		res = "Bracket"
	case Breath_mark:
		res = "Breath_mark"
	case Caesura:
		res = "Caesura"
	case Cancel:
		res = "Cancel"
	case Clef:
		res = "Clef"
	case Coda:
		res = "Coda"
	case Credit:
		res = "Credit"
	case Dashes:
		res = "Dashes"
	case Defaults:
		res = "Defaults"
	case Degree:
		res = "Degree"
	case Degree_alter:
		res = "Degree_alter"
	case Degree_type:
		res = "Degree_type"
	case Degree_value:
		res = "Degree_value"
	case Direction:
		res = "Direction"
	case Direction_type:
		res = "Direction_type"
	case Distance:
		res = "Distance"
	case Double:
		res = "Double"
	case Dynamics:
		res = "Dynamics"
	case Effect:
		res = "Effect"
	case Elision:
		res = "Elision"
	case Empty:
		res = "Empty"
	case Empty_font:
		res = "Empty_font"
	case Empty_line:
		res = "Empty_line"
	case Empty_placement:
		res = "Empty_placement"
	case Empty_placement_smufl:
		res = "Empty_placement_smufl"
	case Empty_print_object_style_align:
		res = "Empty_print_object_style_align"
	case Empty_print_style:
		res = "Empty_print_style"
	case Empty_print_style_align:
		res = "Empty_print_style_align"
	case Empty_print_style_align_id:
		res = "Empty_print_style_align_id"
	case Empty_trill_sound:
		res = "Empty_trill_sound"
	case Encoding:
		res = "Encoding"
	case Ending:
		res = "Ending"
	case Extend:
		res = "Extend"
	case Feature:
		res = "Feature"
	case Fermata:
		res = "Fermata"
	case Figure:
		res = "Figure"
	case Figured_bass:
		res = "Figured_bass"
	case Fingering:
		res = "Fingering"
	case First_fret:
		res = "First_fret"
	case Foo:
		res = "Foo"
	case For_part:
		res = "For_part"
	case Formatted_symbol:
		res = "Formatted_symbol"
	case Formatted_symbol_id:
		res = "Formatted_symbol_id"
	case Forward:
		res = "Forward"
	case Frame:
		res = "Frame"
	case Frame_note:
		res = "Frame_note"
	case Fret:
		res = "Fret"
	case Glass:
		res = "Glass"
	case Glissando:
		res = "Glissando"
	case Glyph:
		res = "Glyph"
	case Grace:
		res = "Grace"
	case Group_barline:
		res = "Group_barline"
	case Group_symbol:
		res = "Group_symbol"
	case Grouping:
		res = "Grouping"
	case Hammer_on_pull_off:
		res = "Hammer_on_pull_off"
	case Handbell:
		res = "Handbell"
	case Harmon_closed:
		res = "Harmon_closed"
	case Harmon_mute:
		res = "Harmon_mute"
	case Harmonic:
		res = "Harmonic"
	case Harmony:
		res = "Harmony"
	case Harmony_alter:
		res = "Harmony_alter"
	case Harp_pedals:
		res = "Harp_pedals"
	case Heel_toe:
		res = "Heel_toe"
	case Hole:
		res = "Hole"
	case Hole_closed:
		res = "Hole_closed"
	case Horizontal_turn:
		res = "Horizontal_turn"
	case Identification:
		res = "Identification"
	case Image:
		res = "Image"
	case Instrument:
		res = "Instrument"
	case Instrument_change:
		res = "Instrument_change"
	case Instrument_link:
		res = "Instrument_link"
	case Interchangeable:
		res = "Interchangeable"
	case Inversion:
		res = "Inversion"
	case Key:
		res = "Key"
	case Key_accidental:
		res = "Key_accidental"
	case Key_octave:
		res = "Key_octave"
	case Kind:
		res = "Kind"
	case Level:
		res = "Level"
	case Line_detail:
		res = "Line_detail"
	case Line_width:
		res = "Line_width"
	case Link:
		res = "Link"
	case Listen:
		res = "Listen"
	case Listening:
		res = "Listening"
	case Lyric:
		res = "Lyric"
	case Lyric_font:
		res = "Lyric_font"
	case Lyric_language:
		res = "Lyric_language"
	case Measure_layout:
		res = "Measure_layout"
	case Measure_numbering:
		res = "Measure_numbering"
	case Measure_repeat:
		res = "Measure_repeat"
	case Measure_style:
		res = "Measure_style"
	case Membrane:
		res = "Membrane"
	case Metal:
		res = "Metal"
	case Metronome:
		res = "Metronome"
	case Metronome_beam:
		res = "Metronome_beam"
	case Metronome_note:
		res = "Metronome_note"
	case Metronome_tied:
		res = "Metronome_tied"
	case Metronome_tuplet:
		res = "Metronome_tuplet"
	case Midi_device:
		res = "Midi_device"
	case Midi_instrument:
		res = "Midi_instrument"
	case Miscellaneous:
		res = "Miscellaneous"
	case Miscellaneous_field:
		res = "Miscellaneous_field"
	case Mordent:
		res = "Mordent"
	case Multiple_rest:
		res = "Multiple_rest"
	case Name_display:
		res = "Name_display"
	case Non_arpeggiate:
		res = "Non_arpeggiate"
	case Notations:
		res = "Notations"
	case Note:
		res = "Note"
	case Note_size:
		res = "Note_size"
	case Note_type:
		res = "Note_type"
	case Notehead:
		res = "Notehead"
	case Notehead_text:
		res = "Notehead_text"
	case Numeral:
		res = "Numeral"
	case Numeral_key:
		res = "Numeral_key"
	case Numeral_root:
		res = "Numeral_root"
	case Octave_shift:
		res = "Octave_shift"
	case Offset:
		res = "Offset"
	case Opus:
		res = "Opus"
	case Ornaments:
		res = "Ornaments"
	case Other_appearance:
		res = "Other_appearance"
	case Other_listening:
		res = "Other_listening"
	case Other_notation:
		res = "Other_notation"
	case Other_play:
		res = "Other_play"
	case Page_layout:
		res = "Page_layout"
	case Page_margins:
		res = "Page_margins"
	case Part_clef:
		res = "Part_clef"
	case Part_group:
		res = "Part_group"
	case Part_link:
		res = "Part_link"
	case Part_list:
		res = "Part_list"
	case Part_symbol:
		res = "Part_symbol"
	case Part_transpose:
		res = "Part_transpose"
	case Pedal:
		res = "Pedal"
	case Pedal_tuning:
		res = "Pedal_tuning"
	case Percussion:
		res = "Percussion"
	case Pitch:
		res = "Pitch"
	case Pitched:
		res = "Pitched"
	case Play:
		res = "Play"
	case Player:
		res = "Player"
	case Principal_voice:
		res = "Principal_voice"
	case Print:
		res = "Print"
	case Release:
		res = "Release"
	case Repeat:
		res = "Repeat"
	case Rest:
		res = "Rest"
	case Root:
		res = "Root"
	case Root_step:
		res = "Root_step"
	case Scaling:
		res = "Scaling"
	case Scordatura:
		res = "Scordatura"
	case Score_instrument:
		res = "Score_instrument"
	case Score_part:
		res = "Score_part"
	case Score_partwise:
		res = "Score_partwise"
	case Score_timewise:
		res = "Score_timewise"
	case Segno:
		res = "Segno"
	case Slash:
		res = "Slash"
	case Slide:
		res = "Slide"
	case Slur:
		res = "Slur"
	case Sound:
		res = "Sound"
	case Staff_details:
		res = "Staff_details"
	case Staff_divide:
		res = "Staff_divide"
	case Staff_layout:
		res = "Staff_layout"
	case Staff_size:
		res = "Staff_size"
	case Staff_tuning:
		res = "Staff_tuning"
	case Stem:
		res = "Stem"
	case Stick:
		res = "Stick"
	case String_mute:
		res = "String_mute"
	case Strong_accent:
		res = "Strong_accent"
	case Supports:
		res = "Supports"
	case Swing:
		res = "Swing"
	case Sync:
		res = "Sync"
	case System_dividers:
		res = "System_dividers"
	case System_layout:
		res = "System_layout"
	case System_margins:
		res = "System_margins"
	case Tap:
		res = "Tap"
	case Technical:
		res = "Technical"
	case Text_element_data:
		res = "Text_element_data"
	case Tie:
		res = "Tie"
	case Tied:
		res = "Tied"
	case Time:
		res = "Time"
	case Time_modification:
		res = "Time_modification"
	case Timpani:
		res = "Timpani"
	case Transpose:
		res = "Transpose"
	case Tremolo:
		res = "Tremolo"
	case Tuplet:
		res = "Tuplet"
	case Tuplet_dot:
		res = "Tuplet_dot"
	case Tuplet_number:
		res = "Tuplet_number"
	case Tuplet_portion:
		res = "Tuplet_portion"
	case Tuplet_type:
		res = "Tuplet_type"
	case Typed_text:
		res = "Typed_text"
	case Unpitched:
		res = "Unpitched"
	case Virtual_instrument:
		res = "Virtual_instrument"
	case Wait:
		res = "Wait"
	case Wavy_line:
		res = "Wavy_line"
	case Wedge:
		res = "Wedge"
	case Wood:
		res = "Wood"
	case Work:
		res = "Work"
	}
	return res
}

// GetPointerToGongstructName returns the name of the Gongstruct
// this can be usefull if one want program robust to refactoring
func GetPointerToGongstructName[Type PointerToGongstruct]() (res string) {

	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get gongstruct name
	case *Accidental:
		res = "Accidental"
	case *Accidental_mark:
		res = "Accidental_mark"
	case *Accidental_text:
		res = "Accidental_text"
	case *Accord:
		res = "Accord"
	case *Accordion_registration:
		res = "Accordion_registration"
	case *AnyType:
		res = "AnyType"
	case *Appearance:
		res = "Appearance"
	case *Arpeggiate:
		res = "Arpeggiate"
	case *Arrow:
		res = "Arrow"
	case *Articulations:
		res = "Articulations"
	case *Assess:
		res = "Assess"
	case *Attributes:
		res = "Attributes"
	case *Backup:
		res = "Backup"
	case *Bar_style_color:
		res = "Bar_style_color"
	case *Barline:
		res = "Barline"
	case *Barre:
		res = "Barre"
	case *Bass:
		res = "Bass"
	case *Bass_step:
		res = "Bass_step"
	case *Beam:
		res = "Beam"
	case *Beat_repeat:
		res = "Beat_repeat"
	case *Beat_unit_tied:
		res = "Beat_unit_tied"
	case *Beater:
		res = "Beater"
	case *Bend:
		res = "Bend"
	case *Bookmark:
		res = "Bookmark"
	case *Bracket:
		res = "Bracket"
	case *Breath_mark:
		res = "Breath_mark"
	case *Caesura:
		res = "Caesura"
	case *Cancel:
		res = "Cancel"
	case *Clef:
		res = "Clef"
	case *Coda:
		res = "Coda"
	case *Credit:
		res = "Credit"
	case *Dashes:
		res = "Dashes"
	case *Defaults:
		res = "Defaults"
	case *Degree:
		res = "Degree"
	case *Degree_alter:
		res = "Degree_alter"
	case *Degree_type:
		res = "Degree_type"
	case *Degree_value:
		res = "Degree_value"
	case *Direction:
		res = "Direction"
	case *Direction_type:
		res = "Direction_type"
	case *Distance:
		res = "Distance"
	case *Double:
		res = "Double"
	case *Dynamics:
		res = "Dynamics"
	case *Effect:
		res = "Effect"
	case *Elision:
		res = "Elision"
	case *Empty:
		res = "Empty"
	case *Empty_font:
		res = "Empty_font"
	case *Empty_line:
		res = "Empty_line"
	case *Empty_placement:
		res = "Empty_placement"
	case *Empty_placement_smufl:
		res = "Empty_placement_smufl"
	case *Empty_print_object_style_align:
		res = "Empty_print_object_style_align"
	case *Empty_print_style:
		res = "Empty_print_style"
	case *Empty_print_style_align:
		res = "Empty_print_style_align"
	case *Empty_print_style_align_id:
		res = "Empty_print_style_align_id"
	case *Empty_trill_sound:
		res = "Empty_trill_sound"
	case *Encoding:
		res = "Encoding"
	case *Ending:
		res = "Ending"
	case *Extend:
		res = "Extend"
	case *Feature:
		res = "Feature"
	case *Fermata:
		res = "Fermata"
	case *Figure:
		res = "Figure"
	case *Figured_bass:
		res = "Figured_bass"
	case *Fingering:
		res = "Fingering"
	case *First_fret:
		res = "First_fret"
	case *Foo:
		res = "Foo"
	case *For_part:
		res = "For_part"
	case *Formatted_symbol:
		res = "Formatted_symbol"
	case *Formatted_symbol_id:
		res = "Formatted_symbol_id"
	case *Forward:
		res = "Forward"
	case *Frame:
		res = "Frame"
	case *Frame_note:
		res = "Frame_note"
	case *Fret:
		res = "Fret"
	case *Glass:
		res = "Glass"
	case *Glissando:
		res = "Glissando"
	case *Glyph:
		res = "Glyph"
	case *Grace:
		res = "Grace"
	case *Group_barline:
		res = "Group_barline"
	case *Group_symbol:
		res = "Group_symbol"
	case *Grouping:
		res = "Grouping"
	case *Hammer_on_pull_off:
		res = "Hammer_on_pull_off"
	case *Handbell:
		res = "Handbell"
	case *Harmon_closed:
		res = "Harmon_closed"
	case *Harmon_mute:
		res = "Harmon_mute"
	case *Harmonic:
		res = "Harmonic"
	case *Harmony:
		res = "Harmony"
	case *Harmony_alter:
		res = "Harmony_alter"
	case *Harp_pedals:
		res = "Harp_pedals"
	case *Heel_toe:
		res = "Heel_toe"
	case *Hole:
		res = "Hole"
	case *Hole_closed:
		res = "Hole_closed"
	case *Horizontal_turn:
		res = "Horizontal_turn"
	case *Identification:
		res = "Identification"
	case *Image:
		res = "Image"
	case *Instrument:
		res = "Instrument"
	case *Instrument_change:
		res = "Instrument_change"
	case *Instrument_link:
		res = "Instrument_link"
	case *Interchangeable:
		res = "Interchangeable"
	case *Inversion:
		res = "Inversion"
	case *Key:
		res = "Key"
	case *Key_accidental:
		res = "Key_accidental"
	case *Key_octave:
		res = "Key_octave"
	case *Kind:
		res = "Kind"
	case *Level:
		res = "Level"
	case *Line_detail:
		res = "Line_detail"
	case *Line_width:
		res = "Line_width"
	case *Link:
		res = "Link"
	case *Listen:
		res = "Listen"
	case *Listening:
		res = "Listening"
	case *Lyric:
		res = "Lyric"
	case *Lyric_font:
		res = "Lyric_font"
	case *Lyric_language:
		res = "Lyric_language"
	case *Measure_layout:
		res = "Measure_layout"
	case *Measure_numbering:
		res = "Measure_numbering"
	case *Measure_repeat:
		res = "Measure_repeat"
	case *Measure_style:
		res = "Measure_style"
	case *Membrane:
		res = "Membrane"
	case *Metal:
		res = "Metal"
	case *Metronome:
		res = "Metronome"
	case *Metronome_beam:
		res = "Metronome_beam"
	case *Metronome_note:
		res = "Metronome_note"
	case *Metronome_tied:
		res = "Metronome_tied"
	case *Metronome_tuplet:
		res = "Metronome_tuplet"
	case *Midi_device:
		res = "Midi_device"
	case *Midi_instrument:
		res = "Midi_instrument"
	case *Miscellaneous:
		res = "Miscellaneous"
	case *Miscellaneous_field:
		res = "Miscellaneous_field"
	case *Mordent:
		res = "Mordent"
	case *Multiple_rest:
		res = "Multiple_rest"
	case *Name_display:
		res = "Name_display"
	case *Non_arpeggiate:
		res = "Non_arpeggiate"
	case *Notations:
		res = "Notations"
	case *Note:
		res = "Note"
	case *Note_size:
		res = "Note_size"
	case *Note_type:
		res = "Note_type"
	case *Notehead:
		res = "Notehead"
	case *Notehead_text:
		res = "Notehead_text"
	case *Numeral:
		res = "Numeral"
	case *Numeral_key:
		res = "Numeral_key"
	case *Numeral_root:
		res = "Numeral_root"
	case *Octave_shift:
		res = "Octave_shift"
	case *Offset:
		res = "Offset"
	case *Opus:
		res = "Opus"
	case *Ornaments:
		res = "Ornaments"
	case *Other_appearance:
		res = "Other_appearance"
	case *Other_listening:
		res = "Other_listening"
	case *Other_notation:
		res = "Other_notation"
	case *Other_play:
		res = "Other_play"
	case *Page_layout:
		res = "Page_layout"
	case *Page_margins:
		res = "Page_margins"
	case *Part_clef:
		res = "Part_clef"
	case *Part_group:
		res = "Part_group"
	case *Part_link:
		res = "Part_link"
	case *Part_list:
		res = "Part_list"
	case *Part_symbol:
		res = "Part_symbol"
	case *Part_transpose:
		res = "Part_transpose"
	case *Pedal:
		res = "Pedal"
	case *Pedal_tuning:
		res = "Pedal_tuning"
	case *Percussion:
		res = "Percussion"
	case *Pitch:
		res = "Pitch"
	case *Pitched:
		res = "Pitched"
	case *Play:
		res = "Play"
	case *Player:
		res = "Player"
	case *Principal_voice:
		res = "Principal_voice"
	case *Print:
		res = "Print"
	case *Release:
		res = "Release"
	case *Repeat:
		res = "Repeat"
	case *Rest:
		res = "Rest"
	case *Root:
		res = "Root"
	case *Root_step:
		res = "Root_step"
	case *Scaling:
		res = "Scaling"
	case *Scordatura:
		res = "Scordatura"
	case *Score_instrument:
		res = "Score_instrument"
	case *Score_part:
		res = "Score_part"
	case *Score_partwise:
		res = "Score_partwise"
	case *Score_timewise:
		res = "Score_timewise"
	case *Segno:
		res = "Segno"
	case *Slash:
		res = "Slash"
	case *Slide:
		res = "Slide"
	case *Slur:
		res = "Slur"
	case *Sound:
		res = "Sound"
	case *Staff_details:
		res = "Staff_details"
	case *Staff_divide:
		res = "Staff_divide"
	case *Staff_layout:
		res = "Staff_layout"
	case *Staff_size:
		res = "Staff_size"
	case *Staff_tuning:
		res = "Staff_tuning"
	case *Stem:
		res = "Stem"
	case *Stick:
		res = "Stick"
	case *String_mute:
		res = "String_mute"
	case *Strong_accent:
		res = "Strong_accent"
	case *Supports:
		res = "Supports"
	case *Swing:
		res = "Swing"
	case *Sync:
		res = "Sync"
	case *System_dividers:
		res = "System_dividers"
	case *System_layout:
		res = "System_layout"
	case *System_margins:
		res = "System_margins"
	case *Tap:
		res = "Tap"
	case *Technical:
		res = "Technical"
	case *Text_element_data:
		res = "Text_element_data"
	case *Tie:
		res = "Tie"
	case *Tied:
		res = "Tied"
	case *Time:
		res = "Time"
	case *Time_modification:
		res = "Time_modification"
	case *Timpani:
		res = "Timpani"
	case *Transpose:
		res = "Transpose"
	case *Tremolo:
		res = "Tremolo"
	case *Tuplet:
		res = "Tuplet"
	case *Tuplet_dot:
		res = "Tuplet_dot"
	case *Tuplet_number:
		res = "Tuplet_number"
	case *Tuplet_portion:
		res = "Tuplet_portion"
	case *Tuplet_type:
		res = "Tuplet_type"
	case *Typed_text:
		res = "Typed_text"
	case *Unpitched:
		res = "Unpitched"
	case *Virtual_instrument:
		res = "Virtual_instrument"
	case *Wait:
		res = "Wait"
	case *Wavy_line:
		res = "Wavy_line"
	case *Wedge:
		res = "Wedge"
	case *Wood:
		res = "Wood"
	case *Work:
		res = "Work"
	}
	return res
}

// GetFields return the array of the fields
func GetFields[Type Gongstruct]() (res []string) {

	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get gongstruct name
	case Accidental:
		res = []string{"Name"}
	case Accidental_mark:
		res = []string{"Name"}
	case Accidental_text:
		res = []string{"Name"}
	case Accord:
		res = []string{"Name"}
	case Accordion_registration:
		res = []string{"Name", "Accordion_high", "Accordion_low"}
	case AnyType:
		res = []string{"Name", "InnerXML"}
	case Appearance:
		res = []string{"Name", "Line_width", "Note_size", "Distance", "Glyph", "Other_appearance"}
	case Arpeggiate:
		res = []string{"Name"}
	case Arrow:
		res = []string{"Name"}
	case Articulations:
		res = []string{"Name", "Accent", "Strong_accent", "Staccato", "Tenuto", "Detached_legato", "Staccatissimo", "Spiccato", "Scoop", "Plop", "Doit", "Falloff", "Breath_mark", "Caesura", "Stress", "Unstress", "Soft_accent"}
	case Assess:
		res = []string{"Name"}
	case Attributes:
		res = []string{"Name", "Key", "Part_symbol", "Clef", "Staff_details", "Measure_style", "Transpose", "For_part"}
	case Backup:
		res = []string{"Name"}
	case Bar_style_color:
		res = []string{"Name"}
	case Barline:
		res = []string{"Name", "Bar_style", "Wavy_line", "Fermata", "Ending", "Repeat", "Segno", "Coda"}
	case Barre:
		res = []string{"Name"}
	case Bass:
		res = []string{"Name", "Bass_step", "Bass_alter"}
	case Bass_step:
		res = []string{"Name", "Text"}
	case Beam:
		res = []string{"Name"}
	case Beat_repeat:
		res = []string{"Name"}
	case Beat_unit_tied:
		res = []string{"Name"}
	case Beater:
		res = []string{"Name"}
	case Bend:
		res = []string{"Name", "Pre_bend", "Release"}
	case Bookmark:
		res = []string{"Name"}
	case Bracket:
		res = []string{"Name"}
	case Breath_mark:
		res = []string{"Name"}
	case Caesura:
		res = []string{"Name"}
	case Cancel:
		res = []string{"Name"}
	case Clef:
		res = []string{"Name"}
	case Coda:
		res = []string{"Name"}
	case Credit:
		res = []string{"Name", "Link", "Bookmark", "Credit_image"}
	case Dashes:
		res = []string{"Name"}
	case Defaults:
		res = []string{"Name", "Scaling", "Concert_score", "Appearance", "Music_font", "Word_font", "Lyric_font", "Lyric_language"}
	case Degree:
		res = []string{"Name", "Degree_value", "Degree_alter", "Degree_type"}
	case Degree_alter:
		res = []string{"Name"}
	case Degree_type:
		res = []string{"Name", "Text"}
	case Degree_value:
		res = []string{"Name", "Text"}
	case Direction:
		res = []string{"Name", "Direction_type", "Offset", "Sound", "Listening"}
	case Direction_type:
		res = []string{"Name", "Segno", "Coda", "Wedge", "Dynamics", "Dashes", "Bracket", "Pedal", "Metronome", "Octave_shift", "Harp_pedals", "Damp", "Damp_all", "Eyeglasses", "String_mute", "Scordatura", "Image", "Principal_voice", "Percussion", "Accordion_registration", "Staff_divide"}
	case Distance:
		res = []string{"Name"}
	case Double:
		res = []string{"Name"}
	case Dynamics:
		res = []string{"Name", "P", "Pp", "Ppp", "Pppp", "Ppppp", "Pppppp", "F", "Ff", "Fff", "Ffff", "Fffff", "Ffffff", "Mp", "Mf", "Sf", "Sfp", "Sfpp", "Fp", "Rf", "Rfz", "Sfz", "Sffz", "Fz", "N", "Pf", "Sfzp"}
	case Effect:
		res = []string{"Name"}
	case Elision:
		res = []string{"Name", "Value"}
	case Empty:
		res = []string{"Name"}
	case Empty_font:
		res = []string{"Name"}
	case Empty_line:
		res = []string{"Name"}
	case Empty_placement:
		res = []string{"Name"}
	case Empty_placement_smufl:
		res = []string{"Name"}
	case Empty_print_object_style_align:
		res = []string{"Name"}
	case Empty_print_style:
		res = []string{"Name"}
	case Empty_print_style_align:
		res = []string{"Name"}
	case Empty_print_style_align_id:
		res = []string{"Name"}
	case Empty_trill_sound:
		res = []string{"Name"}
	case Encoding:
		res = []string{"Name", "Encoder", "Software", "Encoding_description", "Supports"}
	case Ending:
		res = []string{"Name", "Value"}
	case Extend:
		res = []string{"Name"}
	case Feature:
		res = []string{"Name", "Value", "Type"}
	case Fermata:
		res = []string{"Name"}
	case Figure:
		res = []string{"Name", "Extend"}
	case Figured_bass:
		res = []string{"Name", "Figure"}
	case Fingering:
		res = []string{"Name", "Value"}
	case First_fret:
		res = []string{"Name", "Text"}
	case Foo:
		res = []string{"Name"}
	case For_part:
		res = []string{"Name", "Part_clef", "Part_transpose"}
	case Formatted_symbol:
		res = []string{"Name"}
	case Formatted_symbol_id:
		res = []string{"Name"}
	case Forward:
		res = []string{"Name"}
	case Frame:
		res = []string{"Name", "First_fret", "Frame_note", "Unplayed"}
	case Frame_note:
		res = []string{"Name", "Astring", "Fret", "Fingering", "Barre"}
	case Fret:
		res = []string{"Name"}
	case Glass:
		res = []string{"Name"}
	case Glissando:
		res = []string{"Name", "Value"}
	case Glyph:
		res = []string{"Name"}
	case Grace:
		res = []string{"Name"}
	case Group_barline:
		res = []string{"Name"}
	case Group_symbol:
		res = []string{"Name"}
	case Grouping:
		res = []string{"Name", "Feature", "Number", "Member_of"}
	case Hammer_on_pull_off:
		res = []string{"Name", "Value"}
	case Handbell:
		res = []string{"Name"}
	case Harmon_closed:
		res = []string{"Name"}
	case Harmon_mute:
		res = []string{"Name", "Harmon_closed"}
	case Harmonic:
		res = []string{"Name", "Natural", "Artificial", "Base_pitch", "Touching_pitch", "Sounding_pitch"}
	case Harmony:
		res = []string{"Name", "Frame", "Offset"}
	case Harmony_alter:
		res = []string{"Name"}
	case Harp_pedals:
		res = []string{"Name", "Pedal_tuning"}
	case Heel_toe:
		res = []string{"Name"}
	case Hole:
		res = []string{"Name", "Hole_type", "Hole_closed", "Hole_shape"}
	case Hole_closed:
		res = []string{"Name"}
	case Horizontal_turn:
		res = []string{"Name"}
	case Identification:
		res = []string{"Name", "Creator", "Rights", "Encoding", "Source", "Relation", "Miscellaneous"}
	case Image:
		res = []string{"Name"}
	case Instrument:
		res = []string{"Name"}
	case Instrument_change:
		res = []string{"Name"}
	case Instrument_link:
		res = []string{"Name"}
	case Interchangeable:
		res = []string{"Name"}
	case Inversion:
		res = []string{"Name", "Text"}
	case Key:
		res = []string{"Name", "Key_octave"}
	case Key_accidental:
		res = []string{"Name"}
	case Key_octave:
		res = []string{"Name"}
	case Kind:
		res = []string{"Name", "Text"}
	case Level:
		res = []string{"Name", "Value"}
	case Line_detail:
		res = []string{"Name"}
	case Line_width:
		res = []string{"Name"}
	case Link:
		res = []string{"Name"}
	case Listen:
		res = []string{"Name", "Assess", "Wait", "Other_listen"}
	case Listening:
		res = []string{"Name", "Offset", "Sync", "Other_listening"}
	case Lyric:
		res = []string{"End_line", "End_paragraph", "Extend", "Laughing", "Humming", "Name"}
	case Lyric_font:
		res = []string{"Name"}
	case Lyric_language:
		res = []string{"Name", "EmptyString"}
	case Measure_layout:
		res = []string{"Name"}
	case Measure_numbering:
		res = []string{"Name"}
	case Measure_repeat:
		res = []string{"Name"}
	case Measure_style:
		res = []string{"Name", "Multiple_rest", "Measure_repeat", "Beat_repeat", "Slash"}
	case Membrane:
		res = []string{"Name"}
	case Metal:
		res = []string{"Name"}
	case Metronome:
		res = []string{"Name"}
	case Metronome_beam:
		res = []string{"Name"}
	case Metronome_note:
		res = []string{"Name", "Metronome_dot", "Metronome_beam", "Metronome_tied", "Metronome_tuplet"}
	case Metronome_tied:
		res = []string{"Name"}
	case Metronome_tuplet:
		res = []string{"Name"}
	case Midi_device:
		res = []string{"Name", "Value"}
	case Midi_instrument:
		res = []string{"Name", "Midi_name"}
	case Miscellaneous:
		res = []string{"Name", "Miscellaneous_field"}
	case Miscellaneous_field:
		res = []string{"Value", "Name"}
	case Mordent:
		res = []string{"Name"}
	case Multiple_rest:
		res = []string{"Name"}
	case Name_display:
		res = []string{"Name", "Accidental_text"}
	case Non_arpeggiate:
		res = []string{"Name"}
	case Notations:
		res = []string{"Name", "Tied", "Slur", "Tuplet", "Glissando", "Slide", "Ornaments", "Technical", "Articulations", "Dynamics", "Fermata", "Arpeggiate", "Non_arpeggiate", "Accidental_mark", "Other_notation"}
	case Note:
		res = []string{"Name", "Instrument", "Type_", "Dot", "Accidental", "Time_modification", "Stem", "Notehead", "Notehead_text", "Beam", "Notations", "Lyric", "Play", "Listen"}
	case Note_size:
		res = []string{"Name"}
	case Note_type:
		res = []string{"Name"}
	case Notehead:
		res = []string{"Name"}
	case Notehead_text:
		res = []string{"Name", "Accidental_text"}
	case Numeral:
		res = []string{"Name", "Numeral_root", "Numeral_alter", "Numeral_key"}
	case Numeral_key:
		res = []string{"Name"}
	case Numeral_root:
		res = []string{"Name", "Text"}
	case Octave_shift:
		res = []string{"Name"}
	case Offset:
		res = []string{"Name"}
	case Opus:
		res = []string{"Name"}
	case Ornaments:
		res = []string{"Name", "Accidental_mark", "Trill_mark", "Turn", "Delayed_turn", "Inverted_turn", "Delayed_inverted_turn", "Vertical_turn", "Inverted_vertical_turn", "Shake", "Wavy_line", "Mordent", "Inverted_mordent", "Schleifer", "Tremolo", "Haydn"}
	case Other_appearance:
		res = []string{"Name", "Value", "Type"}
	case Other_listening:
		res = []string{"Name", "Value", "Type"}
	case Other_notation:
		res = []string{"Name", "Value"}
	case Other_play:
		res = []string{"Name", "Value", "Type"}
	case Page_layout:
		res = []string{"Name", "Page_margins"}
	case Page_margins:
		res = []string{"Name"}
	case Part_clef:
		res = []string{"Name"}
	case Part_group:
		res = []string{"Name", "Group_name_display", "Group_abbreviation_display", "Group_symbol", "Group_barline", "Group_time", "Number"}
	case Part_link:
		res = []string{"Name", "Instrument_link"}
	case Part_list:
		res = []string{"Name"}
	case Part_symbol:
		res = []string{"Name"}
	case Part_transpose:
		res = []string{"Name"}
	case Pedal:
		res = []string{"Name"}
	case Pedal_tuning:
		res = []string{"Name"}
	case Percussion:
		res = []string{"Name", "Glass", "Metal", "Wood", "Pitched", "Membrane", "Effect", "Timpani", "Beater", "Stick"}
	case Pitch:
		res = []string{"Name"}
	case Pitched:
		res = []string{"Name"}
	case Play:
		res = []string{"Name", "Ipa", "Other_play"}
	case Player:
		res = []string{"Name", "Player_name"}
	case Principal_voice:
		res = []string{"Name", "Value"}
	case Print:
		res = []string{"Name", "Measure_layout", "Measure_numbering", "Part_name_display", "Part_abbreviation_display"}
	case Release:
		res = []string{"Name"}
	case Repeat:
		res = []string{"Name"}
	case Rest:
		res = []string{"Name"}
	case Root:
		res = []string{"Name", "Root_step", "Root_alter"}
	case Root_step:
		res = []string{"Name", "Text"}
	case Scaling:
		res = []string{"Name"}
	case Scordatura:
		res = []string{"Name", "Accord"}
	case Score_instrument:
		res = []string{"Name", "Instrument_name", "Instrument_abbreviation"}
	case Score_part:
		res = []string{"Name", "Identification", "Part_link", "Part_name_display", "Part_abbreviation_display", "Score_instrument", "Player"}
	case Score_partwise:
		res = []string{"Name"}
	case Score_timewise:
		res = []string{"Name"}
	case Segno:
		res = []string{"Name"}
	case Slash:
		res = []string{"Name"}
	case Slide:
		res = []string{"Name", "Value"}
	case Slur:
		res = []string{"Name"}
	case Sound:
		res = []string{"Name", "Swing", "Offset", "Segno", "Dalsegno", "Coda", "Tocoda", "Fine"}
	case Staff_details:
		res = []string{"Name", "Staff_tuning", "Staff_size"}
	case Staff_divide:
		res = []string{"Name"}
	case Staff_layout:
		res = []string{"Name"}
	case Staff_size:
		res = []string{"Name"}
	case Staff_tuning:
		res = []string{"Name"}
	case Stem:
		res = []string{"Name"}
	case Stick:
		res = []string{"Name"}
	case String_mute:
		res = []string{"Name"}
	case Strong_accent:
		res = []string{"Name"}
	case Supports:
		res = []string{"Name", "Value"}
	case Swing:
		res = []string{"Name", "Swing_style", "Straight"}
	case Sync:
		res = []string{"Name"}
	case System_dividers:
		res = []string{"Name", "Left_divider", "Right_divider"}
	case System_layout:
		res = []string{"Name", "System_margins", "System_dividers"}
	case System_margins:
		res = []string{"Name"}
	case Tap:
		res = []string{"Name", "Value"}
	case Technical:
		res = []string{"Name", "Up_bow", "Down_bow", "Harmonic", "Open_string", "Thumb_position", "Fingering", "Double_tongue", "Triple_tongue", "Stopped", "Snap_pizzicato", "Fret", "Astring", "Hammer_on", "Pull_off", "Bend", "Tap", "Heel", "Toe", "Fingernails", "Hole", "Arrow", "Handbell", "Brass_bend", "Flip", "Smear", "Open", "Half_muted", "Harmon_mute", "Golpe"}
	case Text_element_data:
		res = []string{"Name", "Value", "EmptyString"}
	case Tie:
		res = []string{"Name"}
	case Tied:
		res = []string{"Name"}
	case Time:
		res = []string{"Name", "Senza_misura"}
	case Time_modification:
		res = []string{"Name"}
	case Timpani:
		res = []string{"Name"}
	case Transpose:
		res = []string{"Name"}
	case Tremolo:
		res = []string{"Name"}
	case Tuplet:
		res = []string{"Name", "Tuplet_actual", "Tuplet_normal"}
	case Tuplet_dot:
		res = []string{"Name"}
	case Tuplet_number:
		res = []string{"Name"}
	case Tuplet_portion:
		res = []string{"Name", "Tuplet_number", "Tuplet_type", "Tuplet_dot"}
	case Tuplet_type:
		res = []string{"Name"}
	case Typed_text:
		res = []string{"Name", "Value", "Type"}
	case Unpitched:
		res = []string{"Name"}
	case Virtual_instrument:
		res = []string{"Name", "Virtual_library", "Virtual_name"}
	case Wait:
		res = []string{"Name"}
	case Wavy_line:
		res = []string{"Name"}
	case Wedge:
		res = []string{"Name"}
	case Wood:
		res = []string{"Name"}
	case Work:
		res = []string{"Name", "Work_number", "Work_title", "Opus"}
	}
	return
}

type ReverseField struct {
	GongstructName string
	Fieldname      string
}

func GetReverseFields[Type Gongstruct]() (res []ReverseField) {

	res = make([]ReverseField, 0)

	var ret Type

	switch any(ret).(type) {

	// insertion point for generic get gongstruct name
	case Accidental:
		var rf ReverseField
		_ = rf
	case Accidental_mark:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Ornaments"
		rf.Fieldname = "Accidental_mark"
		res = append(res, rf)
	case Accidental_text:
		var rf ReverseField
		_ = rf
	case Accord:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Scordatura"
		rf.Fieldname = "Accord"
		res = append(res, rf)
	case Accordion_registration:
		var rf ReverseField
		_ = rf
	case AnyType:
		var rf ReverseField
		_ = rf
	case Appearance:
		var rf ReverseField
		_ = rf
	case Arpeggiate:
		var rf ReverseField
		_ = rf
	case Arrow:
		var rf ReverseField
		_ = rf
	case Articulations:
		var rf ReverseField
		_ = rf
	case Assess:
		var rf ReverseField
		_ = rf
	case Attributes:
		var rf ReverseField
		_ = rf
	case Backup:
		var rf ReverseField
		_ = rf
	case Bar_style_color:
		var rf ReverseField
		_ = rf
	case Barline:
		var rf ReverseField
		_ = rf
	case Barre:
		var rf ReverseField
		_ = rf
	case Bass:
		var rf ReverseField
		_ = rf
	case Bass_step:
		var rf ReverseField
		_ = rf
	case Beam:
		var rf ReverseField
		_ = rf
	case Beat_repeat:
		var rf ReverseField
		_ = rf
	case Beat_unit_tied:
		var rf ReverseField
		_ = rf
	case Beater:
		var rf ReverseField
		_ = rf
	case Bend:
		var rf ReverseField
		_ = rf
	case Bookmark:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Credit"
		rf.Fieldname = "Bookmark"
		res = append(res, rf)
	case Bracket:
		var rf ReverseField
		_ = rf
	case Breath_mark:
		var rf ReverseField
		_ = rf
	case Caesura:
		var rf ReverseField
		_ = rf
	case Cancel:
		var rf ReverseField
		_ = rf
	case Clef:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Attributes"
		rf.Fieldname = "Clef"
		res = append(res, rf)
	case Coda:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Direction_type"
		rf.Fieldname = "Coda"
		res = append(res, rf)
	case Credit:
		var rf ReverseField
		_ = rf
	case Dashes:
		var rf ReverseField
		_ = rf
	case Defaults:
		var rf ReverseField
		_ = rf
	case Degree:
		var rf ReverseField
		_ = rf
	case Degree_alter:
		var rf ReverseField
		_ = rf
	case Degree_type:
		var rf ReverseField
		_ = rf
	case Degree_value:
		var rf ReverseField
		_ = rf
	case Direction:
		var rf ReverseField
		_ = rf
	case Direction_type:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Direction"
		rf.Fieldname = "Direction_type"
		res = append(res, rf)
	case Distance:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Appearance"
		rf.Fieldname = "Distance"
		res = append(res, rf)
	case Double:
		var rf ReverseField
		_ = rf
	case Dynamics:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Direction_type"
		rf.Fieldname = "Dynamics"
		res = append(res, rf)
	case Effect:
		var rf ReverseField
		_ = rf
	case Elision:
		var rf ReverseField
		_ = rf
	case Empty:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Metronome_note"
		rf.Fieldname = "Metronome_dot"
		res = append(res, rf)
	case Empty_font:
		var rf ReverseField
		_ = rf
	case Empty_line:
		var rf ReverseField
		_ = rf
	case Empty_placement:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Note"
		rf.Fieldname = "Dot"
		res = append(res, rf)
	case Empty_placement_smufl:
		var rf ReverseField
		_ = rf
	case Empty_print_object_style_align:
		var rf ReverseField
		_ = rf
	case Empty_print_style:
		var rf ReverseField
		_ = rf
	case Empty_print_style_align:
		var rf ReverseField
		_ = rf
	case Empty_print_style_align_id:
		var rf ReverseField
		_ = rf
	case Empty_trill_sound:
		var rf ReverseField
		_ = rf
	case Encoding:
		var rf ReverseField
		_ = rf
	case Ending:
		var rf ReverseField
		_ = rf
	case Extend:
		var rf ReverseField
		_ = rf
	case Feature:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Grouping"
		rf.Fieldname = "Feature"
		res = append(res, rf)
	case Fermata:
		var rf ReverseField
		_ = rf
	case Figure:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Figured_bass"
		rf.Fieldname = "Figure"
		res = append(res, rf)
	case Figured_bass:
		var rf ReverseField
		_ = rf
	case Fingering:
		var rf ReverseField
		_ = rf
	case First_fret:
		var rf ReverseField
		_ = rf
	case Foo:
		var rf ReverseField
		_ = rf
	case For_part:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Attributes"
		rf.Fieldname = "For_part"
		res = append(res, rf)
	case Formatted_symbol:
		var rf ReverseField
		_ = rf
	case Formatted_symbol_id:
		var rf ReverseField
		_ = rf
	case Forward:
		var rf ReverseField
		_ = rf
	case Frame:
		var rf ReverseField
		_ = rf
	case Frame_note:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Frame"
		rf.Fieldname = "Frame_note"
		res = append(res, rf)
	case Fret:
		var rf ReverseField
		_ = rf
	case Glass:
		var rf ReverseField
		_ = rf
	case Glissando:
		var rf ReverseField
		_ = rf
	case Glyph:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Appearance"
		rf.Fieldname = "Glyph"
		res = append(res, rf)
	case Grace:
		var rf ReverseField
		_ = rf
	case Group_barline:
		var rf ReverseField
		_ = rf
	case Group_symbol:
		var rf ReverseField
		_ = rf
	case Grouping:
		var rf ReverseField
		_ = rf
	case Hammer_on_pull_off:
		var rf ReverseField
		_ = rf
	case Handbell:
		var rf ReverseField
		_ = rf
	case Harmon_closed:
		var rf ReverseField
		_ = rf
	case Harmon_mute:
		var rf ReverseField
		_ = rf
	case Harmonic:
		var rf ReverseField
		_ = rf
	case Harmony:
		var rf ReverseField
		_ = rf
	case Harmony_alter:
		var rf ReverseField
		_ = rf
	case Harp_pedals:
		var rf ReverseField
		_ = rf
	case Heel_toe:
		var rf ReverseField
		_ = rf
	case Hole:
		var rf ReverseField
		_ = rf
	case Hole_closed:
		var rf ReverseField
		_ = rf
	case Horizontal_turn:
		var rf ReverseField
		_ = rf
	case Identification:
		var rf ReverseField
		_ = rf
	case Image:
		var rf ReverseField
		_ = rf
	case Instrument:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Note"
		rf.Fieldname = "Instrument"
		res = append(res, rf)
	case Instrument_change:
		var rf ReverseField
		_ = rf
	case Instrument_link:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Part_link"
		rf.Fieldname = "Instrument_link"
		res = append(res, rf)
	case Interchangeable:
		var rf ReverseField
		_ = rf
	case Inversion:
		var rf ReverseField
		_ = rf
	case Key:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Attributes"
		rf.Fieldname = "Key"
		res = append(res, rf)
	case Key_accidental:
		var rf ReverseField
		_ = rf
	case Key_octave:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Key"
		rf.Fieldname = "Key_octave"
		res = append(res, rf)
	case Kind:
		var rf ReverseField
		_ = rf
	case Level:
		var rf ReverseField
		_ = rf
	case Line_detail:
		var rf ReverseField
		_ = rf
	case Line_width:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Appearance"
		rf.Fieldname = "Line_width"
		res = append(res, rf)
	case Link:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Credit"
		rf.Fieldname = "Link"
		res = append(res, rf)
	case Listen:
		var rf ReverseField
		_ = rf
	case Listening:
		var rf ReverseField
		_ = rf
	case Lyric:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Note"
		rf.Fieldname = "Lyric"
		res = append(res, rf)
	case Lyric_font:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Defaults"
		rf.Fieldname = "Lyric_font"
		res = append(res, rf)
	case Lyric_language:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Defaults"
		rf.Fieldname = "Lyric_language"
		res = append(res, rf)
	case Measure_layout:
		var rf ReverseField
		_ = rf
	case Measure_numbering:
		var rf ReverseField
		_ = rf
	case Measure_repeat:
		var rf ReverseField
		_ = rf
	case Measure_style:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Attributes"
		rf.Fieldname = "Measure_style"
		res = append(res, rf)
	case Membrane:
		var rf ReverseField
		_ = rf
	case Metal:
		var rf ReverseField
		_ = rf
	case Metronome:
		var rf ReverseField
		_ = rf
	case Metronome_beam:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Metronome_note"
		rf.Fieldname = "Metronome_beam"
		res = append(res, rf)
	case Metronome_note:
		var rf ReverseField
		_ = rf
	case Metronome_tied:
		var rf ReverseField
		_ = rf
	case Metronome_tuplet:
		var rf ReverseField
		_ = rf
	case Midi_device:
		var rf ReverseField
		_ = rf
	case Midi_instrument:
		var rf ReverseField
		_ = rf
	case Miscellaneous:
		var rf ReverseField
		_ = rf
	case Miscellaneous_field:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Miscellaneous"
		rf.Fieldname = "Miscellaneous_field"
		res = append(res, rf)
	case Mordent:
		var rf ReverseField
		_ = rf
	case Multiple_rest:
		var rf ReverseField
		_ = rf
	case Name_display:
		var rf ReverseField
		_ = rf
	case Non_arpeggiate:
		var rf ReverseField
		_ = rf
	case Notations:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Note"
		rf.Fieldname = "Notations"
		res = append(res, rf)
	case Note:
		var rf ReverseField
		_ = rf
	case Note_size:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Appearance"
		rf.Fieldname = "Note_size"
		res = append(res, rf)
	case Note_type:
		var rf ReverseField
		_ = rf
	case Notehead:
		var rf ReverseField
		_ = rf
	case Notehead_text:
		var rf ReverseField
		_ = rf
	case Numeral:
		var rf ReverseField
		_ = rf
	case Numeral_key:
		var rf ReverseField
		_ = rf
	case Numeral_root:
		var rf ReverseField
		_ = rf
	case Octave_shift:
		var rf ReverseField
		_ = rf
	case Offset:
		var rf ReverseField
		_ = rf
	case Opus:
		var rf ReverseField
		_ = rf
	case Ornaments:
		var rf ReverseField
		_ = rf
	case Other_appearance:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Appearance"
		rf.Fieldname = "Other_appearance"
		res = append(res, rf)
	case Other_listening:
		var rf ReverseField
		_ = rf
	case Other_notation:
		var rf ReverseField
		_ = rf
	case Other_play:
		var rf ReverseField
		_ = rf
	case Page_layout:
		var rf ReverseField
		_ = rf
	case Page_margins:
		var rf ReverseField
		_ = rf
	case Part_clef:
		var rf ReverseField
		_ = rf
	case Part_group:
		var rf ReverseField
		_ = rf
	case Part_link:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Score_part"
		rf.Fieldname = "Part_link"
		res = append(res, rf)
	case Part_list:
		var rf ReverseField
		_ = rf
	case Part_symbol:
		var rf ReverseField
		_ = rf
	case Part_transpose:
		var rf ReverseField
		_ = rf
	case Pedal:
		var rf ReverseField
		_ = rf
	case Pedal_tuning:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Harp_pedals"
		rf.Fieldname = "Pedal_tuning"
		res = append(res, rf)
	case Percussion:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Direction_type"
		rf.Fieldname = "Percussion"
		res = append(res, rf)
	case Pitch:
		var rf ReverseField
		_ = rf
	case Pitched:
		var rf ReverseField
		_ = rf
	case Play:
		var rf ReverseField
		_ = rf
	case Player:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Score_part"
		rf.Fieldname = "Player"
		res = append(res, rf)
	case Principal_voice:
		var rf ReverseField
		_ = rf
	case Print:
		var rf ReverseField
		_ = rf
	case Release:
		var rf ReverseField
		_ = rf
	case Repeat:
		var rf ReverseField
		_ = rf
	case Rest:
		var rf ReverseField
		_ = rf
	case Root:
		var rf ReverseField
		_ = rf
	case Root_step:
		var rf ReverseField
		_ = rf
	case Scaling:
		var rf ReverseField
		_ = rf
	case Scordatura:
		var rf ReverseField
		_ = rf
	case Score_instrument:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Score_part"
		rf.Fieldname = "Score_instrument"
		res = append(res, rf)
	case Score_part:
		var rf ReverseField
		_ = rf
	case Score_partwise:
		var rf ReverseField
		_ = rf
	case Score_timewise:
		var rf ReverseField
		_ = rf
	case Segno:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Direction_type"
		rf.Fieldname = "Segno"
		res = append(res, rf)
	case Slash:
		var rf ReverseField
		_ = rf
	case Slide:
		var rf ReverseField
		_ = rf
	case Slur:
		var rf ReverseField
		_ = rf
	case Sound:
		var rf ReverseField
		_ = rf
	case Staff_details:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Attributes"
		rf.Fieldname = "Staff_details"
		res = append(res, rf)
	case Staff_divide:
		var rf ReverseField
		_ = rf
	case Staff_layout:
		var rf ReverseField
		_ = rf
	case Staff_size:
		var rf ReverseField
		_ = rf
	case Staff_tuning:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Staff_details"
		rf.Fieldname = "Staff_tuning"
		res = append(res, rf)
	case Stem:
		var rf ReverseField
		_ = rf
	case Stick:
		var rf ReverseField
		_ = rf
	case String_mute:
		var rf ReverseField
		_ = rf
	case Strong_accent:
		var rf ReverseField
		_ = rf
	case Supports:
		var rf ReverseField
		_ = rf
	case Swing:
		var rf ReverseField
		_ = rf
	case Sync:
		var rf ReverseField
		_ = rf
	case System_dividers:
		var rf ReverseField
		_ = rf
	case System_layout:
		var rf ReverseField
		_ = rf
	case System_margins:
		var rf ReverseField
		_ = rf
	case Tap:
		var rf ReverseField
		_ = rf
	case Technical:
		var rf ReverseField
		_ = rf
	case Text_element_data:
		var rf ReverseField
		_ = rf
	case Tie:
		var rf ReverseField
		_ = rf
	case Tied:
		var rf ReverseField
		_ = rf
	case Time:
		var rf ReverseField
		_ = rf
	case Time_modification:
		var rf ReverseField
		_ = rf
	case Timpani:
		var rf ReverseField
		_ = rf
	case Transpose:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Attributes"
		rf.Fieldname = "Transpose"
		res = append(res, rf)
	case Tremolo:
		var rf ReverseField
		_ = rf
	case Tuplet:
		var rf ReverseField
		_ = rf
	case Tuplet_dot:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Tuplet_portion"
		rf.Fieldname = "Tuplet_dot"
		res = append(res, rf)
	case Tuplet_number:
		var rf ReverseField
		_ = rf
	case Tuplet_portion:
		var rf ReverseField
		_ = rf
	case Tuplet_type:
		var rf ReverseField
		_ = rf
	case Typed_text:
		var rf ReverseField
		_ = rf
		rf.GongstructName = "Identification"
		rf.Fieldname = "Creator"
		res = append(res, rf)
		rf.GongstructName = "Identification"
		rf.Fieldname = "Rights"
		res = append(res, rf)
		rf.GongstructName = "Identification"
		rf.Fieldname = "Relation"
		res = append(res, rf)
	case Unpitched:
		var rf ReverseField
		_ = rf
	case Virtual_instrument:
		var rf ReverseField
		_ = rf
	case Wait:
		var rf ReverseField
		_ = rf
	case Wavy_line:
		var rf ReverseField
		_ = rf
	case Wedge:
		var rf ReverseField
		_ = rf
	case Wood:
		var rf ReverseField
		_ = rf
	case Work:
		var rf ReverseField
		_ = rf
	}
	return
}

// GetFieldsFromPointer return the array of the fields
func GetFieldsFromPointer[Type PointerToGongstruct]() (res []string) {

	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get gongstruct name
	case *Accidental:
		res = []string{"Name"}
	case *Accidental_mark:
		res = []string{"Name"}
	case *Accidental_text:
		res = []string{"Name"}
	case *Accord:
		res = []string{"Name"}
	case *Accordion_registration:
		res = []string{"Name", "Accordion_high", "Accordion_low"}
	case *AnyType:
		res = []string{"Name", "InnerXML"}
	case *Appearance:
		res = []string{"Name", "Line_width", "Note_size", "Distance", "Glyph", "Other_appearance"}
	case *Arpeggiate:
		res = []string{"Name"}
	case *Arrow:
		res = []string{"Name"}
	case *Articulations:
		res = []string{"Name", "Accent", "Strong_accent", "Staccato", "Tenuto", "Detached_legato", "Staccatissimo", "Spiccato", "Scoop", "Plop", "Doit", "Falloff", "Breath_mark", "Caesura", "Stress", "Unstress", "Soft_accent"}
	case *Assess:
		res = []string{"Name"}
	case *Attributes:
		res = []string{"Name", "Key", "Part_symbol", "Clef", "Staff_details", "Measure_style", "Transpose", "For_part"}
	case *Backup:
		res = []string{"Name"}
	case *Bar_style_color:
		res = []string{"Name"}
	case *Barline:
		res = []string{"Name", "Bar_style", "Wavy_line", "Fermata", "Ending", "Repeat", "Segno", "Coda"}
	case *Barre:
		res = []string{"Name"}
	case *Bass:
		res = []string{"Name", "Bass_step", "Bass_alter"}
	case *Bass_step:
		res = []string{"Name", "Text"}
	case *Beam:
		res = []string{"Name"}
	case *Beat_repeat:
		res = []string{"Name"}
	case *Beat_unit_tied:
		res = []string{"Name"}
	case *Beater:
		res = []string{"Name"}
	case *Bend:
		res = []string{"Name", "Pre_bend", "Release"}
	case *Bookmark:
		res = []string{"Name"}
	case *Bracket:
		res = []string{"Name"}
	case *Breath_mark:
		res = []string{"Name"}
	case *Caesura:
		res = []string{"Name"}
	case *Cancel:
		res = []string{"Name"}
	case *Clef:
		res = []string{"Name"}
	case *Coda:
		res = []string{"Name"}
	case *Credit:
		res = []string{"Name", "Link", "Bookmark", "Credit_image"}
	case *Dashes:
		res = []string{"Name"}
	case *Defaults:
		res = []string{"Name", "Scaling", "Concert_score", "Appearance", "Music_font", "Word_font", "Lyric_font", "Lyric_language"}
	case *Degree:
		res = []string{"Name", "Degree_value", "Degree_alter", "Degree_type"}
	case *Degree_alter:
		res = []string{"Name"}
	case *Degree_type:
		res = []string{"Name", "Text"}
	case *Degree_value:
		res = []string{"Name", "Text"}
	case *Direction:
		res = []string{"Name", "Direction_type", "Offset", "Sound", "Listening"}
	case *Direction_type:
		res = []string{"Name", "Segno", "Coda", "Wedge", "Dynamics", "Dashes", "Bracket", "Pedal", "Metronome", "Octave_shift", "Harp_pedals", "Damp", "Damp_all", "Eyeglasses", "String_mute", "Scordatura", "Image", "Principal_voice", "Percussion", "Accordion_registration", "Staff_divide"}
	case *Distance:
		res = []string{"Name"}
	case *Double:
		res = []string{"Name"}
	case *Dynamics:
		res = []string{"Name", "P", "Pp", "Ppp", "Pppp", "Ppppp", "Pppppp", "F", "Ff", "Fff", "Ffff", "Fffff", "Ffffff", "Mp", "Mf", "Sf", "Sfp", "Sfpp", "Fp", "Rf", "Rfz", "Sfz", "Sffz", "Fz", "N", "Pf", "Sfzp"}
	case *Effect:
		res = []string{"Name"}
	case *Elision:
		res = []string{"Name", "Value"}
	case *Empty:
		res = []string{"Name"}
	case *Empty_font:
		res = []string{"Name"}
	case *Empty_line:
		res = []string{"Name"}
	case *Empty_placement:
		res = []string{"Name"}
	case *Empty_placement_smufl:
		res = []string{"Name"}
	case *Empty_print_object_style_align:
		res = []string{"Name"}
	case *Empty_print_style:
		res = []string{"Name"}
	case *Empty_print_style_align:
		res = []string{"Name"}
	case *Empty_print_style_align_id:
		res = []string{"Name"}
	case *Empty_trill_sound:
		res = []string{"Name"}
	case *Encoding:
		res = []string{"Name", "Encoder", "Software", "Encoding_description", "Supports"}
	case *Ending:
		res = []string{"Name", "Value"}
	case *Extend:
		res = []string{"Name"}
	case *Feature:
		res = []string{"Name", "Value", "Type"}
	case *Fermata:
		res = []string{"Name"}
	case *Figure:
		res = []string{"Name", "Extend"}
	case *Figured_bass:
		res = []string{"Name", "Figure"}
	case *Fingering:
		res = []string{"Name", "Value"}
	case *First_fret:
		res = []string{"Name", "Text"}
	case *Foo:
		res = []string{"Name"}
	case *For_part:
		res = []string{"Name", "Part_clef", "Part_transpose"}
	case *Formatted_symbol:
		res = []string{"Name"}
	case *Formatted_symbol_id:
		res = []string{"Name"}
	case *Forward:
		res = []string{"Name"}
	case *Frame:
		res = []string{"Name", "First_fret", "Frame_note", "Unplayed"}
	case *Frame_note:
		res = []string{"Name", "Astring", "Fret", "Fingering", "Barre"}
	case *Fret:
		res = []string{"Name"}
	case *Glass:
		res = []string{"Name"}
	case *Glissando:
		res = []string{"Name", "Value"}
	case *Glyph:
		res = []string{"Name"}
	case *Grace:
		res = []string{"Name"}
	case *Group_barline:
		res = []string{"Name"}
	case *Group_symbol:
		res = []string{"Name"}
	case *Grouping:
		res = []string{"Name", "Feature", "Number", "Member_of"}
	case *Hammer_on_pull_off:
		res = []string{"Name", "Value"}
	case *Handbell:
		res = []string{"Name"}
	case *Harmon_closed:
		res = []string{"Name"}
	case *Harmon_mute:
		res = []string{"Name", "Harmon_closed"}
	case *Harmonic:
		res = []string{"Name", "Natural", "Artificial", "Base_pitch", "Touching_pitch", "Sounding_pitch"}
	case *Harmony:
		res = []string{"Name", "Frame", "Offset"}
	case *Harmony_alter:
		res = []string{"Name"}
	case *Harp_pedals:
		res = []string{"Name", "Pedal_tuning"}
	case *Heel_toe:
		res = []string{"Name"}
	case *Hole:
		res = []string{"Name", "Hole_type", "Hole_closed", "Hole_shape"}
	case *Hole_closed:
		res = []string{"Name"}
	case *Horizontal_turn:
		res = []string{"Name"}
	case *Identification:
		res = []string{"Name", "Creator", "Rights", "Encoding", "Source", "Relation", "Miscellaneous"}
	case *Image:
		res = []string{"Name"}
	case *Instrument:
		res = []string{"Name"}
	case *Instrument_change:
		res = []string{"Name"}
	case *Instrument_link:
		res = []string{"Name"}
	case *Interchangeable:
		res = []string{"Name"}
	case *Inversion:
		res = []string{"Name", "Text"}
	case *Key:
		res = []string{"Name", "Key_octave"}
	case *Key_accidental:
		res = []string{"Name"}
	case *Key_octave:
		res = []string{"Name"}
	case *Kind:
		res = []string{"Name", "Text"}
	case *Level:
		res = []string{"Name", "Value"}
	case *Line_detail:
		res = []string{"Name"}
	case *Line_width:
		res = []string{"Name"}
	case *Link:
		res = []string{"Name"}
	case *Listen:
		res = []string{"Name", "Assess", "Wait", "Other_listen"}
	case *Listening:
		res = []string{"Name", "Offset", "Sync", "Other_listening"}
	case *Lyric:
		res = []string{"End_line", "End_paragraph", "Extend", "Laughing", "Humming", "Name"}
	case *Lyric_font:
		res = []string{"Name"}
	case *Lyric_language:
		res = []string{"Name", "EmptyString"}
	case *Measure_layout:
		res = []string{"Name"}
	case *Measure_numbering:
		res = []string{"Name"}
	case *Measure_repeat:
		res = []string{"Name"}
	case *Measure_style:
		res = []string{"Name", "Multiple_rest", "Measure_repeat", "Beat_repeat", "Slash"}
	case *Membrane:
		res = []string{"Name"}
	case *Metal:
		res = []string{"Name"}
	case *Metronome:
		res = []string{"Name"}
	case *Metronome_beam:
		res = []string{"Name"}
	case *Metronome_note:
		res = []string{"Name", "Metronome_dot", "Metronome_beam", "Metronome_tied", "Metronome_tuplet"}
	case *Metronome_tied:
		res = []string{"Name"}
	case *Metronome_tuplet:
		res = []string{"Name"}
	case *Midi_device:
		res = []string{"Name", "Value"}
	case *Midi_instrument:
		res = []string{"Name", "Midi_name"}
	case *Miscellaneous:
		res = []string{"Name", "Miscellaneous_field"}
	case *Miscellaneous_field:
		res = []string{"Value", "Name"}
	case *Mordent:
		res = []string{"Name"}
	case *Multiple_rest:
		res = []string{"Name"}
	case *Name_display:
		res = []string{"Name", "Accidental_text"}
	case *Non_arpeggiate:
		res = []string{"Name"}
	case *Notations:
		res = []string{"Name", "Tied", "Slur", "Tuplet", "Glissando", "Slide", "Ornaments", "Technical", "Articulations", "Dynamics", "Fermata", "Arpeggiate", "Non_arpeggiate", "Accidental_mark", "Other_notation"}
	case *Note:
		res = []string{"Name", "Instrument", "Type_", "Dot", "Accidental", "Time_modification", "Stem", "Notehead", "Notehead_text", "Beam", "Notations", "Lyric", "Play", "Listen"}
	case *Note_size:
		res = []string{"Name"}
	case *Note_type:
		res = []string{"Name"}
	case *Notehead:
		res = []string{"Name"}
	case *Notehead_text:
		res = []string{"Name", "Accidental_text"}
	case *Numeral:
		res = []string{"Name", "Numeral_root", "Numeral_alter", "Numeral_key"}
	case *Numeral_key:
		res = []string{"Name"}
	case *Numeral_root:
		res = []string{"Name", "Text"}
	case *Octave_shift:
		res = []string{"Name"}
	case *Offset:
		res = []string{"Name"}
	case *Opus:
		res = []string{"Name"}
	case *Ornaments:
		res = []string{"Name", "Accidental_mark", "Trill_mark", "Turn", "Delayed_turn", "Inverted_turn", "Delayed_inverted_turn", "Vertical_turn", "Inverted_vertical_turn", "Shake", "Wavy_line", "Mordent", "Inverted_mordent", "Schleifer", "Tremolo", "Haydn"}
	case *Other_appearance:
		res = []string{"Name", "Value", "Type"}
	case *Other_listening:
		res = []string{"Name", "Value", "Type"}
	case *Other_notation:
		res = []string{"Name", "Value"}
	case *Other_play:
		res = []string{"Name", "Value", "Type"}
	case *Page_layout:
		res = []string{"Name", "Page_margins"}
	case *Page_margins:
		res = []string{"Name"}
	case *Part_clef:
		res = []string{"Name"}
	case *Part_group:
		res = []string{"Name", "Group_name_display", "Group_abbreviation_display", "Group_symbol", "Group_barline", "Group_time", "Number"}
	case *Part_link:
		res = []string{"Name", "Instrument_link"}
	case *Part_list:
		res = []string{"Name"}
	case *Part_symbol:
		res = []string{"Name"}
	case *Part_transpose:
		res = []string{"Name"}
	case *Pedal:
		res = []string{"Name"}
	case *Pedal_tuning:
		res = []string{"Name"}
	case *Percussion:
		res = []string{"Name", "Glass", "Metal", "Wood", "Pitched", "Membrane", "Effect", "Timpani", "Beater", "Stick"}
	case *Pitch:
		res = []string{"Name"}
	case *Pitched:
		res = []string{"Name"}
	case *Play:
		res = []string{"Name", "Ipa", "Other_play"}
	case *Player:
		res = []string{"Name", "Player_name"}
	case *Principal_voice:
		res = []string{"Name", "Value"}
	case *Print:
		res = []string{"Name", "Measure_layout", "Measure_numbering", "Part_name_display", "Part_abbreviation_display"}
	case *Release:
		res = []string{"Name"}
	case *Repeat:
		res = []string{"Name"}
	case *Rest:
		res = []string{"Name"}
	case *Root:
		res = []string{"Name", "Root_step", "Root_alter"}
	case *Root_step:
		res = []string{"Name", "Text"}
	case *Scaling:
		res = []string{"Name"}
	case *Scordatura:
		res = []string{"Name", "Accord"}
	case *Score_instrument:
		res = []string{"Name", "Instrument_name", "Instrument_abbreviation"}
	case *Score_part:
		res = []string{"Name", "Identification", "Part_link", "Part_name_display", "Part_abbreviation_display", "Score_instrument", "Player"}
	case *Score_partwise:
		res = []string{"Name"}
	case *Score_timewise:
		res = []string{"Name"}
	case *Segno:
		res = []string{"Name"}
	case *Slash:
		res = []string{"Name"}
	case *Slide:
		res = []string{"Name", "Value"}
	case *Slur:
		res = []string{"Name"}
	case *Sound:
		res = []string{"Name", "Swing", "Offset", "Segno", "Dalsegno", "Coda", "Tocoda", "Fine"}
	case *Staff_details:
		res = []string{"Name", "Staff_tuning", "Staff_size"}
	case *Staff_divide:
		res = []string{"Name"}
	case *Staff_layout:
		res = []string{"Name"}
	case *Staff_size:
		res = []string{"Name"}
	case *Staff_tuning:
		res = []string{"Name"}
	case *Stem:
		res = []string{"Name"}
	case *Stick:
		res = []string{"Name"}
	case *String_mute:
		res = []string{"Name"}
	case *Strong_accent:
		res = []string{"Name"}
	case *Supports:
		res = []string{"Name", "Value"}
	case *Swing:
		res = []string{"Name", "Swing_style", "Straight"}
	case *Sync:
		res = []string{"Name"}
	case *System_dividers:
		res = []string{"Name", "Left_divider", "Right_divider"}
	case *System_layout:
		res = []string{"Name", "System_margins", "System_dividers"}
	case *System_margins:
		res = []string{"Name"}
	case *Tap:
		res = []string{"Name", "Value"}
	case *Technical:
		res = []string{"Name", "Up_bow", "Down_bow", "Harmonic", "Open_string", "Thumb_position", "Fingering", "Double_tongue", "Triple_tongue", "Stopped", "Snap_pizzicato", "Fret", "Astring", "Hammer_on", "Pull_off", "Bend", "Tap", "Heel", "Toe", "Fingernails", "Hole", "Arrow", "Handbell", "Brass_bend", "Flip", "Smear", "Open", "Half_muted", "Harmon_mute", "Golpe"}
	case *Text_element_data:
		res = []string{"Name", "Value", "EmptyString"}
	case *Tie:
		res = []string{"Name"}
	case *Tied:
		res = []string{"Name"}
	case *Time:
		res = []string{"Name", "Senza_misura"}
	case *Time_modification:
		res = []string{"Name"}
	case *Timpani:
		res = []string{"Name"}
	case *Transpose:
		res = []string{"Name"}
	case *Tremolo:
		res = []string{"Name"}
	case *Tuplet:
		res = []string{"Name", "Tuplet_actual", "Tuplet_normal"}
	case *Tuplet_dot:
		res = []string{"Name"}
	case *Tuplet_number:
		res = []string{"Name"}
	case *Tuplet_portion:
		res = []string{"Name", "Tuplet_number", "Tuplet_type", "Tuplet_dot"}
	case *Tuplet_type:
		res = []string{"Name"}
	case *Typed_text:
		res = []string{"Name", "Value", "Type"}
	case *Unpitched:
		res = []string{"Name"}
	case *Virtual_instrument:
		res = []string{"Name", "Virtual_library", "Virtual_name"}
	case *Wait:
		res = []string{"Name"}
	case *Wavy_line:
		res = []string{"Name"}
	case *Wedge:
		res = []string{"Name"}
	case *Wood:
		res = []string{"Name"}
	case *Work:
		res = []string{"Name", "Work_number", "Work_title", "Opus"}
	}
	return
}

func GetFieldStringValueFromPointer[Type PointerToGongstruct](instance Type, fieldName string) (res string) {

	switch inferedInstance := any(instance).(type) {
	// insertion point for generic get gongstruct field value
	case *Accidental:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Accidental_mark:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Accidental_text:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Accord:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Accordion_registration:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accordion_high":
			if inferedInstance.Accordion_high != nil {
				res = inferedInstance.Accordion_high.Name
			}
		case "Accordion_low":
			if inferedInstance.Accordion_low != nil {
				res = inferedInstance.Accordion_low.Name
			}
		}
	case *AnyType:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "InnerXML":
			res = inferedInstance.InnerXML
		}
	case *Appearance:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Line_width":
			for idx, __instance__ := range inferedInstance.Line_width {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Note_size":
			for idx, __instance__ := range inferedInstance.Note_size {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Distance":
			for idx, __instance__ := range inferedInstance.Distance {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Glyph":
			for idx, __instance__ := range inferedInstance.Glyph {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Other_appearance":
			for idx, __instance__ := range inferedInstance.Other_appearance {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case *Arpeggiate:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Arrow:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Articulations:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accent":
			if inferedInstance.Accent != nil {
				res = inferedInstance.Accent.Name
			}
		case "Strong_accent":
			if inferedInstance.Strong_accent != nil {
				res = inferedInstance.Strong_accent.Name
			}
		case "Staccato":
			if inferedInstance.Staccato != nil {
				res = inferedInstance.Staccato.Name
			}
		case "Tenuto":
			if inferedInstance.Tenuto != nil {
				res = inferedInstance.Tenuto.Name
			}
		case "Detached_legato":
			if inferedInstance.Detached_legato != nil {
				res = inferedInstance.Detached_legato.Name
			}
		case "Staccatissimo":
			if inferedInstance.Staccatissimo != nil {
				res = inferedInstance.Staccatissimo.Name
			}
		case "Spiccato":
			if inferedInstance.Spiccato != nil {
				res = inferedInstance.Spiccato.Name
			}
		case "Scoop":
			if inferedInstance.Scoop != nil {
				res = inferedInstance.Scoop.Name
			}
		case "Plop":
			if inferedInstance.Plop != nil {
				res = inferedInstance.Plop.Name
			}
		case "Doit":
			if inferedInstance.Doit != nil {
				res = inferedInstance.Doit.Name
			}
		case "Falloff":
			if inferedInstance.Falloff != nil {
				res = inferedInstance.Falloff.Name
			}
		case "Breath_mark":
			if inferedInstance.Breath_mark != nil {
				res = inferedInstance.Breath_mark.Name
			}
		case "Caesura":
			if inferedInstance.Caesura != nil {
				res = inferedInstance.Caesura.Name
			}
		case "Stress":
			if inferedInstance.Stress != nil {
				res = inferedInstance.Stress.Name
			}
		case "Unstress":
			if inferedInstance.Unstress != nil {
				res = inferedInstance.Unstress.Name
			}
		case "Soft_accent":
			if inferedInstance.Soft_accent != nil {
				res = inferedInstance.Soft_accent.Name
			}
		}
	case *Assess:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Attributes:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Key":
			for idx, __instance__ := range inferedInstance.Key {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Part_symbol":
			if inferedInstance.Part_symbol != nil {
				res = inferedInstance.Part_symbol.Name
			}
		case "Clef":
			for idx, __instance__ := range inferedInstance.Clef {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Staff_details":
			for idx, __instance__ := range inferedInstance.Staff_details {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Measure_style":
			for idx, __instance__ := range inferedInstance.Measure_style {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Transpose":
			for idx, __instance__ := range inferedInstance.Transpose {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "For_part":
			for idx, __instance__ := range inferedInstance.For_part {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case *Backup:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Bar_style_color:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Barline:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Bar_style":
			if inferedInstance.Bar_style != nil {
				res = inferedInstance.Bar_style.Name
			}
		case "Wavy_line":
			if inferedInstance.Wavy_line != nil {
				res = inferedInstance.Wavy_line.Name
			}
		case "Fermata":
			if inferedInstance.Fermata != nil {
				res = inferedInstance.Fermata.Name
			}
		case "Ending":
			if inferedInstance.Ending != nil {
				res = inferedInstance.Ending.Name
			}
		case "Repeat":
			if inferedInstance.Repeat != nil {
				res = inferedInstance.Repeat.Name
			}
		case "Segno":
			res = inferedInstance.Segno
		case "Coda":
			res = inferedInstance.Coda
		}
	case *Barre:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Bass:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Bass_step":
			if inferedInstance.Bass_step != nil {
				res = inferedInstance.Bass_step.Name
			}
		case "Bass_alter":
			if inferedInstance.Bass_alter != nil {
				res = inferedInstance.Bass_alter.Name
			}
		}
	case *Bass_step:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case *Beam:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Beat_repeat:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Beat_unit_tied:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Beater:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Bend:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Pre_bend":
			if inferedInstance.Pre_bend != nil {
				res = inferedInstance.Pre_bend.Name
			}
		case "Release":
			if inferedInstance.Release != nil {
				res = inferedInstance.Release.Name
			}
		}
	case *Bookmark:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Bracket:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Breath_mark:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Caesura:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Cancel:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Clef:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Coda:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Credit:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Link":
			for idx, __instance__ := range inferedInstance.Link {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Bookmark":
			for idx, __instance__ := range inferedInstance.Bookmark {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Credit_image":
			if inferedInstance.Credit_image != nil {
				res = inferedInstance.Credit_image.Name
			}
		}
	case *Dashes:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Defaults:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Scaling":
			if inferedInstance.Scaling != nil {
				res = inferedInstance.Scaling.Name
			}
		case "Concert_score":
			if inferedInstance.Concert_score != nil {
				res = inferedInstance.Concert_score.Name
			}
		case "Appearance":
			if inferedInstance.Appearance != nil {
				res = inferedInstance.Appearance.Name
			}
		case "Music_font":
			if inferedInstance.Music_font != nil {
				res = inferedInstance.Music_font.Name
			}
		case "Word_font":
			if inferedInstance.Word_font != nil {
				res = inferedInstance.Word_font.Name
			}
		case "Lyric_font":
			for idx, __instance__ := range inferedInstance.Lyric_font {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Lyric_language":
			for idx, __instance__ := range inferedInstance.Lyric_language {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case *Degree:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Degree_value":
			if inferedInstance.Degree_value != nil {
				res = inferedInstance.Degree_value.Name
			}
		case "Degree_alter":
			if inferedInstance.Degree_alter != nil {
				res = inferedInstance.Degree_alter.Name
			}
		case "Degree_type":
			if inferedInstance.Degree_type != nil {
				res = inferedInstance.Degree_type.Name
			}
		}
	case *Degree_alter:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Degree_type:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case *Degree_value:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case *Direction:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Direction_type":
			for idx, __instance__ := range inferedInstance.Direction_type {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Offset":
			if inferedInstance.Offset != nil {
				res = inferedInstance.Offset.Name
			}
		case "Sound":
			if inferedInstance.Sound != nil {
				res = inferedInstance.Sound.Name
			}
		case "Listening":
			if inferedInstance.Listening != nil {
				res = inferedInstance.Listening.Name
			}
		}
	case *Direction_type:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Segno":
			for idx, __instance__ := range inferedInstance.Segno {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Coda":
			for idx, __instance__ := range inferedInstance.Coda {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Wedge":
			if inferedInstance.Wedge != nil {
				res = inferedInstance.Wedge.Name
			}
		case "Dynamics":
			for idx, __instance__ := range inferedInstance.Dynamics {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Dashes":
			if inferedInstance.Dashes != nil {
				res = inferedInstance.Dashes.Name
			}
		case "Bracket":
			if inferedInstance.Bracket != nil {
				res = inferedInstance.Bracket.Name
			}
		case "Pedal":
			if inferedInstance.Pedal != nil {
				res = inferedInstance.Pedal.Name
			}
		case "Metronome":
			if inferedInstance.Metronome != nil {
				res = inferedInstance.Metronome.Name
			}
		case "Octave_shift":
			if inferedInstance.Octave_shift != nil {
				res = inferedInstance.Octave_shift.Name
			}
		case "Harp_pedals":
			if inferedInstance.Harp_pedals != nil {
				res = inferedInstance.Harp_pedals.Name
			}
		case "Damp":
			if inferedInstance.Damp != nil {
				res = inferedInstance.Damp.Name
			}
		case "Damp_all":
			if inferedInstance.Damp_all != nil {
				res = inferedInstance.Damp_all.Name
			}
		case "Eyeglasses":
			if inferedInstance.Eyeglasses != nil {
				res = inferedInstance.Eyeglasses.Name
			}
		case "String_mute":
			if inferedInstance.String_mute != nil {
				res = inferedInstance.String_mute.Name
			}
		case "Scordatura":
			if inferedInstance.Scordatura != nil {
				res = inferedInstance.Scordatura.Name
			}
		case "Image":
			if inferedInstance.Image != nil {
				res = inferedInstance.Image.Name
			}
		case "Principal_voice":
			if inferedInstance.Principal_voice != nil {
				res = inferedInstance.Principal_voice.Name
			}
		case "Percussion":
			for idx, __instance__ := range inferedInstance.Percussion {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Accordion_registration":
			if inferedInstance.Accordion_registration != nil {
				res = inferedInstance.Accordion_registration.Name
			}
		case "Staff_divide":
			if inferedInstance.Staff_divide != nil {
				res = inferedInstance.Staff_divide.Name
			}
		}
	case *Distance:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Double:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Dynamics:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "P":
			if inferedInstance.P != nil {
				res = inferedInstance.P.Name
			}
		case "Pp":
			if inferedInstance.Pp != nil {
				res = inferedInstance.Pp.Name
			}
		case "Ppp":
			if inferedInstance.Ppp != nil {
				res = inferedInstance.Ppp.Name
			}
		case "Pppp":
			if inferedInstance.Pppp != nil {
				res = inferedInstance.Pppp.Name
			}
		case "Ppppp":
			if inferedInstance.Ppppp != nil {
				res = inferedInstance.Ppppp.Name
			}
		case "Pppppp":
			if inferedInstance.Pppppp != nil {
				res = inferedInstance.Pppppp.Name
			}
		case "F":
			if inferedInstance.F != nil {
				res = inferedInstance.F.Name
			}
		case "Ff":
			if inferedInstance.Ff != nil {
				res = inferedInstance.Ff.Name
			}
		case "Fff":
			if inferedInstance.Fff != nil {
				res = inferedInstance.Fff.Name
			}
		case "Ffff":
			if inferedInstance.Ffff != nil {
				res = inferedInstance.Ffff.Name
			}
		case "Fffff":
			if inferedInstance.Fffff != nil {
				res = inferedInstance.Fffff.Name
			}
		case "Ffffff":
			if inferedInstance.Ffffff != nil {
				res = inferedInstance.Ffffff.Name
			}
		case "Mp":
			if inferedInstance.Mp != nil {
				res = inferedInstance.Mp.Name
			}
		case "Mf":
			if inferedInstance.Mf != nil {
				res = inferedInstance.Mf.Name
			}
		case "Sf":
			if inferedInstance.Sf != nil {
				res = inferedInstance.Sf.Name
			}
		case "Sfp":
			if inferedInstance.Sfp != nil {
				res = inferedInstance.Sfp.Name
			}
		case "Sfpp":
			if inferedInstance.Sfpp != nil {
				res = inferedInstance.Sfpp.Name
			}
		case "Fp":
			if inferedInstance.Fp != nil {
				res = inferedInstance.Fp.Name
			}
		case "Rf":
			if inferedInstance.Rf != nil {
				res = inferedInstance.Rf.Name
			}
		case "Rfz":
			if inferedInstance.Rfz != nil {
				res = inferedInstance.Rfz.Name
			}
		case "Sfz":
			if inferedInstance.Sfz != nil {
				res = inferedInstance.Sfz.Name
			}
		case "Sffz":
			if inferedInstance.Sffz != nil {
				res = inferedInstance.Sffz.Name
			}
		case "Fz":
			if inferedInstance.Fz != nil {
				res = inferedInstance.Fz.Name
			}
		case "N":
			if inferedInstance.N != nil {
				res = inferedInstance.N.Name
			}
		case "Pf":
			if inferedInstance.Pf != nil {
				res = inferedInstance.Pf.Name
			}
		case "Sfzp":
			if inferedInstance.Sfzp != nil {
				res = inferedInstance.Sfzp.Name
			}
		}
	case *Effect:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Elision:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *Empty:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Empty_font:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Empty_line:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Empty_placement:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Empty_placement_smufl:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Empty_print_object_style_align:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Empty_print_style:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Empty_print_style_align:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Empty_print_style_align_id:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Empty_trill_sound:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Encoding:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Encoder":
			if inferedInstance.Encoder != nil {
				res = inferedInstance.Encoder.Name
			}
		case "Software":
			res = inferedInstance.Software
		case "Encoding_description":
			res = inferedInstance.Encoding_description
		case "Supports":
			if inferedInstance.Supports != nil {
				res = inferedInstance.Supports.Name
			}
		}
	case *Ending:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *Extend:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Feature:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "Type":
			res = inferedInstance.Type
		}
	case *Fermata:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Figure:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Extend":
			if inferedInstance.Extend != nil {
				res = inferedInstance.Extend.Name
			}
		}
	case *Figured_bass:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Figure":
			for idx, __instance__ := range inferedInstance.Figure {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case *Fingering:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *First_fret:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case *Foo:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *For_part:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Part_clef":
			if inferedInstance.Part_clef != nil {
				res = inferedInstance.Part_clef.Name
			}
		case "Part_transpose":
			if inferedInstance.Part_transpose != nil {
				res = inferedInstance.Part_transpose.Name
			}
		}
	case *Formatted_symbol:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Formatted_symbol_id:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Forward:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Frame:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "First_fret":
			if inferedInstance.First_fret != nil {
				res = inferedInstance.First_fret.Name
			}
		case "Frame_note":
			for idx, __instance__ := range inferedInstance.Frame_note {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Unplayed":
			res = inferedInstance.Unplayed
		}
	case *Frame_note:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Astring":
			res = inferedInstance.Astring
		case "Fret":
			if inferedInstance.Fret != nil {
				res = inferedInstance.Fret.Name
			}
		case "Fingering":
			if inferedInstance.Fingering != nil {
				res = inferedInstance.Fingering.Name
			}
		case "Barre":
			if inferedInstance.Barre != nil {
				res = inferedInstance.Barre.Name
			}
		}
	case *Fret:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Glass:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Glissando:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *Glyph:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Grace:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Group_barline:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Group_symbol:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Grouping:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Feature":
			for idx, __instance__ := range inferedInstance.Feature {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Number":
			res = inferedInstance.Number
		case "Member_of":
			res = inferedInstance.Member_of
		}
	case *Hammer_on_pull_off:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *Handbell:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Harmon_closed:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Harmon_mute:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Harmon_closed":
			if inferedInstance.Harmon_closed != nil {
				res = inferedInstance.Harmon_closed.Name
			}
		}
	case *Harmonic:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Natural":
			if inferedInstance.Natural != nil {
				res = inferedInstance.Natural.Name
			}
		case "Artificial":
			if inferedInstance.Artificial != nil {
				res = inferedInstance.Artificial.Name
			}
		case "Base_pitch":
			if inferedInstance.Base_pitch != nil {
				res = inferedInstance.Base_pitch.Name
			}
		case "Touching_pitch":
			if inferedInstance.Touching_pitch != nil {
				res = inferedInstance.Touching_pitch.Name
			}
		case "Sounding_pitch":
			if inferedInstance.Sounding_pitch != nil {
				res = inferedInstance.Sounding_pitch.Name
			}
		}
	case *Harmony:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Frame":
			if inferedInstance.Frame != nil {
				res = inferedInstance.Frame.Name
			}
		case "Offset":
			if inferedInstance.Offset != nil {
				res = inferedInstance.Offset.Name
			}
		}
	case *Harmony_alter:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Harp_pedals:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Pedal_tuning":
			for idx, __instance__ := range inferedInstance.Pedal_tuning {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case *Heel_toe:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Hole:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Hole_type":
			res = inferedInstance.Hole_type
		case "Hole_closed":
			if inferedInstance.Hole_closed != nil {
				res = inferedInstance.Hole_closed.Name
			}
		case "Hole_shape":
			res = inferedInstance.Hole_shape
		}
	case *Hole_closed:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Horizontal_turn:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Identification:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Creator":
			for idx, __instance__ := range inferedInstance.Creator {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Rights":
			for idx, __instance__ := range inferedInstance.Rights {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Encoding":
			if inferedInstance.Encoding != nil {
				res = inferedInstance.Encoding.Name
			}
		case "Source":
			res = inferedInstance.Source
		case "Relation":
			for idx, __instance__ := range inferedInstance.Relation {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Miscellaneous":
			if inferedInstance.Miscellaneous != nil {
				res = inferedInstance.Miscellaneous.Name
			}
		}
	case *Image:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Instrument:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Instrument_change:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Instrument_link:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Interchangeable:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Inversion:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case *Key:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Key_octave":
			for idx, __instance__ := range inferedInstance.Key_octave {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case *Key_accidental:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Key_octave:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Kind:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case *Level:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *Line_detail:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Line_width:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Link:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Listen:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Assess":
			if inferedInstance.Assess != nil {
				res = inferedInstance.Assess.Name
			}
		case "Wait":
			if inferedInstance.Wait != nil {
				res = inferedInstance.Wait.Name
			}
		case "Other_listen":
			if inferedInstance.Other_listen != nil {
				res = inferedInstance.Other_listen.Name
			}
		}
	case *Listening:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Offset":
			if inferedInstance.Offset != nil {
				res = inferedInstance.Offset.Name
			}
		case "Sync":
			if inferedInstance.Sync != nil {
				res = inferedInstance.Sync.Name
			}
		case "Other_listening":
			if inferedInstance.Other_listening != nil {
				res = inferedInstance.Other_listening.Name
			}
		}
	case *Lyric:
		switch fieldName {
		// string value of fields
		case "End_line":
			if inferedInstance.End_line != nil {
				res = inferedInstance.End_line.Name
			}
		case "End_paragraph":
			if inferedInstance.End_paragraph != nil {
				res = inferedInstance.End_paragraph.Name
			}
		case "Extend":
			if inferedInstance.Extend != nil {
				res = inferedInstance.Extend.Name
			}
		case "Laughing":
			if inferedInstance.Laughing != nil {
				res = inferedInstance.Laughing.Name
			}
		case "Humming":
			if inferedInstance.Humming != nil {
				res = inferedInstance.Humming.Name
			}
		case "Name":
			res = inferedInstance.Name
		}
	case *Lyric_font:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Lyric_language:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "EmptyString":
			res = inferedInstance.EmptyString
		}
	case *Measure_layout:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Measure_numbering:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Measure_repeat:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Measure_style:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Multiple_rest":
			if inferedInstance.Multiple_rest != nil {
				res = inferedInstance.Multiple_rest.Name
			}
		case "Measure_repeat":
			if inferedInstance.Measure_repeat != nil {
				res = inferedInstance.Measure_repeat.Name
			}
		case "Beat_repeat":
			if inferedInstance.Beat_repeat != nil {
				res = inferedInstance.Beat_repeat.Name
			}
		case "Slash":
			if inferedInstance.Slash != nil {
				res = inferedInstance.Slash.Name
			}
		}
	case *Membrane:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Metal:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Metronome:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Metronome_beam:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Metronome_note:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Metronome_dot":
			for idx, __instance__ := range inferedInstance.Metronome_dot {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Metronome_beam":
			for idx, __instance__ := range inferedInstance.Metronome_beam {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Metronome_tied":
			if inferedInstance.Metronome_tied != nil {
				res = inferedInstance.Metronome_tied.Name
			}
		case "Metronome_tuplet":
			if inferedInstance.Metronome_tuplet != nil {
				res = inferedInstance.Metronome_tuplet.Name
			}
		}
	case *Metronome_tied:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Metronome_tuplet:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Midi_device:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *Midi_instrument:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Midi_name":
			res = inferedInstance.Midi_name
		}
	case *Miscellaneous:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Miscellaneous_field":
			for idx, __instance__ := range inferedInstance.Miscellaneous_field {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case *Miscellaneous_field:
		switch fieldName {
		// string value of fields
		case "Value":
			res = inferedInstance.Value
		case "Name":
			res = inferedInstance.Name
		}
	case *Mordent:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Multiple_rest:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Name_display:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accidental_text":
			if inferedInstance.Accidental_text != nil {
				res = inferedInstance.Accidental_text.Name
			}
		}
	case *Non_arpeggiate:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Notations:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Tied":
			if inferedInstance.Tied != nil {
				res = inferedInstance.Tied.Name
			}
		case "Slur":
			if inferedInstance.Slur != nil {
				res = inferedInstance.Slur.Name
			}
		case "Tuplet":
			if inferedInstance.Tuplet != nil {
				res = inferedInstance.Tuplet.Name
			}
		case "Glissando":
			if inferedInstance.Glissando != nil {
				res = inferedInstance.Glissando.Name
			}
		case "Slide":
			if inferedInstance.Slide != nil {
				res = inferedInstance.Slide.Name
			}
		case "Ornaments":
			if inferedInstance.Ornaments != nil {
				res = inferedInstance.Ornaments.Name
			}
		case "Technical":
			if inferedInstance.Technical != nil {
				res = inferedInstance.Technical.Name
			}
		case "Articulations":
			if inferedInstance.Articulations != nil {
				res = inferedInstance.Articulations.Name
			}
		case "Dynamics":
			if inferedInstance.Dynamics != nil {
				res = inferedInstance.Dynamics.Name
			}
		case "Fermata":
			if inferedInstance.Fermata != nil {
				res = inferedInstance.Fermata.Name
			}
		case "Arpeggiate":
			if inferedInstance.Arpeggiate != nil {
				res = inferedInstance.Arpeggiate.Name
			}
		case "Non_arpeggiate":
			if inferedInstance.Non_arpeggiate != nil {
				res = inferedInstance.Non_arpeggiate.Name
			}
		case "Accidental_mark":
			if inferedInstance.Accidental_mark != nil {
				res = inferedInstance.Accidental_mark.Name
			}
		case "Other_notation":
			if inferedInstance.Other_notation != nil {
				res = inferedInstance.Other_notation.Name
			}
		}
	case *Note:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Instrument":
			for idx, __instance__ := range inferedInstance.Instrument {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Type_":
			if inferedInstance.Type_ != nil {
				res = inferedInstance.Type_.Name
			}
		case "Dot":
			for idx, __instance__ := range inferedInstance.Dot {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Accidental":
			if inferedInstance.Accidental != nil {
				res = inferedInstance.Accidental.Name
			}
		case "Time_modification":
			if inferedInstance.Time_modification != nil {
				res = inferedInstance.Time_modification.Name
			}
		case "Stem":
			if inferedInstance.Stem != nil {
				res = inferedInstance.Stem.Name
			}
		case "Notehead":
			if inferedInstance.Notehead != nil {
				res = inferedInstance.Notehead.Name
			}
		case "Notehead_text":
			if inferedInstance.Notehead_text != nil {
				res = inferedInstance.Notehead_text.Name
			}
		case "Beam":
			if inferedInstance.Beam != nil {
				res = inferedInstance.Beam.Name
			}
		case "Notations":
			for idx, __instance__ := range inferedInstance.Notations {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Lyric":
			for idx, __instance__ := range inferedInstance.Lyric {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Play":
			if inferedInstance.Play != nil {
				res = inferedInstance.Play.Name
			}
		case "Listen":
			if inferedInstance.Listen != nil {
				res = inferedInstance.Listen.Name
			}
		}
	case *Note_size:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Note_type:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Notehead:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Notehead_text:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accidental_text":
			if inferedInstance.Accidental_text != nil {
				res = inferedInstance.Accidental_text.Name
			}
		}
	case *Numeral:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Numeral_root":
			if inferedInstance.Numeral_root != nil {
				res = inferedInstance.Numeral_root.Name
			}
		case "Numeral_alter":
			if inferedInstance.Numeral_alter != nil {
				res = inferedInstance.Numeral_alter.Name
			}
		case "Numeral_key":
			if inferedInstance.Numeral_key != nil {
				res = inferedInstance.Numeral_key.Name
			}
		}
	case *Numeral_key:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Numeral_root:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case *Octave_shift:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Offset:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Opus:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Ornaments:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accidental_mark":
			for idx, __instance__ := range inferedInstance.Accidental_mark {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Trill_mark":
			if inferedInstance.Trill_mark != nil {
				res = inferedInstance.Trill_mark.Name
			}
		case "Turn":
			if inferedInstance.Turn != nil {
				res = inferedInstance.Turn.Name
			}
		case "Delayed_turn":
			if inferedInstance.Delayed_turn != nil {
				res = inferedInstance.Delayed_turn.Name
			}
		case "Inverted_turn":
			if inferedInstance.Inverted_turn != nil {
				res = inferedInstance.Inverted_turn.Name
			}
		case "Delayed_inverted_turn":
			if inferedInstance.Delayed_inverted_turn != nil {
				res = inferedInstance.Delayed_inverted_turn.Name
			}
		case "Vertical_turn":
			if inferedInstance.Vertical_turn != nil {
				res = inferedInstance.Vertical_turn.Name
			}
		case "Inverted_vertical_turn":
			if inferedInstance.Inverted_vertical_turn != nil {
				res = inferedInstance.Inverted_vertical_turn.Name
			}
		case "Shake":
			if inferedInstance.Shake != nil {
				res = inferedInstance.Shake.Name
			}
		case "Wavy_line":
			if inferedInstance.Wavy_line != nil {
				res = inferedInstance.Wavy_line.Name
			}
		case "Mordent":
			if inferedInstance.Mordent != nil {
				res = inferedInstance.Mordent.Name
			}
		case "Inverted_mordent":
			if inferedInstance.Inverted_mordent != nil {
				res = inferedInstance.Inverted_mordent.Name
			}
		case "Schleifer":
			if inferedInstance.Schleifer != nil {
				res = inferedInstance.Schleifer.Name
			}
		case "Tremolo":
			if inferedInstance.Tremolo != nil {
				res = inferedInstance.Tremolo.Name
			}
		case "Haydn":
			if inferedInstance.Haydn != nil {
				res = inferedInstance.Haydn.Name
			}
		}
	case *Other_appearance:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "Type":
			res = inferedInstance.Type
		}
	case *Other_listening:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "Type":
			res = inferedInstance.Type
		}
	case *Other_notation:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *Other_play:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "Type":
			res = inferedInstance.Type
		}
	case *Page_layout:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Page_margins":
			if inferedInstance.Page_margins != nil {
				res = inferedInstance.Page_margins.Name
			}
		}
	case *Page_margins:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Part_clef:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Part_group:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Group_name_display":
			if inferedInstance.Group_name_display != nil {
				res = inferedInstance.Group_name_display.Name
			}
		case "Group_abbreviation_display":
			if inferedInstance.Group_abbreviation_display != nil {
				res = inferedInstance.Group_abbreviation_display.Name
			}
		case "Group_symbol":
			if inferedInstance.Group_symbol != nil {
				res = inferedInstance.Group_symbol.Name
			}
		case "Group_barline":
			if inferedInstance.Group_barline != nil {
				res = inferedInstance.Group_barline.Name
			}
		case "Group_time":
			if inferedInstance.Group_time != nil {
				res = inferedInstance.Group_time.Name
			}
		case "Number":
			res = inferedInstance.Number
		}
	case *Part_link:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Instrument_link":
			for idx, __instance__ := range inferedInstance.Instrument_link {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case *Part_list:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Part_symbol:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Part_transpose:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Pedal:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Pedal_tuning:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Percussion:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Glass":
			if inferedInstance.Glass != nil {
				res = inferedInstance.Glass.Name
			}
		case "Metal":
			if inferedInstance.Metal != nil {
				res = inferedInstance.Metal.Name
			}
		case "Wood":
			if inferedInstance.Wood != nil {
				res = inferedInstance.Wood.Name
			}
		case "Pitched":
			if inferedInstance.Pitched != nil {
				res = inferedInstance.Pitched.Name
			}
		case "Membrane":
			if inferedInstance.Membrane != nil {
				res = inferedInstance.Membrane.Name
			}
		case "Effect":
			if inferedInstance.Effect != nil {
				res = inferedInstance.Effect.Name
			}
		case "Timpani":
			if inferedInstance.Timpani != nil {
				res = inferedInstance.Timpani.Name
			}
		case "Beater":
			if inferedInstance.Beater != nil {
				res = inferedInstance.Beater.Name
			}
		case "Stick":
			if inferedInstance.Stick != nil {
				res = inferedInstance.Stick.Name
			}
		}
	case *Pitch:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Pitched:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Play:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Ipa":
			res = inferedInstance.Ipa
		case "Other_play":
			if inferedInstance.Other_play != nil {
				res = inferedInstance.Other_play.Name
			}
		}
	case *Player:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Player_name":
			res = inferedInstance.Player_name
		}
	case *Principal_voice:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *Print:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Measure_layout":
			if inferedInstance.Measure_layout != nil {
				res = inferedInstance.Measure_layout.Name
			}
		case "Measure_numbering":
			if inferedInstance.Measure_numbering != nil {
				res = inferedInstance.Measure_numbering.Name
			}
		case "Part_name_display":
			if inferedInstance.Part_name_display != nil {
				res = inferedInstance.Part_name_display.Name
			}
		case "Part_abbreviation_display":
			if inferedInstance.Part_abbreviation_display != nil {
				res = inferedInstance.Part_abbreviation_display.Name
			}
		}
	case *Release:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Repeat:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Rest:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Root:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Root_step":
			if inferedInstance.Root_step != nil {
				res = inferedInstance.Root_step.Name
			}
		case "Root_alter":
			if inferedInstance.Root_alter != nil {
				res = inferedInstance.Root_alter.Name
			}
		}
	case *Root_step:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case *Scaling:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Scordatura:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accord":
			for idx, __instance__ := range inferedInstance.Accord {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case *Score_instrument:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Instrument_name":
			res = inferedInstance.Instrument_name
		case "Instrument_abbreviation":
			res = inferedInstance.Instrument_abbreviation
		}
	case *Score_part:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Identification":
			if inferedInstance.Identification != nil {
				res = inferedInstance.Identification.Name
			}
		case "Part_link":
			for idx, __instance__ := range inferedInstance.Part_link {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Part_name_display":
			if inferedInstance.Part_name_display != nil {
				res = inferedInstance.Part_name_display.Name
			}
		case "Part_abbreviation_display":
			if inferedInstance.Part_abbreviation_display != nil {
				res = inferedInstance.Part_abbreviation_display.Name
			}
		case "Score_instrument":
			for idx, __instance__ := range inferedInstance.Score_instrument {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Player":
			for idx, __instance__ := range inferedInstance.Player {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case *Score_partwise:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Score_timewise:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Segno:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Slash:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Slide:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *Slur:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Sound:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Swing":
			if inferedInstance.Swing != nil {
				res = inferedInstance.Swing.Name
			}
		case "Offset":
			if inferedInstance.Offset != nil {
				res = inferedInstance.Offset.Name
			}
		case "Segno":
			res = inferedInstance.Segno
		case "Dalsegno":
			res = inferedInstance.Dalsegno
		case "Coda":
			res = inferedInstance.Coda
		case "Tocoda":
			res = inferedInstance.Tocoda
		case "Fine":
			res = inferedInstance.Fine
		}
	case *Staff_details:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Staff_tuning":
			for idx, __instance__ := range inferedInstance.Staff_tuning {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Staff_size":
			if inferedInstance.Staff_size != nil {
				res = inferedInstance.Staff_size.Name
			}
		}
	case *Staff_divide:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Staff_layout:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Staff_size:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Staff_tuning:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Stem:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Stick:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *String_mute:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Strong_accent:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Supports:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *Swing:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Swing_style":
			res = inferedInstance.Swing_style
		case "Straight":
			if inferedInstance.Straight != nil {
				res = inferedInstance.Straight.Name
			}
		}
	case *Sync:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *System_dividers:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Left_divider":
			if inferedInstance.Left_divider != nil {
				res = inferedInstance.Left_divider.Name
			}
		case "Right_divider":
			if inferedInstance.Right_divider != nil {
				res = inferedInstance.Right_divider.Name
			}
		}
	case *System_layout:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "System_margins":
			if inferedInstance.System_margins != nil {
				res = inferedInstance.System_margins.Name
			}
		case "System_dividers":
			if inferedInstance.System_dividers != nil {
				res = inferedInstance.System_dividers.Name
			}
		}
	case *System_margins:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Tap:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case *Technical:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Up_bow":
			if inferedInstance.Up_bow != nil {
				res = inferedInstance.Up_bow.Name
			}
		case "Down_bow":
			if inferedInstance.Down_bow != nil {
				res = inferedInstance.Down_bow.Name
			}
		case "Harmonic":
			if inferedInstance.Harmonic != nil {
				res = inferedInstance.Harmonic.Name
			}
		case "Open_string":
			if inferedInstance.Open_string != nil {
				res = inferedInstance.Open_string.Name
			}
		case "Thumb_position":
			if inferedInstance.Thumb_position != nil {
				res = inferedInstance.Thumb_position.Name
			}
		case "Fingering":
			if inferedInstance.Fingering != nil {
				res = inferedInstance.Fingering.Name
			}
		case "Double_tongue":
			if inferedInstance.Double_tongue != nil {
				res = inferedInstance.Double_tongue.Name
			}
		case "Triple_tongue":
			if inferedInstance.Triple_tongue != nil {
				res = inferedInstance.Triple_tongue.Name
			}
		case "Stopped":
			if inferedInstance.Stopped != nil {
				res = inferedInstance.Stopped.Name
			}
		case "Snap_pizzicato":
			if inferedInstance.Snap_pizzicato != nil {
				res = inferedInstance.Snap_pizzicato.Name
			}
		case "Fret":
			if inferedInstance.Fret != nil {
				res = inferedInstance.Fret.Name
			}
		case "Astring":
			res = inferedInstance.Astring
		case "Hammer_on":
			if inferedInstance.Hammer_on != nil {
				res = inferedInstance.Hammer_on.Name
			}
		case "Pull_off":
			if inferedInstance.Pull_off != nil {
				res = inferedInstance.Pull_off.Name
			}
		case "Bend":
			if inferedInstance.Bend != nil {
				res = inferedInstance.Bend.Name
			}
		case "Tap":
			if inferedInstance.Tap != nil {
				res = inferedInstance.Tap.Name
			}
		case "Heel":
			if inferedInstance.Heel != nil {
				res = inferedInstance.Heel.Name
			}
		case "Toe":
			if inferedInstance.Toe != nil {
				res = inferedInstance.Toe.Name
			}
		case "Fingernails":
			if inferedInstance.Fingernails != nil {
				res = inferedInstance.Fingernails.Name
			}
		case "Hole":
			if inferedInstance.Hole != nil {
				res = inferedInstance.Hole.Name
			}
		case "Arrow":
			if inferedInstance.Arrow != nil {
				res = inferedInstance.Arrow.Name
			}
		case "Handbell":
			if inferedInstance.Handbell != nil {
				res = inferedInstance.Handbell.Name
			}
		case "Brass_bend":
			if inferedInstance.Brass_bend != nil {
				res = inferedInstance.Brass_bend.Name
			}
		case "Flip":
			if inferedInstance.Flip != nil {
				res = inferedInstance.Flip.Name
			}
		case "Smear":
			if inferedInstance.Smear != nil {
				res = inferedInstance.Smear.Name
			}
		case "Open":
			if inferedInstance.Open != nil {
				res = inferedInstance.Open.Name
			}
		case "Half_muted":
			if inferedInstance.Half_muted != nil {
				res = inferedInstance.Half_muted.Name
			}
		case "Harmon_mute":
			if inferedInstance.Harmon_mute != nil {
				res = inferedInstance.Harmon_mute.Name
			}
		case "Golpe":
			if inferedInstance.Golpe != nil {
				res = inferedInstance.Golpe.Name
			}
		}
	case *Text_element_data:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "EmptyString":
			res = inferedInstance.EmptyString
		}
	case *Tie:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Tied:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Time:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Senza_misura":
			res = inferedInstance.Senza_misura
		}
	case *Time_modification:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Timpani:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Transpose:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Tremolo:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Tuplet:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Tuplet_actual":
			if inferedInstance.Tuplet_actual != nil {
				res = inferedInstance.Tuplet_actual.Name
			}
		case "Tuplet_normal":
			if inferedInstance.Tuplet_normal != nil {
				res = inferedInstance.Tuplet_normal.Name
			}
		}
	case *Tuplet_dot:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Tuplet_number:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Tuplet_portion:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Tuplet_number":
			if inferedInstance.Tuplet_number != nil {
				res = inferedInstance.Tuplet_number.Name
			}
		case "Tuplet_type":
			if inferedInstance.Tuplet_type != nil {
				res = inferedInstance.Tuplet_type.Name
			}
		case "Tuplet_dot":
			for idx, __instance__ := range inferedInstance.Tuplet_dot {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case *Tuplet_type:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Typed_text:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "Type":
			res = inferedInstance.Type
		}
	case *Unpitched:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Virtual_instrument:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Virtual_library":
			res = inferedInstance.Virtual_library
		case "Virtual_name":
			res = inferedInstance.Virtual_name
		}
	case *Wait:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Wavy_line:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Wedge:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Wood:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case *Work:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Work_number":
			res = inferedInstance.Work_number
		case "Work_title":
			res = inferedInstance.Work_title
		case "Opus":
			if inferedInstance.Opus != nil {
				res = inferedInstance.Opus.Name
			}
		}
	default:
		_ = inferedInstance
	}
	return
}

func GetFieldStringValue[Type Gongstruct](instance Type, fieldName string) (res string) {

	switch inferedInstance := any(instance).(type) {
	// insertion point for generic get gongstruct field value
	case Accidental:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Accidental_mark:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Accidental_text:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Accord:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Accordion_registration:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accordion_high":
			if inferedInstance.Accordion_high != nil {
				res = inferedInstance.Accordion_high.Name
			}
		case "Accordion_low":
			if inferedInstance.Accordion_low != nil {
				res = inferedInstance.Accordion_low.Name
			}
		}
	case AnyType:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "InnerXML":
			res = inferedInstance.InnerXML
		}
	case Appearance:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Line_width":
			for idx, __instance__ := range inferedInstance.Line_width {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Note_size":
			for idx, __instance__ := range inferedInstance.Note_size {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Distance":
			for idx, __instance__ := range inferedInstance.Distance {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Glyph":
			for idx, __instance__ := range inferedInstance.Glyph {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Other_appearance":
			for idx, __instance__ := range inferedInstance.Other_appearance {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case Arpeggiate:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Arrow:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Articulations:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accent":
			if inferedInstance.Accent != nil {
				res = inferedInstance.Accent.Name
			}
		case "Strong_accent":
			if inferedInstance.Strong_accent != nil {
				res = inferedInstance.Strong_accent.Name
			}
		case "Staccato":
			if inferedInstance.Staccato != nil {
				res = inferedInstance.Staccato.Name
			}
		case "Tenuto":
			if inferedInstance.Tenuto != nil {
				res = inferedInstance.Tenuto.Name
			}
		case "Detached_legato":
			if inferedInstance.Detached_legato != nil {
				res = inferedInstance.Detached_legato.Name
			}
		case "Staccatissimo":
			if inferedInstance.Staccatissimo != nil {
				res = inferedInstance.Staccatissimo.Name
			}
		case "Spiccato":
			if inferedInstance.Spiccato != nil {
				res = inferedInstance.Spiccato.Name
			}
		case "Scoop":
			if inferedInstance.Scoop != nil {
				res = inferedInstance.Scoop.Name
			}
		case "Plop":
			if inferedInstance.Plop != nil {
				res = inferedInstance.Plop.Name
			}
		case "Doit":
			if inferedInstance.Doit != nil {
				res = inferedInstance.Doit.Name
			}
		case "Falloff":
			if inferedInstance.Falloff != nil {
				res = inferedInstance.Falloff.Name
			}
		case "Breath_mark":
			if inferedInstance.Breath_mark != nil {
				res = inferedInstance.Breath_mark.Name
			}
		case "Caesura":
			if inferedInstance.Caesura != nil {
				res = inferedInstance.Caesura.Name
			}
		case "Stress":
			if inferedInstance.Stress != nil {
				res = inferedInstance.Stress.Name
			}
		case "Unstress":
			if inferedInstance.Unstress != nil {
				res = inferedInstance.Unstress.Name
			}
		case "Soft_accent":
			if inferedInstance.Soft_accent != nil {
				res = inferedInstance.Soft_accent.Name
			}
		}
	case Assess:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Attributes:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Key":
			for idx, __instance__ := range inferedInstance.Key {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Part_symbol":
			if inferedInstance.Part_symbol != nil {
				res = inferedInstance.Part_symbol.Name
			}
		case "Clef":
			for idx, __instance__ := range inferedInstance.Clef {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Staff_details":
			for idx, __instance__ := range inferedInstance.Staff_details {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Measure_style":
			for idx, __instance__ := range inferedInstance.Measure_style {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Transpose":
			for idx, __instance__ := range inferedInstance.Transpose {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "For_part":
			for idx, __instance__ := range inferedInstance.For_part {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case Backup:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Bar_style_color:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Barline:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Bar_style":
			if inferedInstance.Bar_style != nil {
				res = inferedInstance.Bar_style.Name
			}
		case "Wavy_line":
			if inferedInstance.Wavy_line != nil {
				res = inferedInstance.Wavy_line.Name
			}
		case "Fermata":
			if inferedInstance.Fermata != nil {
				res = inferedInstance.Fermata.Name
			}
		case "Ending":
			if inferedInstance.Ending != nil {
				res = inferedInstance.Ending.Name
			}
		case "Repeat":
			if inferedInstance.Repeat != nil {
				res = inferedInstance.Repeat.Name
			}
		case "Segno":
			res = inferedInstance.Segno
		case "Coda":
			res = inferedInstance.Coda
		}
	case Barre:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Bass:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Bass_step":
			if inferedInstance.Bass_step != nil {
				res = inferedInstance.Bass_step.Name
			}
		case "Bass_alter":
			if inferedInstance.Bass_alter != nil {
				res = inferedInstance.Bass_alter.Name
			}
		}
	case Bass_step:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case Beam:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Beat_repeat:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Beat_unit_tied:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Beater:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Bend:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Pre_bend":
			if inferedInstance.Pre_bend != nil {
				res = inferedInstance.Pre_bend.Name
			}
		case "Release":
			if inferedInstance.Release != nil {
				res = inferedInstance.Release.Name
			}
		}
	case Bookmark:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Bracket:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Breath_mark:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Caesura:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Cancel:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Clef:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Coda:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Credit:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Link":
			for idx, __instance__ := range inferedInstance.Link {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Bookmark":
			for idx, __instance__ := range inferedInstance.Bookmark {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Credit_image":
			if inferedInstance.Credit_image != nil {
				res = inferedInstance.Credit_image.Name
			}
		}
	case Dashes:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Defaults:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Scaling":
			if inferedInstance.Scaling != nil {
				res = inferedInstance.Scaling.Name
			}
		case "Concert_score":
			if inferedInstance.Concert_score != nil {
				res = inferedInstance.Concert_score.Name
			}
		case "Appearance":
			if inferedInstance.Appearance != nil {
				res = inferedInstance.Appearance.Name
			}
		case "Music_font":
			if inferedInstance.Music_font != nil {
				res = inferedInstance.Music_font.Name
			}
		case "Word_font":
			if inferedInstance.Word_font != nil {
				res = inferedInstance.Word_font.Name
			}
		case "Lyric_font":
			for idx, __instance__ := range inferedInstance.Lyric_font {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Lyric_language":
			for idx, __instance__ := range inferedInstance.Lyric_language {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case Degree:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Degree_value":
			if inferedInstance.Degree_value != nil {
				res = inferedInstance.Degree_value.Name
			}
		case "Degree_alter":
			if inferedInstance.Degree_alter != nil {
				res = inferedInstance.Degree_alter.Name
			}
		case "Degree_type":
			if inferedInstance.Degree_type != nil {
				res = inferedInstance.Degree_type.Name
			}
		}
	case Degree_alter:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Degree_type:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case Degree_value:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case Direction:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Direction_type":
			for idx, __instance__ := range inferedInstance.Direction_type {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Offset":
			if inferedInstance.Offset != nil {
				res = inferedInstance.Offset.Name
			}
		case "Sound":
			if inferedInstance.Sound != nil {
				res = inferedInstance.Sound.Name
			}
		case "Listening":
			if inferedInstance.Listening != nil {
				res = inferedInstance.Listening.Name
			}
		}
	case Direction_type:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Segno":
			for idx, __instance__ := range inferedInstance.Segno {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Coda":
			for idx, __instance__ := range inferedInstance.Coda {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Wedge":
			if inferedInstance.Wedge != nil {
				res = inferedInstance.Wedge.Name
			}
		case "Dynamics":
			for idx, __instance__ := range inferedInstance.Dynamics {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Dashes":
			if inferedInstance.Dashes != nil {
				res = inferedInstance.Dashes.Name
			}
		case "Bracket":
			if inferedInstance.Bracket != nil {
				res = inferedInstance.Bracket.Name
			}
		case "Pedal":
			if inferedInstance.Pedal != nil {
				res = inferedInstance.Pedal.Name
			}
		case "Metronome":
			if inferedInstance.Metronome != nil {
				res = inferedInstance.Metronome.Name
			}
		case "Octave_shift":
			if inferedInstance.Octave_shift != nil {
				res = inferedInstance.Octave_shift.Name
			}
		case "Harp_pedals":
			if inferedInstance.Harp_pedals != nil {
				res = inferedInstance.Harp_pedals.Name
			}
		case "Damp":
			if inferedInstance.Damp != nil {
				res = inferedInstance.Damp.Name
			}
		case "Damp_all":
			if inferedInstance.Damp_all != nil {
				res = inferedInstance.Damp_all.Name
			}
		case "Eyeglasses":
			if inferedInstance.Eyeglasses != nil {
				res = inferedInstance.Eyeglasses.Name
			}
		case "String_mute":
			if inferedInstance.String_mute != nil {
				res = inferedInstance.String_mute.Name
			}
		case "Scordatura":
			if inferedInstance.Scordatura != nil {
				res = inferedInstance.Scordatura.Name
			}
		case "Image":
			if inferedInstance.Image != nil {
				res = inferedInstance.Image.Name
			}
		case "Principal_voice":
			if inferedInstance.Principal_voice != nil {
				res = inferedInstance.Principal_voice.Name
			}
		case "Percussion":
			for idx, __instance__ := range inferedInstance.Percussion {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Accordion_registration":
			if inferedInstance.Accordion_registration != nil {
				res = inferedInstance.Accordion_registration.Name
			}
		case "Staff_divide":
			if inferedInstance.Staff_divide != nil {
				res = inferedInstance.Staff_divide.Name
			}
		}
	case Distance:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Double:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Dynamics:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "P":
			if inferedInstance.P != nil {
				res = inferedInstance.P.Name
			}
		case "Pp":
			if inferedInstance.Pp != nil {
				res = inferedInstance.Pp.Name
			}
		case "Ppp":
			if inferedInstance.Ppp != nil {
				res = inferedInstance.Ppp.Name
			}
		case "Pppp":
			if inferedInstance.Pppp != nil {
				res = inferedInstance.Pppp.Name
			}
		case "Ppppp":
			if inferedInstance.Ppppp != nil {
				res = inferedInstance.Ppppp.Name
			}
		case "Pppppp":
			if inferedInstance.Pppppp != nil {
				res = inferedInstance.Pppppp.Name
			}
		case "F":
			if inferedInstance.F != nil {
				res = inferedInstance.F.Name
			}
		case "Ff":
			if inferedInstance.Ff != nil {
				res = inferedInstance.Ff.Name
			}
		case "Fff":
			if inferedInstance.Fff != nil {
				res = inferedInstance.Fff.Name
			}
		case "Ffff":
			if inferedInstance.Ffff != nil {
				res = inferedInstance.Ffff.Name
			}
		case "Fffff":
			if inferedInstance.Fffff != nil {
				res = inferedInstance.Fffff.Name
			}
		case "Ffffff":
			if inferedInstance.Ffffff != nil {
				res = inferedInstance.Ffffff.Name
			}
		case "Mp":
			if inferedInstance.Mp != nil {
				res = inferedInstance.Mp.Name
			}
		case "Mf":
			if inferedInstance.Mf != nil {
				res = inferedInstance.Mf.Name
			}
		case "Sf":
			if inferedInstance.Sf != nil {
				res = inferedInstance.Sf.Name
			}
		case "Sfp":
			if inferedInstance.Sfp != nil {
				res = inferedInstance.Sfp.Name
			}
		case "Sfpp":
			if inferedInstance.Sfpp != nil {
				res = inferedInstance.Sfpp.Name
			}
		case "Fp":
			if inferedInstance.Fp != nil {
				res = inferedInstance.Fp.Name
			}
		case "Rf":
			if inferedInstance.Rf != nil {
				res = inferedInstance.Rf.Name
			}
		case "Rfz":
			if inferedInstance.Rfz != nil {
				res = inferedInstance.Rfz.Name
			}
		case "Sfz":
			if inferedInstance.Sfz != nil {
				res = inferedInstance.Sfz.Name
			}
		case "Sffz":
			if inferedInstance.Sffz != nil {
				res = inferedInstance.Sffz.Name
			}
		case "Fz":
			if inferedInstance.Fz != nil {
				res = inferedInstance.Fz.Name
			}
		case "N":
			if inferedInstance.N != nil {
				res = inferedInstance.N.Name
			}
		case "Pf":
			if inferedInstance.Pf != nil {
				res = inferedInstance.Pf.Name
			}
		case "Sfzp":
			if inferedInstance.Sfzp != nil {
				res = inferedInstance.Sfzp.Name
			}
		}
	case Effect:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Elision:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case Empty:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Empty_font:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Empty_line:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Empty_placement:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Empty_placement_smufl:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Empty_print_object_style_align:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Empty_print_style:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Empty_print_style_align:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Empty_print_style_align_id:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Empty_trill_sound:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Encoding:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Encoder":
			if inferedInstance.Encoder != nil {
				res = inferedInstance.Encoder.Name
			}
		case "Software":
			res = inferedInstance.Software
		case "Encoding_description":
			res = inferedInstance.Encoding_description
		case "Supports":
			if inferedInstance.Supports != nil {
				res = inferedInstance.Supports.Name
			}
		}
	case Ending:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case Extend:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Feature:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "Type":
			res = inferedInstance.Type
		}
	case Fermata:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Figure:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Extend":
			if inferedInstance.Extend != nil {
				res = inferedInstance.Extend.Name
			}
		}
	case Figured_bass:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Figure":
			for idx, __instance__ := range inferedInstance.Figure {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case Fingering:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case First_fret:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case Foo:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case For_part:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Part_clef":
			if inferedInstance.Part_clef != nil {
				res = inferedInstance.Part_clef.Name
			}
		case "Part_transpose":
			if inferedInstance.Part_transpose != nil {
				res = inferedInstance.Part_transpose.Name
			}
		}
	case Formatted_symbol:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Formatted_symbol_id:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Forward:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Frame:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "First_fret":
			if inferedInstance.First_fret != nil {
				res = inferedInstance.First_fret.Name
			}
		case "Frame_note":
			for idx, __instance__ := range inferedInstance.Frame_note {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Unplayed":
			res = inferedInstance.Unplayed
		}
	case Frame_note:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Astring":
			res = inferedInstance.Astring
		case "Fret":
			if inferedInstance.Fret != nil {
				res = inferedInstance.Fret.Name
			}
		case "Fingering":
			if inferedInstance.Fingering != nil {
				res = inferedInstance.Fingering.Name
			}
		case "Barre":
			if inferedInstance.Barre != nil {
				res = inferedInstance.Barre.Name
			}
		}
	case Fret:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Glass:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Glissando:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case Glyph:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Grace:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Group_barline:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Group_symbol:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Grouping:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Feature":
			for idx, __instance__ := range inferedInstance.Feature {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Number":
			res = inferedInstance.Number
		case "Member_of":
			res = inferedInstance.Member_of
		}
	case Hammer_on_pull_off:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case Handbell:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Harmon_closed:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Harmon_mute:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Harmon_closed":
			if inferedInstance.Harmon_closed != nil {
				res = inferedInstance.Harmon_closed.Name
			}
		}
	case Harmonic:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Natural":
			if inferedInstance.Natural != nil {
				res = inferedInstance.Natural.Name
			}
		case "Artificial":
			if inferedInstance.Artificial != nil {
				res = inferedInstance.Artificial.Name
			}
		case "Base_pitch":
			if inferedInstance.Base_pitch != nil {
				res = inferedInstance.Base_pitch.Name
			}
		case "Touching_pitch":
			if inferedInstance.Touching_pitch != nil {
				res = inferedInstance.Touching_pitch.Name
			}
		case "Sounding_pitch":
			if inferedInstance.Sounding_pitch != nil {
				res = inferedInstance.Sounding_pitch.Name
			}
		}
	case Harmony:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Frame":
			if inferedInstance.Frame != nil {
				res = inferedInstance.Frame.Name
			}
		case "Offset":
			if inferedInstance.Offset != nil {
				res = inferedInstance.Offset.Name
			}
		}
	case Harmony_alter:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Harp_pedals:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Pedal_tuning":
			for idx, __instance__ := range inferedInstance.Pedal_tuning {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case Heel_toe:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Hole:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Hole_type":
			res = inferedInstance.Hole_type
		case "Hole_closed":
			if inferedInstance.Hole_closed != nil {
				res = inferedInstance.Hole_closed.Name
			}
		case "Hole_shape":
			res = inferedInstance.Hole_shape
		}
	case Hole_closed:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Horizontal_turn:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Identification:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Creator":
			for idx, __instance__ := range inferedInstance.Creator {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Rights":
			for idx, __instance__ := range inferedInstance.Rights {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Encoding":
			if inferedInstance.Encoding != nil {
				res = inferedInstance.Encoding.Name
			}
		case "Source":
			res = inferedInstance.Source
		case "Relation":
			for idx, __instance__ := range inferedInstance.Relation {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Miscellaneous":
			if inferedInstance.Miscellaneous != nil {
				res = inferedInstance.Miscellaneous.Name
			}
		}
	case Image:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Instrument:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Instrument_change:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Instrument_link:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Interchangeable:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Inversion:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case Key:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Key_octave":
			for idx, __instance__ := range inferedInstance.Key_octave {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case Key_accidental:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Key_octave:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Kind:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case Level:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case Line_detail:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Line_width:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Link:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Listen:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Assess":
			if inferedInstance.Assess != nil {
				res = inferedInstance.Assess.Name
			}
		case "Wait":
			if inferedInstance.Wait != nil {
				res = inferedInstance.Wait.Name
			}
		case "Other_listen":
			if inferedInstance.Other_listen != nil {
				res = inferedInstance.Other_listen.Name
			}
		}
	case Listening:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Offset":
			if inferedInstance.Offset != nil {
				res = inferedInstance.Offset.Name
			}
		case "Sync":
			if inferedInstance.Sync != nil {
				res = inferedInstance.Sync.Name
			}
		case "Other_listening":
			if inferedInstance.Other_listening != nil {
				res = inferedInstance.Other_listening.Name
			}
		}
	case Lyric:
		switch fieldName {
		// string value of fields
		case "End_line":
			if inferedInstance.End_line != nil {
				res = inferedInstance.End_line.Name
			}
		case "End_paragraph":
			if inferedInstance.End_paragraph != nil {
				res = inferedInstance.End_paragraph.Name
			}
		case "Extend":
			if inferedInstance.Extend != nil {
				res = inferedInstance.Extend.Name
			}
		case "Laughing":
			if inferedInstance.Laughing != nil {
				res = inferedInstance.Laughing.Name
			}
		case "Humming":
			if inferedInstance.Humming != nil {
				res = inferedInstance.Humming.Name
			}
		case "Name":
			res = inferedInstance.Name
		}
	case Lyric_font:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Lyric_language:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "EmptyString":
			res = inferedInstance.EmptyString
		}
	case Measure_layout:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Measure_numbering:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Measure_repeat:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Measure_style:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Multiple_rest":
			if inferedInstance.Multiple_rest != nil {
				res = inferedInstance.Multiple_rest.Name
			}
		case "Measure_repeat":
			if inferedInstance.Measure_repeat != nil {
				res = inferedInstance.Measure_repeat.Name
			}
		case "Beat_repeat":
			if inferedInstance.Beat_repeat != nil {
				res = inferedInstance.Beat_repeat.Name
			}
		case "Slash":
			if inferedInstance.Slash != nil {
				res = inferedInstance.Slash.Name
			}
		}
	case Membrane:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Metal:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Metronome:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Metronome_beam:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Metronome_note:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Metronome_dot":
			for idx, __instance__ := range inferedInstance.Metronome_dot {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Metronome_beam":
			for idx, __instance__ := range inferedInstance.Metronome_beam {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Metronome_tied":
			if inferedInstance.Metronome_tied != nil {
				res = inferedInstance.Metronome_tied.Name
			}
		case "Metronome_tuplet":
			if inferedInstance.Metronome_tuplet != nil {
				res = inferedInstance.Metronome_tuplet.Name
			}
		}
	case Metronome_tied:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Metronome_tuplet:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Midi_device:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case Midi_instrument:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Midi_name":
			res = inferedInstance.Midi_name
		}
	case Miscellaneous:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Miscellaneous_field":
			for idx, __instance__ := range inferedInstance.Miscellaneous_field {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case Miscellaneous_field:
		switch fieldName {
		// string value of fields
		case "Value":
			res = inferedInstance.Value
		case "Name":
			res = inferedInstance.Name
		}
	case Mordent:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Multiple_rest:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Name_display:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accidental_text":
			if inferedInstance.Accidental_text != nil {
				res = inferedInstance.Accidental_text.Name
			}
		}
	case Non_arpeggiate:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Notations:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Tied":
			if inferedInstance.Tied != nil {
				res = inferedInstance.Tied.Name
			}
		case "Slur":
			if inferedInstance.Slur != nil {
				res = inferedInstance.Slur.Name
			}
		case "Tuplet":
			if inferedInstance.Tuplet != nil {
				res = inferedInstance.Tuplet.Name
			}
		case "Glissando":
			if inferedInstance.Glissando != nil {
				res = inferedInstance.Glissando.Name
			}
		case "Slide":
			if inferedInstance.Slide != nil {
				res = inferedInstance.Slide.Name
			}
		case "Ornaments":
			if inferedInstance.Ornaments != nil {
				res = inferedInstance.Ornaments.Name
			}
		case "Technical":
			if inferedInstance.Technical != nil {
				res = inferedInstance.Technical.Name
			}
		case "Articulations":
			if inferedInstance.Articulations != nil {
				res = inferedInstance.Articulations.Name
			}
		case "Dynamics":
			if inferedInstance.Dynamics != nil {
				res = inferedInstance.Dynamics.Name
			}
		case "Fermata":
			if inferedInstance.Fermata != nil {
				res = inferedInstance.Fermata.Name
			}
		case "Arpeggiate":
			if inferedInstance.Arpeggiate != nil {
				res = inferedInstance.Arpeggiate.Name
			}
		case "Non_arpeggiate":
			if inferedInstance.Non_arpeggiate != nil {
				res = inferedInstance.Non_arpeggiate.Name
			}
		case "Accidental_mark":
			if inferedInstance.Accidental_mark != nil {
				res = inferedInstance.Accidental_mark.Name
			}
		case "Other_notation":
			if inferedInstance.Other_notation != nil {
				res = inferedInstance.Other_notation.Name
			}
		}
	case Note:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Instrument":
			for idx, __instance__ := range inferedInstance.Instrument {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Type_":
			if inferedInstance.Type_ != nil {
				res = inferedInstance.Type_.Name
			}
		case "Dot":
			for idx, __instance__ := range inferedInstance.Dot {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Accidental":
			if inferedInstance.Accidental != nil {
				res = inferedInstance.Accidental.Name
			}
		case "Time_modification":
			if inferedInstance.Time_modification != nil {
				res = inferedInstance.Time_modification.Name
			}
		case "Stem":
			if inferedInstance.Stem != nil {
				res = inferedInstance.Stem.Name
			}
		case "Notehead":
			if inferedInstance.Notehead != nil {
				res = inferedInstance.Notehead.Name
			}
		case "Notehead_text":
			if inferedInstance.Notehead_text != nil {
				res = inferedInstance.Notehead_text.Name
			}
		case "Beam":
			if inferedInstance.Beam != nil {
				res = inferedInstance.Beam.Name
			}
		case "Notations":
			for idx, __instance__ := range inferedInstance.Notations {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Lyric":
			for idx, __instance__ := range inferedInstance.Lyric {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Play":
			if inferedInstance.Play != nil {
				res = inferedInstance.Play.Name
			}
		case "Listen":
			if inferedInstance.Listen != nil {
				res = inferedInstance.Listen.Name
			}
		}
	case Note_size:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Note_type:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Notehead:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Notehead_text:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accidental_text":
			if inferedInstance.Accidental_text != nil {
				res = inferedInstance.Accidental_text.Name
			}
		}
	case Numeral:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Numeral_root":
			if inferedInstance.Numeral_root != nil {
				res = inferedInstance.Numeral_root.Name
			}
		case "Numeral_alter":
			if inferedInstance.Numeral_alter != nil {
				res = inferedInstance.Numeral_alter.Name
			}
		case "Numeral_key":
			if inferedInstance.Numeral_key != nil {
				res = inferedInstance.Numeral_key.Name
			}
		}
	case Numeral_key:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Numeral_root:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case Octave_shift:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Offset:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Opus:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Ornaments:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accidental_mark":
			for idx, __instance__ := range inferedInstance.Accidental_mark {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Trill_mark":
			if inferedInstance.Trill_mark != nil {
				res = inferedInstance.Trill_mark.Name
			}
		case "Turn":
			if inferedInstance.Turn != nil {
				res = inferedInstance.Turn.Name
			}
		case "Delayed_turn":
			if inferedInstance.Delayed_turn != nil {
				res = inferedInstance.Delayed_turn.Name
			}
		case "Inverted_turn":
			if inferedInstance.Inverted_turn != nil {
				res = inferedInstance.Inverted_turn.Name
			}
		case "Delayed_inverted_turn":
			if inferedInstance.Delayed_inverted_turn != nil {
				res = inferedInstance.Delayed_inverted_turn.Name
			}
		case "Vertical_turn":
			if inferedInstance.Vertical_turn != nil {
				res = inferedInstance.Vertical_turn.Name
			}
		case "Inverted_vertical_turn":
			if inferedInstance.Inverted_vertical_turn != nil {
				res = inferedInstance.Inverted_vertical_turn.Name
			}
		case "Shake":
			if inferedInstance.Shake != nil {
				res = inferedInstance.Shake.Name
			}
		case "Wavy_line":
			if inferedInstance.Wavy_line != nil {
				res = inferedInstance.Wavy_line.Name
			}
		case "Mordent":
			if inferedInstance.Mordent != nil {
				res = inferedInstance.Mordent.Name
			}
		case "Inverted_mordent":
			if inferedInstance.Inverted_mordent != nil {
				res = inferedInstance.Inverted_mordent.Name
			}
		case "Schleifer":
			if inferedInstance.Schleifer != nil {
				res = inferedInstance.Schleifer.Name
			}
		case "Tremolo":
			if inferedInstance.Tremolo != nil {
				res = inferedInstance.Tremolo.Name
			}
		case "Haydn":
			if inferedInstance.Haydn != nil {
				res = inferedInstance.Haydn.Name
			}
		}
	case Other_appearance:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "Type":
			res = inferedInstance.Type
		}
	case Other_listening:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "Type":
			res = inferedInstance.Type
		}
	case Other_notation:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case Other_play:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "Type":
			res = inferedInstance.Type
		}
	case Page_layout:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Page_margins":
			if inferedInstance.Page_margins != nil {
				res = inferedInstance.Page_margins.Name
			}
		}
	case Page_margins:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Part_clef:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Part_group:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Group_name_display":
			if inferedInstance.Group_name_display != nil {
				res = inferedInstance.Group_name_display.Name
			}
		case "Group_abbreviation_display":
			if inferedInstance.Group_abbreviation_display != nil {
				res = inferedInstance.Group_abbreviation_display.Name
			}
		case "Group_symbol":
			if inferedInstance.Group_symbol != nil {
				res = inferedInstance.Group_symbol.Name
			}
		case "Group_barline":
			if inferedInstance.Group_barline != nil {
				res = inferedInstance.Group_barline.Name
			}
		case "Group_time":
			if inferedInstance.Group_time != nil {
				res = inferedInstance.Group_time.Name
			}
		case "Number":
			res = inferedInstance.Number
		}
	case Part_link:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Instrument_link":
			for idx, __instance__ := range inferedInstance.Instrument_link {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case Part_list:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Part_symbol:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Part_transpose:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Pedal:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Pedal_tuning:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Percussion:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Glass":
			if inferedInstance.Glass != nil {
				res = inferedInstance.Glass.Name
			}
		case "Metal":
			if inferedInstance.Metal != nil {
				res = inferedInstance.Metal.Name
			}
		case "Wood":
			if inferedInstance.Wood != nil {
				res = inferedInstance.Wood.Name
			}
		case "Pitched":
			if inferedInstance.Pitched != nil {
				res = inferedInstance.Pitched.Name
			}
		case "Membrane":
			if inferedInstance.Membrane != nil {
				res = inferedInstance.Membrane.Name
			}
		case "Effect":
			if inferedInstance.Effect != nil {
				res = inferedInstance.Effect.Name
			}
		case "Timpani":
			if inferedInstance.Timpani != nil {
				res = inferedInstance.Timpani.Name
			}
		case "Beater":
			if inferedInstance.Beater != nil {
				res = inferedInstance.Beater.Name
			}
		case "Stick":
			if inferedInstance.Stick != nil {
				res = inferedInstance.Stick.Name
			}
		}
	case Pitch:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Pitched:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Play:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Ipa":
			res = inferedInstance.Ipa
		case "Other_play":
			if inferedInstance.Other_play != nil {
				res = inferedInstance.Other_play.Name
			}
		}
	case Player:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Player_name":
			res = inferedInstance.Player_name
		}
	case Principal_voice:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case Print:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Measure_layout":
			if inferedInstance.Measure_layout != nil {
				res = inferedInstance.Measure_layout.Name
			}
		case "Measure_numbering":
			if inferedInstance.Measure_numbering != nil {
				res = inferedInstance.Measure_numbering.Name
			}
		case "Part_name_display":
			if inferedInstance.Part_name_display != nil {
				res = inferedInstance.Part_name_display.Name
			}
		case "Part_abbreviation_display":
			if inferedInstance.Part_abbreviation_display != nil {
				res = inferedInstance.Part_abbreviation_display.Name
			}
		}
	case Release:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Repeat:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Rest:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Root:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Root_step":
			if inferedInstance.Root_step != nil {
				res = inferedInstance.Root_step.Name
			}
		case "Root_alter":
			if inferedInstance.Root_alter != nil {
				res = inferedInstance.Root_alter.Name
			}
		}
	case Root_step:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Text":
			res = inferedInstance.Text
		}
	case Scaling:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Scordatura:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Accord":
			for idx, __instance__ := range inferedInstance.Accord {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case Score_instrument:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Instrument_name":
			res = inferedInstance.Instrument_name
		case "Instrument_abbreviation":
			res = inferedInstance.Instrument_abbreviation
		}
	case Score_part:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Identification":
			if inferedInstance.Identification != nil {
				res = inferedInstance.Identification.Name
			}
		case "Part_link":
			for idx, __instance__ := range inferedInstance.Part_link {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Part_name_display":
			if inferedInstance.Part_name_display != nil {
				res = inferedInstance.Part_name_display.Name
			}
		case "Part_abbreviation_display":
			if inferedInstance.Part_abbreviation_display != nil {
				res = inferedInstance.Part_abbreviation_display.Name
			}
		case "Score_instrument":
			for idx, __instance__ := range inferedInstance.Score_instrument {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Player":
			for idx, __instance__ := range inferedInstance.Player {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case Score_partwise:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Score_timewise:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Segno:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Slash:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Slide:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case Slur:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Sound:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Swing":
			if inferedInstance.Swing != nil {
				res = inferedInstance.Swing.Name
			}
		case "Offset":
			if inferedInstance.Offset != nil {
				res = inferedInstance.Offset.Name
			}
		case "Segno":
			res = inferedInstance.Segno
		case "Dalsegno":
			res = inferedInstance.Dalsegno
		case "Coda":
			res = inferedInstance.Coda
		case "Tocoda":
			res = inferedInstance.Tocoda
		case "Fine":
			res = inferedInstance.Fine
		}
	case Staff_details:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Staff_tuning":
			for idx, __instance__ := range inferedInstance.Staff_tuning {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Staff_size":
			if inferedInstance.Staff_size != nil {
				res = inferedInstance.Staff_size.Name
			}
		}
	case Staff_divide:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Staff_layout:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Staff_size:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Staff_tuning:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Stem:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Stick:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case String_mute:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Strong_accent:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Supports:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case Swing:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Swing_style":
			res = inferedInstance.Swing_style
		case "Straight":
			if inferedInstance.Straight != nil {
				res = inferedInstance.Straight.Name
			}
		}
	case Sync:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case System_dividers:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Left_divider":
			if inferedInstance.Left_divider != nil {
				res = inferedInstance.Left_divider.Name
			}
		case "Right_divider":
			if inferedInstance.Right_divider != nil {
				res = inferedInstance.Right_divider.Name
			}
		}
	case System_layout:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "System_margins":
			if inferedInstance.System_margins != nil {
				res = inferedInstance.System_margins.Name
			}
		case "System_dividers":
			if inferedInstance.System_dividers != nil {
				res = inferedInstance.System_dividers.Name
			}
		}
	case System_margins:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Tap:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		}
	case Technical:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Up_bow":
			if inferedInstance.Up_bow != nil {
				res = inferedInstance.Up_bow.Name
			}
		case "Down_bow":
			if inferedInstance.Down_bow != nil {
				res = inferedInstance.Down_bow.Name
			}
		case "Harmonic":
			if inferedInstance.Harmonic != nil {
				res = inferedInstance.Harmonic.Name
			}
		case "Open_string":
			if inferedInstance.Open_string != nil {
				res = inferedInstance.Open_string.Name
			}
		case "Thumb_position":
			if inferedInstance.Thumb_position != nil {
				res = inferedInstance.Thumb_position.Name
			}
		case "Fingering":
			if inferedInstance.Fingering != nil {
				res = inferedInstance.Fingering.Name
			}
		case "Double_tongue":
			if inferedInstance.Double_tongue != nil {
				res = inferedInstance.Double_tongue.Name
			}
		case "Triple_tongue":
			if inferedInstance.Triple_tongue != nil {
				res = inferedInstance.Triple_tongue.Name
			}
		case "Stopped":
			if inferedInstance.Stopped != nil {
				res = inferedInstance.Stopped.Name
			}
		case "Snap_pizzicato":
			if inferedInstance.Snap_pizzicato != nil {
				res = inferedInstance.Snap_pizzicato.Name
			}
		case "Fret":
			if inferedInstance.Fret != nil {
				res = inferedInstance.Fret.Name
			}
		case "Astring":
			res = inferedInstance.Astring
		case "Hammer_on":
			if inferedInstance.Hammer_on != nil {
				res = inferedInstance.Hammer_on.Name
			}
		case "Pull_off":
			if inferedInstance.Pull_off != nil {
				res = inferedInstance.Pull_off.Name
			}
		case "Bend":
			if inferedInstance.Bend != nil {
				res = inferedInstance.Bend.Name
			}
		case "Tap":
			if inferedInstance.Tap != nil {
				res = inferedInstance.Tap.Name
			}
		case "Heel":
			if inferedInstance.Heel != nil {
				res = inferedInstance.Heel.Name
			}
		case "Toe":
			if inferedInstance.Toe != nil {
				res = inferedInstance.Toe.Name
			}
		case "Fingernails":
			if inferedInstance.Fingernails != nil {
				res = inferedInstance.Fingernails.Name
			}
		case "Hole":
			if inferedInstance.Hole != nil {
				res = inferedInstance.Hole.Name
			}
		case "Arrow":
			if inferedInstance.Arrow != nil {
				res = inferedInstance.Arrow.Name
			}
		case "Handbell":
			if inferedInstance.Handbell != nil {
				res = inferedInstance.Handbell.Name
			}
		case "Brass_bend":
			if inferedInstance.Brass_bend != nil {
				res = inferedInstance.Brass_bend.Name
			}
		case "Flip":
			if inferedInstance.Flip != nil {
				res = inferedInstance.Flip.Name
			}
		case "Smear":
			if inferedInstance.Smear != nil {
				res = inferedInstance.Smear.Name
			}
		case "Open":
			if inferedInstance.Open != nil {
				res = inferedInstance.Open.Name
			}
		case "Half_muted":
			if inferedInstance.Half_muted != nil {
				res = inferedInstance.Half_muted.Name
			}
		case "Harmon_mute":
			if inferedInstance.Harmon_mute != nil {
				res = inferedInstance.Harmon_mute.Name
			}
		case "Golpe":
			if inferedInstance.Golpe != nil {
				res = inferedInstance.Golpe.Name
			}
		}
	case Text_element_data:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "EmptyString":
			res = inferedInstance.EmptyString
		}
	case Tie:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Tied:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Time:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Senza_misura":
			res = inferedInstance.Senza_misura
		}
	case Time_modification:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Timpani:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Transpose:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Tremolo:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Tuplet:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Tuplet_actual":
			if inferedInstance.Tuplet_actual != nil {
				res = inferedInstance.Tuplet_actual.Name
			}
		case "Tuplet_normal":
			if inferedInstance.Tuplet_normal != nil {
				res = inferedInstance.Tuplet_normal.Name
			}
		}
	case Tuplet_dot:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Tuplet_number:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Tuplet_portion:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Tuplet_number":
			if inferedInstance.Tuplet_number != nil {
				res = inferedInstance.Tuplet_number.Name
			}
		case "Tuplet_type":
			if inferedInstance.Tuplet_type != nil {
				res = inferedInstance.Tuplet_type.Name
			}
		case "Tuplet_dot":
			for idx, __instance__ := range inferedInstance.Tuplet_dot {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		}
	case Tuplet_type:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Typed_text:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Value":
			res = inferedInstance.Value
		case "Type":
			res = inferedInstance.Type
		}
	case Unpitched:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Virtual_instrument:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Virtual_library":
			res = inferedInstance.Virtual_library
		case "Virtual_name":
			res = inferedInstance.Virtual_name
		}
	case Wait:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Wavy_line:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Wedge:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Wood:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		}
	case Work:
		switch fieldName {
		// string value of fields
		case "Name":
			res = inferedInstance.Name
		case "Work_number":
			res = inferedInstance.Work_number
		case "Work_title":
			res = inferedInstance.Work_title
		case "Opus":
			if inferedInstance.Opus != nil {
				res = inferedInstance.Opus.Name
			}
		}
	default:
		_ = inferedInstance
	}
	return
}

// Last line of the template
