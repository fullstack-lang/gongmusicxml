// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongmusicxml/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Notations_sql sql.NullBool
var dummy_Notations_time time.Duration
var dummy_Notations_sort sort.Float64Slice

// NotationsAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model notationsAPI
type NotationsAPI struct {
	gorm.Model

	models.Notations_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	NotationsPointersEncoding NotationsPointersEncoding
}

// NotationsPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type NotationsPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field Tied is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	TiedID sql.NullInt64

	// field Slur is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	SlurID sql.NullInt64

	// field Tuplet is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	TupletID sql.NullInt64

	// field Glissando is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	GlissandoID sql.NullInt64

	// field Slide is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	SlideID sql.NullInt64

	// field Ornaments is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	OrnamentsID sql.NullInt64

	// field Technical is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	TechnicalID sql.NullInt64

	// field Articulations is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	ArticulationsID sql.NullInt64

	// field Dynamics is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	DynamicsID sql.NullInt64

	// field Fermata is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	FermataID sql.NullInt64

	// field Arpeggiate is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	ArpeggiateID sql.NullInt64

	// field Non_arpeggiate is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Non_arpeggiateID sql.NullInt64

	// field Accidental_mark is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Accidental_markID sql.NullInt64

	// field Other_notation is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Other_notationID sql.NullInt64
}

// NotationsDB describes a notations in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model notationsDB
type NotationsDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field notationsDB.Name
	Name_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	NotationsPointersEncoding
}

// NotationsDBs arrays notationsDBs
// swagger:response notationsDBsResponse
type NotationsDBs []NotationsDB

// NotationsDBResponse provides response
// swagger:response notationsDBResponse
type NotationsDBResponse struct {
	NotationsDB
}

// NotationsWOP is a Notations without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type NotationsWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`
	// insertion for WOP pointer fields
}

var Notations_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
}

type BackRepoNotationsStruct struct {
	// stores NotationsDB according to their gorm ID
	Map_NotationsDBID_NotationsDB map[uint]*NotationsDB

	// stores NotationsDB ID according to Notations address
	Map_NotationsPtr_NotationsDBID map[*models.Notations]uint

	// stores Notations according to their gorm ID
	Map_NotationsDBID_NotationsPtr map[uint]*models.Notations

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoNotations *BackRepoNotationsStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoNotations.stage
	return
}

func (backRepoNotations *BackRepoNotationsStruct) GetDB() *gorm.DB {
	return backRepoNotations.db
}

// GetNotationsDBFromNotationsPtr is a handy function to access the back repo instance from the stage instance
func (backRepoNotations *BackRepoNotationsStruct) GetNotationsDBFromNotationsPtr(notations *models.Notations) (notationsDB *NotationsDB) {
	id := backRepoNotations.Map_NotationsPtr_NotationsDBID[notations]
	notationsDB = backRepoNotations.Map_NotationsDBID_NotationsDB[id]
	return
}

// BackRepoNotations.CommitPhaseOne commits all staged instances of Notations to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoNotations *BackRepoNotationsStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for notations := range stage.Notationss {
		backRepoNotations.CommitPhaseOneInstance(notations)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, notations := range backRepoNotations.Map_NotationsDBID_NotationsPtr {
		if _, ok := stage.Notationss[notations]; !ok {
			backRepoNotations.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoNotations.CommitDeleteInstance commits deletion of Notations to the BackRepo
func (backRepoNotations *BackRepoNotationsStruct) CommitDeleteInstance(id uint) (Error error) {

	notations := backRepoNotations.Map_NotationsDBID_NotationsPtr[id]

	// notations is not staged anymore, remove notationsDB
	notationsDB := backRepoNotations.Map_NotationsDBID_NotationsDB[id]
	query := backRepoNotations.db.Unscoped().Delete(&notationsDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoNotations.Map_NotationsPtr_NotationsDBID, notations)
	delete(backRepoNotations.Map_NotationsDBID_NotationsPtr, id)
	delete(backRepoNotations.Map_NotationsDBID_NotationsDB, id)

	return
}

// BackRepoNotations.CommitPhaseOneInstance commits notations staged instances of Notations to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoNotations *BackRepoNotationsStruct) CommitPhaseOneInstance(notations *models.Notations) (Error error) {

	// check if the notations is not commited yet
	if _, ok := backRepoNotations.Map_NotationsPtr_NotationsDBID[notations]; ok {
		return
	}

	// initiate notations
	var notationsDB NotationsDB
	notationsDB.CopyBasicFieldsFromNotations(notations)

	query := backRepoNotations.db.Create(&notationsDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoNotations.Map_NotationsPtr_NotationsDBID[notations] = notationsDB.ID
	backRepoNotations.Map_NotationsDBID_NotationsPtr[notationsDB.ID] = notations
	backRepoNotations.Map_NotationsDBID_NotationsDB[notationsDB.ID] = &notationsDB

	return
}

// BackRepoNotations.CommitPhaseTwo commits all staged instances of Notations to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoNotations *BackRepoNotationsStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, notations := range backRepoNotations.Map_NotationsDBID_NotationsPtr {
		backRepoNotations.CommitPhaseTwoInstance(backRepo, idx, notations)
	}

	return
}

// BackRepoNotations.CommitPhaseTwoInstance commits {{structname }} of models.Notations to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoNotations *BackRepoNotationsStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, notations *models.Notations) (Error error) {

	// fetch matching notationsDB
	if notationsDB, ok := backRepoNotations.Map_NotationsDBID_NotationsDB[idx]; ok {

		notationsDB.CopyBasicFieldsFromNotations(notations)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value notations.Tied translates to updating the notations.TiedID
		notationsDB.TiedID.Valid = true // allow for a 0 value (nil association)
		if notations.Tied != nil {
			if TiedId, ok := backRepo.BackRepoTied.Map_TiedPtr_TiedDBID[notations.Tied]; ok {
				notationsDB.TiedID.Int64 = int64(TiedId)
				notationsDB.TiedID.Valid = true
			}
		} else {
			notationsDB.TiedID.Int64 = 0
			notationsDB.TiedID.Valid = true
		}

		// commit pointer value notations.Slur translates to updating the notations.SlurID
		notationsDB.SlurID.Valid = true // allow for a 0 value (nil association)
		if notations.Slur != nil {
			if SlurId, ok := backRepo.BackRepoSlur.Map_SlurPtr_SlurDBID[notations.Slur]; ok {
				notationsDB.SlurID.Int64 = int64(SlurId)
				notationsDB.SlurID.Valid = true
			}
		} else {
			notationsDB.SlurID.Int64 = 0
			notationsDB.SlurID.Valid = true
		}

		// commit pointer value notations.Tuplet translates to updating the notations.TupletID
		notationsDB.TupletID.Valid = true // allow for a 0 value (nil association)
		if notations.Tuplet != nil {
			if TupletId, ok := backRepo.BackRepoTuplet.Map_TupletPtr_TupletDBID[notations.Tuplet]; ok {
				notationsDB.TupletID.Int64 = int64(TupletId)
				notationsDB.TupletID.Valid = true
			}
		} else {
			notationsDB.TupletID.Int64 = 0
			notationsDB.TupletID.Valid = true
		}

		// commit pointer value notations.Glissando translates to updating the notations.GlissandoID
		notationsDB.GlissandoID.Valid = true // allow for a 0 value (nil association)
		if notations.Glissando != nil {
			if GlissandoId, ok := backRepo.BackRepoGlissando.Map_GlissandoPtr_GlissandoDBID[notations.Glissando]; ok {
				notationsDB.GlissandoID.Int64 = int64(GlissandoId)
				notationsDB.GlissandoID.Valid = true
			}
		} else {
			notationsDB.GlissandoID.Int64 = 0
			notationsDB.GlissandoID.Valid = true
		}

		// commit pointer value notations.Slide translates to updating the notations.SlideID
		notationsDB.SlideID.Valid = true // allow for a 0 value (nil association)
		if notations.Slide != nil {
			if SlideId, ok := backRepo.BackRepoSlide.Map_SlidePtr_SlideDBID[notations.Slide]; ok {
				notationsDB.SlideID.Int64 = int64(SlideId)
				notationsDB.SlideID.Valid = true
			}
		} else {
			notationsDB.SlideID.Int64 = 0
			notationsDB.SlideID.Valid = true
		}

		// commit pointer value notations.Ornaments translates to updating the notations.OrnamentsID
		notationsDB.OrnamentsID.Valid = true // allow for a 0 value (nil association)
		if notations.Ornaments != nil {
			if OrnamentsId, ok := backRepo.BackRepoOrnaments.Map_OrnamentsPtr_OrnamentsDBID[notations.Ornaments]; ok {
				notationsDB.OrnamentsID.Int64 = int64(OrnamentsId)
				notationsDB.OrnamentsID.Valid = true
			}
		} else {
			notationsDB.OrnamentsID.Int64 = 0
			notationsDB.OrnamentsID.Valid = true
		}

		// commit pointer value notations.Technical translates to updating the notations.TechnicalID
		notationsDB.TechnicalID.Valid = true // allow for a 0 value (nil association)
		if notations.Technical != nil {
			if TechnicalId, ok := backRepo.BackRepoTechnical.Map_TechnicalPtr_TechnicalDBID[notations.Technical]; ok {
				notationsDB.TechnicalID.Int64 = int64(TechnicalId)
				notationsDB.TechnicalID.Valid = true
			}
		} else {
			notationsDB.TechnicalID.Int64 = 0
			notationsDB.TechnicalID.Valid = true
		}

		// commit pointer value notations.Articulations translates to updating the notations.ArticulationsID
		notationsDB.ArticulationsID.Valid = true // allow for a 0 value (nil association)
		if notations.Articulations != nil {
			if ArticulationsId, ok := backRepo.BackRepoArticulations.Map_ArticulationsPtr_ArticulationsDBID[notations.Articulations]; ok {
				notationsDB.ArticulationsID.Int64 = int64(ArticulationsId)
				notationsDB.ArticulationsID.Valid = true
			}
		} else {
			notationsDB.ArticulationsID.Int64 = 0
			notationsDB.ArticulationsID.Valid = true
		}

		// commit pointer value notations.Dynamics translates to updating the notations.DynamicsID
		notationsDB.DynamicsID.Valid = true // allow for a 0 value (nil association)
		if notations.Dynamics != nil {
			if DynamicsId, ok := backRepo.BackRepoDynamics.Map_DynamicsPtr_DynamicsDBID[notations.Dynamics]; ok {
				notationsDB.DynamicsID.Int64 = int64(DynamicsId)
				notationsDB.DynamicsID.Valid = true
			}
		} else {
			notationsDB.DynamicsID.Int64 = 0
			notationsDB.DynamicsID.Valid = true
		}

		// commit pointer value notations.Fermata translates to updating the notations.FermataID
		notationsDB.FermataID.Valid = true // allow for a 0 value (nil association)
		if notations.Fermata != nil {
			if FermataId, ok := backRepo.BackRepoFermata.Map_FermataPtr_FermataDBID[notations.Fermata]; ok {
				notationsDB.FermataID.Int64 = int64(FermataId)
				notationsDB.FermataID.Valid = true
			}
		} else {
			notationsDB.FermataID.Int64 = 0
			notationsDB.FermataID.Valid = true
		}

		// commit pointer value notations.Arpeggiate translates to updating the notations.ArpeggiateID
		notationsDB.ArpeggiateID.Valid = true // allow for a 0 value (nil association)
		if notations.Arpeggiate != nil {
			if ArpeggiateId, ok := backRepo.BackRepoArpeggiate.Map_ArpeggiatePtr_ArpeggiateDBID[notations.Arpeggiate]; ok {
				notationsDB.ArpeggiateID.Int64 = int64(ArpeggiateId)
				notationsDB.ArpeggiateID.Valid = true
			}
		} else {
			notationsDB.ArpeggiateID.Int64 = 0
			notationsDB.ArpeggiateID.Valid = true
		}

		// commit pointer value notations.Non_arpeggiate translates to updating the notations.Non_arpeggiateID
		notationsDB.Non_arpeggiateID.Valid = true // allow for a 0 value (nil association)
		if notations.Non_arpeggiate != nil {
			if Non_arpeggiateId, ok := backRepo.BackRepoNon_arpeggiate.Map_Non_arpeggiatePtr_Non_arpeggiateDBID[notations.Non_arpeggiate]; ok {
				notationsDB.Non_arpeggiateID.Int64 = int64(Non_arpeggiateId)
				notationsDB.Non_arpeggiateID.Valid = true
			}
		} else {
			notationsDB.Non_arpeggiateID.Int64 = 0
			notationsDB.Non_arpeggiateID.Valid = true
		}

		// commit pointer value notations.Accidental_mark translates to updating the notations.Accidental_markID
		notationsDB.Accidental_markID.Valid = true // allow for a 0 value (nil association)
		if notations.Accidental_mark != nil {
			if Accidental_markId, ok := backRepo.BackRepoAccidental_mark.Map_Accidental_markPtr_Accidental_markDBID[notations.Accidental_mark]; ok {
				notationsDB.Accidental_markID.Int64 = int64(Accidental_markId)
				notationsDB.Accidental_markID.Valid = true
			}
		} else {
			notationsDB.Accidental_markID.Int64 = 0
			notationsDB.Accidental_markID.Valid = true
		}

		// commit pointer value notations.Other_notation translates to updating the notations.Other_notationID
		notationsDB.Other_notationID.Valid = true // allow for a 0 value (nil association)
		if notations.Other_notation != nil {
			if Other_notationId, ok := backRepo.BackRepoOther_notation.Map_Other_notationPtr_Other_notationDBID[notations.Other_notation]; ok {
				notationsDB.Other_notationID.Int64 = int64(Other_notationId)
				notationsDB.Other_notationID.Valid = true
			}
		} else {
			notationsDB.Other_notationID.Int64 = 0
			notationsDB.Other_notationID.Valid = true
		}

		query := backRepoNotations.db.Save(&notationsDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Notations intance %s", notations.Name))
		return err
	}

	return
}

// BackRepoNotations.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoNotations *BackRepoNotationsStruct) CheckoutPhaseOne() (Error error) {

	notationsDBArray := make([]NotationsDB, 0)
	query := backRepoNotations.db.Find(&notationsDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	notationsInstancesToBeRemovedFromTheStage := make(map[*models.Notations]any)
	for key, value := range backRepoNotations.stage.Notationss {
		notationsInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, notationsDB := range notationsDBArray {
		backRepoNotations.CheckoutPhaseOneInstance(&notationsDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		notations, ok := backRepoNotations.Map_NotationsDBID_NotationsPtr[notationsDB.ID]
		if ok {
			delete(notationsInstancesToBeRemovedFromTheStage, notations)
		}
	}

	// remove from stage and back repo's 3 maps all notationss that are not in the checkout
	for notations := range notationsInstancesToBeRemovedFromTheStage {
		notations.Unstage(backRepoNotations.GetStage())

		// remove instance from the back repo 3 maps
		notationsID := backRepoNotations.Map_NotationsPtr_NotationsDBID[notations]
		delete(backRepoNotations.Map_NotationsPtr_NotationsDBID, notations)
		delete(backRepoNotations.Map_NotationsDBID_NotationsDB, notationsID)
		delete(backRepoNotations.Map_NotationsDBID_NotationsPtr, notationsID)
	}

	return
}

// CheckoutPhaseOneInstance takes a notationsDB that has been found in the DB, updates the backRepo and stages the
// models version of the notationsDB
func (backRepoNotations *BackRepoNotationsStruct) CheckoutPhaseOneInstance(notationsDB *NotationsDB) (Error error) {

	notations, ok := backRepoNotations.Map_NotationsDBID_NotationsPtr[notationsDB.ID]
	if !ok {
		notations = new(models.Notations)

		backRepoNotations.Map_NotationsDBID_NotationsPtr[notationsDB.ID] = notations
		backRepoNotations.Map_NotationsPtr_NotationsDBID[notations] = notationsDB.ID

		// append model store with the new element
		notations.Name = notationsDB.Name_Data.String
		notations.Stage(backRepoNotations.GetStage())
	}
	notationsDB.CopyBasicFieldsToNotations(notations)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	notations.Stage(backRepoNotations.GetStage())

	// preserve pointer to notationsDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_NotationsDBID_NotationsDB)[notationsDB hold variable pointers
	notationsDB_Data := *notationsDB
	preservedPtrToNotations := &notationsDB_Data
	backRepoNotations.Map_NotationsDBID_NotationsDB[notationsDB.ID] = preservedPtrToNotations

	return
}

// BackRepoNotations.CheckoutPhaseTwo Checkouts all staged instances of Notations to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoNotations *BackRepoNotationsStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, notationsDB := range backRepoNotations.Map_NotationsDBID_NotationsDB {
		backRepoNotations.CheckoutPhaseTwoInstance(backRepo, notationsDB)
	}
	return
}

// BackRepoNotations.CheckoutPhaseTwoInstance Checkouts staged instances of Notations to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoNotations *BackRepoNotationsStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, notationsDB *NotationsDB) (Error error) {

	notations := backRepoNotations.Map_NotationsDBID_NotationsPtr[notationsDB.ID]

	notationsDB.DecodePointers(backRepo, notations)

	return
}

func (notationsDB *NotationsDB) DecodePointers(backRepo *BackRepoStruct, notations *models.Notations) {

	// insertion point for checkout of pointer encoding
	// Tied field
	notations.Tied = nil
	if notationsDB.TiedID.Int64 != 0 {
		notations.Tied = backRepo.BackRepoTied.Map_TiedDBID_TiedPtr[uint(notationsDB.TiedID.Int64)]
	}
	// Slur field
	notations.Slur = nil
	if notationsDB.SlurID.Int64 != 0 {
		notations.Slur = backRepo.BackRepoSlur.Map_SlurDBID_SlurPtr[uint(notationsDB.SlurID.Int64)]
	}
	// Tuplet field
	notations.Tuplet = nil
	if notationsDB.TupletID.Int64 != 0 {
		notations.Tuplet = backRepo.BackRepoTuplet.Map_TupletDBID_TupletPtr[uint(notationsDB.TupletID.Int64)]
	}
	// Glissando field
	notations.Glissando = nil
	if notationsDB.GlissandoID.Int64 != 0 {
		notations.Glissando = backRepo.BackRepoGlissando.Map_GlissandoDBID_GlissandoPtr[uint(notationsDB.GlissandoID.Int64)]
	}
	// Slide field
	notations.Slide = nil
	if notationsDB.SlideID.Int64 != 0 {
		notations.Slide = backRepo.BackRepoSlide.Map_SlideDBID_SlidePtr[uint(notationsDB.SlideID.Int64)]
	}
	// Ornaments field
	notations.Ornaments = nil
	if notationsDB.OrnamentsID.Int64 != 0 {
		notations.Ornaments = backRepo.BackRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr[uint(notationsDB.OrnamentsID.Int64)]
	}
	// Technical field
	notations.Technical = nil
	if notationsDB.TechnicalID.Int64 != 0 {
		notations.Technical = backRepo.BackRepoTechnical.Map_TechnicalDBID_TechnicalPtr[uint(notationsDB.TechnicalID.Int64)]
	}
	// Articulations field
	notations.Articulations = nil
	if notationsDB.ArticulationsID.Int64 != 0 {
		notations.Articulations = backRepo.BackRepoArticulations.Map_ArticulationsDBID_ArticulationsPtr[uint(notationsDB.ArticulationsID.Int64)]
	}
	// Dynamics field
	notations.Dynamics = nil
	if notationsDB.DynamicsID.Int64 != 0 {
		notations.Dynamics = backRepo.BackRepoDynamics.Map_DynamicsDBID_DynamicsPtr[uint(notationsDB.DynamicsID.Int64)]
	}
	// Fermata field
	notations.Fermata = nil
	if notationsDB.FermataID.Int64 != 0 {
		notations.Fermata = backRepo.BackRepoFermata.Map_FermataDBID_FermataPtr[uint(notationsDB.FermataID.Int64)]
	}
	// Arpeggiate field
	notations.Arpeggiate = nil
	if notationsDB.ArpeggiateID.Int64 != 0 {
		notations.Arpeggiate = backRepo.BackRepoArpeggiate.Map_ArpeggiateDBID_ArpeggiatePtr[uint(notationsDB.ArpeggiateID.Int64)]
	}
	// Non_arpeggiate field
	notations.Non_arpeggiate = nil
	if notationsDB.Non_arpeggiateID.Int64 != 0 {
		notations.Non_arpeggiate = backRepo.BackRepoNon_arpeggiate.Map_Non_arpeggiateDBID_Non_arpeggiatePtr[uint(notationsDB.Non_arpeggiateID.Int64)]
	}
	// Accidental_mark field
	notations.Accidental_mark = nil
	if notationsDB.Accidental_markID.Int64 != 0 {
		notations.Accidental_mark = backRepo.BackRepoAccidental_mark.Map_Accidental_markDBID_Accidental_markPtr[uint(notationsDB.Accidental_markID.Int64)]
	}
	// Other_notation field
	notations.Other_notation = nil
	if notationsDB.Other_notationID.Int64 != 0 {
		notations.Other_notation = backRepo.BackRepoOther_notation.Map_Other_notationDBID_Other_notationPtr[uint(notationsDB.Other_notationID.Int64)]
	}
	return
}

// CommitNotations allows commit of a single notations (if already staged)
func (backRepo *BackRepoStruct) CommitNotations(notations *models.Notations) {
	backRepo.BackRepoNotations.CommitPhaseOneInstance(notations)
	if id, ok := backRepo.BackRepoNotations.Map_NotationsPtr_NotationsDBID[notations]; ok {
		backRepo.BackRepoNotations.CommitPhaseTwoInstance(backRepo, id, notations)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitNotations allows checkout of a single notations (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutNotations(notations *models.Notations) {
	// check if the notations is staged
	if _, ok := backRepo.BackRepoNotations.Map_NotationsPtr_NotationsDBID[notations]; ok {

		if id, ok := backRepo.BackRepoNotations.Map_NotationsPtr_NotationsDBID[notations]; ok {
			var notationsDB NotationsDB
			notationsDB.ID = id

			if err := backRepo.BackRepoNotations.db.First(&notationsDB, id).Error; err != nil {
				log.Fatalln("CheckoutNotations : Problem with getting object with id:", id)
			}
			backRepo.BackRepoNotations.CheckoutPhaseOneInstance(&notationsDB)
			backRepo.BackRepoNotations.CheckoutPhaseTwoInstance(backRepo, &notationsDB)
		}
	}
}

// CopyBasicFieldsFromNotations
func (notationsDB *NotationsDB) CopyBasicFieldsFromNotations(notations *models.Notations) {
	// insertion point for fields commit

	notationsDB.Name_Data.String = notations.Name
	notationsDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromNotations_WOP
func (notationsDB *NotationsDB) CopyBasicFieldsFromNotations_WOP(notations *models.Notations_WOP) {
	// insertion point for fields commit

	notationsDB.Name_Data.String = notations.Name
	notationsDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromNotationsWOP
func (notationsDB *NotationsDB) CopyBasicFieldsFromNotationsWOP(notations *NotationsWOP) {
	// insertion point for fields commit

	notationsDB.Name_Data.String = notations.Name
	notationsDB.Name_Data.Valid = true
}

// CopyBasicFieldsToNotations
func (notationsDB *NotationsDB) CopyBasicFieldsToNotations(notations *models.Notations) {
	// insertion point for checkout of basic fields (back repo to stage)
	notations.Name = notationsDB.Name_Data.String
}

// CopyBasicFieldsToNotations_WOP
func (notationsDB *NotationsDB) CopyBasicFieldsToNotations_WOP(notations *models.Notations_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	notations.Name = notationsDB.Name_Data.String
}

// CopyBasicFieldsToNotationsWOP
func (notationsDB *NotationsDB) CopyBasicFieldsToNotationsWOP(notations *NotationsWOP) {
	notations.ID = int(notationsDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	notations.Name = notationsDB.Name_Data.String
}

// Backup generates a json file from a slice of all NotationsDB instances in the backrepo
func (backRepoNotations *BackRepoNotationsStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "NotationsDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*NotationsDB, 0)
	for _, notationsDB := range backRepoNotations.Map_NotationsDBID_NotationsDB {
		forBackup = append(forBackup, notationsDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json Notations ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json Notations file", err.Error())
	}
}

// Backup generates a json file from a slice of all NotationsDB instances in the backrepo
func (backRepoNotations *BackRepoNotationsStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*NotationsDB, 0)
	for _, notationsDB := range backRepoNotations.Map_NotationsDBID_NotationsDB {
		forBackup = append(forBackup, notationsDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("Notations")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&Notations_Fields, -1)
	for _, notationsDB := range forBackup {

		var notationsWOP NotationsWOP
		notationsDB.CopyBasicFieldsToNotationsWOP(&notationsWOP)

		row := sh.AddRow()
		row.WriteStruct(&notationsWOP, -1)
	}
}

// RestoreXL from the "Notations" sheet all NotationsDB instances
func (backRepoNotations *BackRepoNotationsStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoNotationsid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["Notations"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoNotations.rowVisitorNotations)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoNotations *BackRepoNotationsStruct) rowVisitorNotations(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var notationsWOP NotationsWOP
		row.ReadStruct(&notationsWOP)

		// add the unmarshalled struct to the stage
		notationsDB := new(NotationsDB)
		notationsDB.CopyBasicFieldsFromNotationsWOP(&notationsWOP)

		notationsDB_ID_atBackupTime := notationsDB.ID
		notationsDB.ID = 0
		query := backRepoNotations.db.Create(notationsDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoNotations.Map_NotationsDBID_NotationsDB[notationsDB.ID] = notationsDB
		BackRepoNotationsid_atBckpTime_newID[notationsDB_ID_atBackupTime] = notationsDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "NotationsDB.json" in dirPath that stores an array
// of NotationsDB and stores it in the database
// the map BackRepoNotationsid_atBckpTime_newID is updated accordingly
func (backRepoNotations *BackRepoNotationsStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoNotationsid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "NotationsDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json Notations file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*NotationsDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_NotationsDBID_NotationsDB
	for _, notationsDB := range forRestore {

		notationsDB_ID_atBackupTime := notationsDB.ID
		notationsDB.ID = 0
		query := backRepoNotations.db.Create(notationsDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoNotations.Map_NotationsDBID_NotationsDB[notationsDB.ID] = notationsDB
		BackRepoNotationsid_atBckpTime_newID[notationsDB_ID_atBackupTime] = notationsDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json Notations file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Notations>id_atBckpTime_newID
// to compute new index
func (backRepoNotations *BackRepoNotationsStruct) RestorePhaseTwo() {

	for _, notationsDB := range backRepoNotations.Map_NotationsDBID_NotationsDB {

		// next line of code is to avert unused variable compilation error
		_ = notationsDB

		// insertion point for reindexing pointers encoding
		// reindexing Tied field
		if notationsDB.TiedID.Int64 != 0 {
			notationsDB.TiedID.Int64 = int64(BackRepoTiedid_atBckpTime_newID[uint(notationsDB.TiedID.Int64)])
			notationsDB.TiedID.Valid = true
		}

		// reindexing Slur field
		if notationsDB.SlurID.Int64 != 0 {
			notationsDB.SlurID.Int64 = int64(BackRepoSlurid_atBckpTime_newID[uint(notationsDB.SlurID.Int64)])
			notationsDB.SlurID.Valid = true
		}

		// reindexing Tuplet field
		if notationsDB.TupletID.Int64 != 0 {
			notationsDB.TupletID.Int64 = int64(BackRepoTupletid_atBckpTime_newID[uint(notationsDB.TupletID.Int64)])
			notationsDB.TupletID.Valid = true
		}

		// reindexing Glissando field
		if notationsDB.GlissandoID.Int64 != 0 {
			notationsDB.GlissandoID.Int64 = int64(BackRepoGlissandoid_atBckpTime_newID[uint(notationsDB.GlissandoID.Int64)])
			notationsDB.GlissandoID.Valid = true
		}

		// reindexing Slide field
		if notationsDB.SlideID.Int64 != 0 {
			notationsDB.SlideID.Int64 = int64(BackRepoSlideid_atBckpTime_newID[uint(notationsDB.SlideID.Int64)])
			notationsDB.SlideID.Valid = true
		}

		// reindexing Ornaments field
		if notationsDB.OrnamentsID.Int64 != 0 {
			notationsDB.OrnamentsID.Int64 = int64(BackRepoOrnamentsid_atBckpTime_newID[uint(notationsDB.OrnamentsID.Int64)])
			notationsDB.OrnamentsID.Valid = true
		}

		// reindexing Technical field
		if notationsDB.TechnicalID.Int64 != 0 {
			notationsDB.TechnicalID.Int64 = int64(BackRepoTechnicalid_atBckpTime_newID[uint(notationsDB.TechnicalID.Int64)])
			notationsDB.TechnicalID.Valid = true
		}

		// reindexing Articulations field
		if notationsDB.ArticulationsID.Int64 != 0 {
			notationsDB.ArticulationsID.Int64 = int64(BackRepoArticulationsid_atBckpTime_newID[uint(notationsDB.ArticulationsID.Int64)])
			notationsDB.ArticulationsID.Valid = true
		}

		// reindexing Dynamics field
		if notationsDB.DynamicsID.Int64 != 0 {
			notationsDB.DynamicsID.Int64 = int64(BackRepoDynamicsid_atBckpTime_newID[uint(notationsDB.DynamicsID.Int64)])
			notationsDB.DynamicsID.Valid = true
		}

		// reindexing Fermata field
		if notationsDB.FermataID.Int64 != 0 {
			notationsDB.FermataID.Int64 = int64(BackRepoFermataid_atBckpTime_newID[uint(notationsDB.FermataID.Int64)])
			notationsDB.FermataID.Valid = true
		}

		// reindexing Arpeggiate field
		if notationsDB.ArpeggiateID.Int64 != 0 {
			notationsDB.ArpeggiateID.Int64 = int64(BackRepoArpeggiateid_atBckpTime_newID[uint(notationsDB.ArpeggiateID.Int64)])
			notationsDB.ArpeggiateID.Valid = true
		}

		// reindexing Non_arpeggiate field
		if notationsDB.Non_arpeggiateID.Int64 != 0 {
			notationsDB.Non_arpeggiateID.Int64 = int64(BackRepoNon_arpeggiateid_atBckpTime_newID[uint(notationsDB.Non_arpeggiateID.Int64)])
			notationsDB.Non_arpeggiateID.Valid = true
		}

		// reindexing Accidental_mark field
		if notationsDB.Accidental_markID.Int64 != 0 {
			notationsDB.Accidental_markID.Int64 = int64(BackRepoAccidental_markid_atBckpTime_newID[uint(notationsDB.Accidental_markID.Int64)])
			notationsDB.Accidental_markID.Valid = true
		}

		// reindexing Other_notation field
		if notationsDB.Other_notationID.Int64 != 0 {
			notationsDB.Other_notationID.Int64 = int64(BackRepoOther_notationid_atBckpTime_newID[uint(notationsDB.Other_notationID.Int64)])
			notationsDB.Other_notationID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoNotations.db.Model(notationsDB).Updates(*notationsDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoNotations.ResetReversePointers commits all staged instances of Notations to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoNotations *BackRepoNotationsStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, notations := range backRepoNotations.Map_NotationsDBID_NotationsPtr {
		backRepoNotations.ResetReversePointersInstance(backRepo, idx, notations)
	}

	return
}

func (backRepoNotations *BackRepoNotationsStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, notations *models.Notations) (Error error) {

	// fetch matching notationsDB
	if notationsDB, ok := backRepoNotations.Map_NotationsDBID_NotationsDB[idx]; ok {
		_ = notationsDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoNotationsid_atBckpTime_newID map[uint]uint
