// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongmusicxml/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Direction_sql sql.NullBool
var dummy_Direction_time time.Duration
var dummy_Direction_sort sort.Float64Slice

// DirectionAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model directionAPI
type DirectionAPI struct {
	gorm.Model

	models.Direction_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	DirectionPointersEncoding DirectionPointersEncoding
}

// DirectionPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type DirectionPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field Direction_type is a slice of pointers to another Struct (optional or 0..1)
	Direction_type IntSlice `gorm:"type:TEXT"`

	// field Offset is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	OffsetID sql.NullInt64

	// field Sound is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	SoundID sql.NullInt64

	// field Listening is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	ListeningID sql.NullInt64
}

// DirectionDB describes a direction in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model directionDB
type DirectionDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field directionDB.Name
	Name_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	DirectionPointersEncoding
}

// DirectionDBs arrays directionDBs
// swagger:response directionDBsResponse
type DirectionDBs []DirectionDB

// DirectionDBResponse provides response
// swagger:response directionDBResponse
type DirectionDBResponse struct {
	DirectionDB
}

// DirectionWOP is a Direction without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type DirectionWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`
	// insertion for WOP pointer fields
}

var Direction_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
}

type BackRepoDirectionStruct struct {
	// stores DirectionDB according to their gorm ID
	Map_DirectionDBID_DirectionDB map[uint]*DirectionDB

	// stores DirectionDB ID according to Direction address
	Map_DirectionPtr_DirectionDBID map[*models.Direction]uint

	// stores Direction according to their gorm ID
	Map_DirectionDBID_DirectionPtr map[uint]*models.Direction

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoDirection *BackRepoDirectionStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoDirection.stage
	return
}

func (backRepoDirection *BackRepoDirectionStruct) GetDB() *gorm.DB {
	return backRepoDirection.db
}

// GetDirectionDBFromDirectionPtr is a handy function to access the back repo instance from the stage instance
func (backRepoDirection *BackRepoDirectionStruct) GetDirectionDBFromDirectionPtr(direction *models.Direction) (directionDB *DirectionDB) {
	id := backRepoDirection.Map_DirectionPtr_DirectionDBID[direction]
	directionDB = backRepoDirection.Map_DirectionDBID_DirectionDB[id]
	return
}

// BackRepoDirection.CommitPhaseOne commits all staged instances of Direction to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoDirection *BackRepoDirectionStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for direction := range stage.Directions {
		backRepoDirection.CommitPhaseOneInstance(direction)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, direction := range backRepoDirection.Map_DirectionDBID_DirectionPtr {
		if _, ok := stage.Directions[direction]; !ok {
			backRepoDirection.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoDirection.CommitDeleteInstance commits deletion of Direction to the BackRepo
func (backRepoDirection *BackRepoDirectionStruct) CommitDeleteInstance(id uint) (Error error) {

	direction := backRepoDirection.Map_DirectionDBID_DirectionPtr[id]

	// direction is not staged anymore, remove directionDB
	directionDB := backRepoDirection.Map_DirectionDBID_DirectionDB[id]
	query := backRepoDirection.db.Unscoped().Delete(&directionDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoDirection.Map_DirectionPtr_DirectionDBID, direction)
	delete(backRepoDirection.Map_DirectionDBID_DirectionPtr, id)
	delete(backRepoDirection.Map_DirectionDBID_DirectionDB, id)

	return
}

// BackRepoDirection.CommitPhaseOneInstance commits direction staged instances of Direction to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoDirection *BackRepoDirectionStruct) CommitPhaseOneInstance(direction *models.Direction) (Error error) {

	// check if the direction is not commited yet
	if _, ok := backRepoDirection.Map_DirectionPtr_DirectionDBID[direction]; ok {
		return
	}

	// initiate direction
	var directionDB DirectionDB
	directionDB.CopyBasicFieldsFromDirection(direction)

	query := backRepoDirection.db.Create(&directionDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoDirection.Map_DirectionPtr_DirectionDBID[direction] = directionDB.ID
	backRepoDirection.Map_DirectionDBID_DirectionPtr[directionDB.ID] = direction
	backRepoDirection.Map_DirectionDBID_DirectionDB[directionDB.ID] = &directionDB

	return
}

// BackRepoDirection.CommitPhaseTwo commits all staged instances of Direction to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDirection *BackRepoDirectionStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, direction := range backRepoDirection.Map_DirectionDBID_DirectionPtr {
		backRepoDirection.CommitPhaseTwoInstance(backRepo, idx, direction)
	}

	return
}

// BackRepoDirection.CommitPhaseTwoInstance commits {{structname }} of models.Direction to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDirection *BackRepoDirectionStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, direction *models.Direction) (Error error) {

	// fetch matching directionDB
	if directionDB, ok := backRepoDirection.Map_DirectionDBID_DirectionDB[idx]; ok {

		directionDB.CopyBasicFieldsFromDirection(direction)

		// insertion point for translating pointers encodings into actual pointers
		// 1. reset
		directionDB.DirectionPointersEncoding.Direction_type = make([]int, 0)
		// 2. encode
		for _, direction_typeAssocEnd := range direction.Direction_type {
			direction_typeAssocEnd_DB :=
				backRepo.BackRepoDirection_type.GetDirection_typeDBFromDirection_typePtr(direction_typeAssocEnd)
			
			// the stage might be inconsistant, meaning that the direction_typeAssocEnd_DB might
			// be missing from the stage. In this case, the commit operation is robust
			// An alternative would be to crash here to reveal the missing element.
			if direction_typeAssocEnd_DB == nil {
				continue
			}
			
			directionDB.DirectionPointersEncoding.Direction_type =
				append(directionDB.DirectionPointersEncoding.Direction_type, int(direction_typeAssocEnd_DB.ID))
		}

		// commit pointer value direction.Offset translates to updating the direction.OffsetID
		directionDB.OffsetID.Valid = true // allow for a 0 value (nil association)
		if direction.Offset != nil {
			if OffsetId, ok := backRepo.BackRepoOffset.Map_OffsetPtr_OffsetDBID[direction.Offset]; ok {
				directionDB.OffsetID.Int64 = int64(OffsetId)
				directionDB.OffsetID.Valid = true
			}
		} else {
			directionDB.OffsetID.Int64 = 0
			directionDB.OffsetID.Valid = true
		}

		// commit pointer value direction.Sound translates to updating the direction.SoundID
		directionDB.SoundID.Valid = true // allow for a 0 value (nil association)
		if direction.Sound != nil {
			if SoundId, ok := backRepo.BackRepoSound.Map_SoundPtr_SoundDBID[direction.Sound]; ok {
				directionDB.SoundID.Int64 = int64(SoundId)
				directionDB.SoundID.Valid = true
			}
		} else {
			directionDB.SoundID.Int64 = 0
			directionDB.SoundID.Valid = true
		}

		// commit pointer value direction.Listening translates to updating the direction.ListeningID
		directionDB.ListeningID.Valid = true // allow for a 0 value (nil association)
		if direction.Listening != nil {
			if ListeningId, ok := backRepo.BackRepoListening.Map_ListeningPtr_ListeningDBID[direction.Listening]; ok {
				directionDB.ListeningID.Int64 = int64(ListeningId)
				directionDB.ListeningID.Valid = true
			}
		} else {
			directionDB.ListeningID.Int64 = 0
			directionDB.ListeningID.Valid = true
		}

		query := backRepoDirection.db.Save(&directionDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Direction intance %s", direction.Name))
		return err
	}

	return
}

// BackRepoDirection.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoDirection *BackRepoDirectionStruct) CheckoutPhaseOne() (Error error) {

	directionDBArray := make([]DirectionDB, 0)
	query := backRepoDirection.db.Find(&directionDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	directionInstancesToBeRemovedFromTheStage := make(map[*models.Direction]any)
	for key, value := range backRepoDirection.stage.Directions {
		directionInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, directionDB := range directionDBArray {
		backRepoDirection.CheckoutPhaseOneInstance(&directionDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		direction, ok := backRepoDirection.Map_DirectionDBID_DirectionPtr[directionDB.ID]
		if ok {
			delete(directionInstancesToBeRemovedFromTheStage, direction)
		}
	}

	// remove from stage and back repo's 3 maps all directions that are not in the checkout
	for direction := range directionInstancesToBeRemovedFromTheStage {
		direction.Unstage(backRepoDirection.GetStage())

		// remove instance from the back repo 3 maps
		directionID := backRepoDirection.Map_DirectionPtr_DirectionDBID[direction]
		delete(backRepoDirection.Map_DirectionPtr_DirectionDBID, direction)
		delete(backRepoDirection.Map_DirectionDBID_DirectionDB, directionID)
		delete(backRepoDirection.Map_DirectionDBID_DirectionPtr, directionID)
	}

	return
}

// CheckoutPhaseOneInstance takes a directionDB that has been found in the DB, updates the backRepo and stages the
// models version of the directionDB
func (backRepoDirection *BackRepoDirectionStruct) CheckoutPhaseOneInstance(directionDB *DirectionDB) (Error error) {

	direction, ok := backRepoDirection.Map_DirectionDBID_DirectionPtr[directionDB.ID]
	if !ok {
		direction = new(models.Direction)

		backRepoDirection.Map_DirectionDBID_DirectionPtr[directionDB.ID] = direction
		backRepoDirection.Map_DirectionPtr_DirectionDBID[direction] = directionDB.ID

		// append model store with the new element
		direction.Name = directionDB.Name_Data.String
		direction.Stage(backRepoDirection.GetStage())
	}
	directionDB.CopyBasicFieldsToDirection(direction)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	direction.Stage(backRepoDirection.GetStage())

	// preserve pointer to directionDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_DirectionDBID_DirectionDB)[directionDB hold variable pointers
	directionDB_Data := *directionDB
	preservedPtrToDirection := &directionDB_Data
	backRepoDirection.Map_DirectionDBID_DirectionDB[directionDB.ID] = preservedPtrToDirection

	return
}

// BackRepoDirection.CheckoutPhaseTwo Checkouts all staged instances of Direction to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDirection *BackRepoDirectionStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, directionDB := range backRepoDirection.Map_DirectionDBID_DirectionDB {
		backRepoDirection.CheckoutPhaseTwoInstance(backRepo, directionDB)
	}
	return
}

// BackRepoDirection.CheckoutPhaseTwoInstance Checkouts staged instances of Direction to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDirection *BackRepoDirectionStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, directionDB *DirectionDB) (Error error) {

	direction := backRepoDirection.Map_DirectionDBID_DirectionPtr[directionDB.ID]

	directionDB.DecodePointers(backRepo, direction)

	return
}

func (directionDB *DirectionDB) DecodePointers(backRepo *BackRepoStruct, direction *models.Direction) {

	// insertion point for checkout of pointer encoding
	// This loop redeem direction.Direction_type in the stage from the encode in the back repo
	// It parses all Direction_typeDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	direction.Direction_type = direction.Direction_type[:0]
	for _, _Direction_typeid := range directionDB.DirectionPointersEncoding.Direction_type {
		direction.Direction_type = append(direction.Direction_type, backRepo.BackRepoDirection_type.Map_Direction_typeDBID_Direction_typePtr[uint(_Direction_typeid)])
	}

	// Offset field
	direction.Offset = nil
	if directionDB.OffsetID.Int64 != 0 {
		direction.Offset = backRepo.BackRepoOffset.Map_OffsetDBID_OffsetPtr[uint(directionDB.OffsetID.Int64)]
	}
	// Sound field
	direction.Sound = nil
	if directionDB.SoundID.Int64 != 0 {
		direction.Sound = backRepo.BackRepoSound.Map_SoundDBID_SoundPtr[uint(directionDB.SoundID.Int64)]
	}
	// Listening field
	direction.Listening = nil
	if directionDB.ListeningID.Int64 != 0 {
		direction.Listening = backRepo.BackRepoListening.Map_ListeningDBID_ListeningPtr[uint(directionDB.ListeningID.Int64)]
	}
	return
}

// CommitDirection allows commit of a single direction (if already staged)
func (backRepo *BackRepoStruct) CommitDirection(direction *models.Direction) {
	backRepo.BackRepoDirection.CommitPhaseOneInstance(direction)
	if id, ok := backRepo.BackRepoDirection.Map_DirectionPtr_DirectionDBID[direction]; ok {
		backRepo.BackRepoDirection.CommitPhaseTwoInstance(backRepo, id, direction)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitDirection allows checkout of a single direction (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutDirection(direction *models.Direction) {
	// check if the direction is staged
	if _, ok := backRepo.BackRepoDirection.Map_DirectionPtr_DirectionDBID[direction]; ok {

		if id, ok := backRepo.BackRepoDirection.Map_DirectionPtr_DirectionDBID[direction]; ok {
			var directionDB DirectionDB
			directionDB.ID = id

			if err := backRepo.BackRepoDirection.db.First(&directionDB, id).Error; err != nil {
				log.Fatalln("CheckoutDirection : Problem with getting object with id:", id)
			}
			backRepo.BackRepoDirection.CheckoutPhaseOneInstance(&directionDB)
			backRepo.BackRepoDirection.CheckoutPhaseTwoInstance(backRepo, &directionDB)
		}
	}
}

// CopyBasicFieldsFromDirection
func (directionDB *DirectionDB) CopyBasicFieldsFromDirection(direction *models.Direction) {
	// insertion point for fields commit

	directionDB.Name_Data.String = direction.Name
	directionDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromDirection_WOP
func (directionDB *DirectionDB) CopyBasicFieldsFromDirection_WOP(direction *models.Direction_WOP) {
	// insertion point for fields commit

	directionDB.Name_Data.String = direction.Name
	directionDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromDirectionWOP
func (directionDB *DirectionDB) CopyBasicFieldsFromDirectionWOP(direction *DirectionWOP) {
	// insertion point for fields commit

	directionDB.Name_Data.String = direction.Name
	directionDB.Name_Data.Valid = true
}

// CopyBasicFieldsToDirection
func (directionDB *DirectionDB) CopyBasicFieldsToDirection(direction *models.Direction) {
	// insertion point for checkout of basic fields (back repo to stage)
	direction.Name = directionDB.Name_Data.String
}

// CopyBasicFieldsToDirection_WOP
func (directionDB *DirectionDB) CopyBasicFieldsToDirection_WOP(direction *models.Direction_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	direction.Name = directionDB.Name_Data.String
}

// CopyBasicFieldsToDirectionWOP
func (directionDB *DirectionDB) CopyBasicFieldsToDirectionWOP(direction *DirectionWOP) {
	direction.ID = int(directionDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	direction.Name = directionDB.Name_Data.String
}

// Backup generates a json file from a slice of all DirectionDB instances in the backrepo
func (backRepoDirection *BackRepoDirectionStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "DirectionDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*DirectionDB, 0)
	for _, directionDB := range backRepoDirection.Map_DirectionDBID_DirectionDB {
		forBackup = append(forBackup, directionDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json Direction ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json Direction file", err.Error())
	}
}

// Backup generates a json file from a slice of all DirectionDB instances in the backrepo
func (backRepoDirection *BackRepoDirectionStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*DirectionDB, 0)
	for _, directionDB := range backRepoDirection.Map_DirectionDBID_DirectionDB {
		forBackup = append(forBackup, directionDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("Direction")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&Direction_Fields, -1)
	for _, directionDB := range forBackup {

		var directionWOP DirectionWOP
		directionDB.CopyBasicFieldsToDirectionWOP(&directionWOP)

		row := sh.AddRow()
		row.WriteStruct(&directionWOP, -1)
	}
}

// RestoreXL from the "Direction" sheet all DirectionDB instances
func (backRepoDirection *BackRepoDirectionStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoDirectionid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["Direction"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoDirection.rowVisitorDirection)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoDirection *BackRepoDirectionStruct) rowVisitorDirection(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var directionWOP DirectionWOP
		row.ReadStruct(&directionWOP)

		// add the unmarshalled struct to the stage
		directionDB := new(DirectionDB)
		directionDB.CopyBasicFieldsFromDirectionWOP(&directionWOP)

		directionDB_ID_atBackupTime := directionDB.ID
		directionDB.ID = 0
		query := backRepoDirection.db.Create(directionDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoDirection.Map_DirectionDBID_DirectionDB[directionDB.ID] = directionDB
		BackRepoDirectionid_atBckpTime_newID[directionDB_ID_atBackupTime] = directionDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "DirectionDB.json" in dirPath that stores an array
// of DirectionDB and stores it in the database
// the map BackRepoDirectionid_atBckpTime_newID is updated accordingly
func (backRepoDirection *BackRepoDirectionStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoDirectionid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "DirectionDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json Direction file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*DirectionDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_DirectionDBID_DirectionDB
	for _, directionDB := range forRestore {

		directionDB_ID_atBackupTime := directionDB.ID
		directionDB.ID = 0
		query := backRepoDirection.db.Create(directionDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoDirection.Map_DirectionDBID_DirectionDB[directionDB.ID] = directionDB
		BackRepoDirectionid_atBckpTime_newID[directionDB_ID_atBackupTime] = directionDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json Direction file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Direction>id_atBckpTime_newID
// to compute new index
func (backRepoDirection *BackRepoDirectionStruct) RestorePhaseTwo() {

	for _, directionDB := range backRepoDirection.Map_DirectionDBID_DirectionDB {

		// next line of code is to avert unused variable compilation error
		_ = directionDB

		// insertion point for reindexing pointers encoding
		// reindexing Offset field
		if directionDB.OffsetID.Int64 != 0 {
			directionDB.OffsetID.Int64 = int64(BackRepoOffsetid_atBckpTime_newID[uint(directionDB.OffsetID.Int64)])
			directionDB.OffsetID.Valid = true
		}

		// reindexing Sound field
		if directionDB.SoundID.Int64 != 0 {
			directionDB.SoundID.Int64 = int64(BackRepoSoundid_atBckpTime_newID[uint(directionDB.SoundID.Int64)])
			directionDB.SoundID.Valid = true
		}

		// reindexing Listening field
		if directionDB.ListeningID.Int64 != 0 {
			directionDB.ListeningID.Int64 = int64(BackRepoListeningid_atBckpTime_newID[uint(directionDB.ListeningID.Int64)])
			directionDB.ListeningID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoDirection.db.Model(directionDB).Updates(*directionDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoDirection.ResetReversePointers commits all staged instances of Direction to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDirection *BackRepoDirectionStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, direction := range backRepoDirection.Map_DirectionDBID_DirectionPtr {
		backRepoDirection.ResetReversePointersInstance(backRepo, idx, direction)
	}

	return
}

func (backRepoDirection *BackRepoDirectionStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, direction *models.Direction) (Error error) {

	// fetch matching directionDB
	if directionDB, ok := backRepoDirection.Map_DirectionDBID_DirectionDB[idx]; ok {
		_ = directionDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoDirectionid_atBckpTime_newID map[uint]uint
