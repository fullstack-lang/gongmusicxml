// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongmusicxml/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Ornaments_sql sql.NullBool
var dummy_Ornaments_time time.Duration
var dummy_Ornaments_sort sort.Float64Slice

// OrnamentsAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model ornamentsAPI
type OrnamentsAPI struct {
	gorm.Model

	models.Ornaments_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	OrnamentsPointersEncoding OrnamentsPointersEncoding
}

// OrnamentsPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type OrnamentsPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field Accidental_mark is a slice of pointers to another Struct (optional or 0..1)
	Accidental_mark IntSlice `gorm:"type:TEXT"`

	// field Trill_mark is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Trill_markID sql.NullInt64

	// field Turn is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	TurnID sql.NullInt64

	// field Delayed_turn is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Delayed_turnID sql.NullInt64

	// field Inverted_turn is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Inverted_turnID sql.NullInt64

	// field Delayed_inverted_turn is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Delayed_inverted_turnID sql.NullInt64

	// field Vertical_turn is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Vertical_turnID sql.NullInt64

	// field Inverted_vertical_turn is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Inverted_vertical_turnID sql.NullInt64

	// field Shake is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	ShakeID sql.NullInt64

	// field Wavy_line is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Wavy_lineID sql.NullInt64

	// field Mordent is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	MordentID sql.NullInt64

	// field Inverted_mordent is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Inverted_mordentID sql.NullInt64

	// field Schleifer is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	SchleiferID sql.NullInt64

	// field Tremolo is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	TremoloID sql.NullInt64

	// field Haydn is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	HaydnID sql.NullInt64
}

// OrnamentsDB describes a ornaments in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model ornamentsDB
type OrnamentsDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field ornamentsDB.Name
	Name_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	OrnamentsPointersEncoding
}

// OrnamentsDBs arrays ornamentsDBs
// swagger:response ornamentsDBsResponse
type OrnamentsDBs []OrnamentsDB

// OrnamentsDBResponse provides response
// swagger:response ornamentsDBResponse
type OrnamentsDBResponse struct {
	OrnamentsDB
}

// OrnamentsWOP is a Ornaments without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type OrnamentsWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`
	// insertion for WOP pointer fields
}

var Ornaments_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
}

type BackRepoOrnamentsStruct struct {
	// stores OrnamentsDB according to their gorm ID
	Map_OrnamentsDBID_OrnamentsDB map[uint]*OrnamentsDB

	// stores OrnamentsDB ID according to Ornaments address
	Map_OrnamentsPtr_OrnamentsDBID map[*models.Ornaments]uint

	// stores Ornaments according to their gorm ID
	Map_OrnamentsDBID_OrnamentsPtr map[uint]*models.Ornaments

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoOrnaments *BackRepoOrnamentsStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoOrnaments.stage
	return
}

func (backRepoOrnaments *BackRepoOrnamentsStruct) GetDB() *gorm.DB {
	return backRepoOrnaments.db
}

// GetOrnamentsDBFromOrnamentsPtr is a handy function to access the back repo instance from the stage instance
func (backRepoOrnaments *BackRepoOrnamentsStruct) GetOrnamentsDBFromOrnamentsPtr(ornaments *models.Ornaments) (ornamentsDB *OrnamentsDB) {
	id := backRepoOrnaments.Map_OrnamentsPtr_OrnamentsDBID[ornaments]
	ornamentsDB = backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB[id]
	return
}

// BackRepoOrnaments.CommitPhaseOne commits all staged instances of Ornaments to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoOrnaments *BackRepoOrnamentsStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for ornaments := range stage.Ornamentss {
		backRepoOrnaments.CommitPhaseOneInstance(ornaments)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, ornaments := range backRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr {
		if _, ok := stage.Ornamentss[ornaments]; !ok {
			backRepoOrnaments.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoOrnaments.CommitDeleteInstance commits deletion of Ornaments to the BackRepo
func (backRepoOrnaments *BackRepoOrnamentsStruct) CommitDeleteInstance(id uint) (Error error) {

	ornaments := backRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr[id]

	// ornaments is not staged anymore, remove ornamentsDB
	ornamentsDB := backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB[id]
	query := backRepoOrnaments.db.Unscoped().Delete(&ornamentsDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoOrnaments.Map_OrnamentsPtr_OrnamentsDBID, ornaments)
	delete(backRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr, id)
	delete(backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB, id)

	return
}

// BackRepoOrnaments.CommitPhaseOneInstance commits ornaments staged instances of Ornaments to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoOrnaments *BackRepoOrnamentsStruct) CommitPhaseOneInstance(ornaments *models.Ornaments) (Error error) {

	// check if the ornaments is not commited yet
	if _, ok := backRepoOrnaments.Map_OrnamentsPtr_OrnamentsDBID[ornaments]; ok {
		return
	}

	// initiate ornaments
	var ornamentsDB OrnamentsDB
	ornamentsDB.CopyBasicFieldsFromOrnaments(ornaments)

	query := backRepoOrnaments.db.Create(&ornamentsDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoOrnaments.Map_OrnamentsPtr_OrnamentsDBID[ornaments] = ornamentsDB.ID
	backRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr[ornamentsDB.ID] = ornaments
	backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB[ornamentsDB.ID] = &ornamentsDB

	return
}

// BackRepoOrnaments.CommitPhaseTwo commits all staged instances of Ornaments to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoOrnaments *BackRepoOrnamentsStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, ornaments := range backRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr {
		backRepoOrnaments.CommitPhaseTwoInstance(backRepo, idx, ornaments)
	}

	return
}

// BackRepoOrnaments.CommitPhaseTwoInstance commits {{structname }} of models.Ornaments to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoOrnaments *BackRepoOrnamentsStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, ornaments *models.Ornaments) (Error error) {

	// fetch matching ornamentsDB
	if ornamentsDB, ok := backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB[idx]; ok {

		ornamentsDB.CopyBasicFieldsFromOrnaments(ornaments)

		// insertion point for translating pointers encodings into actual pointers
		// 1. reset
		ornamentsDB.OrnamentsPointersEncoding.Accidental_mark = make([]int, 0)
		// 2. encode
		for _, accidental_markAssocEnd := range ornaments.Accidental_mark {
			accidental_markAssocEnd_DB :=
				backRepo.BackRepoAccidental_mark.GetAccidental_markDBFromAccidental_markPtr(accidental_markAssocEnd)
			
			// the stage might be inconsistant, meaning that the accidental_markAssocEnd_DB might
			// be missing from the stage. In this case, the commit operation is robust
			// An alternative would be to crash here to reveal the missing element.
			if accidental_markAssocEnd_DB == nil {
				continue
			}
			
			ornamentsDB.OrnamentsPointersEncoding.Accidental_mark =
				append(ornamentsDB.OrnamentsPointersEncoding.Accidental_mark, int(accidental_markAssocEnd_DB.ID))
		}

		// commit pointer value ornaments.Trill_mark translates to updating the ornaments.Trill_markID
		ornamentsDB.Trill_markID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Trill_mark != nil {
			if Trill_markId, ok := backRepo.BackRepoEmpty_trill_sound.Map_Empty_trill_soundPtr_Empty_trill_soundDBID[ornaments.Trill_mark]; ok {
				ornamentsDB.Trill_markID.Int64 = int64(Trill_markId)
				ornamentsDB.Trill_markID.Valid = true
			}
		} else {
			ornamentsDB.Trill_markID.Int64 = 0
			ornamentsDB.Trill_markID.Valid = true
		}

		// commit pointer value ornaments.Turn translates to updating the ornaments.TurnID
		ornamentsDB.TurnID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Turn != nil {
			if TurnId, ok := backRepo.BackRepoHorizontal_turn.Map_Horizontal_turnPtr_Horizontal_turnDBID[ornaments.Turn]; ok {
				ornamentsDB.TurnID.Int64 = int64(TurnId)
				ornamentsDB.TurnID.Valid = true
			}
		} else {
			ornamentsDB.TurnID.Int64 = 0
			ornamentsDB.TurnID.Valid = true
		}

		// commit pointer value ornaments.Delayed_turn translates to updating the ornaments.Delayed_turnID
		ornamentsDB.Delayed_turnID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Delayed_turn != nil {
			if Delayed_turnId, ok := backRepo.BackRepoHorizontal_turn.Map_Horizontal_turnPtr_Horizontal_turnDBID[ornaments.Delayed_turn]; ok {
				ornamentsDB.Delayed_turnID.Int64 = int64(Delayed_turnId)
				ornamentsDB.Delayed_turnID.Valid = true
			}
		} else {
			ornamentsDB.Delayed_turnID.Int64 = 0
			ornamentsDB.Delayed_turnID.Valid = true
		}

		// commit pointer value ornaments.Inverted_turn translates to updating the ornaments.Inverted_turnID
		ornamentsDB.Inverted_turnID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Inverted_turn != nil {
			if Inverted_turnId, ok := backRepo.BackRepoHorizontal_turn.Map_Horizontal_turnPtr_Horizontal_turnDBID[ornaments.Inverted_turn]; ok {
				ornamentsDB.Inverted_turnID.Int64 = int64(Inverted_turnId)
				ornamentsDB.Inverted_turnID.Valid = true
			}
		} else {
			ornamentsDB.Inverted_turnID.Int64 = 0
			ornamentsDB.Inverted_turnID.Valid = true
		}

		// commit pointer value ornaments.Delayed_inverted_turn translates to updating the ornaments.Delayed_inverted_turnID
		ornamentsDB.Delayed_inverted_turnID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Delayed_inverted_turn != nil {
			if Delayed_inverted_turnId, ok := backRepo.BackRepoHorizontal_turn.Map_Horizontal_turnPtr_Horizontal_turnDBID[ornaments.Delayed_inverted_turn]; ok {
				ornamentsDB.Delayed_inverted_turnID.Int64 = int64(Delayed_inverted_turnId)
				ornamentsDB.Delayed_inverted_turnID.Valid = true
			}
		} else {
			ornamentsDB.Delayed_inverted_turnID.Int64 = 0
			ornamentsDB.Delayed_inverted_turnID.Valid = true
		}

		// commit pointer value ornaments.Vertical_turn translates to updating the ornaments.Vertical_turnID
		ornamentsDB.Vertical_turnID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Vertical_turn != nil {
			if Vertical_turnId, ok := backRepo.BackRepoEmpty_trill_sound.Map_Empty_trill_soundPtr_Empty_trill_soundDBID[ornaments.Vertical_turn]; ok {
				ornamentsDB.Vertical_turnID.Int64 = int64(Vertical_turnId)
				ornamentsDB.Vertical_turnID.Valid = true
			}
		} else {
			ornamentsDB.Vertical_turnID.Int64 = 0
			ornamentsDB.Vertical_turnID.Valid = true
		}

		// commit pointer value ornaments.Inverted_vertical_turn translates to updating the ornaments.Inverted_vertical_turnID
		ornamentsDB.Inverted_vertical_turnID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Inverted_vertical_turn != nil {
			if Inverted_vertical_turnId, ok := backRepo.BackRepoEmpty_trill_sound.Map_Empty_trill_soundPtr_Empty_trill_soundDBID[ornaments.Inverted_vertical_turn]; ok {
				ornamentsDB.Inverted_vertical_turnID.Int64 = int64(Inverted_vertical_turnId)
				ornamentsDB.Inverted_vertical_turnID.Valid = true
			}
		} else {
			ornamentsDB.Inverted_vertical_turnID.Int64 = 0
			ornamentsDB.Inverted_vertical_turnID.Valid = true
		}

		// commit pointer value ornaments.Shake translates to updating the ornaments.ShakeID
		ornamentsDB.ShakeID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Shake != nil {
			if ShakeId, ok := backRepo.BackRepoEmpty_trill_sound.Map_Empty_trill_soundPtr_Empty_trill_soundDBID[ornaments.Shake]; ok {
				ornamentsDB.ShakeID.Int64 = int64(ShakeId)
				ornamentsDB.ShakeID.Valid = true
			}
		} else {
			ornamentsDB.ShakeID.Int64 = 0
			ornamentsDB.ShakeID.Valid = true
		}

		// commit pointer value ornaments.Wavy_line translates to updating the ornaments.Wavy_lineID
		ornamentsDB.Wavy_lineID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Wavy_line != nil {
			if Wavy_lineId, ok := backRepo.BackRepoWavy_line.Map_Wavy_linePtr_Wavy_lineDBID[ornaments.Wavy_line]; ok {
				ornamentsDB.Wavy_lineID.Int64 = int64(Wavy_lineId)
				ornamentsDB.Wavy_lineID.Valid = true
			}
		} else {
			ornamentsDB.Wavy_lineID.Int64 = 0
			ornamentsDB.Wavy_lineID.Valid = true
		}

		// commit pointer value ornaments.Mordent translates to updating the ornaments.MordentID
		ornamentsDB.MordentID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Mordent != nil {
			if MordentId, ok := backRepo.BackRepoMordent.Map_MordentPtr_MordentDBID[ornaments.Mordent]; ok {
				ornamentsDB.MordentID.Int64 = int64(MordentId)
				ornamentsDB.MordentID.Valid = true
			}
		} else {
			ornamentsDB.MordentID.Int64 = 0
			ornamentsDB.MordentID.Valid = true
		}

		// commit pointer value ornaments.Inverted_mordent translates to updating the ornaments.Inverted_mordentID
		ornamentsDB.Inverted_mordentID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Inverted_mordent != nil {
			if Inverted_mordentId, ok := backRepo.BackRepoMordent.Map_MordentPtr_MordentDBID[ornaments.Inverted_mordent]; ok {
				ornamentsDB.Inverted_mordentID.Int64 = int64(Inverted_mordentId)
				ornamentsDB.Inverted_mordentID.Valid = true
			}
		} else {
			ornamentsDB.Inverted_mordentID.Int64 = 0
			ornamentsDB.Inverted_mordentID.Valid = true
		}

		// commit pointer value ornaments.Schleifer translates to updating the ornaments.SchleiferID
		ornamentsDB.SchleiferID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Schleifer != nil {
			if SchleiferId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[ornaments.Schleifer]; ok {
				ornamentsDB.SchleiferID.Int64 = int64(SchleiferId)
				ornamentsDB.SchleiferID.Valid = true
			}
		} else {
			ornamentsDB.SchleiferID.Int64 = 0
			ornamentsDB.SchleiferID.Valid = true
		}

		// commit pointer value ornaments.Tremolo translates to updating the ornaments.TremoloID
		ornamentsDB.TremoloID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Tremolo != nil {
			if TremoloId, ok := backRepo.BackRepoTremolo.Map_TremoloPtr_TremoloDBID[ornaments.Tremolo]; ok {
				ornamentsDB.TremoloID.Int64 = int64(TremoloId)
				ornamentsDB.TremoloID.Valid = true
			}
		} else {
			ornamentsDB.TremoloID.Int64 = 0
			ornamentsDB.TremoloID.Valid = true
		}

		// commit pointer value ornaments.Haydn translates to updating the ornaments.HaydnID
		ornamentsDB.HaydnID.Valid = true // allow for a 0 value (nil association)
		if ornaments.Haydn != nil {
			if HaydnId, ok := backRepo.BackRepoEmpty_trill_sound.Map_Empty_trill_soundPtr_Empty_trill_soundDBID[ornaments.Haydn]; ok {
				ornamentsDB.HaydnID.Int64 = int64(HaydnId)
				ornamentsDB.HaydnID.Valid = true
			}
		} else {
			ornamentsDB.HaydnID.Int64 = 0
			ornamentsDB.HaydnID.Valid = true
		}

		query := backRepoOrnaments.db.Save(&ornamentsDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Ornaments intance %s", ornaments.Name))
		return err
	}

	return
}

// BackRepoOrnaments.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoOrnaments *BackRepoOrnamentsStruct) CheckoutPhaseOne() (Error error) {

	ornamentsDBArray := make([]OrnamentsDB, 0)
	query := backRepoOrnaments.db.Find(&ornamentsDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	ornamentsInstancesToBeRemovedFromTheStage := make(map[*models.Ornaments]any)
	for key, value := range backRepoOrnaments.stage.Ornamentss {
		ornamentsInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, ornamentsDB := range ornamentsDBArray {
		backRepoOrnaments.CheckoutPhaseOneInstance(&ornamentsDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		ornaments, ok := backRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr[ornamentsDB.ID]
		if ok {
			delete(ornamentsInstancesToBeRemovedFromTheStage, ornaments)
		}
	}

	// remove from stage and back repo's 3 maps all ornamentss that are not in the checkout
	for ornaments := range ornamentsInstancesToBeRemovedFromTheStage {
		ornaments.Unstage(backRepoOrnaments.GetStage())

		// remove instance from the back repo 3 maps
		ornamentsID := backRepoOrnaments.Map_OrnamentsPtr_OrnamentsDBID[ornaments]
		delete(backRepoOrnaments.Map_OrnamentsPtr_OrnamentsDBID, ornaments)
		delete(backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB, ornamentsID)
		delete(backRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr, ornamentsID)
	}

	return
}

// CheckoutPhaseOneInstance takes a ornamentsDB that has been found in the DB, updates the backRepo and stages the
// models version of the ornamentsDB
func (backRepoOrnaments *BackRepoOrnamentsStruct) CheckoutPhaseOneInstance(ornamentsDB *OrnamentsDB) (Error error) {

	ornaments, ok := backRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr[ornamentsDB.ID]
	if !ok {
		ornaments = new(models.Ornaments)

		backRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr[ornamentsDB.ID] = ornaments
		backRepoOrnaments.Map_OrnamentsPtr_OrnamentsDBID[ornaments] = ornamentsDB.ID

		// append model store with the new element
		ornaments.Name = ornamentsDB.Name_Data.String
		ornaments.Stage(backRepoOrnaments.GetStage())
	}
	ornamentsDB.CopyBasicFieldsToOrnaments(ornaments)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	ornaments.Stage(backRepoOrnaments.GetStage())

	// preserve pointer to ornamentsDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_OrnamentsDBID_OrnamentsDB)[ornamentsDB hold variable pointers
	ornamentsDB_Data := *ornamentsDB
	preservedPtrToOrnaments := &ornamentsDB_Data
	backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB[ornamentsDB.ID] = preservedPtrToOrnaments

	return
}

// BackRepoOrnaments.CheckoutPhaseTwo Checkouts all staged instances of Ornaments to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoOrnaments *BackRepoOrnamentsStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, ornamentsDB := range backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB {
		backRepoOrnaments.CheckoutPhaseTwoInstance(backRepo, ornamentsDB)
	}
	return
}

// BackRepoOrnaments.CheckoutPhaseTwoInstance Checkouts staged instances of Ornaments to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoOrnaments *BackRepoOrnamentsStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, ornamentsDB *OrnamentsDB) (Error error) {

	ornaments := backRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr[ornamentsDB.ID]

	ornamentsDB.DecodePointers(backRepo, ornaments)

	return
}

func (ornamentsDB *OrnamentsDB) DecodePointers(backRepo *BackRepoStruct, ornaments *models.Ornaments) {

	// insertion point for checkout of pointer encoding
	// This loop redeem ornaments.Accidental_mark in the stage from the encode in the back repo
	// It parses all Accidental_markDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	ornaments.Accidental_mark = ornaments.Accidental_mark[:0]
	for _, _Accidental_markid := range ornamentsDB.OrnamentsPointersEncoding.Accidental_mark {
		ornaments.Accidental_mark = append(ornaments.Accidental_mark, backRepo.BackRepoAccidental_mark.Map_Accidental_markDBID_Accidental_markPtr[uint(_Accidental_markid)])
	}

	// Trill_mark field
	ornaments.Trill_mark = nil
	if ornamentsDB.Trill_markID.Int64 != 0 {
		ornaments.Trill_mark = backRepo.BackRepoEmpty_trill_sound.Map_Empty_trill_soundDBID_Empty_trill_soundPtr[uint(ornamentsDB.Trill_markID.Int64)]
	}
	// Turn field
	ornaments.Turn = nil
	if ornamentsDB.TurnID.Int64 != 0 {
		ornaments.Turn = backRepo.BackRepoHorizontal_turn.Map_Horizontal_turnDBID_Horizontal_turnPtr[uint(ornamentsDB.TurnID.Int64)]
	}
	// Delayed_turn field
	ornaments.Delayed_turn = nil
	if ornamentsDB.Delayed_turnID.Int64 != 0 {
		ornaments.Delayed_turn = backRepo.BackRepoHorizontal_turn.Map_Horizontal_turnDBID_Horizontal_turnPtr[uint(ornamentsDB.Delayed_turnID.Int64)]
	}
	// Inverted_turn field
	ornaments.Inverted_turn = nil
	if ornamentsDB.Inverted_turnID.Int64 != 0 {
		ornaments.Inverted_turn = backRepo.BackRepoHorizontal_turn.Map_Horizontal_turnDBID_Horizontal_turnPtr[uint(ornamentsDB.Inverted_turnID.Int64)]
	}
	// Delayed_inverted_turn field
	ornaments.Delayed_inverted_turn = nil
	if ornamentsDB.Delayed_inverted_turnID.Int64 != 0 {
		ornaments.Delayed_inverted_turn = backRepo.BackRepoHorizontal_turn.Map_Horizontal_turnDBID_Horizontal_turnPtr[uint(ornamentsDB.Delayed_inverted_turnID.Int64)]
	}
	// Vertical_turn field
	ornaments.Vertical_turn = nil
	if ornamentsDB.Vertical_turnID.Int64 != 0 {
		ornaments.Vertical_turn = backRepo.BackRepoEmpty_trill_sound.Map_Empty_trill_soundDBID_Empty_trill_soundPtr[uint(ornamentsDB.Vertical_turnID.Int64)]
	}
	// Inverted_vertical_turn field
	ornaments.Inverted_vertical_turn = nil
	if ornamentsDB.Inverted_vertical_turnID.Int64 != 0 {
		ornaments.Inverted_vertical_turn = backRepo.BackRepoEmpty_trill_sound.Map_Empty_trill_soundDBID_Empty_trill_soundPtr[uint(ornamentsDB.Inverted_vertical_turnID.Int64)]
	}
	// Shake field
	ornaments.Shake = nil
	if ornamentsDB.ShakeID.Int64 != 0 {
		ornaments.Shake = backRepo.BackRepoEmpty_trill_sound.Map_Empty_trill_soundDBID_Empty_trill_soundPtr[uint(ornamentsDB.ShakeID.Int64)]
	}
	// Wavy_line field
	ornaments.Wavy_line = nil
	if ornamentsDB.Wavy_lineID.Int64 != 0 {
		ornaments.Wavy_line = backRepo.BackRepoWavy_line.Map_Wavy_lineDBID_Wavy_linePtr[uint(ornamentsDB.Wavy_lineID.Int64)]
	}
	// Mordent field
	ornaments.Mordent = nil
	if ornamentsDB.MordentID.Int64 != 0 {
		ornaments.Mordent = backRepo.BackRepoMordent.Map_MordentDBID_MordentPtr[uint(ornamentsDB.MordentID.Int64)]
	}
	// Inverted_mordent field
	ornaments.Inverted_mordent = nil
	if ornamentsDB.Inverted_mordentID.Int64 != 0 {
		ornaments.Inverted_mordent = backRepo.BackRepoMordent.Map_MordentDBID_MordentPtr[uint(ornamentsDB.Inverted_mordentID.Int64)]
	}
	// Schleifer field
	ornaments.Schleifer = nil
	if ornamentsDB.SchleiferID.Int64 != 0 {
		ornaments.Schleifer = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(ornamentsDB.SchleiferID.Int64)]
	}
	// Tremolo field
	ornaments.Tremolo = nil
	if ornamentsDB.TremoloID.Int64 != 0 {
		ornaments.Tremolo = backRepo.BackRepoTremolo.Map_TremoloDBID_TremoloPtr[uint(ornamentsDB.TremoloID.Int64)]
	}
	// Haydn field
	ornaments.Haydn = nil
	if ornamentsDB.HaydnID.Int64 != 0 {
		ornaments.Haydn = backRepo.BackRepoEmpty_trill_sound.Map_Empty_trill_soundDBID_Empty_trill_soundPtr[uint(ornamentsDB.HaydnID.Int64)]
	}
	return
}

// CommitOrnaments allows commit of a single ornaments (if already staged)
func (backRepo *BackRepoStruct) CommitOrnaments(ornaments *models.Ornaments) {
	backRepo.BackRepoOrnaments.CommitPhaseOneInstance(ornaments)
	if id, ok := backRepo.BackRepoOrnaments.Map_OrnamentsPtr_OrnamentsDBID[ornaments]; ok {
		backRepo.BackRepoOrnaments.CommitPhaseTwoInstance(backRepo, id, ornaments)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitOrnaments allows checkout of a single ornaments (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutOrnaments(ornaments *models.Ornaments) {
	// check if the ornaments is staged
	if _, ok := backRepo.BackRepoOrnaments.Map_OrnamentsPtr_OrnamentsDBID[ornaments]; ok {

		if id, ok := backRepo.BackRepoOrnaments.Map_OrnamentsPtr_OrnamentsDBID[ornaments]; ok {
			var ornamentsDB OrnamentsDB
			ornamentsDB.ID = id

			if err := backRepo.BackRepoOrnaments.db.First(&ornamentsDB, id).Error; err != nil {
				log.Fatalln("CheckoutOrnaments : Problem with getting object with id:", id)
			}
			backRepo.BackRepoOrnaments.CheckoutPhaseOneInstance(&ornamentsDB)
			backRepo.BackRepoOrnaments.CheckoutPhaseTwoInstance(backRepo, &ornamentsDB)
		}
	}
}

// CopyBasicFieldsFromOrnaments
func (ornamentsDB *OrnamentsDB) CopyBasicFieldsFromOrnaments(ornaments *models.Ornaments) {
	// insertion point for fields commit

	ornamentsDB.Name_Data.String = ornaments.Name
	ornamentsDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromOrnaments_WOP
func (ornamentsDB *OrnamentsDB) CopyBasicFieldsFromOrnaments_WOP(ornaments *models.Ornaments_WOP) {
	// insertion point for fields commit

	ornamentsDB.Name_Data.String = ornaments.Name
	ornamentsDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromOrnamentsWOP
func (ornamentsDB *OrnamentsDB) CopyBasicFieldsFromOrnamentsWOP(ornaments *OrnamentsWOP) {
	// insertion point for fields commit

	ornamentsDB.Name_Data.String = ornaments.Name
	ornamentsDB.Name_Data.Valid = true
}

// CopyBasicFieldsToOrnaments
func (ornamentsDB *OrnamentsDB) CopyBasicFieldsToOrnaments(ornaments *models.Ornaments) {
	// insertion point for checkout of basic fields (back repo to stage)
	ornaments.Name = ornamentsDB.Name_Data.String
}

// CopyBasicFieldsToOrnaments_WOP
func (ornamentsDB *OrnamentsDB) CopyBasicFieldsToOrnaments_WOP(ornaments *models.Ornaments_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	ornaments.Name = ornamentsDB.Name_Data.String
}

// CopyBasicFieldsToOrnamentsWOP
func (ornamentsDB *OrnamentsDB) CopyBasicFieldsToOrnamentsWOP(ornaments *OrnamentsWOP) {
	ornaments.ID = int(ornamentsDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	ornaments.Name = ornamentsDB.Name_Data.String
}

// Backup generates a json file from a slice of all OrnamentsDB instances in the backrepo
func (backRepoOrnaments *BackRepoOrnamentsStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "OrnamentsDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*OrnamentsDB, 0)
	for _, ornamentsDB := range backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB {
		forBackup = append(forBackup, ornamentsDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json Ornaments ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json Ornaments file", err.Error())
	}
}

// Backup generates a json file from a slice of all OrnamentsDB instances in the backrepo
func (backRepoOrnaments *BackRepoOrnamentsStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*OrnamentsDB, 0)
	for _, ornamentsDB := range backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB {
		forBackup = append(forBackup, ornamentsDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("Ornaments")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&Ornaments_Fields, -1)
	for _, ornamentsDB := range forBackup {

		var ornamentsWOP OrnamentsWOP
		ornamentsDB.CopyBasicFieldsToOrnamentsWOP(&ornamentsWOP)

		row := sh.AddRow()
		row.WriteStruct(&ornamentsWOP, -1)
	}
}

// RestoreXL from the "Ornaments" sheet all OrnamentsDB instances
func (backRepoOrnaments *BackRepoOrnamentsStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoOrnamentsid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["Ornaments"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoOrnaments.rowVisitorOrnaments)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoOrnaments *BackRepoOrnamentsStruct) rowVisitorOrnaments(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var ornamentsWOP OrnamentsWOP
		row.ReadStruct(&ornamentsWOP)

		// add the unmarshalled struct to the stage
		ornamentsDB := new(OrnamentsDB)
		ornamentsDB.CopyBasicFieldsFromOrnamentsWOP(&ornamentsWOP)

		ornamentsDB_ID_atBackupTime := ornamentsDB.ID
		ornamentsDB.ID = 0
		query := backRepoOrnaments.db.Create(ornamentsDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB[ornamentsDB.ID] = ornamentsDB
		BackRepoOrnamentsid_atBckpTime_newID[ornamentsDB_ID_atBackupTime] = ornamentsDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "OrnamentsDB.json" in dirPath that stores an array
// of OrnamentsDB and stores it in the database
// the map BackRepoOrnamentsid_atBckpTime_newID is updated accordingly
func (backRepoOrnaments *BackRepoOrnamentsStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoOrnamentsid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "OrnamentsDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json Ornaments file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*OrnamentsDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_OrnamentsDBID_OrnamentsDB
	for _, ornamentsDB := range forRestore {

		ornamentsDB_ID_atBackupTime := ornamentsDB.ID
		ornamentsDB.ID = 0
		query := backRepoOrnaments.db.Create(ornamentsDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB[ornamentsDB.ID] = ornamentsDB
		BackRepoOrnamentsid_atBckpTime_newID[ornamentsDB_ID_atBackupTime] = ornamentsDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json Ornaments file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Ornaments>id_atBckpTime_newID
// to compute new index
func (backRepoOrnaments *BackRepoOrnamentsStruct) RestorePhaseTwo() {

	for _, ornamentsDB := range backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB {

		// next line of code is to avert unused variable compilation error
		_ = ornamentsDB

		// insertion point for reindexing pointers encoding
		// reindexing Trill_mark field
		if ornamentsDB.Trill_markID.Int64 != 0 {
			ornamentsDB.Trill_markID.Int64 = int64(BackRepoEmpty_trill_soundid_atBckpTime_newID[uint(ornamentsDB.Trill_markID.Int64)])
			ornamentsDB.Trill_markID.Valid = true
		}

		// reindexing Turn field
		if ornamentsDB.TurnID.Int64 != 0 {
			ornamentsDB.TurnID.Int64 = int64(BackRepoHorizontal_turnid_atBckpTime_newID[uint(ornamentsDB.TurnID.Int64)])
			ornamentsDB.TurnID.Valid = true
		}

		// reindexing Delayed_turn field
		if ornamentsDB.Delayed_turnID.Int64 != 0 {
			ornamentsDB.Delayed_turnID.Int64 = int64(BackRepoHorizontal_turnid_atBckpTime_newID[uint(ornamentsDB.Delayed_turnID.Int64)])
			ornamentsDB.Delayed_turnID.Valid = true
		}

		// reindexing Inverted_turn field
		if ornamentsDB.Inverted_turnID.Int64 != 0 {
			ornamentsDB.Inverted_turnID.Int64 = int64(BackRepoHorizontal_turnid_atBckpTime_newID[uint(ornamentsDB.Inverted_turnID.Int64)])
			ornamentsDB.Inverted_turnID.Valid = true
		}

		// reindexing Delayed_inverted_turn field
		if ornamentsDB.Delayed_inverted_turnID.Int64 != 0 {
			ornamentsDB.Delayed_inverted_turnID.Int64 = int64(BackRepoHorizontal_turnid_atBckpTime_newID[uint(ornamentsDB.Delayed_inverted_turnID.Int64)])
			ornamentsDB.Delayed_inverted_turnID.Valid = true
		}

		// reindexing Vertical_turn field
		if ornamentsDB.Vertical_turnID.Int64 != 0 {
			ornamentsDB.Vertical_turnID.Int64 = int64(BackRepoEmpty_trill_soundid_atBckpTime_newID[uint(ornamentsDB.Vertical_turnID.Int64)])
			ornamentsDB.Vertical_turnID.Valid = true
		}

		// reindexing Inverted_vertical_turn field
		if ornamentsDB.Inverted_vertical_turnID.Int64 != 0 {
			ornamentsDB.Inverted_vertical_turnID.Int64 = int64(BackRepoEmpty_trill_soundid_atBckpTime_newID[uint(ornamentsDB.Inverted_vertical_turnID.Int64)])
			ornamentsDB.Inverted_vertical_turnID.Valid = true
		}

		// reindexing Shake field
		if ornamentsDB.ShakeID.Int64 != 0 {
			ornamentsDB.ShakeID.Int64 = int64(BackRepoEmpty_trill_soundid_atBckpTime_newID[uint(ornamentsDB.ShakeID.Int64)])
			ornamentsDB.ShakeID.Valid = true
		}

		// reindexing Wavy_line field
		if ornamentsDB.Wavy_lineID.Int64 != 0 {
			ornamentsDB.Wavy_lineID.Int64 = int64(BackRepoWavy_lineid_atBckpTime_newID[uint(ornamentsDB.Wavy_lineID.Int64)])
			ornamentsDB.Wavy_lineID.Valid = true
		}

		// reindexing Mordent field
		if ornamentsDB.MordentID.Int64 != 0 {
			ornamentsDB.MordentID.Int64 = int64(BackRepoMordentid_atBckpTime_newID[uint(ornamentsDB.MordentID.Int64)])
			ornamentsDB.MordentID.Valid = true
		}

		// reindexing Inverted_mordent field
		if ornamentsDB.Inverted_mordentID.Int64 != 0 {
			ornamentsDB.Inverted_mordentID.Int64 = int64(BackRepoMordentid_atBckpTime_newID[uint(ornamentsDB.Inverted_mordentID.Int64)])
			ornamentsDB.Inverted_mordentID.Valid = true
		}

		// reindexing Schleifer field
		if ornamentsDB.SchleiferID.Int64 != 0 {
			ornamentsDB.SchleiferID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(ornamentsDB.SchleiferID.Int64)])
			ornamentsDB.SchleiferID.Valid = true
		}

		// reindexing Tremolo field
		if ornamentsDB.TremoloID.Int64 != 0 {
			ornamentsDB.TremoloID.Int64 = int64(BackRepoTremoloid_atBckpTime_newID[uint(ornamentsDB.TremoloID.Int64)])
			ornamentsDB.TremoloID.Valid = true
		}

		// reindexing Haydn field
		if ornamentsDB.HaydnID.Int64 != 0 {
			ornamentsDB.HaydnID.Int64 = int64(BackRepoEmpty_trill_soundid_atBckpTime_newID[uint(ornamentsDB.HaydnID.Int64)])
			ornamentsDB.HaydnID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoOrnaments.db.Model(ornamentsDB).Updates(*ornamentsDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoOrnaments.ResetReversePointers commits all staged instances of Ornaments to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoOrnaments *BackRepoOrnamentsStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, ornaments := range backRepoOrnaments.Map_OrnamentsDBID_OrnamentsPtr {
		backRepoOrnaments.ResetReversePointersInstance(backRepo, idx, ornaments)
	}

	return
}

func (backRepoOrnaments *BackRepoOrnamentsStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, ornaments *models.Ornaments) (Error error) {

	// fetch matching ornamentsDB
	if ornamentsDB, ok := backRepoOrnaments.Map_OrnamentsDBID_OrnamentsDB[idx]; ok {
		_ = ornamentsDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoOrnamentsid_atBckpTime_newID map[uint]uint
