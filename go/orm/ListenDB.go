// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongmusicxml/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Listen_sql sql.NullBool
var dummy_Listen_time time.Duration
var dummy_Listen_sort sort.Float64Slice

// ListenAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model listenAPI
type ListenAPI struct {
	gorm.Model

	models.Listen_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	ListenPointersEncoding ListenPointersEncoding
}

// ListenPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type ListenPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field Assess is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	AssessID sql.NullInt64

	// field Wait is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	WaitID sql.NullInt64

	// field Other_listen is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Other_listenID sql.NullInt64
}

// ListenDB describes a listen in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model listenDB
type ListenDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field listenDB.Name
	Name_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	ListenPointersEncoding
}

// ListenDBs arrays listenDBs
// swagger:response listenDBsResponse
type ListenDBs []ListenDB

// ListenDBResponse provides response
// swagger:response listenDBResponse
type ListenDBResponse struct {
	ListenDB
}

// ListenWOP is a Listen without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type ListenWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`
	// insertion for WOP pointer fields
}

var Listen_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
}

type BackRepoListenStruct struct {
	// stores ListenDB according to their gorm ID
	Map_ListenDBID_ListenDB map[uint]*ListenDB

	// stores ListenDB ID according to Listen address
	Map_ListenPtr_ListenDBID map[*models.Listen]uint

	// stores Listen according to their gorm ID
	Map_ListenDBID_ListenPtr map[uint]*models.Listen

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoListen *BackRepoListenStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoListen.stage
	return
}

func (backRepoListen *BackRepoListenStruct) GetDB() *gorm.DB {
	return backRepoListen.db
}

// GetListenDBFromListenPtr is a handy function to access the back repo instance from the stage instance
func (backRepoListen *BackRepoListenStruct) GetListenDBFromListenPtr(listen *models.Listen) (listenDB *ListenDB) {
	id := backRepoListen.Map_ListenPtr_ListenDBID[listen]
	listenDB = backRepoListen.Map_ListenDBID_ListenDB[id]
	return
}

// BackRepoListen.CommitPhaseOne commits all staged instances of Listen to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoListen *BackRepoListenStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for listen := range stage.Listens {
		backRepoListen.CommitPhaseOneInstance(listen)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, listen := range backRepoListen.Map_ListenDBID_ListenPtr {
		if _, ok := stage.Listens[listen]; !ok {
			backRepoListen.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoListen.CommitDeleteInstance commits deletion of Listen to the BackRepo
func (backRepoListen *BackRepoListenStruct) CommitDeleteInstance(id uint) (Error error) {

	listen := backRepoListen.Map_ListenDBID_ListenPtr[id]

	// listen is not staged anymore, remove listenDB
	listenDB := backRepoListen.Map_ListenDBID_ListenDB[id]
	query := backRepoListen.db.Unscoped().Delete(&listenDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoListen.Map_ListenPtr_ListenDBID, listen)
	delete(backRepoListen.Map_ListenDBID_ListenPtr, id)
	delete(backRepoListen.Map_ListenDBID_ListenDB, id)

	return
}

// BackRepoListen.CommitPhaseOneInstance commits listen staged instances of Listen to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoListen *BackRepoListenStruct) CommitPhaseOneInstance(listen *models.Listen) (Error error) {

	// check if the listen is not commited yet
	if _, ok := backRepoListen.Map_ListenPtr_ListenDBID[listen]; ok {
		return
	}

	// initiate listen
	var listenDB ListenDB
	listenDB.CopyBasicFieldsFromListen(listen)

	query := backRepoListen.db.Create(&listenDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoListen.Map_ListenPtr_ListenDBID[listen] = listenDB.ID
	backRepoListen.Map_ListenDBID_ListenPtr[listenDB.ID] = listen
	backRepoListen.Map_ListenDBID_ListenDB[listenDB.ID] = &listenDB

	return
}

// BackRepoListen.CommitPhaseTwo commits all staged instances of Listen to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoListen *BackRepoListenStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, listen := range backRepoListen.Map_ListenDBID_ListenPtr {
		backRepoListen.CommitPhaseTwoInstance(backRepo, idx, listen)
	}

	return
}

// BackRepoListen.CommitPhaseTwoInstance commits {{structname }} of models.Listen to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoListen *BackRepoListenStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, listen *models.Listen) (Error error) {

	// fetch matching listenDB
	if listenDB, ok := backRepoListen.Map_ListenDBID_ListenDB[idx]; ok {

		listenDB.CopyBasicFieldsFromListen(listen)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value listen.Assess translates to updating the listen.AssessID
		listenDB.AssessID.Valid = true // allow for a 0 value (nil association)
		if listen.Assess != nil {
			if AssessId, ok := backRepo.BackRepoAssess.Map_AssessPtr_AssessDBID[listen.Assess]; ok {
				listenDB.AssessID.Int64 = int64(AssessId)
				listenDB.AssessID.Valid = true
			}
		} else {
			listenDB.AssessID.Int64 = 0
			listenDB.AssessID.Valid = true
		}

		// commit pointer value listen.Wait translates to updating the listen.WaitID
		listenDB.WaitID.Valid = true // allow for a 0 value (nil association)
		if listen.Wait != nil {
			if WaitId, ok := backRepo.BackRepoWait.Map_WaitPtr_WaitDBID[listen.Wait]; ok {
				listenDB.WaitID.Int64 = int64(WaitId)
				listenDB.WaitID.Valid = true
			}
		} else {
			listenDB.WaitID.Int64 = 0
			listenDB.WaitID.Valid = true
		}

		// commit pointer value listen.Other_listen translates to updating the listen.Other_listenID
		listenDB.Other_listenID.Valid = true // allow for a 0 value (nil association)
		if listen.Other_listen != nil {
			if Other_listenId, ok := backRepo.BackRepoOther_listening.Map_Other_listeningPtr_Other_listeningDBID[listen.Other_listen]; ok {
				listenDB.Other_listenID.Int64 = int64(Other_listenId)
				listenDB.Other_listenID.Valid = true
			}
		} else {
			listenDB.Other_listenID.Int64 = 0
			listenDB.Other_listenID.Valid = true
		}

		query := backRepoListen.db.Save(&listenDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Listen intance %s", listen.Name))
		return err
	}

	return
}

// BackRepoListen.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoListen *BackRepoListenStruct) CheckoutPhaseOne() (Error error) {

	listenDBArray := make([]ListenDB, 0)
	query := backRepoListen.db.Find(&listenDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	listenInstancesToBeRemovedFromTheStage := make(map[*models.Listen]any)
	for key, value := range backRepoListen.stage.Listens {
		listenInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, listenDB := range listenDBArray {
		backRepoListen.CheckoutPhaseOneInstance(&listenDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		listen, ok := backRepoListen.Map_ListenDBID_ListenPtr[listenDB.ID]
		if ok {
			delete(listenInstancesToBeRemovedFromTheStage, listen)
		}
	}

	// remove from stage and back repo's 3 maps all listens that are not in the checkout
	for listen := range listenInstancesToBeRemovedFromTheStage {
		listen.Unstage(backRepoListen.GetStage())

		// remove instance from the back repo 3 maps
		listenID := backRepoListen.Map_ListenPtr_ListenDBID[listen]
		delete(backRepoListen.Map_ListenPtr_ListenDBID, listen)
		delete(backRepoListen.Map_ListenDBID_ListenDB, listenID)
		delete(backRepoListen.Map_ListenDBID_ListenPtr, listenID)
	}

	return
}

// CheckoutPhaseOneInstance takes a listenDB that has been found in the DB, updates the backRepo and stages the
// models version of the listenDB
func (backRepoListen *BackRepoListenStruct) CheckoutPhaseOneInstance(listenDB *ListenDB) (Error error) {

	listen, ok := backRepoListen.Map_ListenDBID_ListenPtr[listenDB.ID]
	if !ok {
		listen = new(models.Listen)

		backRepoListen.Map_ListenDBID_ListenPtr[listenDB.ID] = listen
		backRepoListen.Map_ListenPtr_ListenDBID[listen] = listenDB.ID

		// append model store with the new element
		listen.Name = listenDB.Name_Data.String
		listen.Stage(backRepoListen.GetStage())
	}
	listenDB.CopyBasicFieldsToListen(listen)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	listen.Stage(backRepoListen.GetStage())

	// preserve pointer to listenDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_ListenDBID_ListenDB)[listenDB hold variable pointers
	listenDB_Data := *listenDB
	preservedPtrToListen := &listenDB_Data
	backRepoListen.Map_ListenDBID_ListenDB[listenDB.ID] = preservedPtrToListen

	return
}

// BackRepoListen.CheckoutPhaseTwo Checkouts all staged instances of Listen to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoListen *BackRepoListenStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, listenDB := range backRepoListen.Map_ListenDBID_ListenDB {
		backRepoListen.CheckoutPhaseTwoInstance(backRepo, listenDB)
	}
	return
}

// BackRepoListen.CheckoutPhaseTwoInstance Checkouts staged instances of Listen to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoListen *BackRepoListenStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, listenDB *ListenDB) (Error error) {

	listen := backRepoListen.Map_ListenDBID_ListenPtr[listenDB.ID]

	listenDB.DecodePointers(backRepo, listen)

	return
}

func (listenDB *ListenDB) DecodePointers(backRepo *BackRepoStruct, listen *models.Listen) {

	// insertion point for checkout of pointer encoding
	// Assess field
	listen.Assess = nil
	if listenDB.AssessID.Int64 != 0 {
		listen.Assess = backRepo.BackRepoAssess.Map_AssessDBID_AssessPtr[uint(listenDB.AssessID.Int64)]
	}
	// Wait field
	listen.Wait = nil
	if listenDB.WaitID.Int64 != 0 {
		listen.Wait = backRepo.BackRepoWait.Map_WaitDBID_WaitPtr[uint(listenDB.WaitID.Int64)]
	}
	// Other_listen field
	listen.Other_listen = nil
	if listenDB.Other_listenID.Int64 != 0 {
		listen.Other_listen = backRepo.BackRepoOther_listening.Map_Other_listeningDBID_Other_listeningPtr[uint(listenDB.Other_listenID.Int64)]
	}
	return
}

// CommitListen allows commit of a single listen (if already staged)
func (backRepo *BackRepoStruct) CommitListen(listen *models.Listen) {
	backRepo.BackRepoListen.CommitPhaseOneInstance(listen)
	if id, ok := backRepo.BackRepoListen.Map_ListenPtr_ListenDBID[listen]; ok {
		backRepo.BackRepoListen.CommitPhaseTwoInstance(backRepo, id, listen)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitListen allows checkout of a single listen (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutListen(listen *models.Listen) {
	// check if the listen is staged
	if _, ok := backRepo.BackRepoListen.Map_ListenPtr_ListenDBID[listen]; ok {

		if id, ok := backRepo.BackRepoListen.Map_ListenPtr_ListenDBID[listen]; ok {
			var listenDB ListenDB
			listenDB.ID = id

			if err := backRepo.BackRepoListen.db.First(&listenDB, id).Error; err != nil {
				log.Fatalln("CheckoutListen : Problem with getting object with id:", id)
			}
			backRepo.BackRepoListen.CheckoutPhaseOneInstance(&listenDB)
			backRepo.BackRepoListen.CheckoutPhaseTwoInstance(backRepo, &listenDB)
		}
	}
}

// CopyBasicFieldsFromListen
func (listenDB *ListenDB) CopyBasicFieldsFromListen(listen *models.Listen) {
	// insertion point for fields commit

	listenDB.Name_Data.String = listen.Name
	listenDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromListen_WOP
func (listenDB *ListenDB) CopyBasicFieldsFromListen_WOP(listen *models.Listen_WOP) {
	// insertion point for fields commit

	listenDB.Name_Data.String = listen.Name
	listenDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromListenWOP
func (listenDB *ListenDB) CopyBasicFieldsFromListenWOP(listen *ListenWOP) {
	// insertion point for fields commit

	listenDB.Name_Data.String = listen.Name
	listenDB.Name_Data.Valid = true
}

// CopyBasicFieldsToListen
func (listenDB *ListenDB) CopyBasicFieldsToListen(listen *models.Listen) {
	// insertion point for checkout of basic fields (back repo to stage)
	listen.Name = listenDB.Name_Data.String
}

// CopyBasicFieldsToListen_WOP
func (listenDB *ListenDB) CopyBasicFieldsToListen_WOP(listen *models.Listen_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	listen.Name = listenDB.Name_Data.String
}

// CopyBasicFieldsToListenWOP
func (listenDB *ListenDB) CopyBasicFieldsToListenWOP(listen *ListenWOP) {
	listen.ID = int(listenDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	listen.Name = listenDB.Name_Data.String
}

// Backup generates a json file from a slice of all ListenDB instances in the backrepo
func (backRepoListen *BackRepoListenStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "ListenDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*ListenDB, 0)
	for _, listenDB := range backRepoListen.Map_ListenDBID_ListenDB {
		forBackup = append(forBackup, listenDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json Listen ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json Listen file", err.Error())
	}
}

// Backup generates a json file from a slice of all ListenDB instances in the backrepo
func (backRepoListen *BackRepoListenStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*ListenDB, 0)
	for _, listenDB := range backRepoListen.Map_ListenDBID_ListenDB {
		forBackup = append(forBackup, listenDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("Listen")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&Listen_Fields, -1)
	for _, listenDB := range forBackup {

		var listenWOP ListenWOP
		listenDB.CopyBasicFieldsToListenWOP(&listenWOP)

		row := sh.AddRow()
		row.WriteStruct(&listenWOP, -1)
	}
}

// RestoreXL from the "Listen" sheet all ListenDB instances
func (backRepoListen *BackRepoListenStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoListenid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["Listen"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoListen.rowVisitorListen)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoListen *BackRepoListenStruct) rowVisitorListen(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var listenWOP ListenWOP
		row.ReadStruct(&listenWOP)

		// add the unmarshalled struct to the stage
		listenDB := new(ListenDB)
		listenDB.CopyBasicFieldsFromListenWOP(&listenWOP)

		listenDB_ID_atBackupTime := listenDB.ID
		listenDB.ID = 0
		query := backRepoListen.db.Create(listenDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoListen.Map_ListenDBID_ListenDB[listenDB.ID] = listenDB
		BackRepoListenid_atBckpTime_newID[listenDB_ID_atBackupTime] = listenDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "ListenDB.json" in dirPath that stores an array
// of ListenDB and stores it in the database
// the map BackRepoListenid_atBckpTime_newID is updated accordingly
func (backRepoListen *BackRepoListenStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoListenid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "ListenDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json Listen file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*ListenDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_ListenDBID_ListenDB
	for _, listenDB := range forRestore {

		listenDB_ID_atBackupTime := listenDB.ID
		listenDB.ID = 0
		query := backRepoListen.db.Create(listenDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoListen.Map_ListenDBID_ListenDB[listenDB.ID] = listenDB
		BackRepoListenid_atBckpTime_newID[listenDB_ID_atBackupTime] = listenDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json Listen file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Listen>id_atBckpTime_newID
// to compute new index
func (backRepoListen *BackRepoListenStruct) RestorePhaseTwo() {

	for _, listenDB := range backRepoListen.Map_ListenDBID_ListenDB {

		// next line of code is to avert unused variable compilation error
		_ = listenDB

		// insertion point for reindexing pointers encoding
		// reindexing Assess field
		if listenDB.AssessID.Int64 != 0 {
			listenDB.AssessID.Int64 = int64(BackRepoAssessid_atBckpTime_newID[uint(listenDB.AssessID.Int64)])
			listenDB.AssessID.Valid = true
		}

		// reindexing Wait field
		if listenDB.WaitID.Int64 != 0 {
			listenDB.WaitID.Int64 = int64(BackRepoWaitid_atBckpTime_newID[uint(listenDB.WaitID.Int64)])
			listenDB.WaitID.Valid = true
		}

		// reindexing Other_listen field
		if listenDB.Other_listenID.Int64 != 0 {
			listenDB.Other_listenID.Int64 = int64(BackRepoOther_listeningid_atBckpTime_newID[uint(listenDB.Other_listenID.Int64)])
			listenDB.Other_listenID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoListen.db.Model(listenDB).Updates(*listenDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoListen.ResetReversePointers commits all staged instances of Listen to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoListen *BackRepoListenStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, listen := range backRepoListen.Map_ListenDBID_ListenPtr {
		backRepoListen.ResetReversePointersInstance(backRepo, idx, listen)
	}

	return
}

func (backRepoListen *BackRepoListenStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, listen *models.Listen) (Error error) {

	// fetch matching listenDB
	if listenDB, ok := backRepoListen.Map_ListenDBID_ListenDB[idx]; ok {
		_ = listenDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoListenid_atBckpTime_newID map[uint]uint
