// Code generated by gowsdl DO NOT EDIT.

package models

import (
	"context"
	"encoding/xml"
	"github.com/hooklift/gowsdl/soap"
	"time"
)

var _ context.Context

// against "unused imports"
var _ time.Time
var _ xml.Name

type AnyType struct {
	InnerXML string `xml:",innerxml"`
}

type AnyURI string

type NCName string

// The above-below type is used to indicate whether one element appears
// above or below another element.

type Above_below string

const (
	Above_belowAbove Above_below = "above"

	Above_belowBelow Above_below = "below"
)

// The MusicXML format supports six levels of beaming, up to 1024th
// notes. Unlike the number-level type, the beam-level type identifies concurrent beams
// in a beam group. It does not distinguish overlapping beams such as grace notes
// within regular notes, or beams used in different voices.

type Beam_level PositiveInteger

// The color type indicates the color of an element. Color may be
// represented as hexadecimal RGB triples, as in HTML, or as hexadecimal ARGB tuples,
// with the A indicating alpha of transparency. An alpha value of 00 is totally
// transparent; FF is totally opaque. If RGB is used, the A value is assumed to be FF.
// For instance, the RGB value "#800080" represents purple. An ARGB value of
// "#40800080" would be a transparent purple. As in SVG 1.1, colors are defined in
// terms of the sRGB color space (IEC 61966).

type Color string

// The comma-separated-text type is used to specify a comma-separated
// list of text elements, as is used by the font-family attribute.

type Comma_separated_text string

// The css-font-size type includes the CSS font sizes used as an
// alternative to a numeric point size.

type Css_font_size string

const (
	Css_font_sizeXx_small Css_font_size = "xx-small"

	Css_font_sizeX_small Css_font_size = "x-small"

	Css_font_sizeSmall Css_font_size = "small"

	Css_font_sizeMedium Css_font_size = "medium"

	Css_font_sizeLarge Css_font_size = "large"

	Css_font_sizeX_large Css_font_size = "x-large"

	Css_font_sizeXx_large Css_font_size = "xx-large"
)

// The divisions type is used to express values in terms of the musical
// divisions defined by the divisions element. It is preferred that these be integer
// values both for MIDI interoperability and to avoid roundoff errors.

type Divisions float64

// The enclosure-shape type describes the shape and presence / absence of
// an enclosure around text or symbols. A bracket enclosure is similar to a rectangle
// with the bottom line missing, as is common in jazz notation. An inverted-bracket
// enclosure is similar to a rectangle with the top line missing.

type Enclosure_shape string

const (
	Enclosure_shapeRectangle Enclosure_shape = "rectangle"

	Enclosure_shapeSquare Enclosure_shape = "square"

	Enclosure_shapeOval Enclosure_shape = "oval"

	Enclosure_shapeCircle Enclosure_shape = "circle"

	Enclosure_shapeBracket Enclosure_shape = "bracket"

	Enclosure_shapeInverted_bracket Enclosure_shape = "inverted-bracket"

	Enclosure_shapeTriangle Enclosure_shape = "triangle"

	Enclosure_shapeDiamond Enclosure_shape = "diamond"

	Enclosure_shapePentagon Enclosure_shape = "pentagon"

	Enclosure_shapeHexagon Enclosure_shape = "hexagon"

	Enclosure_shapeHeptagon Enclosure_shape = "heptagon"

	Enclosure_shapeOctagon Enclosure_shape = "octagon"

	Enclosure_shapeNonagon Enclosure_shape = "nonagon"

	Enclosure_shapeDecagon Enclosure_shape = "decagon"

	Enclosure_shapeNone Enclosure_shape = "none"
)

// The fermata-shape type represents the shape of the fermata sign. The
// empty value is equivalent to the normal value.

type Fermata_shape string

const (
	Fermata_shapeNormal Fermata_shape = "normal"

	Fermata_shapeAngled Fermata_shape = "angled"

	Fermata_shapeSquare Fermata_shape = "square"

	Fermata_shapeDouble_angled Fermata_shape = "double-angled"

	Fermata_shapeDouble_square Fermata_shape = "double-square"

	Fermata_shapeDouble_dot Fermata_shape = "double-dot"

	Fermata_shapeHalf_curve Fermata_shape = "half-curve"

	Fermata_shapeCurlew Fermata_shape = "curlew"

	Fermata_shapeEmptyString Fermata_shape = ""
)

// The font-family is a comma-separated list of font names. These can be
// specific font styles such as Maestro or Opus, or one of several generic font styles:
// music, engraved, handwritten, text, serif, sans-serif, handwritten, cursive,
// fantasy, and monospace. The music, engraved, and handwritten values refer to music
// fonts; the rest refer to text fonts. The fantasy style refers to decorative text
// such as found in older German-style printing.

type Font_family Comma_separated_text

// The font-size can be one of the CSS font sizes (xx-small, x-small,
// small, medium, large, x-large, xx-large) or a numeric point size.

type Font_size string

// The font-style type represents a simplified version of the CSS
// font-style property.

type Font_style string

const (
	Font_styleNormal Font_style = "normal"

	Font_styleItalic Font_style = "italic"
)

// The font-weight type represents a simplified version of the CSS
// font-weight property.

type Font_weight string

const (
	Font_weightNormal Font_weight = "normal"

	Font_weightBold Font_weight = "bold"
)

// The left-center-right type is used to define horizontal alignment and
// text justification.

type Left_center_right string

const (
	Left_center_rightLeft Left_center_right = "left"

	Left_center_rightCenter Left_center_right = "center"

	Left_center_rightRight Left_center_right = "right"
)

// The left-right type is used to indicate whether one element appears to
// the left or the right of another element.

type Left_right string

const (
	Left_rightLeft Left_right = "left"

	Left_rightRight Left_right = "right"
)

// The line-length type distinguishes between different line lengths for
// doit, falloff, plop, and scoop articulations.

type Line_length string

const (
	Line_lengthShort Line_length = "short"

	Line_lengthMedium Line_length = "medium"

	Line_lengthLong Line_length = "long"
)

// The line-shape type distinguishes between straight and curved lines.

type Line_shape string

const (
	Line_shapeStraight Line_shape = "straight"

	Line_shapeCurved Line_shape = "curved"
)

// The line-type type distinguishes between solid, dashed, dotted, and
// wavy lines.

type Line_type string

const (
	Line_typeSolid Line_type = "solid"

	Line_typeDashed Line_type = "dashed"

	Line_typeDotted Line_type = "dotted"

	Line_typeWavy Line_type = "wavy"
)

// The midi-16 type is used to express MIDI 1.0 values that range from 1
// to 16.

type Midi_16 PositiveInteger

// The midi-128 type is used to express MIDI 1.0 values that range from 1
// to 128.

type Midi_128 PositiveInteger

// The midi-16384 type is used to express MIDI 1.0 values that range from
// 1 to 16,384.

type Midi_16384 PositiveInteger

// The mute type represents muting for different instruments, including
// brass, winds, and strings. The on and off values are used for undifferentiated
// mutes. The remaining values represent specific mutes.

type Mute string

const (
	MuteOn Mute = "on"

	MuteOff Mute = "off"

	MuteStraight Mute = "straight"

	MuteCup Mute = "cup"

	MuteHarmon_no_stem Mute = "harmon-no-stem"

	MuteHarmon_stem Mute = "harmon-stem"

	MuteBucket Mute = "bucket"

	MutePlunger Mute = "plunger"

	MuteHat Mute = "hat"

	MuteSolotone Mute = "solotone"

	MutePractice Mute = "practice"

	MuteStop_mute Mute = "stop-mute"

	MuteStop_hand Mute = "stop-hand"

	MuteEcho Mute = "echo"

	MutePalm Mute = "palm"
)

// The non-negative-decimal type specifies a non-negative decimal value.

type Non_negative_decimal float64

// Slurs, tuplets, and many other features can be concurrent and overlap
// within a single musical part. The number-level entity distinguishes up to 16
// concurrent objects of the same type when the objects overlap in MusicXML document
// order. Values greater than 6 are usually only needed for music with a large number
// of divisi staves in a single part, or if there are more than 6 cross-staff arpeggios
// in a single measure. When a number-level value is implied, the value is 1 by
// default. When polyphonic parts are involved, the ordering within a MusicXML document
// can differ from musical score order. As an example, say we have a piano part in 4/4
// where within a single measure, all the notes on the top staff are followed by all
// the notes on the bottom staff. In this example, each staff has a slur that starts on
// beat 2 and stops on beat 3, and there is a third slur that goes from beat 1 of one
// staff to beat 4 of the other staff. In this situation, the two mid-measure slurs can
// use the same number because they do not overlap in MusicXML document order, even
// though they do overlap in musical score order. Within the MusicXML document, the top
// staff slur will both start and stop before the bottom staff slur starts and stops.
// If the cross-staff slur starts in the top staff and stops in the bottom staff, it
// will need a separate number from the mid-measure slurs because it overlaps those
// slurs in MusicXML document order. However, if the cross-staff slur starts in the
// bottom staff and stops in the top staff, all three slurs can use the same number.
// None of them overlap within the MusicXML document, even though they all overlap each
// other in the musical score order. Within the MusicXML document, the start and stop
// of the top-staff slur will be followed by the stop and start of the cross-staff
// slur, followed by the start and stop of the bottom-staff slur. As this example
// demonstrates, a reading program should be prepared to handle cases where the
// number-levels start and stop in an arbitrary order. Because the start and stop
// values refer to musical score order, a program may find the stopping point of an
// object earlier in the MusicXML document than it will find its starting point.

type Number_level PositiveInteger

// The number-of-lines type is used to specify the number of lines in
// text decoration attributes.

type Number_of_lines uint32

// The number-or-normal values can be either a decimal number or the
// string "normal". This is used by the line-height and letter-spacing attributes.

type Number_or_normal string

// The numeral-value type represents a Roman numeral or Nashville number
// value as a positive integer from 1 to 7.

type Numeral_value PositiveInteger

// The over-under type is used to indicate whether the tips of curved
// lines such as slurs and ties are overhand (tips down) or underhand (tips up).

type Over_under string

const (
	Over_underOver Over_under = "over"

	Over_underUnder Over_under = "under"
)

// The percent type specifies a percentage from 0 to 100.

type Percent float64

// The positive-decimal type specifies a positive decimal value.

type Positive_decimal float64

// The positive-divisions type restricts divisions values to positive
// numbers.

type Positive_divisions Divisions

// The positive-integer-or-empty values can be either a positive integer
// or an empty string.

type Positive_integer_or_empty string

// The rotation-degrees type specifies rotation, pan, and elevation
// values in degrees. Values range from -180 to 180.

type Rotation_degrees float64

// The semi-pitched type represents categories of indefinite pitch for
// percussion instruments.

type Semi_pitched string

const (
	Semi_pitchedHigh Semi_pitched = "high"

	Semi_pitchedMedium_high Semi_pitched = "medium-high"

	Semi_pitchedMedium Semi_pitched = "medium"

	Semi_pitchedMedium_low Semi_pitched = "medium-low"

	Semi_pitchedLow Semi_pitched = "low"

	Semi_pitchedVery_low Semi_pitched = "very-low"
)

// The smufl-glyph-name type is used for attributes that reference a
// specific Standard Music Font Layout (SMuFL) character. The value is a SMuFL
// canonical glyph name, not a code point. For instance, the value for a standard piano
// pedal mark would be keyboardPedalPed, not U+E650.

type Smufl_glyph_name NMTOKEN

// The smufl-accidental-glyph-name type is used to reference a specific
// Standard Music Font Layout (SMuFL) accidental character. The value is a SMuFL
// canonical glyph name that starts with one of the strings used at the start of glyph
// names for SMuFL accidentals.

type Smufl_accidental_glyph_name Smufl_glyph_name

// The smufl-coda-glyph-name type is used to reference a specific
// Standard Music Font Layout (SMuFL) coda character. The value is a SMuFL canonical
// glyph name that starts with coda.

type Smufl_coda_glyph_name Smufl_glyph_name

// The smufl-lyrics-glyph-name type is used to reference a specific
// Standard Music Font Layout (SMuFL) lyrics elision character. The value is a SMuFL
// canonical glyph name that starts with lyrics.

type Smufl_lyrics_glyph_name Smufl_glyph_name

// The smufl-pictogram-glyph-name type is used to reference a specific
// Standard Music Font Layout (SMuFL) percussion pictogram character. The value is a
// SMuFL canonical glyph name that starts with pict.

type Smufl_pictogram_glyph_name Smufl_glyph_name

// The smufl-segno-glyph-name type is used to reference a specific
// Standard Music Font Layout (SMuFL) segno character. The value is a SMuFL canonical
// glyph name that starts with segno.

type Smufl_segno_glyph_name Smufl_glyph_name

// The smufl-wavy-line-glyph-name type is used to reference a specific
// Standard Music Font Layout (SMuFL) wavy line character. The value is a SMuFL
// canonical glyph name that either starts with wiggle, or begins with guitar and ends
// with VibratoStroke. This includes all the glyphs in the Multi-segment lines range,
// excluding the beam glyphs.

type Smufl_wavy_line_glyph_name Smufl_glyph_name

// The start-note type describes the starting note of trills and mordents
// for playback, relative to the current note.

type Start_note string

const (
	Start_noteUpper Start_note = "upper"

	Start_noteMain Start_note = "main"

	Start_noteBelow Start_note = "below"
)

// The start-stop type is used for an attribute of musical elements that
// can either start or stop, such as tuplets. The values of start and stop refer to how
// an element appears in musical score order, not in MusicXML document order. An
// element with a stop attribute may precede the corresponding element with a start
// attribute within a MusicXML document. This is particularly common in multi-staff
// music. For example, the stopping point for a tuplet may appear in staff 1 before the
// starting point for the tuplet appears in staff 2 later in the document. When
// multiple elements with the same tag are used within the same note, their order
// within the MusicXML document should match the musical score order.

type Start_stop string

const (
	Start_stopStart Start_stop = "start"

	Start_stopStop Start_stop = "stop"
)

// The start-stop-continue type is used for an attribute of musical
// elements that can either start or stop, but also need to refer to an intermediate
// point in the symbol, as for complex slurs or for formatting of symbols across system
// breaks. The values of start, stop, and continue refer to how an element appears in
// musical score order, not in MusicXML document order. An element with a stop
// attribute may precede the corresponding element with a start attribute within a
// MusicXML document. This is particularly common in multi-staff music. For example,
// the stopping point for a slur may appear in staff 1 before the starting point for
// the slur appears in staff 2 later in the document. When multiple elements with the
// same tag are used within the same note, their order within the MusicXML document
// should match the musical score order. For example, a note that marks both the end of
// one slur and the start of a new slur should have the incoming slur element with a
// type of stop precede the outgoing slur element with a type of start.

type Start_stop_continue string

const (
	Start_stop_continueStart Start_stop_continue = "start"

	Start_stop_continueStop Start_stop_continue = "stop"

	Start_stop_continueContinue_ Start_stop_continue = "continue"
)

// The start-stop-single type is used for an attribute of musical
// elements that can be used for either multi-note or single-note musical elements, as
// for groupings. When multiple elements with the same tag are used within the same
// note, their order within the MusicXML document should match the musical score order.

type Start_stop_single string

const (
	Start_stop_singleStart Start_stop_single = "start"

	Start_stop_singleStop Start_stop_single = "stop"

	Start_stop_singleSingle Start_stop_single = "single"
)

// The string-number type indicates a string number. Strings are numbered
// from high to low, with 1 being the highest pitched full-length string.

type String_number PositiveInteger

// The symbol-size type is used to distinguish between full, cue sized,
// grace cue sized, and oversized symbols.

type Symbol_size string

const (
	Symbol_sizeFull Symbol_size = "full"

	Symbol_sizeCue Symbol_size = "cue"

	Symbol_sizeGrace_cue Symbol_size = "grace-cue"

	Symbol_sizeLarge Symbol_size = "large"
)

// The tenths type is a number representing tenths of interline staff
// space (positive or negative). Both integer and decimal values are allowed, such as 5
// for a half space and 2.5 for a quarter space. Interline space is measured from the
// middle of a staff line. Distances in a MusicXML file are measured in tenths of staff
// space. Tenths are then scaled to millimeters within the scaling element, used in the
// defaults element at the start of a score. Individual staves can apply a scaling
// factor to adjust staff size. When a MusicXML element or attribute refers to tenths,
// it means the global tenths defined by the scaling element, not the local tenths as
// adjusted by the staff-size element.

type Tenths float64

// The text-direction type is used to adjust and override the Unicode
// bidirectional text algorithm, similar to the Directionality data category in the W3C
// Internationalization Tag Set recommendation. Values are ltr (left-to-right embed),
// rtl (right-to-left embed), lro (left-to-right bidi-override), and rlo (right-to-left
// bidi-override). The default value is ltr. This type is typically used by
// applications that store text in left-to-right visual order rather than logical
// order. Such applications can use the lro value to better communicate with other
// applications that more fully support bidirectional text.

type Text_direction string

const (
	Text_directionLtr Text_direction = "ltr"

	Text_directionRtl Text_direction = "rtl"

	Text_directionLro Text_direction = "lro"

	Text_directionRlo Text_direction = "rlo"
)

// The tied-type type is used as an attribute of the tied element to
// specify where the visual representation of a tie begins and ends. A tied element
// which joins two notes of the same pitch can be specified with tied-type start on the
// first note and tied-type stop on the second note. To indicate a note should be
// undamped, use a single tied element with tied-type let-ring. For other ties that are
// visually attached to a single note, such as a tie leading into or out of a repeated
// section or coda, use two tied elements on the same note, one start and one stop. In
// start-stop cases, ties can add more elements using a continue type. This is
// typically used to specify the formatting of cross-system ties. When multiple
// elements with the same tag are used within the same note, their order within the
// MusicXML document should match the musical score order. For example, a note with a
// tie at the end of a first ending should have the tied element with a type of start
// precede the tied element with a type of stop.

type Tied_type string

const (
	Tied_typeStart Tied_type = "start"

	Tied_typeStop Tied_type = "stop"

	Tied_typeContinue_ Tied_type = "continue"

	Tied_typeLet_ring Tied_type = "let-ring"
)

// The time-only type is used to indicate that a particular playback- or
// listening-related element only applies particular times through a repeated section.
// The value is a comma-separated list of positive integers arranged in ascending
// order, indicating which times through the repeated section that the element applies.

type Time_only string

// The top-bottom type is used to indicate the top or bottom part of a
// vertical shape like non-arpeggiate.

type Top_bottom string

const (
	Top_bottomTop Top_bottom = "top"

	Top_bottomBottom Top_bottom = "bottom"
)

// The tremolo-type is used to distinguish double-note, single-note, and
// unmeasured tremolos.

type Tremolo_type string

const (
	Tremolo_typeStart Tremolo_type = "start"

	Tremolo_typeStop Tremolo_type = "stop"

	Tremolo_typeSingle Tremolo_type = "single"

	Tremolo_typeUnmeasured Tremolo_type = "unmeasured"
)

// The trill-beats type specifies the beats used in a trill-sound or
// bend-sound attribute group. It is a decimal value with a minimum value of 2.

type Trill_beats float64

// The trill-step type describes the alternating note of trills and
// mordents for playback, relative to the current note.

type Trill_step string

const (
	Trill_stepWhole Trill_step = "whole"

	Trill_stepHalf Trill_step = "half"

	Trill_stepUnison Trill_step = "unison"
)

// The two-note-turn type describes the ending notes of trills and
// mordents for playback, relative to the current note.

type Two_note_turn string

const (
	Two_note_turnWhole Two_note_turn = "whole"

	Two_note_turnHalf Two_note_turn = "half"

	Two_note_turnNone Two_note_turn = "none"
)

// The up-down type is used for the direction of arrows and other pointed
// symbols like vertical accents, indicating which way the tip is pointing.

type Up_down string

const (
	Up_downUp Up_down = "up"

	Up_downDown Up_down = "down"
)

// The upright-inverted type describes the appearance of a fermata
// element. The value is upright if not specified.

type Upright_inverted string

const (
	Upright_invertedUpright Upright_inverted = "upright"

	Upright_invertedInverted Upright_inverted = "inverted"
)

// The valign type is used to indicate vertical alignment to the top,
// middle, bottom, or baseline of the text. If the text is on multiple lines, baseline
// alignment refers to the baseline of the lowest line of text. Defaults are
// implementation-dependent.

type Valign string

const (
	ValignTop Valign = "top"

	ValignMiddle Valign = "middle"

	ValignBottom Valign = "bottom"

	ValignBaseline Valign = "baseline"
)

// The valign-image type is used to indicate vertical alignment for
// images and graphics, so it does not include a baseline value. Defaults are
// implementation-dependent.

type Valign_image string

const (
	Valign_imageTop Valign_image = "top"

	Valign_imageMiddle Valign_image = "middle"

	Valign_imageBottom Valign_image = "bottom"
)

// The yes-no type is used for boolean-like attributes. We cannot use W3C
// XML Schema booleans due to their restrictions on expression of boolean values.

type Yes_no string

const (
	Yes_noYes Yes_no = "yes"

	Yes_noNo Yes_no = "no"
)

// The yes-no-number type is used for attributes that can be either
// boolean or numeric values.

type Yes_no_number string

// Calendar dates are represented yyyy-mm-dd format, following ISO 8601.
// This is a W3C XML Schema date type, but without the optional timezone data.

type Yyyy_mm_dd soap.XSDDate

// The cancel-location type is used to indicate where a key signature
// cancellation appears relative to a new key signature: to the left, to the right, or
// before the barline and to the left. It is left by default. For mid-measure key
// elements, a cancel-location of before-barline should be treated like a
// cancel-location of left.

type Cancel_location string

const (
	Cancel_locationLeft Cancel_location = "left"

	Cancel_locationRight Cancel_location = "right"

	Cancel_locationBefore_barline Cancel_location = "before-barline"
)

// The clef-sign type represents the different clef symbols. The jianpu
// sign indicates that the music that follows should be in jianpu numbered notation,
// just as the TAB sign indicates that the music that follows should be in tablature
// notation. Unlike TAB, a jianpu sign does not correspond to a visual clef notation.
// The none sign is deprecated as of MusicXML 4.0. Use the clef element's print-object
// attribute instead. When the none sign is used, notes should be displayed as if in
// treble clef.

type Clef_sign string

const (
	Clef_signG Clef_sign = "G"

	Clef_signF Clef_sign = "F"

	Clef_signC Clef_sign = "C"

	Clef_signPercussion Clef_sign = "percussion"

	Clef_signTAB Clef_sign = "TAB"

	Clef_signJianpu Clef_sign = "jianpu"

	Clef_signNone Clef_sign = "none"
)

// The fifths type represents the number of flats or sharps in a
// traditional key signature. Negative numbers are used for flats and positive numbers
// for sharps, reflecting the key's placement within the circle of fifths (hence the
// type name).

type Fifths int32

// The mode type is used to specify major/minor and other mode
// distinctions. Valid mode values include major, minor, dorian, phrygian, lydian,
// mixolydian, aeolian, ionian, locrian, and none.

type Mode string

// The show-frets type indicates whether to show tablature frets as
// numbers (0, 1, 2) or letters (a, b, c). The default choice is numbers.

type Show_frets string

const (
	Show_fretsNumbers Show_frets = "numbers"

	Show_fretsLetters Show_frets = "letters"
)

// The staff-line type indicates the line on a given staff. Staff lines
// are numbered from bottom to top, with 1 being the bottom line on a staff.

type Staff_line PositiveInteger

// The staff-line-position type indicates the line position on a given
// staff. Staff lines are numbered from bottom to top, with 1 being the bottom line on
// a staff. A staff-line-position value can extend beyond the range of the lines on the
// current staff.

type Staff_line_position int32

// The staff-number type indicates staff numbers within a multi-staff
// part. Staves are numbered from top to bottom, with 1 being the top staff on a part.

type Staff_number PositiveInteger

// The staff-type value can be ossia, editorial, cue, alternate, or
// regular. An ossia staff represents music that can be played instead of what appears
// on the regular staff. An editorial staff also represents musical alternatives, but
// is created by an editor rather than the composer. It can be used for suggested
// interpretations or alternatives from other sources. A cue staff represents music
// from another part. An alternate staff shares the same music as the prior staff, but
// displayed differently (e.g., treble and bass clef, standard notation and tablature).
// It is not included in playback. An alternate staff provides more information to an
// application reading a file than encoding the same music in separate parts, so its
// use is preferred in this situation if feasible. A regular staff is the standard
// default staff-type.

type Staff_type string

const (
	Staff_typeOssia Staff_type = "ossia"

	Staff_typeEditorial Staff_type = "editorial"

	Staff_typeCue Staff_type = "cue"

	Staff_typeAlternate Staff_type = "alternate"

	Staff_typeRegular Staff_type = "regular"
)

// The time-relation type indicates the symbol used to represent the
// interchangeable aspect of dual time signatures.

type Time_relation string

const (
	Time_relationParentheses Time_relation = "parentheses"

	Time_relationBracket Time_relation = "bracket"

	Time_relationEquals Time_relation = "equals"

	Time_relationSlash Time_relation = "slash"

	Time_relationSpace Time_relation = "space"

	Time_relationHyphen Time_relation = "hyphen"
)

// The time-separator type indicates how to display the arrangement
// between the beats and beat-type values in a time signature. The default value is
// none. The horizontal, diagonal, and vertical values represent horizontal, diagonal
// lower-left to upper-right, and vertical lines respectively. For these values, the
// beats and beat-type values are arranged on either side of the separator line. The
// none value represents no separator with the beats and beat-type arranged vertically.
// The adjacent value represents no separator with the beats and beat-type arranged
// horizontally.

type Time_separator string

const (
	Time_separatorNone Time_separator = "none"

	Time_separatorHorizontal Time_separator = "horizontal"

	Time_separatorDiagonal Time_separator = "diagonal"

	Time_separatorVertical Time_separator = "vertical"

	Time_separatorAdjacent Time_separator = "adjacent"
)

// The time-symbol type indicates how to display a time signature. The
// normal value is the usual fractional display, and is the implied symbol type if none
// is specified. Other options are the common and cut time symbols, as well as a single
// number with an implied denominator. The note symbol indicates that the beat-type
// should be represented with the corresponding downstem note rather than a number. The
// dotted-note symbol indicates that the beat-type should be represented with a dotted
// downstem note that corresponds to three times the beat-type value, and a numerator
// that is one third the beats value.

type Time_symbol string

const (
	Time_symbolCommon Time_symbol = "common"

	Time_symbolCut Time_symbol = "cut"

	Time_symbolSingle_number Time_symbol = "single-number"

	Time_symbolNote Time_symbol = "note"

	Time_symbolDotted_note Time_symbol = "dotted-note"

	Time_symbolNormal Time_symbol = "normal"
)

// The backward-forward type is used to specify repeat directions. The
// start of the repeat has a forward direction while the end of the repeat has a
// backward direction.

type Backward_forward string

const (
	Backward_forwardBackward Backward_forward = "backward"

	Backward_forwardForward Backward_forward = "forward"
)

// The bar-style type represents barline style information. Choices are
// regular, dotted, dashed, heavy, light-light, light-heavy, heavy-light, heavy-heavy,
// tick (a short stroke through the top line), short (a partial barline between the 2nd
// and 4th lines), and none.

type Bar_style string

const (
	Bar_styleRegular Bar_style = "regular"

	Bar_styleDotted Bar_style = "dotted"

	Bar_styleDashed Bar_style = "dashed"

	Bar_styleHeavy Bar_style = "heavy"

	Bar_styleLight_light Bar_style = "light-light"

	Bar_styleLight_heavy Bar_style = "light-heavy"

	Bar_styleHeavy_light Bar_style = "heavy-light"

	Bar_styleHeavy_heavy Bar_style = "heavy-heavy"

	Bar_styleTick Bar_style = "tick"

	Bar_styleShort Bar_style = "short"

	Bar_styleNone Bar_style = "none"
)

// The ending-number type is used to specify either a comma-separated
// list of positive integers without leading zeros, or a string of zero or more spaces.
// It is used for the number attribute of the ending element. The zero or more spaces
// version is used when software knows that an ending is present, but cannot determine
// the type of the ending.

type Ending_number string

// The right-left-middle type is used to specify barline location.

type Right_left_middle string

const (
	Right_left_middleRight Right_left_middle = "right"

	Right_left_middleLeft Right_left_middle = "left"

	Right_left_middleMiddle Right_left_middle = "middle"
)

// The start-stop-discontinue type is used to specify ending types.
// Typically, the start type is associated with the left barline of the first measure
// in an ending. The stop and discontinue types are associated with the right barline
// of the last measure in an ending. Stop is used when the ending mark concludes with a
// downward jog, as is typical for first endings. Discontinue is used when there is no
// downward jog, as is typical for second endings that do not conclude a piece.

type Start_stop_discontinue string

const (
	Start_stop_discontinueStart Start_stop_discontinue = "start"

	Start_stop_discontinueStop Start_stop_discontinue = "stop"

	Start_stop_discontinueDiscontinue Start_stop_discontinue = "discontinue"
)

// The winged attribute indicates whether the repeat has winged
// extensions that appear above and below the barline. The straight and curved values
// represent single wings, while the double-straight and double-curved values represent
// double wings. The none value indicates no wings and is the default.

type Winged string

const (
	WingedNone Winged = "none"

	WingedStraight Winged = "straight"

	WingedCurved Winged = "curved"

	WingedDouble_straight Winged = "double-straight"

	WingedDouble_curved Winged = "double-curved"
)

// The accordion-middle type may have values of 1, 2, or 3, corresponding
// to having 1 to 3 dots in the middle section of the accordion registration symbol.
// This type is not used if no dots are present.

type Accordion_middle PositiveInteger

// The beater-value type represents pictograms for beaters, mallets, and
// sticks that do not have different materials represented in the pictogram. The finger
// and hammer values are in addition to Stone's list.

type Beater_value string

const (
	Beater_valueBow Beater_value = "bow"

	Beater_valueChimehammer Beater_value = "chime hammer"

	Beater_valueCoin Beater_value = "coin"

	Beater_valueDrumstick Beater_value = "drum stick"

	Beater_valueFinger Beater_value = "finger"

	Beater_valueFingernail Beater_value = "fingernail"

	Beater_valueFist Beater_value = "fist"

	Beater_valueGuiroscraper Beater_value = "guiro scraper"

	Beater_valueHammer Beater_value = "hammer"

	Beater_valueHand Beater_value = "hand"

	Beater_valueJazzstick Beater_value = "jazz stick"

	Beater_valueKnittingneedle Beater_value = "knitting needle"

	Beater_valueMetalhammer Beater_value = "metal hammer"

	Beater_valueSlidebrushongong Beater_value = "slide brush on gong"

	Beater_valueSnarestick Beater_value = "snare stick"

	Beater_valueSpoonmallet Beater_value = "spoon mallet"

	Beater_valueSuperball Beater_value = "superball"

	Beater_valueTrianglebeater Beater_value = "triangle beater"

	Beater_valueTrianglebeaterplain Beater_value = "triangle beater plain"

	Beater_valueWirebrush Beater_value = "wire brush"
)

// The degree-symbol-value type indicates which symbol should be used in
// specifying a degree.

type Degree_symbol_value string

const (
	Degree_symbol_valueMajor Degree_symbol_value = "major"

	Degree_symbol_valueMinor Degree_symbol_value = "minor"

	Degree_symbol_valueAugmented Degree_symbol_value = "augmented"

	Degree_symbol_valueDiminished Degree_symbol_value = "diminished"

	Degree_symbol_valueHalf_diminished Degree_symbol_value = "half-diminished"
)

// The degree-type-value type indicates whether the current degree
// element is an addition, alteration, or subtraction to the kind of the current chord
// in the harmony element.

type Degree_type_value string

const (
	Degree_type_valueAdd Degree_type_value = "add"

	Degree_type_valueAlter Degree_type_value = "alter"

	Degree_type_valueSubtract Degree_type_value = "subtract"
)

// The effect-value type represents pictograms for sound effect
// percussion instruments. The cannon, lotus flute, and megaphone values are in
// addition to Stone's list.

type Effect_value string

const (
	Effect_valueAnvil Effect_value = "anvil"

	Effect_valueAutohorn Effect_value = "auto horn"

	Effect_valueBirdwhistle Effect_value = "bird whistle"

	Effect_valueCannon Effect_value = "cannon"

	Effect_valueDuckcall Effect_value = "duck call"

	Effect_valueGunshot Effect_value = "gun shot"

	Effect_valueKlaxonhorn Effect_value = "klaxon horn"

	Effect_valueLionsroar Effect_value = "lions roar"

	Effect_valueLotusflute Effect_value = "lotus flute"

	Effect_valueMegaphone Effect_value = "megaphone"

	Effect_valuePolicewhistle Effect_value = "police whistle"

	Effect_valueSiren Effect_value = "siren"

	Effect_valueSlidewhistle Effect_value = "slide whistle"

	Effect_valueThundersheet Effect_value = "thunder sheet"

	Effect_valueWindmachine Effect_value = "wind machine"

	Effect_valueWindwhistle Effect_value = "wind whistle"
)

// The glass-value type represents pictograms for glass percussion
// instruments.

type Glass_value string

const (
	Glass_valueGlassharmonica Glass_value = "glass harmonica"

	Glass_valueGlassharp Glass_value = "glass harp"

	Glass_valueWindchimes Glass_value = "wind chimes"
)

// The harmony-arrangement type indicates how stacked chords and bass
// notes are displayed within a harmony element. The vertical value specifies that the
// second element appears below the first. The horizontal value specifies that the
// second element appears to the right of the first. The diagonal value specifies that
// the second element appears both below and to the right of the first.

type Harmony_arrangement string

const (
	Harmony_arrangementVertical Harmony_arrangement = "vertical"

	Harmony_arrangementHorizontal Harmony_arrangement = "horizontal"

	Harmony_arrangementDiagonal Harmony_arrangement = "diagonal"
)

// The harmony-type type differentiates different types of harmonies when
// alternate harmonies are possible. Explicit harmonies have all note present in the
// music; implied have some notes missing but implied; alternate represents alternate
// analyses.

type Harmony_type string

const (
	Harmony_typeExplicit Harmony_type = "explicit"

	Harmony_typeImplied Harmony_type = "implied"

	Harmony_typeAlternate Harmony_type = "alternate"
)

// A kind-value indicates the type of chord. Degree elements can then
// add, subtract, or alter from these starting points. Values include: Triads: major
// (major third, perfect fifth) minor (minor third, perfect fifth) augmented (major
// third, augmented fifth) diminished (minor third, diminished fifth) Sevenths:
// dominant (major triad, minor seventh) major-seventh (major triad, major seventh)
// minor-seventh (minor triad, minor seventh) diminished-seventh (diminished triad,
// diminished seventh) augmented-seventh (augmented triad, minor seventh)
// half-diminished (diminished triad, minor seventh) major-minor (minor triad, major
// seventh) Sixths: major-sixth (major triad, added sixth) minor-sixth (minor triad,
// added sixth) Ninths: dominant-ninth (dominant-seventh, major ninth) major-ninth
// (major-seventh, major ninth) minor-ninth (minor-seventh, major ninth) 11ths (usually
// as the basis for alteration): dominant-11th (dominant-ninth, perfect 11th)
// major-11th (major-ninth, perfect 11th) minor-11th (minor-ninth, perfect 11th) 13ths
// (usually as the basis for alteration): dominant-13th (dominant-11th, major 13th)
// major-13th (major-11th, major 13th) minor-13th (minor-11th, major 13th) Suspended:
// suspended-second (major second, perfect fifth) suspended-fourth (perfect fourth,
// perfect fifth) Functional sixths: Neapolitan Italian French German Other: pedal
// (pedal-point bass) power (perfect fifth) Tristan The "other" kind is used when the
// harmony is entirely composed of add elements. The "none" kind is used to explicitly
// encode absence of chords or functional harmony. In this case, the root, numeral, or
// function element has no meaning. When using the root or numeral element, the
// root-step or numeral-step text attribute should be set to the empty string to keep
// the root or numeral from being displayed.

type Kind_value string

const (
	Kind_valueMajor Kind_value = "major"

	Kind_valueMinor Kind_value = "minor"

	Kind_valueAugmented Kind_value = "augmented"

	Kind_valueDiminished Kind_value = "diminished"

	Kind_valueDominant Kind_value = "dominant"

	Kind_valueMajor_seventh Kind_value = "major-seventh"

	Kind_valueMinor_seventh Kind_value = "minor-seventh"

	Kind_valueDiminished_seventh Kind_value = "diminished-seventh"

	Kind_valueAugmented_seventh Kind_value = "augmented-seventh"

	Kind_valueHalf_diminished Kind_value = "half-diminished"

	Kind_valueMajor_minor Kind_value = "major-minor"

	Kind_valueMajor_sixth Kind_value = "major-sixth"

	Kind_valueMinor_sixth Kind_value = "minor-sixth"

	Kind_valueDominant_ninth Kind_value = "dominant-ninth"

	Kind_valueMajor_ninth Kind_value = "major-ninth"

	Kind_valueMinor_ninth Kind_value = "minor-ninth"

	Kind_valueDominant_11th Kind_value = "dominant-11th"

	Kind_valueMajor_11th Kind_value = "major-11th"

	Kind_valueMinor_11th Kind_value = "minor-11th"

	Kind_valueDominant_13th Kind_value = "dominant-13th"

	Kind_valueMajor_13th Kind_value = "major-13th"

	Kind_valueMinor_13th Kind_value = "minor-13th"

	Kind_valueSuspended_second Kind_value = "suspended-second"

	Kind_valueSuspended_fourth Kind_value = "suspended-fourth"

	Kind_valueNeapolitan Kind_value = "Neapolitan"

	Kind_valueItalian Kind_value = "Italian"

	Kind_valueFrench Kind_value = "French"

	Kind_valueGerman Kind_value = "German"

	Kind_valuePedal Kind_value = "pedal"

	Kind_valuePower Kind_value = "power"

	Kind_valueTristan Kind_value = "Tristan"

	Kind_valueOther Kind_value = "other"

	Kind_valueNone Kind_value = "none"
)

// The line-end type specifies if there is a jog up or down (or both), an
// arrow, or nothing at the start or end of a bracket.

type Line_end string

const (
	Line_endUp Line_end = "up"

	Line_endDown Line_end = "down"

	Line_endBoth Line_end = "both"

	Line_endArrow Line_end = "arrow"

	Line_endNone Line_end = "none"
)

// The measure-numbering-value type describes how measure numbers are
// displayed on this part: no numbers, numbers every measure, or numbers every system.

type Measure_numbering_value string

const (
	Measure_numbering_valueNone Measure_numbering_value = "none"

	Measure_numbering_valueMeasure Measure_numbering_value = "measure"

	Measure_numbering_valueSystem Measure_numbering_value = "system"
)

// The membrane-value type represents pictograms for membrane percussion
// instruments.

type Membrane_value string

const (
	Membrane_valueBassdrum Membrane_value = "bass drum"

	Membrane_valueBassdrumonside Membrane_value = "bass drum on side"

	Membrane_valueBongos Membrane_value = "bongos"

	Membrane_valueChinesetomtom Membrane_value = "Chinese tomtom"

	Membrane_valueCongadrum Membrane_value = "conga drum"

	Membrane_valueCuica Membrane_value = "cuica"

	Membrane_valueGobletdrum Membrane_value = "goblet drum"

	Membrane_valueIndo_Americantomtom Membrane_value = "Indo-American tomtom"

	Membrane_valueJapanesetomtom Membrane_value = "Japanese tomtom"

	Membrane_valueMilitarydrum Membrane_value = "military drum"

	Membrane_valueSnaredrum Membrane_value = "snare drum"

	Membrane_valueSnaredrumsnaresoff Membrane_value = "snare drum snares off"

	Membrane_valueTabla Membrane_value = "tabla"

	Membrane_valueTambourine Membrane_value = "tambourine"

	Membrane_valueTenordrum Membrane_value = "tenor drum"

	Membrane_valueTimbales Membrane_value = "timbales"

	Membrane_valueTomtom Membrane_value = "tomtom"
)

// The metal-value type represents pictograms for metal percussion
// instruments. The hi-hat value refers to a pictogram like Stone's high-hat cymbals
// but without the long vertical line at the bottom.

type Metal_value string

const (
	Metal_valueAgogo Metal_value = "agogo"

	Metal_valueAlmglocken Metal_value = "almglocken"

	Metal_valueBell Metal_value = "bell"

	Metal_valueBellplate Metal_value = "bell plate"

	Metal_valueBelltree Metal_value = "bell tree"

	Metal_valueBrakedrum Metal_value = "brake drum"

	Metal_valueCencerro Metal_value = "cencerro"

	Metal_valueChainrattle Metal_value = "chain rattle"

	Metal_valueChinesecymbal Metal_value = "Chinese cymbal"

	Metal_valueCowbell Metal_value = "cowbell"

	Metal_valueCrashcymbals Metal_value = "crash cymbals"

	Metal_valueCrotale Metal_value = "crotale"

	Metal_valueCymbaltongs Metal_value = "cymbal tongs"

	Metal_valueDomedgong Metal_value = "domed gong"

	Metal_valueFingercymbals Metal_value = "finger cymbals"

	Metal_valueFlexatone Metal_value = "flexatone"

	Metal_valueGong Metal_value = "gong"

	Metal_valueHi_hat Metal_value = "hi-hat"

	Metal_valueHigh_hatcymbals Metal_value = "high-hat cymbals"

	Metal_valueHandbell Metal_value = "handbell"

	Metal_valueJawharp Metal_value = "jaw harp"

	Metal_valueJinglebells Metal_value = "jingle bells"

	Metal_valueMusicalsaw Metal_value = "musical saw"

	Metal_valueShellbells Metal_value = "shell bells"

	Metal_valueSistrum Metal_value = "sistrum"

	Metal_valueSizzlecymbal Metal_value = "sizzle cymbal"

	Metal_valueSleighbells Metal_value = "sleigh bells"

	Metal_valueSuspendedcymbal Metal_value = "suspended cymbal"

	Metal_valueTamtam Metal_value = "tam tam"

	Metal_valueTamtamwithbeater Metal_value = "tam tam with beater"

	Metal_valueTriangle Metal_value = "triangle"

	Metal_valueVietnamesehat Metal_value = "Vietnamese hat"
)

// The milliseconds type represents an integral number of milliseconds.

type Milliseconds uint32

// The numeral-mode type specifies the mode similar to the mode type, but
// with a restricted set of values. The different minor values are used to interpret
// numeral-root values of 6 and 7 when present in a minor key. The harmonic minor value
// sharpens the 7 and the melodic minor value sharpens both 6 and 7. If a minor mode is
// used without qualification, either in the mode or numeral-mode elements, natural
// minor is used.

type Numeral_mode string

const (
	Numeral_modeMajor Numeral_mode = "major"

	Numeral_modeMinor Numeral_mode = "minor"

	Numeral_modeNaturalminor Numeral_mode = "natural minor"

	Numeral_modeMelodicminor Numeral_mode = "melodic minor"

	Numeral_modeHarmonicminor Numeral_mode = "harmonic minor"
)

// The on-off type is used for notation elements such as string mutes.

type On_off string

const (
	On_offOn On_off = "on"

	On_offOff On_off = "off"
)

// The pedal-type simple type is used to distinguish types of pedal
// directions. The start value indicates the start of a damper pedal, while the
// sostenuto value indicates the start of a sostenuto pedal. The other values can be
// used with either the damper or sostenuto pedal. The soft pedal is not included here
// because there is no special symbol or graphic used for it beyond what can be
// specified with words and bracket elements. The change, continue, discontinue, and
// resume types are used when the line attribute is yes. The change type indicates a
// pedal lift and retake indicated with an inverted V marking. The continue type allows
// more precise formatting across system breaks and for more complex pedaling lines.
// The discontinue type indicates the end of a pedal line that does not include the
// explicit lift represented by the stop type. The resume type indicates the start of a
// pedal line that does not include the downstroke represented by the start type. It
// can be used when a line resumes after being discontinued, or to start a pedal line
// that is preceded by a text or symbol representation of the pedal.

type Pedal_type string

const (
	Pedal_typeStart Pedal_type = "start"

	Pedal_typeStop Pedal_type = "stop"

	Pedal_typeSostenuto Pedal_type = "sostenuto"

	Pedal_typeChange Pedal_type = "change"

	Pedal_typeContinue_ Pedal_type = "continue"

	Pedal_typeDiscontinue Pedal_type = "discontinue"

	Pedal_typeResume Pedal_type = "resume"
)

// The pitched-value type represents pictograms for pitched percussion
// instruments. The chimes and tubular chimes values distinguish the single-line and
// double-line versions of the pictogram.

type Pitched_value string

const (
	Pitched_valueCelesta Pitched_value = "celesta"

	Pitched_valueChimes Pitched_value = "chimes"

	Pitched_valueGlockenspiel Pitched_value = "glockenspiel"

	Pitched_valueLithophone Pitched_value = "lithophone"

	Pitched_valueMallet Pitched_value = "mallet"

	Pitched_valueMarimba Pitched_value = "marimba"

	Pitched_valueSteeldrums Pitched_value = "steel drums"

	Pitched_valueTubaphone Pitched_value = "tubaphone"

	Pitched_valueTubularchimes Pitched_value = "tubular chimes"

	Pitched_valueVibraphone Pitched_value = "vibraphone"

	Pitched_valueXylophone Pitched_value = "xylophone"
)

// The principal-voice-symbol type represents the type of symbol used to
// indicate a principal or secondary voice. The "plain" value represents a plain square
// bracket. The value of "none" is used for analysis markup when the principal-voice
// element does not have a corresponding appearance in the score.

type Principal_voice_symbol string

const (
	Principal_voice_symbolHauptstimme Principal_voice_symbol = "Hauptstimme"

	Principal_voice_symbolNebenstimme Principal_voice_symbol = "Nebenstimme"

	Principal_voice_symbolPlain Principal_voice_symbol = "plain"

	Principal_voice_symbolNone Principal_voice_symbol = "none"
)

// The staff-divide-symbol type is used for staff division symbols. The
// down, up, and up-down values correspond to SMuFL code points U+E00B, U+E00C, and
// U+E00D respectively.

type Staff_divide_symbol string

const (
	Staff_divide_symbolDown Staff_divide_symbol = "down"

	Staff_divide_symbolUp Staff_divide_symbol = "up"

	Staff_divide_symbolUp_down Staff_divide_symbol = "up-down"
)

// The start-stop-change-continue type is used to distinguish types of
// pedal directions.

type Start_stop_change_continue string

const (
	Start_stop_change_continueStart Start_stop_change_continue = "start"

	Start_stop_change_continueStop Start_stop_change_continue = "stop"

	Start_stop_change_continueChange Start_stop_change_continue = "change"

	Start_stop_change_continueContinue_ Start_stop_change_continue = "continue"
)

// The sync-type type specifies the style that a score following
// application should use to synchronize an accompaniment with a performer. The none
// type indicates no synchronization to the performer. The tempo type indicates
// synchronization based on the performer tempo rather than individual events in the
// score. The event type indicates synchronization by following the performance of
// individual events in the score rather than the performer tempo. The mostly-tempo and
// mostly-event types combine these two approaches, with mostly-tempo giving more
// weight to tempo and mostly-event giving more weight to performed events. The
// always-event type provides the strictest synchronization by not being forgiving of
// missing performed events.

type Sync_type string

const (
	Sync_typeNone Sync_type = "none"

	Sync_typeTempo Sync_type = "tempo"

	Sync_typeMostly_tempo Sync_type = "mostly-tempo"

	Sync_typeMostly_event Sync_type = "mostly-event"

	Sync_typeEvent Sync_type = "event"

	Sync_typeAlways_event Sync_type = "always-event"
)

// The system-relation-number type distinguishes measure numbers that are
// associated with a system rather than the particular part where the element appears.
// A value of only-top or only-bottom indicates that the number should appear only on
// the top or bottom part of the current system, respectively. A value of also-top or
// also-bottom indicates that the number should appear on both the current part and the
// top or bottom part of the current system, respectively. If these values appear in a
// score, when parts are created the number should only appear once in this part, not
// twice. A value of none indicates that the number is associated only with the current
// part, not with the system.

type System_relation_number string

const (
	System_relation_numberOnly_top System_relation_number = "only-top"

	System_relation_numberOnly_bottom System_relation_number = "only-bottom"

	System_relation_numberAlso_top System_relation_number = "also-top"

	System_relation_numberAlso_bottom System_relation_number = "also-bottom"

	System_relation_numberNone System_relation_number = "none"
)

// The system-relation type distinguishes elements that are associated
// with a system rather than the particular part where the element appears. A value of
// only-top indicates that the element should appear only on the top part of the
// current system. A value of also-top indicates that the element should appear on both
// the current part and the top part of the current system. If this value appears in a
// score, when parts are created the element should only appear once in this part, not
// twice. A value of none indicates that the element is associated only with the
// current part, not with the system.

type System_relation System_relation_number

const (
	System_relationOnly_top System_relation = "only-top"

	System_relationAlso_top System_relation = "also-top"

	System_relationNone System_relation = "none"
)

// The tip-direction type represents the direction in which the tip of a
// stick or beater points, using Unicode arrow terminology.

type Tip_direction string

const (
	Tip_directionUp Tip_direction = "up"

	Tip_directionDown Tip_direction = "down"

	Tip_directionLeft Tip_direction = "left"

	Tip_directionRight Tip_direction = "right"

	Tip_directionNorthwest Tip_direction = "northwest"

	Tip_directionNortheast Tip_direction = "northeast"

	Tip_directionSoutheast Tip_direction = "southeast"

	Tip_directionSouthwest Tip_direction = "southwest"
)

// The stick-location type represents pictograms for the location of
// sticks, beaters, or mallets on cymbals, gongs, drums, and other instruments.

type Stick_location string

const (
	Stick_locationCenter Stick_location = "center"

	Stick_locationRim Stick_location = "rim"

	Stick_locationCymbalbell Stick_location = "cymbal bell"

	Stick_locationCymbaledge Stick_location = "cymbal edge"
)

// The stick-material type represents the material being displayed in a
// stick pictogram.

type Stick_material string

const (
	Stick_materialSoft Stick_material = "soft"

	Stick_materialMedium Stick_material = "medium"

	Stick_materialHard Stick_material = "hard"

	Stick_materialShaded Stick_material = "shaded"

	Stick_materialX Stick_material = "x"
)

// The stick-type type represents the shape of pictograms where the
// material in the stick, mallet, or beater is represented in the pictogram.

type Stick_type string

const (
	Stick_typeBassdrum Stick_type = "bass drum"

	Stick_typeDoublebassdrum Stick_type = "double bass drum"

	Stick_typeGlockenspiel Stick_type = "glockenspiel"

	Stick_typeGum Stick_type = "gum"

	Stick_typeHammer Stick_type = "hammer"

	Stick_typeSuperball Stick_type = "superball"

	Stick_typeTimpani Stick_type = "timpani"

	Stick_typeWound Stick_type = "wound"

	Stick_typeXylophone Stick_type = "xylophone"

	Stick_typeYarn Stick_type = "yarn"
)

// The up-down-stop-continue type is used for octave-shift elements,
// indicating the direction of the shift from their true pitched values because of
// printing difficulty.

type Up_down_stop_continue string

const (
	Up_down_stop_continueUp Up_down_stop_continue = "up"

	Up_down_stop_continueDown Up_down_stop_continue = "down"

	Up_down_stop_continueStop Up_down_stop_continue = "stop"

	Up_down_stop_continueContinue_ Up_down_stop_continue = "continue"
)

// The wedge type is crescendo for the start of a wedge that is closed at
// the left side, diminuendo for the start of a wedge that is closed on the right side,
// and stop for the end of a wedge. The continue type is used for formatting wedges
// over a system break, or for other situations where a single wedge is divided into
// multiple segments.

type Wedge_type string

const (
	Wedge_typeCrescendo Wedge_type = "crescendo"

	Wedge_typeDiminuendo Wedge_type = "diminuendo"

	Wedge_typeStop Wedge_type = "stop"

	Wedge_typeContinue_ Wedge_type = "continue"
)

// The wood-value type represents pictograms for wood percussion
// instruments. The maraca and maracas values distinguish the one- and two-maraca
// versions of the pictogram.

type Wood_value string

const (
	Wood_valueBambooscraper Wood_value = "bamboo scraper"

	Wood_valueBoardclapper Wood_value = "board clapper"

	Wood_valueCabasa Wood_value = "cabasa"

	Wood_valueCastanets Wood_value = "castanets"

	Wood_valueCastanetswithhandle Wood_value = "castanets with handle"

	Wood_valueClaves Wood_value = "claves"

	Wood_valueFootballrattle Wood_value = "football rattle"

	Wood_valueGuiro Wood_value = "guiro"

	Wood_valueLogdrum Wood_value = "log drum"

	Wood_valueMaraca Wood_value = "maraca"

	Wood_valueMaracas Wood_value = "maracas"

	Wood_valueQuijada Wood_value = "quijada"

	Wood_valueRainstick Wood_value = "rainstick"

	Wood_valueRatchet Wood_value = "ratchet"

	Wood_valueReco_reco Wood_value = "reco-reco"

	Wood_valueSandpaperblocks Wood_value = "sandpaper blocks"

	Wood_valueSlitdrum Wood_value = "slit drum"

	Wood_valueTempleblock Wood_value = "temple block"

	Wood_valueVibraslap Wood_value = "vibraslap"

	Wood_valueWhip Wood_value = "whip"

	Wood_valueWoodblock Wood_value = "wood block"
)

// The distance-type defines what type of distance is being defined in a
// distance element. Values include beam and hyphen. This is left as a string so that
// other application-specific types can be defined, but it is made a separate type so
// that it can be redefined more strictly.

type Distance_type string

// The glyph-type defines what type of glyph is being defined in a glyph
// element. Values include quarter-rest, g-clef-ottava-bassa, c-clef, f-clef,
// percussion-clef, octave-shift-up-8, octave-shift-down-8, octave-shift-continue-8,
// octave-shift-down-15, octave-shift-up-15, octave-shift-continue-15,
// octave-shift-down-22, octave-shift-up-22, and octave-shift-continue-22. This is left
// as a string so that other application-specific types can be defined, but it is made
// a separate type so that it can be redefined more strictly. A quarter-rest type
// specifies the glyph to use when a note has a rest element and a type value of
// quarter. The c-clef, f-clef, and percussion-clef types specify the glyph to use when
// a clef sign element value is C, F, or percussion respectively. The
// g-clef-ottava-bassa type specifies the glyph to use when a clef sign element value
// is G and the clef-octave-change element value is -1. The octave-shift types specify
// the glyph to use when an octave-shift type attribute value is up, down, or continue
// and the octave-shift size attribute value is 8, 15, or 22.

type Glyph_type string

// The line-width-type defines what type of line is being defined in a
// line-width element. Values include beam, bracket, dashes, enclosure, ending, extend,
// heavy barline, leger, light barline, octave shift, pedal, slur middle, slur tip,
// staff, stem, tie middle, tie tip, tuplet bracket, and wedge. This is left as a
// string so that other application-specific types can be defined, but it is made a
// separate type so that it can be redefined more strictly.

type Line_width_type string

// The margin-type type specifies whether margins apply to even page, odd
// pages, or both.

type Margin_type string

const (
	Margin_typeOdd Margin_type = "odd"

	Margin_typeEven Margin_type = "even"

	Margin_typeBoth Margin_type = "both"
)

// The millimeters type is a number representing millimeters. This is
// used in the scaling element to provide a default scaling from tenths to physical
// units.

type Millimeters float64

// The note-size-type type indicates the type of note being defined by a
// note-size element. The grace-cue type is used for notes of grace-cue size. The grace
// type is used for notes of cue size that include a grace element. The cue type is
// used for all other notes with cue size, whether defined explicitly or implicitly via
// a cue element. The large type is used for notes of large size.

type Note_size_type string

const (
	Note_size_typeCue Note_size_type = "cue"

	Note_size_typeGrace Note_size_type = "grace"

	Note_size_typeGrace_cue Note_size_type = "grace-cue"

	Note_size_typeLarge Note_size_type = "large"
)

// The accidental-value type represents notated accidentals supported by
// MusicXML. In the MusicXML 2.0 DTD this was a string with values that could be
// included. The XSD strengthens the data typing to an enumerated list. The quarter-
// and three-quarters- accidentals are Tartini-style quarter-tone accidentals. The
// -down and -up accidentals are quarter-tone accidentals that include arrows pointing
// down or up. The slash- accidentals are used in Turkish classical music. The numbered
// sharp and flat accidentals are superscripted versions of the accidental signs, used
// in Turkish folk music. The sori and koron accidentals are microtonal sharp and flat
// accidentals used in Iranian and Persian music. The other accidental covers
// accidentals other than those listed here. It is usually used in combination with the
// smufl attribute to specify a particular SMuFL accidental. The smufl attribute may be
// used with any accidental value to help specify the appearance of symbols that share
// the same MusicXML semantics.

type Accidental_value string

const (
	Accidental_valueSharp Accidental_value = "sharp"

	Accidental_valueNatural Accidental_value = "natural"

	Accidental_valueFlat Accidental_value = "flat"

	Accidental_valueDouble_sharp Accidental_value = "double-sharp"

	Accidental_valueSharp_sharp Accidental_value = "sharp-sharp"

	Accidental_valueFlat_flat Accidental_value = "flat-flat"

	Accidental_valueNatural_sharp Accidental_value = "natural-sharp"

	Accidental_valueNatural_flat Accidental_value = "natural-flat"

	Accidental_valueQuarter_flat Accidental_value = "quarter-flat"

	Accidental_valueQuarter_sharp Accidental_value = "quarter-sharp"

	Accidental_valueThree_quarters_flat Accidental_value = "three-quarters-flat"

	Accidental_valueThree_quarters_sharp Accidental_value = "three-quarters-sharp"

	Accidental_valueSharp_down Accidental_value = "sharp-down"

	Accidental_valueSharp_up Accidental_value = "sharp-up"

	Accidental_valueNatural_down Accidental_value = "natural-down"

	Accidental_valueNatural_up Accidental_value = "natural-up"

	Accidental_valueFlat_down Accidental_value = "flat-down"

	Accidental_valueFlat_up Accidental_value = "flat-up"

	Accidental_valueDouble_sharp_down Accidental_value = "double-sharp-down"

	Accidental_valueDouble_sharp_up Accidental_value = "double-sharp-up"

	Accidental_valueFlat_flat_down Accidental_value = "flat-flat-down"

	Accidental_valueFlat_flat_up Accidental_value = "flat-flat-up"

	Accidental_valueArrow_down Accidental_value = "arrow-down"

	Accidental_valueArrow_up Accidental_value = "arrow-up"

	Accidental_valueTriple_sharp Accidental_value = "triple-sharp"

	Accidental_valueTriple_flat Accidental_value = "triple-flat"

	Accidental_valueSlash_quarter_sharp Accidental_value = "slash-quarter-sharp"

	Accidental_valueSlash_sharp Accidental_value = "slash-sharp"

	Accidental_valueSlash_flat Accidental_value = "slash-flat"

	Accidental_valueDouble_slash_flat Accidental_value = "double-slash-flat"

	Accidental_valueSharp_1 Accidental_value = "sharp-1"

	Accidental_valueSharp_2 Accidental_value = "sharp-2"

	Accidental_valueSharp_3 Accidental_value = "sharp-3"

	Accidental_valueSharp_5 Accidental_value = "sharp-5"

	Accidental_valueFlat_1 Accidental_value = "flat-1"

	Accidental_valueFlat_2 Accidental_value = "flat-2"

	Accidental_valueFlat_3 Accidental_value = "flat-3"

	Accidental_valueFlat_4 Accidental_value = "flat-4"

	Accidental_valueSori Accidental_value = "sori"

	Accidental_valueKoron Accidental_value = "koron"

	Accidental_valueOther Accidental_value = "other"
)

// The arrow-direction type represents the direction in which an arrow
// points, using Unicode arrow terminology.

type Arrow_direction string

const (
	Arrow_directionLeft Arrow_direction = "left"

	Arrow_directionUp Arrow_direction = "up"

	Arrow_directionRight Arrow_direction = "right"

	Arrow_directionDown Arrow_direction = "down"

	Arrow_directionNorthwest Arrow_direction = "northwest"

	Arrow_directionNortheast Arrow_direction = "northeast"

	Arrow_directionSoutheast Arrow_direction = "southeast"

	Arrow_directionSouthwest Arrow_direction = "southwest"

	Arrow_directionLeftright Arrow_direction = "left right"

	Arrow_directionUpdown Arrow_direction = "up down"

	Arrow_directionNorthwestsoutheast Arrow_direction = "northwest southeast"

	Arrow_directionNortheastsouthwest Arrow_direction = "northeast southwest"

	Arrow_directionOther Arrow_direction = "other"
)

// The arrow-style type represents the style of an arrow, using Unicode
// arrow terminology. Filled and hollow arrows indicate polygonal single arrows. Paired
// arrows are duplicate single arrows in the same direction. Combined arrows apply to
// double direction arrows like left right, indicating that an arrow in one direction
// should be combined with an arrow in the other direction.

type Arrow_style string

const (
	Arrow_styleSingle Arrow_style = "single"

	Arrow_styleDouble Arrow_style = "double"

	Arrow_styleFilled Arrow_style = "filled"

	Arrow_styleHollow Arrow_style = "hollow"

	Arrow_stylePaired Arrow_style = "paired"

	Arrow_styleCombined Arrow_style = "combined"

	Arrow_styleOther Arrow_style = "other"
)

// The beam-value type represents the type of beam associated with each
// of 8 beam levels (up to 1024th notes) available for each note.

type Beam_value string

const (
	Beam_valueBegin Beam_value = "begin"

	Beam_valueContinue_ Beam_value = "continue"

	Beam_valueEnd Beam_value = "end"

	Beam_valueForwardhook Beam_value = "forward hook"

	Beam_valueBackwardhook Beam_value = "backward hook"
)

// The bend-shape type distinguishes between the angled bend symbols
// commonly used in standard notation and the curved bend symbols commonly used in both
// tablature and standard notation.

type Bend_shape string

const (
	Bend_shapeAngled Bend_shape = "angled"

	Bend_shapeCurved Bend_shape = "curved"
)

// The breath-mark-value type represents the symbol used for a breath
// mark.

type Breath_mark_value string

const (
	Breath_mark_valueEmptyString Breath_mark_value = ""

	Breath_mark_valueComma Breath_mark_value = "comma"

	Breath_mark_valueTick Breath_mark_value = "tick"

	Breath_mark_valueUpbow Breath_mark_value = "upbow"

	Breath_mark_valueSalzedo Breath_mark_value = "salzedo"
)

// The caesura-value type represents the shape of the caesura sign.

type Caesura_value string

const (
	Caesura_valueNormal Caesura_value = "normal"

	Caesura_valueThick Caesura_value = "thick"

	Caesura_valueShort Caesura_value = "short"

	Caesura_valueCurved Caesura_value = "curved"

	Caesura_valueSingle Caesura_value = "single"

	Caesura_valueEmptyString Caesura_value = ""
)

// The circular-arrow type represents the direction in which a circular
// arrow points, using Unicode arrow terminology.

type Circular_arrow string

const (
	Circular_arrowClockwise Circular_arrow = "clockwise"

	Circular_arrowAnticlockwise Circular_arrow = "anticlockwise"
)

// The fan type represents the type of beam fanning present on a note,
// used to represent accelerandos and ritardandos.

type Fan string

const (
	FanAccel Fan = "accel"

	FanRit Fan = "rit"

	FanNone Fan = "none"
)

// The handbell-value type represents the type of handbell technique
// being notated.

type Handbell_value string

const (
	Handbell_valueBelltree Handbell_value = "belltree"

	Handbell_valueDamp Handbell_value = "damp"

	Handbell_valueEcho Handbell_value = "echo"

	Handbell_valueGyro Handbell_value = "gyro"

	Handbell_valueHandmartellato Handbell_value = "hand martellato"

	Handbell_valueMalletlift Handbell_value = "mallet lift"

	Handbell_valueMallettable Handbell_value = "mallet table"

	Handbell_valueMartellato Handbell_value = "martellato"

	Handbell_valueMartellatolift Handbell_value = "martellato lift"

	Handbell_valueMutedmartellato Handbell_value = "muted martellato"

	Handbell_valuePlucklift Handbell_value = "pluck lift"

	Handbell_valueSwing Handbell_value = "swing"
)

// The harmon-closed-location type indicates which portion of the symbol
// is filled in when the corresponding harmon-closed-value is half.

type Harmon_closed_location string

const (
	Harmon_closed_locationRight Harmon_closed_location = "right"

	Harmon_closed_locationBottom Harmon_closed_location = "bottom"

	Harmon_closed_locationLeft Harmon_closed_location = "left"

	Harmon_closed_locationTop Harmon_closed_location = "top"
)

// The harmon-closed-value type represents whether the harmon mute is
// closed, open, or half-open.

type Harmon_closed_value string

const (
	Harmon_closed_valueYes Harmon_closed_value = "yes"

	Harmon_closed_valueNo Harmon_closed_value = "no"

	Harmon_closed_valueHalf Harmon_closed_value = "half"
)

// The hole-closed-location type indicates which portion of the hole is
// filled in when the corresponding hole-closed-value is half.

type Hole_closed_location string

const (
	Hole_closed_locationRight Hole_closed_location = "right"

	Hole_closed_locationBottom Hole_closed_location = "bottom"

	Hole_closed_locationLeft Hole_closed_location = "left"

	Hole_closed_locationTop Hole_closed_location = "top"
)

// The hole-closed-value type represents whether the hole is closed,
// open, or half-open.

type Hole_closed_value string

const (
	Hole_closed_valueYes Hole_closed_value = "yes"

	Hole_closed_valueNo Hole_closed_value = "no"

	Hole_closed_valueHalf Hole_closed_value = "half"
)

// The note-type-value type is used for the MusicXML type element and
// represents the graphic note type, from 1024th (shortest) to maxima (longest).

type Note_type_value string

const (
	Note_type_value1024th Note_type_value = "1024th"

	Note_type_value512th Note_type_value = "512th"

	Note_type_value256th Note_type_value = "256th"

	Note_type_value128th Note_type_value = "128th"

	Note_type_value64th Note_type_value = "64th"

	Note_type_value32nd Note_type_value = "32nd"

	Note_type_value16th Note_type_value = "16th"

	Note_type_valueEighth Note_type_value = "eighth"

	Note_type_valueQuarter Note_type_value = "quarter"

	Note_type_valueHalf Note_type_value = "half"

	Note_type_valueWhole Note_type_value = "whole"

	Note_type_valueBreve Note_type_value = "breve"

	Note_type_valueLong Note_type_value = "long"

	Note_type_valueMaxima Note_type_value = "maxima"
)

// The notehead-value type indicates shapes other than the open and
// closed ovals associated with note durations. The values do, re, mi, fa, fa up, so,
// la, and ti correspond to Aikin's 7-shape system. The fa up shape is typically used
// with upstems; the fa shape is typically used with downstems or no stems. The arrow
// shapes differ from triangle and inverted triangle by being centered on the stem.
// Slashed and back slashed notes include both the normal notehead and a slash. The
// triangle shape has the tip of the triangle pointing up; the inverted triangle shape
// has the tip of the triangle pointing down. The left triangle shape is a right
// triangle with the hypotenuse facing up and to the left. The other notehead covers
// noteheads other than those listed here. It is usually used in combination with the
// smufl attribute to specify a particular SMuFL notehead. The smufl attribute may be
// used with any notehead value to help specify the appearance of symbols that share
// the same MusicXML semantics. Noteheads in the SMuFL Note name noteheads and Note
// name noteheads supplement ranges (U+E150U+E1AF and U+EEE0U+EEFF) should not use
// the smufl attribute or the "other" value, but instead use the notehead-text element.

type Notehead_value string

const (
	Notehead_valueSlash Notehead_value = "slash"

	Notehead_valueTriangle Notehead_value = "triangle"

	Notehead_valueDiamond Notehead_value = "diamond"

	Notehead_valueSquare Notehead_value = "square"

	Notehead_valueCross Notehead_value = "cross"

	Notehead_valueX Notehead_value = "x"

	Notehead_valueCircle_x Notehead_value = "circle-x"

	Notehead_valueInvertedtriangle Notehead_value = "inverted triangle"

	Notehead_valueArrowdown Notehead_value = "arrow down"

	Notehead_valueArrowup Notehead_value = "arrow up"

	Notehead_valueCircled Notehead_value = "circled"

	Notehead_valueSlashed Notehead_value = "slashed"

	Notehead_valueBackslashed Notehead_value = "back slashed"

	Notehead_valueNormal Notehead_value = "normal"

	Notehead_valueCluster Notehead_value = "cluster"

	Notehead_valueCircledot Notehead_value = "circle dot"

	Notehead_valueLefttriangle Notehead_value = "left triangle"

	Notehead_valueRectangle Notehead_value = "rectangle"

	Notehead_valueNone Notehead_value = "none"

	Notehead_valueDo Notehead_value = "do"

	Notehead_valueRe Notehead_value = "re"

	Notehead_valueMi Notehead_value = "mi"

	Notehead_valueFa Notehead_value = "fa"

	Notehead_valueFaup Notehead_value = "fa up"

	Notehead_valueSo Notehead_value = "so"

	Notehead_valueLa Notehead_value = "la"

	Notehead_valueTi Notehead_value = "ti"

	Notehead_valueOther Notehead_value = "other"
)

// Octaves are represented by the numbers 0 to 9, where 4 indicates the
// octave started by middle C.

type Octave int32

// The semitones type is a number representing semitones, used for
// chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a
// sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.

type Semitones float64

// The show-tuplet type indicates whether to show a part of a tuplet
// relating to the tuplet-actual element, both the tuplet-actual and tuplet-normal
// elements, or neither.

type Show_tuplet string

const (
	Show_tupletActual Show_tuplet = "actual"

	Show_tupletBoth Show_tuplet = "both"

	Show_tupletNone Show_tuplet = "none"
)

// The stem-value type represents the notated stem direction.

type Stem_value string

const (
	Stem_valueDown Stem_value = "down"

	Stem_valueUp Stem_value = "up"

	Stem_valueDouble Stem_value = "double"

	Stem_valueNone Stem_value = "none"
)

// The step type represents a step of the diatonic scale, represented
// using the English letters A through G.

type Step string

const (
	StepA Step = "A"

	StepB Step = "B"

	StepC Step = "C"

	StepD Step = "D"

	StepE Step = "E"

	StepF Step = "F"

	StepG Step = "G"
)

// Lyric hyphenation is indicated by the syllabic type. The single,
// begin, end, and middle values represent single-syllable words, word-beginning
// syllables, word-ending syllables, and mid-word syllables, respectively.

type Syllabic string

const (
	SyllabicSingle Syllabic = "single"

	SyllabicBegin Syllabic = "begin"

	SyllabicEnd Syllabic = "end"

	SyllabicMiddle Syllabic = "middle"
)

// The tap-hand type represents the symbol to use for a tap element. The
// left and right values refer to the SMuFL guitarLeftHandTapping and
// guitarRightHandTapping glyphs respectively.

type Tap_hand string

const (
	Tap_handLeft Tap_hand = "left"

	Tap_handRight Tap_hand = "right"
)

// The number of tremolo marks is represented by a number from 0 to 8:
// the same as beam-level with 0 added.

type Tremolo_marks int32

// The group-barline-value type indicates if the group should have common
// barlines.

type Group_barline_value string

const (
	Group_barline_valueYes Group_barline_value = "yes"

	Group_barline_valueNo Group_barline_value = "no"

	Group_barline_valueMensurstrich Group_barline_value = "Mensurstrich"
)

// The group-symbol-value type indicates how the symbol for a group or
// multi-staff part is indicated in the score.

type Group_symbol_value string

const (
	Group_symbol_valueNone Group_symbol_value = "none"

	Group_symbol_valueBrace Group_symbol_value = "brace"

	Group_symbol_valueLine Group_symbol_value = "line"

	Group_symbol_valueBracket Group_symbol_value = "bracket"

	Group_symbol_valueSquare Group_symbol_value = "square"
)

// The measure-text type is used for the text attribute of measure
// elements. It has at least one character. The implicit attribute of the measure
// element should be set to "yes" rather than setting the text attribute to an empty
// string.

type Measure_text string

// The swing-type-value type specifies the note type, either eighth or
// 16th, to which the ratio defined in the swing element is applied.

type Swing_type_value Note_type_value

const (
	Swing_type_value16th Swing_type_value = "16th"

	Swing_type_valueEighth Swing_type_value = "eighth"
)

type Score_partwise struct {
	XMLName xml.Name `xml:" score-partwise"`

	Part []struct {
		Measure []struct {
		} `xml:"measure,omitempty" json:"measure,omitempty"`
	} `xml:"part,omitempty" json:"part,omitempty"`
}

type Score_timewise struct {
	XMLName xml.Name `xml:" score-timewise"`

	Measure []struct {
		Part []struct {
		} `xml:"part,omitempty" json:"part,omitempty"`
	} `xml:"measure,omitempty" json:"measure,omitempty"`
}

type Accidental_text struct {
	Value *Accidental_value `xml:",chardata" json:"-,"`

	Smufl *Smufl_accidental_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Coda struct {
	Smufl *Smufl_coda_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Dynamics struct {
	P *Empty `xml:"p,omitempty" json:"p,omitempty"`

	Pp *Empty `xml:"pp,omitempty" json:"pp,omitempty"`

	Ppp *Empty `xml:"ppp,omitempty" json:"ppp,omitempty"`

	Pppp *Empty `xml:"pppp,omitempty" json:"pppp,omitempty"`

	Ppppp *Empty `xml:"ppppp,omitempty" json:"ppppp,omitempty"`

	Pppppp *Empty `xml:"pppppp,omitempty" json:"pppppp,omitempty"`

	F *Empty `xml:"f,omitempty" json:"f,omitempty"`

	Ff *Empty `xml:"ff,omitempty" json:"ff,omitempty"`

	Fff *Empty `xml:"fff,omitempty" json:"fff,omitempty"`

	Ffff *Empty `xml:"ffff,omitempty" json:"ffff,omitempty"`

	Fffff *Empty `xml:"fffff,omitempty" json:"fffff,omitempty"`

	Ffffff *Empty `xml:"ffffff,omitempty" json:"ffffff,omitempty"`

	Mp *Empty `xml:"mp,omitempty" json:"mp,omitempty"`

	Mf *Empty `xml:"mf,omitempty" json:"mf,omitempty"`

	Sf *Empty `xml:"sf,omitempty" json:"sf,omitempty"`

	Sfp *Empty `xml:"sfp,omitempty" json:"sfp,omitempty"`

	Sfpp *Empty `xml:"sfpp,omitempty" json:"sfpp,omitempty"`

	Fp *Empty `xml:"fp,omitempty" json:"fp,omitempty"`

	Rf *Empty `xml:"rf,omitempty" json:"rf,omitempty"`

	Rfz *Empty `xml:"rfz,omitempty" json:"rfz,omitempty"`

	Sfz *Empty `xml:"sfz,omitempty" json:"sfz,omitempty"`

	Sffz *Empty `xml:"sffz,omitempty" json:"sffz,omitempty"`

	Fz *Empty `xml:"fz,omitempty" json:"fz,omitempty"`

	N *Empty `xml:"n,omitempty" json:"n,omitempty"`

	Pf *Empty `xml:"pf,omitempty" json:"pf,omitempty"`

	Sfzp *Empty `xml:"sfzp,omitempty" json:"sfzp,omitempty"`

	Other_dynamics *Other_text `xml:"other-dynamics,omitempty" json:"other-dynamics,omitempty"`
}

type Empty struct {
}

type Empty_placement struct {
}

type Empty_placement_smufl struct {
}

type Empty_print_style struct {
}

type Empty_print_style_align struct {
}

type Empty_print_style_align_id struct {
}

type Empty_print_object_style_align struct {
}

type Empty_trill_sound struct {
}

type Horizontal_turn struct {
	Slash *Yes_no `xml:"slash,attr,omitempty" json:"slash,omitempty"`
}

type Fermata struct {
	Value *Fermata_shape `xml:",chardata" json:"-,"`

	Type *Upright_inverted `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Fingering struct {
	Value string `xml:",chardata" json:"-,"`

	Substitution *Yes_no `xml:"substitution,attr,omitempty" json:"substitution,omitempty"`

	Alternate *Yes_no `xml:"alternate,attr,omitempty" json:"alternate,omitempty"`
}

type Formatted_symbol struct {
	Value *Smufl_glyph_name `xml:",chardata" json:"-,"`
}

type Formatted_symbol_id struct {
	Value *Smufl_glyph_name `xml:",chardata" json:"-,"`
}

type Formatted_text string

type Formatted_text_id string

type Fret struct {
	Value uint32 `xml:",chardata" json:"-,"`
}

type Level struct {
	Value string `xml:",chardata" json:"-,"`

	Reference *Yes_no `xml:"reference,attr,omitempty" json:"reference,omitempty"`

	Type *Start_stop_single `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Midi_device struct {
	Value string `xml:",chardata" json:"-,"`

	Port *Midi_16 `xml:"port,attr,omitempty" json:"port,omitempty"`

	Id *IDREF `xml:"id,attr,omitempty" json:"id,omitempty"`
}

type Midi_instrument struct {

	// The midi-channel element specifies a MIDI 1.0 channel numbers
	// ranging from 1 to 16.
	Midi_channel *Midi_16 `xml:"midi-channel,omitempty" json:"midi-channel,omitempty"`

	// The midi-name element corresponds to a ProgramName meta-event
	// within a Standard MIDI File.
	Midi_name string `xml:"midi-name,omitempty" json:"midi-name,omitempty"`

	// The midi-bank element specifies a MIDI 1.0 bank number ranging
	// from 1 to 16,384.
	Midi_bank *Midi_16384 `xml:"midi-bank,omitempty" json:"midi-bank,omitempty"`

	// The midi-program element specifies a MIDI 1.0 program number
	// ranging from 1 to 128.
	Midi_program *Midi_128 `xml:"midi-program,omitempty" json:"midi-program,omitempty"`

	// For unpitched instruments, the midi-unpitched element
	// specifies a MIDI 1.0 note number ranging from 1 to 128. It is usually used
	// with MIDI banks for percussion. Note that MIDI 1.0 note numbers are
	// generally specified from 0 to 127 rather than the 1 to 128 numbering used in
	// this element.
	Midi_unpitched *Midi_128 `xml:"midi-unpitched,omitempty" json:"midi-unpitched,omitempty"`

	// The volume element value is a percentage of the maximum
	// ranging from 0 to 100, with decimal values allowed. This corresponds to a
	// scaling value for the MIDI 1.0 channel volume controller.
	Volume *Percent `xml:"volume,omitempty" json:"volume,omitempty"`

	// The pan and elevation elements allow placing of sound in a 3-D
	// space relative to the listener. Both are expressed in degrees ranging from
	// -180 to 180. For pan, 0 is straight ahead, -90 is hard left, 90 is hard
	// right, and -180 and 180 are directly behind the listener.
	Pan *Rotation_degrees `xml:"pan,omitempty" json:"pan,omitempty"`

	// The elevation and pan elements allow placing of sound in a 3-D
	// space relative to the listener. Both are expressed in degrees ranging from
	// -180 to 180. For elevation, 0 is level with the listener, 90 is directly
	// above, and -90 is directly below.
	Elevation *Rotation_degrees `xml:"elevation,omitempty" json:"elevation,omitempty"`

	Id *IDREF `xml:"id,attr,omitempty" json:"id,omitempty"`
}

type Name_display struct {
	Display_text *Formatted_text `xml:"display-text,omitempty" json:"display-text,omitempty"`

	Accidental_text *Accidental_text `xml:"accidental-text,omitempty" json:"accidental-text,omitempty"`
}

type Other_play struct {
	Value string `xml:",chardata" json:"-,"`

	Type string `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Play struct {

	// The ipa element represents International Phonetic Alphabet
	// (IPA) sounds for vocal music. String content is limited to IPA 2015
	// symbols represented in Unicode 13.0.
	Ipa string `xml:"ipa,omitempty" json:"ipa,omitempty"`

	Mute *Mute `xml:"mute,omitempty" json:"mute,omitempty"`

	Semi_pitched *Semi_pitched `xml:"semi-pitched,omitempty" json:"semi-pitched,omitempty"`

	Other_play *Other_play `xml:"other-play,omitempty" json:"other-play,omitempty"`

	Id *IDREF `xml:"id,attr,omitempty" json:"id,omitempty"`
}

type Segno struct {
	Smufl *Smufl_segno_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

// type string struct {
// 	Value *String_number `xml:",chardata" json:"-,"`
// }

type Typed_text struct {
	Value string `xml:",chardata" json:"-,"`

	Type string `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Wavy_line struct {
	Type *Start_stop_continue `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`

	Smufl *Smufl_wavy_line_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Attributes struct {

	// Musical notation duration is commonly represented as
	// fractions. The divisions element indicates how many divisions per quarter
	// note are used to indicate a note's duration. For example, if duration = 1
	// and divisions = 2, this is an eighth note duration. Duration and divisions
	// are used directly for generating sound output, so they must be chosen to
	// take tuplets into account. Using a divisions element lets us use just one
	// number to represent a duration for each note in the score, while retaining
	// the full power of a fractional representation. If maximum compatibility with
	// Standard MIDI 1.0 files is important, do not have the divisions value exceed
	// 16383.
	Divisions *Positive_divisions `xml:"divisions,omitempty" json:"divisions,omitempty"`

	// The key element represents a key signature. Both traditional
	// and non-traditional key signatures are supported. The optional number
	// attribute refers to staff numbers. If absent, the key signature applies to
	// all staves in the part.
	Key []*Key `xml:"key,omitempty" json:"key,omitempty"`

	// Time signatures are represented by the beats element for the
	// numerator and the beat-type element for the denominator.
	// Time []soap.XSDTime `xml:"time,omitempty" json:"time,omitempty"`

	// The staves element is used if there is more than one staff
	// represented in the given part (e.g., 2 staves for typical piano parts). If
	// absent, a value of 1 is assumed. Staves are ordered from top to bottom in a
	// part in numerical order, with staff 1 above staff 2.
	Staves uint32 `xml:"staves,omitempty" json:"staves,omitempty"`

	// The part-symbol element indicates how a symbol for a
	// multi-staff part is indicated in the score.
	Part_symbol *Part_symbol `xml:"part-symbol,omitempty" json:"part-symbol,omitempty"`

	// The instruments element is only used if more than one
	// instrument is represented in the part (e.g., oboe I and II where they play
	// together most of the time). If absent, a value of 1 is assumed.
	Instruments uint32 `xml:"instruments,omitempty" json:"instruments,omitempty"`

	// Clefs are represented by a combination of sign, line, and
	// clef-octave-change elements.
	Clef []*Clef `xml:"clef,omitempty" json:"clef,omitempty"`

	// The staff-details element is used to indicate different types
	// of staves.
	Staff_details []*Staff_details `xml:"staff-details,omitempty" json:"staff-details,omitempty"`

	Directive []struct {
		Value string `xml:",chardata" json:"-,"`

		EmptyString string `xml:",attr,omitempty" json:",omitempty"`
	} `xml:"directive,omitempty" json:"directive,omitempty"`

	// A measure-style indicates a special way to print partial to
	// multiple measures within a part. This includes multiple rests over several
	// measures, repeats of beats, single, or multiple measures, and use of slash
	// notation.
	Measure_style []*Measure_style `xml:"measure-style,omitempty" json:"measure-style,omitempty"`

	// If the part is being encoded for a transposing instrument
	// in written vs. concert pitch, the transposition must be encoded in the
	// transpose element using the transpose type.
	Transpose []*Transpose `xml:"transpose,omitempty" json:"transpose,omitempty"`

	// The for-part element is used in a concert score to
	// indicate the transposition for a transposed part created from that
	// score. It is only used in score files that contain a concert-score
	// element in the defaults. This allows concert scores with transposed
	// parts to be represented in a single uncompressed MusicXML file.
	For_part []*For_part `xml:"for-part,omitempty" json:"for-part,omitempty"`
}

type Beat_repeat struct {
	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`

	Slashes *PositiveInteger `xml:"slashes,attr,omitempty" json:"slashes,omitempty"`

	Use_dots *Yes_no `xml:"use-dots,attr,omitempty" json:"use-dots,omitempty"`
}

type Cancel struct {
	Value *Fifths `xml:",chardata" json:"-,"`

	Location *Cancel_location `xml:"location,attr,omitempty" json:"location,omitempty"`
}

type Clef struct {
	Number *Staff_number `xml:"number,attr,omitempty" json:"number,omitempty"`

	Additional *Yes_no `xml:"additional,attr,omitempty" json:"additional,omitempty"`

	Size *Symbol_size `xml:"size,attr,omitempty" json:"size,omitempty"`

	After_barline *Yes_no `xml:"after-barline,attr,omitempty" json:"after-barline,omitempty"`
}

type Double struct {
	Above *Yes_no `xml:"above,attr,omitempty" json:"above,omitempty"`
}

type For_part struct {

	// The part-clef element is used for transpositions that also
	// include a change of clef, as for instruments such as bass clarinet.
	Part_clef *Part_clef `xml:"part-clef,omitempty" json:"part-clef,omitempty"`

	// The chromatic element in a part-transpose element will usually
	// have a non-zero value, since octave transpositions can be represented in
	// concert scores using the transpose element.
	Part_transpose *Part_transpose `xml:"part-transpose,omitempty" json:"part-transpose,omitempty"`

	Number *Staff_number `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Interchangeable struct {
	Time_relation *Time_relation `xml:"time-relation,omitempty" json:"time-relation,omitempty"`

	Symbol *Time_symbol `xml:"symbol,attr,omitempty" json:"symbol,omitempty"`

	Separator *Time_separator `xml:"separator,attr,omitempty" json:"separator,omitempty"`
}

type Key struct {

	// The optional list of key-octave elements is used to specify in
	// which octave each element of the key signature appears.
	Key_octave []*Key_octave `xml:"key-octave,omitempty" json:"key-octave,omitempty"`

	Number *Staff_number `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Key_accidental struct {
	Value *Accidental_value `xml:",chardata" json:"-,"`

	Smufl *Smufl_accidental_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Key_octave struct {
	Value *Octave `xml:",chardata" json:"-,"`

	Number *PositiveInteger `xml:"number,attr,omitempty" json:"number,omitempty"`

	Cancel *Yes_no `xml:"cancel,attr,omitempty" json:"cancel,omitempty"`
}

type Line_detail struct {
	Line *Staff_line `xml:"line,attr,omitempty" json:"line,omitempty"`

	Width *Tenths `xml:"width,attr,omitempty" json:"width,omitempty"`
}

type Measure_repeat struct {
	Value *Positive_integer_or_empty `xml:",chardata" json:"-,"`

	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`

	Slashes *PositiveInteger `xml:"slashes,attr,omitempty" json:"slashes,omitempty"`
}

type Measure_style struct {
	Multiple_rest *Multiple_rest `xml:"multiple-rest,omitempty" json:"multiple-rest,omitempty"`

	Measure_repeat *Measure_repeat `xml:"measure-repeat,omitempty" json:"measure-repeat,omitempty"`

	Beat_repeat *Beat_repeat `xml:"beat-repeat,omitempty" json:"beat-repeat,omitempty"`

	Slash *Slash `xml:"slash,omitempty" json:"slash,omitempty"`

	Number *Staff_number `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Multiple_rest struct {
	Value *PositiveInteger `xml:",chardata" json:"-,"`

	Use_symbols *Yes_no `xml:"use-symbols,attr,omitempty" json:"use-symbols,omitempty"`
}

type Part_clef struct {
}

type Part_symbol struct {
	Value *Group_symbol_value `xml:",chardata" json:"-,"`

	Top_staff *Staff_number `xml:"top-staff,attr,omitempty" json:"top-staff,omitempty"`

	Bottom_staff *Staff_number `xml:"bottom-staff,attr,omitempty" json:"bottom-staff,omitempty"`
}

type Part_transpose struct {
}

type Slash struct {
	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`

	Use_dots *Yes_no `xml:"use-dots,attr,omitempty" json:"use-dots,omitempty"`

	Use_stems *Yes_no `xml:"use-stems,attr,omitempty" json:"use-stems,omitempty"`
}

type Staff_details struct {
	Staff_type *Staff_type `xml:"staff-type,omitempty" json:"staff-type,omitempty"`

	Staff_tuning []*Staff_tuning `xml:"staff-tuning,omitempty" json:"staff-tuning,omitempty"`

	// The capo element indicates at which fret a capo should be
	// placed on a fretted instrument. This changes the open tuning of the strings
	// specified by staff-tuning by the specified number of half-steps.
	Capo uint32 `xml:"capo,omitempty" json:"capo,omitempty"`

	Staff_size *Staff_size `xml:"staff-size,omitempty" json:"staff-size,omitempty"`

	Number *Staff_number `xml:"number,attr,omitempty" json:"number,omitempty"`

	Show_frets *Show_frets `xml:"show-frets,attr,omitempty" json:"show-frets,omitempty"`
}

type Staff_size struct {
	Value *Non_negative_decimal `xml:",chardata" json:"-,"`

	Scaling *Non_negative_decimal `xml:"scaling,attr,omitempty" json:"scaling,omitempty"`
}

type Staff_tuning struct {
	Line *Staff_line `xml:"line,attr,omitempty" json:"line,omitempty"`
}

type Time struct {

	// A senza-misura element explicitly indicates that no time
	// signature is present. The optional element content indicates the symbol to
	// be used, if any, such as an X. The time element's symbol attribute is not
	// used when a senza-misura element is present.
	Senza_misura string `xml:"senza-misura,omitempty" json:"senza-misura,omitempty"`

	Number *Staff_number `xml:"number,attr,omitempty" json:"number,omitempty"`

	Symbol *Time_symbol `xml:"symbol,attr,omitempty" json:"symbol,omitempty"`

	Separator *Time_separator `xml:"separator,attr,omitempty" json:"separator,omitempty"`
}

type Transpose struct {
	Number *Staff_number `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Bar_style_color struct {
	XMLName xml.Name `xml:" bar-style"`

	Value *Bar_style `xml:",chardata" json:"-,"`
}

type Barline struct {
	Bar_style *Bar_style_color `xml:"bar-style,omitempty" json:"bar-style,omitempty"`

	Wavy_line *Wavy_line `xml:"wavy-line,omitempty" json:"wavy-line,omitempty"`

	// Segno *Segno `xml:"segno,omitempty" json:"segno,omitempty"`

	// Coda *Coda `xml:"coda,omitempty" json:"coda,omitempty"`

	Fermata *Fermata `xml:"fermata,omitempty" json:"fermata,omitempty"`

	Ending *Ending `xml:"ending,omitempty" json:"ending,omitempty"`

	Repeat *Repeat `xml:"repeat,omitempty" json:"repeat,omitempty"`

	Location *Right_left_middle `xml:"location,attr,omitempty" json:"location,omitempty"`

	Segno string `xml:"segno,attr,omitempty" json:"segno,omitempty"`

	Coda string `xml:"coda,attr,omitempty" json:"coda,omitempty"`

	Divisions *Divisions `xml:"divisions,attr,omitempty" json:"divisions,omitempty"`
}

type Ending struct {
	Value string `xml:",chardata" json:"-,"`

	Number *Ending_number `xml:"number,attr,omitempty" json:"number,omitempty"`

	Type *Start_stop_discontinue `xml:"type,attr,omitempty" json:"type,omitempty"`

	End_length *Tenths `xml:"end-length,attr,omitempty" json:"end-length,omitempty"`

	Text_x *Tenths `xml:"text-x,attr,omitempty" json:"text-x,omitempty"`

	Text_y *Tenths `xml:"text-y,attr,omitempty" json:"text-y,omitempty"`
}

type Repeat struct {
	Direction *Backward_forward `xml:"direction,attr,omitempty" json:"direction,omitempty"`

	Times uint32 `xml:"times,attr,omitempty" json:"times,omitempty"`

	After_jump *Yes_no `xml:"after-jump,attr,omitempty" json:"after-jump,omitempty"`

	Winged *Winged `xml:"winged,attr,omitempty" json:"winged,omitempty"`
}

type Accord struct {
	string *String_number `xml:"string,attr,omitempty" json:"string,omitempty"`
}

type Accordion_registration struct {

	// The accordion-high element indicates the presence of a dot in
	// the high (4') section of the registration symbol. This element is omitted if
	// no dot is present.
	Accordion_high *Empty `xml:"accordion-high,omitempty" json:"accordion-high,omitempty"`

	// The accordion-middle element indicates the presence of 1 to 3
	// dots in the middle (8') section of the registration symbol. This element is
	// omitted if no dots are present.
	Accordion_middle *Accordion_middle `xml:"accordion-middle,omitempty" json:"accordion-middle,omitempty"`

	// The accordion-low element indicates the presence of a dot in
	// the low (16') section of the registration symbol. This element is omitted if
	// no dot is present.
	Accordion_low *Empty `xml:"accordion-low,omitempty" json:"accordion-low,omitempty"`
}

type Barre struct {
	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Bass struct {

	// The optional bass-separator element indicates that text,
	// rather than a line or slash, separates the bass from what precedes it.
	Bass_separator *Style_text `xml:"bass-separator,omitempty" json:"bass-separator,omitempty"`

	Bass_step *Bass_step `xml:"bass-step,omitempty" json:"bass-step,omitempty"`

	// The bass-alter element represents the chromatic alteration of
	// the bass of the current chord within the harmony element. In some chord
	// styles, the text for the bass-step element may include bass-alter
	// information. In that case, the print-object attribute of the bass-alter
	// element can be set to no. The location attribute indicates whether the
	// alteration should appear to the left or the right of the bass-step; it is
	// right if not specified.
	Bass_alter *Harmony_alter `xml:"bass-alter,omitempty" json:"bass-alter,omitempty"`

	Arrangement *Harmony_arrangement `xml:"arrangement,attr,omitempty" json:"arrangement,omitempty"`
}

type Harmony_alter struct {
	Value *Semitones `xml:",chardata" json:"-,"`

	Location *Left_right `xml:"location,attr,omitempty" json:"location,omitempty"`
}

type Bass_step struct {
	Value *Step `xml:",chardata" json:"-,"`

	Text string `xml:"text,attr,omitempty" json:"text,omitempty"`
}

type Beater struct {
	Value *Beater_value `xml:",chardata" json:"-,"`

	Tip *Tip_direction `xml:"tip,attr,omitempty" json:"tip,omitempty"`
}

type Beat_unit_tied struct {
}

type Bracket struct {
	Type *Start_stop_continue `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`

	Line_end *Line_end `xml:"line-end,attr,omitempty" json:"line-end,omitempty"`

	End_length *Tenths `xml:"end-length,attr,omitempty" json:"end-length,omitempty"`
}

type Dashes struct {
	Type *Start_stop_continue `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Degree struct {
	Degree_value *Degree_value `xml:"degree-value,omitempty" json:"degree-value,omitempty"`

	Degree_alter *Degree_alter `xml:"degree-alter,omitempty" json:"degree-alter,omitempty"`

	Degree_type *Degree_type `xml:"degree-type,omitempty" json:"degree-type,omitempty"`
}

type Degree_alter struct {
	Value *Semitones `xml:",chardata" json:"-,"`

	Plus_minus *Yes_no `xml:"plus-minus,attr,omitempty" json:"plus-minus,omitempty"`
}

type Degree_type struct {
	Value *Degree_type_value `xml:",chardata" json:"-,"`

	Text string `xml:"text,attr,omitempty" json:"text,omitempty"`
}

type Degree_value struct {
	Value *PositiveInteger `xml:",chardata" json:"-,"`

	Symbol *Degree_symbol_value `xml:"symbol,attr,omitempty" json:"symbol,omitempty"`

	Text string `xml:"text,attr,omitempty" json:"text,omitempty"`
}

type Direction struct {
	Direction_type []*Direction_type `xml:"direction-type,omitempty" json:"direction-type,omitempty"`

	Offset *Offset `xml:"offset,omitempty" json:"offset,omitempty"`

	Sound *Sound `xml:"sound,omitempty" json:"sound,omitempty"`

	Listening *Listening `xml:"listening,omitempty" json:"listening,omitempty"`
}

type Direction_type struct {

	// The rehearsal element specifies letters, numbers, and section
	// names that are notated in the score for reference during rehearsal. The
	// enclosure is square if not specified. The language is Italian ("it") if not
	// specified. Left justification is used if not specified.
	Rehearsal []*Formatted_text_id `xml:"rehearsal,omitempty" json:"rehearsal,omitempty"`

	Segno []*Segno `xml:"segno,omitempty" json:"segno,omitempty"`

	Coda []*Coda `xml:"coda,omitempty" json:"coda,omitempty"`

	Wedge *Wedge `xml:"wedge,omitempty" json:"wedge,omitempty"`

	Dynamics []*Dynamics `xml:"dynamics,omitempty" json:"dynamics,omitempty"`

	Dashes *Dashes `xml:"dashes,omitempty" json:"dashes,omitempty"`

	Bracket *Bracket `xml:"bracket,omitempty" json:"bracket,omitempty"`

	Pedal *Pedal `xml:"pedal,omitempty" json:"pedal,omitempty"`

	Metronome *Metronome `xml:"metronome,omitempty" json:"metronome,omitempty"`

	Octave_shift *Octave_shift `xml:"octave-shift,omitempty" json:"octave-shift,omitempty"`

	Harp_pedals *Harp_pedals `xml:"harp-pedals,omitempty" json:"harp-pedals,omitempty"`

	// The damp element specifies a harp damping mark.
	Damp *Empty_print_style_align_id `xml:"damp,omitempty" json:"damp,omitempty"`

	// The damp-all element specifies a harp damping mark for all
	// strings.
	Damp_all *Empty_print_style_align_id `xml:"damp-all,omitempty" json:"damp-all,omitempty"`

	// The eyeglasses element represents the eyeglasses symbol,
	// common in commercial music.
	Eyeglasses *Empty_print_style_align_id `xml:"eyeglasses,omitempty" json:"eyeglasses,omitempty"`

	String_mute *String_mute `xml:"string-mute,omitempty" json:"string-mute,omitempty"`

	Scordatura *Scordatura `xml:"scordatura,omitempty" json:"scordatura,omitempty"`

	Image *Image `xml:"image,omitempty" json:"image,omitempty"`

	Principal_voice *Principal_voice `xml:"principal-voice,omitempty" json:"principal-voice,omitempty"`

	Percussion []*Percussion `xml:"percussion,omitempty" json:"percussion,omitempty"`

	Accordion_registration *Accordion_registration `xml:"accordion-registration,omitempty" json:"accordion-registration,omitempty"`

	Staff_divide *Staff_divide `xml:"staff-divide,omitempty" json:"staff-divide,omitempty"`

	Other_direction *Other_direction `xml:"other-direction,omitempty" json:"other-direction,omitempty"`
}

type Effect struct {
	Value *Effect_value `xml:",chardata" json:"-,"`

	Smufl *Smufl_pictogram_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Feature struct {
	Value string `xml:",chardata" json:"-,"`

	Type string `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type First_fret struct {
	Value *PositiveInteger `xml:",chardata" json:"-,"`

	Text string `xml:"text,attr,omitempty" json:"text,omitempty"`

	Location *Left_right `xml:"location,attr,omitempty" json:"location,omitempty"`
}

type Frame struct {

	// The frame-strings element gives the overall size of the frame
	// in vertical lines (strings).
	Frame_strings *PositiveInteger `xml:"frame-strings,omitempty" json:"frame-strings,omitempty"`

	// The frame-frets element gives the overall size of the frame in
	// horizontal spaces (frets).
	Frame_frets *PositiveInteger `xml:"frame-frets,omitempty" json:"frame-frets,omitempty"`

	First_fret *First_fret `xml:"first-fret,omitempty" json:"first-fret,omitempty"`

	Frame_note []*Frame_note `xml:"frame-note,omitempty" json:"frame-note,omitempty"`

	Height *Tenths `xml:"height,attr,omitempty" json:"height,omitempty"`

	Width *Tenths `xml:"width,attr,omitempty" json:"width,omitempty"`

	Unplayed string `xml:"unplayed,attr,omitempty" json:"unplayed,omitempty"`
}

type Frame_note struct {
	Astring string `xml:"string,omitempty" json:"string,omitempty"`

	Fret *Fret `xml:"fret,omitempty" json:"fret,omitempty"`

	Fingering *Fingering `xml:"fingering,omitempty" json:"fingering,omitempty"`

	Barre *Barre `xml:"barre,omitempty" json:"barre,omitempty"`
}

type Glass struct {
	Value *Glass_value `xml:",chardata" json:"-,"`

	Smufl *Smufl_pictogram_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Grouping struct {
	Feature []*Feature `xml:"feature,omitempty" json:"feature,omitempty"`

	Type *Start_stop_single `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number string `xml:"number,attr,omitempty" json:"number,omitempty"`

	Member_of string `xml:"member-of,attr,omitempty" json:"member-of,omitempty"`
}

type Harmony struct {
	Frame *Frame `xml:"frame,omitempty" json:"frame,omitempty"`

	Offset *Offset `xml:"offset,omitempty" json:"offset,omitempty"`

	Type *Harmony_type `xml:"type,attr,omitempty" json:"type,omitempty"`

	Print_frame *Yes_no `xml:"print-frame,attr,omitempty" json:"print-frame,omitempty"`

	Arrangement *Harmony_arrangement `xml:"arrangement,attr,omitempty" json:"arrangement,omitempty"`
}

type Harp_pedals struct {
	Pedal_tuning []*Pedal_tuning `xml:"pedal-tuning,omitempty" json:"pedal-tuning,omitempty"`
}

type Image struct {
}

type Instrument_change struct {
	Id *IDREF `xml:"id,attr,omitempty" json:"id,omitempty"`
}

type Inversion struct {
	Value uint32 `xml:",chardata" json:"-,"`

	Text string `xml:"text,attr,omitempty" json:"text,omitempty"`
}

type Kind struct {
	Value *Kind_value `xml:",chardata" json:"-,"`

	Use_symbols *Yes_no `xml:"use-symbols,attr,omitempty" json:"use-symbols,omitempty"`

	Text string `xml:"text,attr,omitempty" json:"text,omitempty"`

	Stack_degrees *Yes_no `xml:"stack-degrees,attr,omitempty" json:"stack-degrees,omitempty"`

	Parentheses_degrees *Yes_no `xml:"parentheses-degrees,attr,omitempty" json:"parentheses-degrees,omitempty"`

	Bracket_degrees *Yes_no `xml:"bracket-degrees,attr,omitempty" json:"bracket-degrees,omitempty"`
}

type Listening struct {
	Offset *Offset `xml:"offset,omitempty" json:"offset,omitempty"`

	Sync *Sync `xml:"sync,omitempty" json:"sync,omitempty"`

	Other_listening *Other_listening `xml:"other-listening,omitempty" json:"other-listening,omitempty"`
}

type Measure_numbering struct {
	Value *Measure_numbering_value `xml:",chardata" json:"-,"`

	System *System_relation_number `xml:"system,attr,omitempty" json:"system,omitempty"`

	Staff *Staff_number `xml:"staff,attr,omitempty" json:"staff,omitempty"`

	Multiple_rest_always *Yes_no `xml:"multiple-rest-always,attr,omitempty" json:"multiple-rest-always,omitempty"`

	Multiple_rest_range *Yes_no `xml:"multiple-rest-range,attr,omitempty" json:"multiple-rest-range,omitempty"`
}

type Membrane struct {
	Value *Membrane_value `xml:",chardata" json:"-,"`

	Smufl *Smufl_pictogram_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Metal struct {
	Value *Metal_value `xml:",chardata" json:"-,"`

	Smufl *Smufl_pictogram_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Metronome struct {
	Parentheses *Yes_no `xml:"parentheses,attr,omitempty" json:"parentheses,omitempty"`
}

type Metronome_beam struct {
	Value *Beam_value `xml:",chardata" json:"-,"`

	Number *Beam_level `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Metronome_note struct {

	// The metronome-type element works like the type element in
	// defining metric relationships.
	Metronome_type *Note_type_value `xml:"metronome-type,omitempty" json:"metronome-type,omitempty"`

	// The metronome-dot element works like the dot element in
	// defining metric relationships.
	Metronome_dot []*Empty `xml:"metronome-dot,omitempty" json:"metronome-dot,omitempty"`

	Metronome_beam []*Metronome_beam `xml:"metronome-beam,omitempty" json:"metronome-beam,omitempty"`

	Metronome_tied *Metronome_tied `xml:"metronome-tied,omitempty" json:"metronome-tied,omitempty"`

	Metronome_tuplet *Metronome_tuplet `xml:"metronome-tuplet,omitempty" json:"metronome-tuplet,omitempty"`
}

type Metronome_tied struct {
	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Metronome_tuplet struct {
	*Time_modification

	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`

	Bracket *Yes_no `xml:"bracket,attr,omitempty" json:"bracket,omitempty"`

	Show_number *Show_tuplet `xml:"show-number,attr,omitempty" json:"show-number,omitempty"`
}

type Numeral struct {
	Numeral_root *Numeral_root `xml:"numeral-root,omitempty" json:"numeral-root,omitempty"`

	// The numeral-alter element represents an alteration to the
	// numeral-root, similar to the alter element for a pitch. The print-object
	// attribute can be used to hide an alteration in cases such as when the
	// MusicXML encoding of a 6 or 7 numeral-root in a minor key requires an
	// alteration that is not displayed. The location attribute indicates whether
	// the alteration should appear to the left or the right of the numeral-root.
	// It is left by default.
	Numeral_alter *Harmony_alter `xml:"numeral-alter,omitempty" json:"numeral-alter,omitempty"`

	Numeral_key *Numeral_key `xml:"numeral-key,omitempty" json:"numeral-key,omitempty"`
}

type Numeral_key struct {
	Numeral_fifths *Fifths `xml:"numeral-fifths,omitempty" json:"numeral-fifths,omitempty"`

	Numeral_mode *Numeral_mode `xml:"numeral-mode,omitempty" json:"numeral-mode,omitempty"`
}

type Numeral_root struct {
	Value *Numeral_value `xml:",chardata" json:"-,"`

	Text string `xml:"text,attr,omitempty" json:"text,omitempty"`
}

type Octave_shift struct {
	Type *Up_down_stop_continue `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`

	Size *PositiveInteger `xml:"size,attr,omitempty" json:"size,omitempty"`
}

type Offset struct {
	Value *Divisions `xml:",chardata" json:"-,"`

	Sound *Yes_no `xml:"sound,attr,omitempty" json:"sound,omitempty"`
}

type Other_direction string

type Other_listening struct {
	Value string `xml:",chardata" json:"-,"`

	Type string `xml:"type,attr,omitempty" json:"type,omitempty"`

	Player *IDREF `xml:"player,attr,omitempty" json:"player,omitempty"`

	Time_only *Time_only `xml:"time-only,attr,omitempty" json:"time-only,omitempty"`
}

type Pedal struct {
	Type *Pedal_type `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`

	Line *Yes_no `xml:"line,attr,omitempty" json:"line,omitempty"`

	Sign *Yes_no `xml:"sign,attr,omitempty" json:"sign,omitempty"`

	Abbreviated *Yes_no `xml:"abbreviated,attr,omitempty" json:"abbreviated,omitempty"`
}

type Pedal_tuning struct {

	// The pedal-step element defines the pitch step for a single
	// harp pedal.
	Pedal_step *Step `xml:"pedal-step,omitempty" json:"pedal-step,omitempty"`

	// The pedal-alter element defines the chromatic alteration for a
	// single harp pedal.
	Pedal_alter *Semitones `xml:"pedal-alter,omitempty" json:"pedal-alter,omitempty"`
}

type Per_minute string

type Percussion struct {
	Glass *Glass `xml:"glass,omitempty" json:"glass,omitempty"`

	Metal *Metal `xml:"metal,omitempty" json:"metal,omitempty"`

	Wood *Wood `xml:"wood,omitempty" json:"wood,omitempty"`

	Pitched *Pitched `xml:"pitched,omitempty" json:"pitched,omitempty"`

	Membrane *Membrane `xml:"membrane,omitempty" json:"membrane,omitempty"`

	Effect *Effect `xml:"effect,omitempty" json:"effect,omitempty"`

	Timpani *Timpani `xml:"timpani,omitempty" json:"timpani,omitempty"`

	Beater *Beater `xml:"beater,omitempty" json:"beater,omitempty"`

	Stick *Stick `xml:"stick,omitempty" json:"stick,omitempty"`

	Stick_location *Stick_location `xml:"stick-location,omitempty" json:"stick-location,omitempty"`

	// The other-percussion element represents percussion pictograms
	// not defined elsewhere.
	Other_percussion *Other_text `xml:"other-percussion,omitempty" json:"other-percussion,omitempty"`
}

type Pitched struct {
	Value *Pitched_value `xml:",chardata" json:"-,"`

	Smufl *Smufl_pictogram_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Principal_voice struct {
	Value string `xml:",chardata" json:"-,"`

	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`

	Symbol *Principal_voice_symbol `xml:"symbol,attr,omitempty" json:"symbol,omitempty"`
}

type Print struct {
	Measure_layout *Measure_layout `xml:"measure-layout,omitempty" json:"measure-layout,omitempty"`

	Measure_numbering *Measure_numbering `xml:"measure-numbering,omitempty" json:"measure-numbering,omitempty"`

	Part_name_display *Name_display `xml:"part-name-display,omitempty" json:"part-name-display,omitempty"`

	Part_abbreviation_display *Name_display `xml:"part-abbreviation-display,omitempty" json:"part-abbreviation-display,omitempty"`
}

type Root struct {
	Root_step *Root_step `xml:"root-step,omitempty" json:"root-step,omitempty"`

	// The root-alter element represents the chromatic alteration of
	// the root of the current chord within the harmony element. In some chord
	// styles, the text for the root-step element may include root-alter
	// information. In that case, the print-object attribute of the root-alter
	// element can be set to no. The location attribute indicates whether the
	// alteration should appear to the left or the right of the root-step; it is
	// right by default.
	Root_alter *Harmony_alter `xml:"root-alter,omitempty" json:"root-alter,omitempty"`
}

type Root_step struct {
	Value *Step `xml:",chardata" json:"-,"`

	Text string `xml:"text,attr,omitempty" json:"text,omitempty"`
}

type Scordatura struct {
	Accord []*Accord `xml:"accord,omitempty" json:"accord,omitempty"`
}

type Sound struct {
	Swing *Swing `xml:"swing,omitempty" json:"swing,omitempty"`

	Offset *Offset `xml:"offset,omitempty" json:"offset,omitempty"`

	Tempo *Non_negative_decimal `xml:"tempo,attr,omitempty" json:"tempo,omitempty"`

	Dynamics *Non_negative_decimal `xml:"dynamics,attr,omitempty" json:"dynamics,omitempty"`

	Dacapo *Yes_no `xml:"dacapo,attr,omitempty" json:"dacapo,omitempty"`

	Segno string `xml:"segno,attr,omitempty" json:"segno,omitempty"`

	Dalsegno string `xml:"dalsegno,attr,omitempty" json:"dalsegno,omitempty"`

	Coda string `xml:"coda,attr,omitempty" json:"coda,omitempty"`

	Tocoda string `xml:"tocoda,attr,omitempty" json:"tocoda,omitempty"`

	Divisions *Divisions `xml:"divisions,attr,omitempty" json:"divisions,omitempty"`

	Forward_repeat *Yes_no `xml:"forward-repeat,attr,omitempty" json:"forward-repeat,omitempty"`

	Fine string `xml:"fine,attr,omitempty" json:"fine,omitempty"`

	Time_only *Time_only `xml:"time-only,attr,omitempty" json:"time-only,omitempty"`

	Pizzicato *Yes_no `xml:"pizzicato,attr,omitempty" json:"pizzicato,omitempty"`

	Pan *Rotation_degrees `xml:"pan,attr,omitempty" json:"pan,omitempty"`

	Elevation *Rotation_degrees `xml:"elevation,attr,omitempty" json:"elevation,omitempty"`

	Damper_pedal *Yes_no_number `xml:"damper-pedal,attr,omitempty" json:"damper-pedal,omitempty"`

	Soft_pedal *Yes_no_number `xml:"soft-pedal,attr,omitempty" json:"soft-pedal,omitempty"`

	Sostenuto_pedal *Yes_no_number `xml:"sostenuto-pedal,attr,omitempty" json:"sostenuto-pedal,omitempty"`
}

type Staff_divide struct {
	Type *Staff_divide_symbol `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Stick struct {
	Stick_type *Stick_type `xml:"stick-type,omitempty" json:"stick-type,omitempty"`

	Stick_material *Stick_material `xml:"stick-material,omitempty" json:"stick-material,omitempty"`

	Tip *Tip_direction `xml:"tip,attr,omitempty" json:"tip,omitempty"`

	Parentheses *Yes_no `xml:"parentheses,attr,omitempty" json:"parentheses,omitempty"`

	Dashed_circle *Yes_no `xml:"dashed-circle,attr,omitempty" json:"dashed-circle,omitempty"`
}

type String_mute struct {
	Type *On_off `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Swing struct {
	Swing_style string `xml:"swing-style,omitempty" json:"swing-style,omitempty"`

	Straight *Empty `xml:"straight,omitempty" json:"straight,omitempty"`
}

type Sync struct {
	Type *Sync_type `xml:"type,attr,omitempty" json:"type,omitempty"`

	Latency *Milliseconds `xml:"latency,attr,omitempty" json:"latency,omitempty"`

	Player *IDREF `xml:"player,attr,omitempty" json:"player,omitempty"`

	Time_only *Time_only `xml:"time-only,attr,omitempty" json:"time-only,omitempty"`
}

type Timpani struct {
	Smufl *Smufl_pictogram_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Wedge struct {
	Type *Wedge_type `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`

	Spread *Tenths `xml:"spread,attr,omitempty" json:"spread,omitempty"`

	Niente *Yes_no `xml:"niente,attr,omitempty" json:"niente,omitempty"`
}

type Wood struct {
	Value *Wood_value `xml:",chardata" json:"-,"`

	Smufl *Smufl_pictogram_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Encoding struct {
	Encoding_date *Yyyy_mm_dd `xml:"encoding-date,omitempty" json:"encoding-date,omitempty"`

	Encoder *Typed_text `xml:"encoder,omitempty" json:"encoder,omitempty"`

	Software string `xml:"software,omitempty" json:"software,omitempty"`

	Encoding_description string `xml:"encoding-description,omitempty" json:"encoding-description,omitempty"`

	Supports *Supports `xml:"supports,omitempty" json:"supports,omitempty"`
}

type Identification struct {

	// The creator element is borrowed from Dublin Core. It is used
	// for the creators of the score. The type attribute is used to distinguish
	// different creative contributions. Thus, there can be multiple creators
	// within an identification. Standard type values are composer, lyricist, and
	// arranger. Other type values may be used for different types of creative
	// roles. The type attribute should usually be used even if there is just a
	// single creator element. The MusicXML format does not use the creator /
	// contributor distinction from Dublin Core.
	Creator []*Typed_text `xml:"creator,omitempty" json:"creator,omitempty"`

	// The rights element is borrowed from Dublin Core. It contains
	// copyright and other intellectual property notices. Words, music, and
	// derivatives can have different types, so multiple rights elements with
	// different type attributes are supported. Standard type values are music,
	// words, and arrangement, but other types may be used. The type attribute is
	// only needed when there are multiple rights elements.
	Rights []*Typed_text `xml:"rights,omitempty" json:"rights,omitempty"`

	Encoding *Encoding `xml:"encoding,omitempty" json:"encoding,omitempty"`

	// The source for the music that is encoded. This is similar to
	// the Dublin Core source element.
	Source string `xml:"source,omitempty" json:"source,omitempty"`

	// A related resource for the music that is encoded. This is
	// similar to the Dublin Core relation element. Standard type values are music,
	// words, and arrangement, but other types may be used.
	Relation []*Typed_text `xml:"relation,omitempty" json:"relation,omitempty"`

	Miscellaneous *Miscellaneous `xml:"miscellaneous,omitempty" json:"miscellaneous,omitempty"`
}

type Miscellaneous struct {
	Miscellaneous_field []*Miscellaneous_field `xml:"miscellaneous-field,omitempty" json:"miscellaneous-field,omitempty"`
}

type Miscellaneous_field struct {
	Value string `xml:",chardata" json:"-,"`

	Name string `xml:"name,attr,omitempty" json:"name,omitempty"`
}

type Supports struct {
	Type *Yes_no `xml:"type,attr,omitempty" json:"type,omitempty"`

	Element *NMTOKEN `xml:"element,attr,omitempty" json:"element,omitempty"`

	Attribute *NMTOKEN `xml:"attribute,attr,omitempty" json:"attribute,omitempty"`

	Value string `xml:"value,attr,omitempty" json:"value,omitempty"`
}

type Appearance struct {
	Line_width []*Line_width `xml:"line-width,omitempty" json:"line-width,omitempty"`

	Note_size []*Note_size `xml:"note-size,omitempty" json:"note-size,omitempty"`

	Distance []*Distance `xml:"distance,omitempty" json:"distance,omitempty"`

	Glyph []*Glyph `xml:"glyph,omitempty" json:"glyph,omitempty"`

	Other_appearance []*Other_appearance `xml:"other-appearance,omitempty" json:"other-appearance,omitempty"`
}

type Distance struct {
	Value *Tenths `xml:",chardata" json:"-,"`

	Type *Distance_type `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Glyph struct {
	Value *Smufl_glyph_name `xml:",chardata" json:"-,"`

	Type *Glyph_type `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Line_width struct {
	Value *Tenths `xml:",chardata" json:"-,"`

	Type *Line_width_type `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Measure_layout struct {

	// The measure-distance element specifies the horizontal distance
	// from the previous measure. This value is only used for systems where there
	// is horizontal whitespace in the middle of a system, as in systems with
	// codas. To specify the measure width, use the width attribute of the measure
	// element.
	Measure_distance *Tenths `xml:"measure-distance,omitempty" json:"measure-distance,omitempty"`
}

type Note_size struct {
	Value *Non_negative_decimal `xml:",chardata" json:"-,"`

	Type *Note_size_type `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Other_appearance struct {
	Value string `xml:",chardata" json:"-,"`

	Type string `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Page_layout struct {
	Page_margins *Page_margins `xml:"page-margins,omitempty" json:"page-margins,omitempty"`
}

type Page_margins struct {
	Type *Margin_type `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Scaling struct {
	Millimeters *Millimeters `xml:"millimeters,omitempty" json:"millimeters,omitempty"`

	Tenths *Tenths `xml:"tenths,omitempty" json:"tenths,omitempty"`
}

type Staff_layout struct {
	Staff_distance *Tenths `xml:"staff-distance,omitempty" json:"staff-distance,omitempty"`

	Number *Staff_number `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type System_dividers struct {
	Left_divider *Empty_print_object_style_align `xml:"left-divider,omitempty" json:"left-divider,omitempty"`

	Right_divider *Empty_print_object_style_align `xml:"right-divider,omitempty" json:"right-divider,omitempty"`
}

type System_layout struct {
	System_margins *System_margins `xml:"system-margins,omitempty" json:"system-margins,omitempty"`

	System_distance *Tenths `xml:"system-distance,omitempty" json:"system-distance,omitempty"`

	Top_system_distance *Tenths `xml:"top-system-distance,omitempty" json:"top-system-distance,omitempty"`

	System_dividers *System_dividers `xml:"system-dividers,omitempty" json:"system-dividers,omitempty"`
}

type System_margins struct {
}

type Bookmark struct {
	Id *ID_MUSICXML `xml:"id,attr,omitempty" json:"id,omitempty"`

	Name string `xml:"name,attr,omitempty" json:"name,omitempty"`
}

type Link struct {
	Name string `xml:"name,attr,omitempty" json:"name,omitempty"`
}

type Accidental struct {
	Value *Accidental_value `xml:",chardata" json:"-,"`

	Cautionary *Yes_no `xml:"cautionary,attr,omitempty" json:"cautionary,omitempty"`

	Editorial *Yes_no `xml:"editorial,attr,omitempty" json:"editorial,omitempty"`

	Smufl *Smufl_accidental_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Accidental_mark struct {
	Value *Accidental_value `xml:",chardata" json:"-,"`

	Smufl *Smufl_accidental_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Arpeggiate struct {
	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`

	Direction *Up_down `xml:"direction,attr,omitempty" json:"direction,omitempty"`

	Unbroken *Yes_no `xml:"unbroken,attr,omitempty" json:"unbroken,omitempty"`
}

type Articulations struct {

	// The accent element indicates a regular horizontal accent mark.
	Accent *Empty_placement `xml:"accent,omitempty" json:"accent,omitempty"`

	// The strong-accent element indicates a vertical accent mark.
	Strong_accent *Strong_accent `xml:"strong-accent,omitempty" json:"strong-accent,omitempty"`

	// The staccato element is used for a dot articulation, as
	// opposed to a stroke or a wedge.
	Staccato *Empty_placement `xml:"staccato,omitempty" json:"staccato,omitempty"`

	// The tenuto element indicates a tenuto line symbol.
	Tenuto *Empty_placement `xml:"tenuto,omitempty" json:"tenuto,omitempty"`

	// The detached-legato element indicates the combination of a
	// tenuto line and staccato dot symbol.
	Detached_legato *Empty_placement `xml:"detached-legato,omitempty" json:"detached-legato,omitempty"`

	// The staccatissimo element is used for a wedge articulation, as
	// opposed to a dot or a stroke.
	Staccatissimo *Empty_placement `xml:"staccatissimo,omitempty" json:"staccatissimo,omitempty"`

	// The spiccato element is used for a stroke articulation, as
	// opposed to a dot or a wedge.
	Spiccato *Empty_placement `xml:"spiccato,omitempty" json:"spiccato,omitempty"`

	// The scoop element is an indeterminate slide attached to a
	// single note. The scoop appears before the main note and comes from below the
	// main pitch.
	Scoop *Empty_line `xml:"scoop,omitempty" json:"scoop,omitempty"`

	// The plop element is an indeterminate slide attached to a
	// single note. The plop appears before the main note and comes from above the
	// main pitch.
	Plop *Empty_line `xml:"plop,omitempty" json:"plop,omitempty"`

	// The doit element is an indeterminate slide attached to a
	// single note. The doit appears after the main note and goes above the main
	// pitch.
	Doit *Empty_line `xml:"doit,omitempty" json:"doit,omitempty"`

	// The falloff element is an indeterminate slide attached to a
	// single note. The falloff appears after the main note and goes below the main
	// pitch.
	Falloff *Empty_line `xml:"falloff,omitempty" json:"falloff,omitempty"`

	Breath_mark *Breath_mark `xml:"breath-mark,omitempty" json:"breath-mark,omitempty"`

	Caesura *Caesura `xml:"caesura,omitempty" json:"caesura,omitempty"`

	// The stress element indicates a stressed note.
	Stress *Empty_placement `xml:"stress,omitempty" json:"stress,omitempty"`

	// The unstress element indicates an unstressed note. It is often
	// notated using a u-shaped symbol.
	Unstress *Empty_placement `xml:"unstress,omitempty" json:"unstress,omitempty"`

	// The soft-accent element indicates a soft accent that is not as
	// heavy as a normal accent. It is often notated as <>. It can be
	// combined with other articulations to implement the first eight symbols in
	// the SMuFL Articulation supplement range.
	Soft_accent *Empty_placement `xml:"soft-accent,omitempty" json:"soft-accent,omitempty"`

	// The other-articulation element is used to define any
	// articulations not yet in the MusicXML format. The smufl attribute can be
	// used to specify a particular articulation, allowing application
	// interoperability without requiring every SMuFL articulation to have a
	// MusicXML element equivalent. Using the other-articulation element without
	// the smufl attribute allows for extended representation, though without
	// application interoperability.
	Other_articulation *Other_placement_text `xml:"other-articulation,omitempty" json:"other-articulation,omitempty"`
}

type Arrow struct {
	Circular_arrow *Circular_arrow `xml:"circular-arrow,omitempty" json:"circular-arrow,omitempty"`
}

type Assess struct {
	Type *Yes_no `xml:"type,attr,omitempty" json:"type,omitempty"`

	Player *IDREF `xml:"player,attr,omitempty" json:"player,omitempty"`

	Time_only *Time_only `xml:"time-only,attr,omitempty" json:"time-only,omitempty"`
}

type Backup struct {
}

type Beam struct {
	Value *Beam_value `xml:",chardata" json:"-,"`

	Number *Beam_level `xml:"number,attr,omitempty" json:"number,omitempty"`

	Repeater *Yes_no `xml:"repeater,attr,omitempty" json:"repeater,omitempty"`

	Fan *Fan `xml:"fan,attr,omitempty" json:"fan,omitempty"`
}

type Bend struct {

	// The bend-alter element indicates the number of semitones in
	// the bend, similar to the alter element. As with the alter element, numbers
	// like 0.5 can be used to indicate microtones. Negative values indicate
	// pre-bends or releases. The pre-bend and release elements are used to
	// distinguish what is intended. Because the bend-alter element represents the
	// number of steps in the bend, a release after a bend has a negative
	// bend-alter value, not a zero value.
	Bend_alter *Semitones `xml:"bend-alter,omitempty" json:"bend-alter,omitempty"`

	// The with-bar element indicates that the bend is to be done at
	// the bridge with a whammy or vibrato bar. The content of the element
	// indicates how this should be notated. Content values of "scoop" and "dip"
	// refer to the SMuFL guitarVibratoBarScoop and guitarVibratoBarDip glyphs.
	With_bar *Placement_text `xml:"with-bar,omitempty" json:"with-bar,omitempty"`

	// The pre-bend element indicates that a bend is a pre-bend
	// rather than a normal bend or a release.
	Pre_bend *Empty `xml:"pre-bend,omitempty" json:"pre-bend,omitempty"`

	Release *Release `xml:"release,omitempty" json:"release,omitempty"`

	Shape *Bend_shape `xml:"shape,attr,omitempty" json:"shape,omitempty"`
}

type Breath_mark struct {
	Value *Breath_mark_value `xml:",chardata" json:"-,"`
}

type Caesura struct {
	Value *Caesura_value `xml:",chardata" json:"-,"`
}

type Elision struct {
	Value string `xml:",chardata" json:"-,"`

	Smufl *Smufl_lyrics_glyph_name `xml:"smufl,attr,omitempty" json:"smufl,omitempty"`
}

type Empty_line struct {
}

type Extend struct {
	Type *Start_stop_continue `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Figure struct {

	// Values for the prefix element include plus and the accidental
	// values sharp, flat, natural, double-sharp, flat-flat, and sharp-sharp. The
	// prefix element may contain additional values for symbols specific to
	// particular figured bass styles.
	Prefix *Style_text `xml:"prefix,omitempty" json:"prefix,omitempty"`

	// A figure-number is a number. Overstrikes of the figure number
	// are represented in the suffix element.
	Figure_number *Style_text `xml:"figure-number,omitempty" json:"figure-number,omitempty"`

	// Values for the suffix element include plus and the accidental
	// values sharp, flat, natural, double-sharp, flat-flat, and sharp-sharp.
	// Suffixes include both symbols that come after the figure number and those
	// that overstrike the figure number. The suffix values slash, back-slash, and
	// vertical are used for slashed numbers indicating chromatic alteration. The
	// orientation and display of the slash usually depends on the figure number.
	// The suffix element may contain additional values for symbols specific to
	// particular figured bass styles.
	Suffix *Style_text `xml:"suffix,omitempty" json:"suffix,omitempty"`

	Extend *Extend `xml:"extend,omitempty" json:"extend,omitempty"`
}

type Figured_bass struct {
	Figure []*Figure `xml:"figure,omitempty" json:"figure,omitempty"`

	Parentheses *Yes_no `xml:"parentheses,attr,omitempty" json:"parentheses,omitempty"`
}

type Forward struct {
}

type Glissando struct {
	Value string `xml:",chardata" json:"-,"`

	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Grace struct {
	Steal_time_previous *Percent `xml:"steal-time-previous,attr,omitempty" json:"steal-time-previous,omitempty"`

	Steal_time_following *Percent `xml:"steal-time-following,attr,omitempty" json:"steal-time-following,omitempty"`

	Make_time *Divisions `xml:"make-time,attr,omitempty" json:"make-time,omitempty"`

	Slash *Yes_no `xml:"slash,attr,omitempty" json:"slash,omitempty"`
}

type Hammer_on_pull_off struct {
	Value string `xml:",chardata" json:"-,"`

	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Handbell struct {
	Value *Handbell_value `xml:",chardata" json:"-,"`
}

type Harmon_closed struct {
	Value *Harmon_closed_value `xml:",chardata" json:"-,"`

	Location *Harmon_closed_location `xml:"location,attr,omitempty" json:"location,omitempty"`
}

type Harmon_mute struct {
	Harmon_closed *Harmon_closed `xml:"harmon-closed,omitempty" json:"harmon-closed,omitempty"`
}

type Harmonic struct {

	// The natural element indicates that this is a natural
	// harmonic. These are usually notated at base pitch rather than sounding
	// pitch.
	Natural *Empty `xml:"natural,omitempty" json:"natural,omitempty"`

	// The artificial element indicates that this is an
	// artificial harmonic.
	Artificial *Empty `xml:"artificial,omitempty" json:"artificial,omitempty"`

	// The base pitch is the pitch at which the string is played
	// before touching to create the harmonic.
	Base_pitch *Empty `xml:"base-pitch,omitempty" json:"base-pitch,omitempty"`

	// The touching-pitch is the pitch at which the string is
	// touched lightly to produce the harmonic.
	Touching_pitch *Empty `xml:"touching-pitch,omitempty" json:"touching-pitch,omitempty"`

	// The sounding-pitch is the pitch which is heard when
	// playing the harmonic.
	Sounding_pitch *Empty `xml:"sounding-pitch,omitempty" json:"sounding-pitch,omitempty"`
}

type Heel_toe struct {
	*Empty_placement

	Substitution *Yes_no `xml:"substitution,attr,omitempty" json:"substitution,omitempty"`
}

type Hole struct {

	// The content of the optional hole-type element indicates what
	// the hole symbol represents in terms of instrument fingering or other
	// techniques.
	Hole_type string `xml:"hole-type,omitempty" json:"hole-type,omitempty"`

	Hole_closed *Hole_closed `xml:"hole-closed,omitempty" json:"hole-closed,omitempty"`

	// The optional hole-shape element indicates the shape of the
	// hole symbol; the default is a circle.
	Hole_shape string `xml:"hole-shape,omitempty" json:"hole-shape,omitempty"`
}

type Hole_closed struct {
	Value *Hole_closed_value `xml:",chardata" json:"-,"`

	Location *Hole_closed_location `xml:"location,attr,omitempty" json:"location,omitempty"`
}

type Instrument struct {
	Id *IDREF `xml:"id,attr,omitempty" json:"id,omitempty"`
}

type Listen struct {
	Assess *Assess `xml:"assess,omitempty" json:"assess,omitempty"`

	Wait *Wait `xml:"wait,omitempty" json:"wait,omitempty"`

	Other_listen *Other_listening `xml:"other-listen,omitempty" json:"other-listen,omitempty"`
}

type Lyric struct {

	// The end-line element comes from RP-017 for Standard MIDI File
	// Lyric meta-events. It facilitates lyric display for Karaoke and similar
	// applications.
	End_line *Empty `xml:"end-line,omitempty" json:"end-line,omitempty"`

	// The end-paragraph element comes from RP-017 for Standard MIDI
	// File Lyric meta-events. It facilitates lyric display for Karaoke and similar
	// applications.
	End_paragraph *Empty `xml:"end-paragraph,omitempty" json:"end-paragraph,omitempty"`

	Extend *Extend `xml:"extend,omitempty" json:"extend,omitempty"`

	// The laughing element represents a laughing voice.
	Laughing *Empty `xml:"laughing,omitempty" json:"laughing,omitempty"`

	// The humming element represents a humming voice.
	Humming *Empty `xml:"humming,omitempty" json:"humming,omitempty"`

	Number *NMTOKEN `xml:"number,attr,omitempty" json:"number,omitempty"`

	Name string `xml:"name,attr,omitempty" json:"name,omitempty"`

	Time_only *Time_only `xml:"time-only,attr,omitempty" json:"time-only,omitempty"`
}

type Mordent struct {
	*Empty_trill_sound

	Long *Yes_no `xml:"long,attr,omitempty" json:"long,omitempty"`

	Approach *Above_below `xml:"approach,attr,omitempty" json:"approach,omitempty"`

	Departure *Above_below `xml:"departure,attr,omitempty" json:"departure,omitempty"`
}

type Non_arpeggiate struct {
	Type *Top_bottom `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Notations struct {
	Tied *Tied `xml:"tied,omitempty" json:"tied,omitempty"`

	Slur *Slur `xml:"slur,omitempty" json:"slur,omitempty"`

	Tuplet *Tuplet `xml:"tuplet,omitempty" json:"tuplet,omitempty"`

	Glissando *Glissando `xml:"glissando,omitempty" json:"glissando,omitempty"`

	Slide *Slide `xml:"slide,omitempty" json:"slide,omitempty"`

	Ornaments *Ornaments `xml:"ornaments,omitempty" json:"ornaments,omitempty"`

	Technical *Technical `xml:"technical,omitempty" json:"technical,omitempty"`

	Articulations *Articulations `xml:"articulations,omitempty" json:"articulations,omitempty"`

	Dynamics *Dynamics `xml:"dynamics,omitempty" json:"dynamics,omitempty"`

	Fermata *Fermata `xml:"fermata,omitempty" json:"fermata,omitempty"`

	Arpeggiate *Arpeggiate `xml:"arpeggiate,omitempty" json:"arpeggiate,omitempty"`

	Non_arpeggiate *Non_arpeggiate `xml:"non-arpeggiate,omitempty" json:"non-arpeggiate,omitempty"`

	Accidental_mark *Accidental_mark `xml:"accidental-mark,omitempty" json:"accidental-mark,omitempty"`

	Other_notation *Other_notation `xml:"other-notation,omitempty" json:"other-notation,omitempty"`
}

type Note struct {
	Instrument []*Instrument `xml:"instrument,omitempty" json:"instrument,omitempty"`

	Type_ *Note_type `xml:"type,omitempty" json:"type,omitempty"`

	// One dot element is used for each dot of prolongation. The
	// placement attribute is used to specify whether the dot should appear above
	// or below the staff line. It is ignored for notes that appear on a staff
	// space.
	Dot []*Empty_placement `xml:"dot,omitempty" json:"dot,omitempty"`

	Accidental *Accidental `xml:"accidental,omitempty" json:"accidental,omitempty"`

	Time_modification *Time_modification `xml:"time-modification,omitempty" json:"time-modification,omitempty"`

	Stem *Stem `xml:"stem,omitempty" json:"stem,omitempty"`

	Notehead *Notehead `xml:"notehead,omitempty" json:"notehead,omitempty"`

	Notehead_text *Notehead_text `xml:"notehead-text,omitempty" json:"notehead-text,omitempty"`

	Beam *Beam `xml:"beam,omitempty" json:"beam,omitempty"`

	Notations []*Notations `xml:"notations,omitempty" json:"notations,omitempty"`

	Lyric []*Lyric `xml:"lyric,omitempty" json:"lyric,omitempty"`

	Play *Play `xml:"play,omitempty" json:"play,omitempty"`

	Listen *Listen `xml:"listen,omitempty" json:"listen,omitempty"`

	Print_leger *Yes_no `xml:"print-leger,attr,omitempty" json:"print-leger,omitempty"`

	Dynamics *Non_negative_decimal `xml:"dynamics,attr,omitempty" json:"dynamics,omitempty"`

	End_dynamics *Non_negative_decimal `xml:"end-dynamics,attr,omitempty" json:"end-dynamics,omitempty"`

	Attack *Divisions `xml:"attack,attr,omitempty" json:"attack,omitempty"`

	Release *Divisions `xml:"release,attr,omitempty" json:"release,omitempty"`

	Time_only *Time_only `xml:"time-only,attr,omitempty" json:"time-only,omitempty"`

	Pizzicato *Yes_no `xml:"pizzicato,attr,omitempty" json:"pizzicato,omitempty"`
}

type Note_type struct {
	XMLName xml.Name `xml:" type"`

	Value *Note_type_value `xml:",chardata" json:"-,"`

	Size *Symbol_size `xml:"size,attr,omitempty" json:"size,omitempty"`
}

type Notehead struct {
	Value *Notehead_value `xml:",chardata" json:"-,"`

	Filled *Yes_no `xml:"filled,attr,omitempty" json:"filled,omitempty"`

	Parentheses *Yes_no `xml:"parentheses,attr,omitempty" json:"parentheses,omitempty"`
}

type Notehead_text struct {
	Display_text *Formatted_text `xml:"display-text,omitempty" json:"display-text,omitempty"`

	Accidental_text *Accidental_text `xml:"accidental-text,omitempty" json:"accidental-text,omitempty"`
}

type Ornaments struct {
	Accidental_mark []*Accidental_mark `xml:"accidental-mark,omitempty" json:"accidental-mark,omitempty"`

	// The trill-mark element represents the trill-mark symbol.
	Trill_mark *Empty_trill_sound `xml:"trill-mark,omitempty" json:"trill-mark,omitempty"`

	// The turn element is the normal turn shape which goes up
	// then down.
	Turn *Horizontal_turn `xml:"turn,omitempty" json:"turn,omitempty"`

	// The delayed-turn element indicates a normal turn that is
	// delayed until the end of the current note.
	Delayed_turn *Horizontal_turn `xml:"delayed-turn,omitempty" json:"delayed-turn,omitempty"`

	// The inverted-turn element has the shape which goes down
	// and then up.
	Inverted_turn *Horizontal_turn `xml:"inverted-turn,omitempty" json:"inverted-turn,omitempty"`

	// The delayed-inverted-turn element indicates an inverted
	// turn that is delayed until the end of the current note.
	Delayed_inverted_turn *Horizontal_turn `xml:"delayed-inverted-turn,omitempty" json:"delayed-inverted-turn,omitempty"`

	// The vertical-turn element has the turn symbol shape
	// arranged vertically going from upper left to lower right.
	Vertical_turn *Empty_trill_sound `xml:"vertical-turn,omitempty" json:"vertical-turn,omitempty"`

	// The inverted-vertical-turn element has the turn symbol
	// shape arranged vertically going from upper right to lower left.
	Inverted_vertical_turn *Empty_trill_sound `xml:"inverted-vertical-turn,omitempty" json:"inverted-vertical-turn,omitempty"`

	// The shake element has a similar appearance to an
	// inverted-mordent element.
	Shake *Empty_trill_sound `xml:"shake,omitempty" json:"shake,omitempty"`

	Wavy_line *Wavy_line `xml:"wavy-line,omitempty" json:"wavy-line,omitempty"`

	// The mordent element represents the sign with the vertical
	// line. The choice of which mordent sign is inverted differs between
	// MusicXML and SMuFL. The long attribute is "no" by default.
	Mordent *Mordent `xml:"mordent,omitempty" json:"mordent,omitempty"`

	// The inverted-mordent element represents the sign without
	// the vertical line. The choice of which mordent is inverted differs
	// between MusicXML and SMuFL. The long attribute is "no" by default.
	Inverted_mordent *Mordent `xml:"inverted-mordent,omitempty" json:"inverted-mordent,omitempty"`

	// The name for this ornament is based on the German, to
	// avoid confusion with the more common slide element defined earlier.
	Schleifer *Empty_placement `xml:"schleifer,omitempty" json:"schleifer,omitempty"`

	Tremolo *Tremolo `xml:"tremolo,omitempty" json:"tremolo,omitempty"`

	// The haydn element represents the Haydn ornament. This is
	// defined in SMuFL as ornamentHaydn.
	Haydn *Empty_trill_sound `xml:"haydn,omitempty" json:"haydn,omitempty"`

	// The other-ornament element is used to define any ornaments
	// not yet in the MusicXML format. The smufl attribute can be used to
	// specify a particular ornament, allowing application interoperability
	// without requiring every SMuFL ornament to have a MusicXML element
	// equivalent. Using the other-ornament element without the smufl attribute
	// allows for extended representation, though without application
	// interoperability.
	Other_ornament *Other_placement_text `xml:"other-ornament,omitempty" json:"other-ornament,omitempty"`
}

type Other_notation struct {
	Value string `xml:",chardata" json:"-,"`

	Type *Start_stop_single `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Other_placement_text string

type Other_text string

type Pitch struct {
	Step *Step `xml:"step,omitempty" json:"step,omitempty"`

	Alter *Semitones `xml:"alter,omitempty" json:"alter,omitempty"`

	Octave *Octave `xml:"octave,omitempty" json:"octave,omitempty"`
}

type Placement_text string

type Release struct {
	*Empty

	Offset *Divisions `xml:"offset,attr,omitempty" json:"offset,omitempty"`
}

type Rest struct {
	Measure *Yes_no `xml:"measure,attr,omitempty" json:"measure,omitempty"`
}

type Slide struct {
	Value string `xml:",chardata" json:"-,"`

	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Slur struct {
	Type *Start_stop_continue `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Stem struct {
	Value *Stem_value `xml:",chardata" json:"-,"`
}

type Strong_accent struct {
	*Empty_placement

	Type *Up_down `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Style_text string

type Tap struct {
	Value string `xml:",chardata" json:"-,"`

	Hand *Tap_hand `xml:"hand,attr,omitempty" json:"hand,omitempty"`
}

type Technical struct {

	// The up-bow element represents the symbol that is used both for
	// up-bowing on bowed instruments, and up-stroke on plucked instruments.
	Up_bow *Empty_placement `xml:"up-bow,omitempty" json:"up-bow,omitempty"`

	// The down-bow element represents the symbol that is used both
	// for down-bowing on bowed instruments, and down-stroke on plucked
	// instruments.
	Down_bow *Empty_placement `xml:"down-bow,omitempty" json:"down-bow,omitempty"`

	Harmonic *Harmonic `xml:"harmonic,omitempty" json:"harmonic,omitempty"`

	// The open-string element represents the zero-shaped open string
	// symbol.
	Open_string *Empty_placement `xml:"open-string,omitempty" json:"open-string,omitempty"`

	// The thumb-position element represents the thumb position
	// symbol. This is a circle with a line, where the line does not come within
	// the circle. It is distinct from the snap pizzicato symbol, where the line
	// comes inside the circle.
	Thumb_position *Empty_placement `xml:"thumb-position,omitempty" json:"thumb-position,omitempty"`

	Fingering *Fingering `xml:"fingering,omitempty" json:"fingering,omitempty"`

	// The pluck element is used to specify the plucking fingering on
	// a fretted instrument, where the fingering element refers to the fretting
	// fingering. Typical values are p, i, m, a for pulgar/thumb, indicio/index,
	// medio/middle, and anular/ring fingers.
	Pluck *Placement_text `xml:"pluck,omitempty" json:"pluck,omitempty"`

	// The double-tongue element represents the double tongue symbol
	// (two dots arranged horizontally).
	Double_tongue *Empty_placement `xml:"double-tongue,omitempty" json:"double-tongue,omitempty"`

	// The triple-tongue element represents the triple tongue symbol
	// (three dots arranged horizontally).
	Triple_tongue *Empty_placement `xml:"triple-tongue,omitempty" json:"triple-tongue,omitempty"`

	// The stopped element represents the stopped symbol, which looks
	// like a plus sign. The smufl attribute distinguishes different SMuFL glyphs
	// that have a similar appearance such as handbellsMalletBellSuspended and
	// guitarClosePedal. If not present, the default glyph is brassMuteClosed.
	Stopped *Empty_placement_smufl `xml:"stopped,omitempty" json:"stopped,omitempty"`

	// The snap-pizzicato element represents the snap pizzicato
	// symbol. This is a circle with a line, where the line comes inside the
	// circle. It is distinct from the thumb-position symbol, where the line does
	// not come inside the circle.
	Snap_pizzicato *Empty_placement `xml:"snap-pizzicato,omitempty" json:"snap-pizzicato,omitempty"`

	Fret *Fret `xml:"fret,omitempty" json:"fret,omitempty"`

	Astring string `xml:"string,omitempty" json:"string,omitempty"`

	Hammer_on *Hammer_on_pull_off `xml:"hammer-on,omitempty" json:"hammer-on,omitempty"`

	Pull_off *Hammer_on_pull_off `xml:"pull-off,omitempty" json:"pull-off,omitempty"`

	Bend *Bend `xml:"bend,omitempty" json:"bend,omitempty"`

	Tap *Tap `xml:"tap,omitempty" json:"tap,omitempty"`

	Heel *Heel_toe `xml:"heel,omitempty" json:"heel,omitempty"`

	Toe *Heel_toe `xml:"toe,omitempty" json:"toe,omitempty"`

	// The fingernails element is used in notation for harp and other
	// plucked string instruments.
	Fingernails *Empty_placement `xml:"fingernails,omitempty" json:"fingernails,omitempty"`

	Hole *Hole `xml:"hole,omitempty" json:"hole,omitempty"`

	Arrow *Arrow `xml:"arrow,omitempty" json:"arrow,omitempty"`

	Handbell *Handbell `xml:"handbell,omitempty" json:"handbell,omitempty"`

	// The brass-bend element represents the u-shaped bend symbol
	// used in brass notation, distinct from the bend element used in guitar music.
	Brass_bend *Empty_placement `xml:"brass-bend,omitempty" json:"brass-bend,omitempty"`

	// The flip element represents the flip symbol used in brass
	// notation.
	Flip *Empty_placement `xml:"flip,omitempty" json:"flip,omitempty"`

	// The smear element represents the tilde-shaped smear symbol
	// used in brass notation.
	Smear *Empty_placement `xml:"smear,omitempty" json:"smear,omitempty"`

	// The open element represents the open symbol, which looks like
	// a circle. The smufl attribute can be used to distinguish different SMuFL
	// glyphs that have a similar appearance such as brassMuteOpen and
	// guitarOpenPedal. If not present, the default glyph is brassMuteOpen.
	Open *Empty_placement_smufl `xml:"open,omitempty" json:"open,omitempty"`

	// The half-muted element represents the half-muted symbol, which
	// looks like a circle with a plus sign inside. The smufl attribute can be used
	// to distinguish different SMuFL glyphs that have a similar appearance such as
	// brassMuteHalfClosed and guitarHalfOpenPedal. If not present, the default
	// glyph is brassMuteHalfClosed.
	Half_muted *Empty_placement_smufl `xml:"half-muted,omitempty" json:"half-muted,omitempty"`

	Harmon_mute *Harmon_mute `xml:"harmon-mute,omitempty" json:"harmon-mute,omitempty"`

	// The golpe element represents the golpe symbol that is used for
	// tapping the pick guard in guitar music.
	Golpe *Empty_placement `xml:"golpe,omitempty" json:"golpe,omitempty"`

	// The other-technical element is used to define any technical
	// indications not yet in the MusicXML format. The smufl attribute can be used
	// to specify a particular glyph, allowing application interoperability without
	// requiring every SMuFL technical indication to have a MusicXML element
	// equivalent. Using the other-technical element without the smufl attribute
	// allows for extended representation, though without application
	// interoperability.
	Other_technical *Other_placement_text `xml:"other-technical,omitempty" json:"other-technical,omitempty"`
}

type Text_element_data struct {
	Value string `xml:",chardata" json:"-,"`

	EmptyString string `xml:",attr,omitempty" json:",omitempty"`
}

type Tie struct {
	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`

	Time_only *Time_only `xml:"time-only,attr,omitempty" json:"time-only,omitempty"`
}

type Tied struct {
	Type *Tied_type `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Time_modification struct {

	// The actual-notes element describes how many notes are played
	// in the time usually occupied by the number in the normal-notes element.
	Actual_notes uint32 `xml:"actual-notes,omitempty" json:"actual-notes,omitempty"`

	// The normal-notes element describes how many notes are usually
	// played in the time occupied by the number in the actual-notes element.
	Normal_notes uint32 `xml:"normal-notes,omitempty" json:"normal-notes,omitempty"`
}

type Tremolo struct {
	Value *Tremolo_marks `xml:",chardata" json:"-,"`

	Type *Tremolo_type `xml:"type,attr,omitempty" json:"type,omitempty"`
}

type Tuplet struct {

	// The tuplet-actual element provide optional full control over
	// how the actual part of the tuplet is displayed, including number and note
	// type (with dots). If any of these elements are absent, their values are
	// based on the time-modification element.
	Tuplet_actual *Tuplet_portion `xml:"tuplet-actual,omitempty" json:"tuplet-actual,omitempty"`

	// The tuplet-normal element provide optional full control over
	// how the normal part of the tuplet is displayed, including number and note
	// type (with dots). If any of these elements are absent, their values are
	// based on the time-modification element.
	Tuplet_normal *Tuplet_portion `xml:"tuplet-normal,omitempty" json:"tuplet-normal,omitempty"`

	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number *Number_level `xml:"number,attr,omitempty" json:"number,omitempty"`

	Bracket *Yes_no `xml:"bracket,attr,omitempty" json:"bracket,omitempty"`

	Show_number *Show_tuplet `xml:"show-number,attr,omitempty" json:"show-number,omitempty"`

	Show_type *Show_tuplet `xml:"show-type,attr,omitempty" json:"show-type,omitempty"`
}

type Tuplet_dot struct {
}

type Tuplet_number struct {
	Value uint32 `xml:",chardata" json:"-,"`
}

type Tuplet_portion struct {
	Tuplet_number *Tuplet_number `xml:"tuplet-number,omitempty" json:"tuplet-number,omitempty"`

	Tuplet_type *Tuplet_type `xml:"tuplet-type,omitempty" json:"tuplet-type,omitempty"`

	Tuplet_dot []*Tuplet_dot `xml:"tuplet-dot,omitempty" json:"tuplet-dot,omitempty"`
}

type Tuplet_type struct {
	Value *Note_type_value `xml:",chardata" json:"-,"`
}

type Unpitched struct {
}

type Wait struct {
	Player *IDREF `xml:"player,attr,omitempty" json:"player,omitempty"`

	Time_only *Time_only `xml:"time-only,attr,omitempty" json:"time-only,omitempty"`
}

type Credit struct {
	Credit_type []string `xml:"credit-type,omitempty" json:"credit-type,omitempty"`

	Link []*Link `xml:"link,omitempty" json:"link,omitempty"`

	Bookmark []*Bookmark `xml:"bookmark,omitempty" json:"bookmark,omitempty"`

	Credit_image *Image `xml:"credit-image,omitempty" json:"credit-image,omitempty"`

	Page *PositiveInteger `xml:"page,attr,omitempty" json:"page,omitempty"`
}

type Defaults struct {
	Scaling *Scaling `xml:"scaling,omitempty" json:"scaling,omitempty"`

	// The presence of a concert-score element indicates that a score
	// is displayed in concert pitch. It is used for scores that contain parts for
	// transposing instruments. A document with a concert-score element may not
	// contain any transpose elements that have non-zero values for either the
	// diatonic or chromatic elements. Concert scores may include octave
	// transpositions, so transpose elements with a double element or a non-zero
	// octave-change element value are permitted.
	Concert_score *Empty `xml:"concert-score,omitempty" json:"concert-score,omitempty"`

	Appearance *Appearance `xml:"appearance,omitempty" json:"appearance,omitempty"`

	Music_font *Empty_font `xml:"music-font,omitempty" json:"music-font,omitempty"`

	Word_font *Empty_font `xml:"word-font,omitempty" json:"word-font,omitempty"`

	Lyric_font []*Lyric_font `xml:"lyric-font,omitempty" json:"lyric-font,omitempty"`

	Lyric_language []*Lyric_language `xml:"lyric-language,omitempty" json:"lyric-language,omitempty"`
}

type Empty_font struct {
}

type Group_barline struct {
	Value *Group_barline_value `xml:",chardata" json:"-,"`
}

type Group_name string

type Group_symbol struct {
	Value *Group_symbol_value `xml:",chardata" json:"-,"`
}

type Instrument_link struct {
	Id *IDREF `xml:"id,attr,omitempty" json:"id,omitempty"`
}

type Lyric_font struct {
	Number *NMTOKEN `xml:"number,attr,omitempty" json:"number,omitempty"`

	Name string `xml:"name,attr,omitempty" json:"name,omitempty"`
}

type Lyric_language struct {
	Number *NMTOKEN `xml:"number,attr,omitempty" json:"number,omitempty"`

	Name string `xml:"name,attr,omitempty" json:"name,omitempty"`

	EmptyString string `xml:",attr,omitempty" json:",omitempty"`
}

type Opus struct {
}

type Part_group struct {
	Group_name *Group_name `xml:"group-name,omitempty" json:"group-name,omitempty"`

	// Formatting specified in the group-name-display element
	// overrides formatting specified in the group-name element.
	Group_name_display *Name_display `xml:"group-name-display,omitempty" json:"group-name-display,omitempty"`

	Group_abbreviation *Group_name `xml:"group-abbreviation,omitempty" json:"group-abbreviation,omitempty"`

	// Formatting specified in the group-abbreviation-display element
	// overrides formatting specified in the group-abbreviation element.
	Group_abbreviation_display *Name_display `xml:"group-abbreviation-display,omitempty" json:"group-abbreviation-display,omitempty"`

	Group_symbol *Group_symbol `xml:"group-symbol,omitempty" json:"group-symbol,omitempty"`

	Group_barline *Group_barline `xml:"group-barline,omitempty" json:"group-barline,omitempty"`

	// The group-time element indicates that the displayed time
	// signatures should stretch across all parts and staves in the group.
	Group_time *Empty `xml:"group-time,omitempty" json:"group-time,omitempty"`

	Type *Start_stop `xml:"type,attr,omitempty" json:"type,omitempty"`

	Number string `xml:"number,attr,omitempty" json:"number,omitempty"`
}

type Part_link struct {
	Instrument_link []*Instrument_link `xml:"instrument-link,omitempty" json:"instrument-link,omitempty"`

	// Multiple part-link elements can reference different types of
	// linked documents, such as parts and condensed score. The optional group-link
	// elements identify the groups used in the linked document. The content of a
	// group-link element should match the content of a group element in the linked
	// document.
	Group_link []string `xml:"group-link,omitempty" json:"group-link,omitempty"`
}

type Part_list struct {
}

type Part_name string

type Player struct {

	// The player-name element is typically used within a software
	// application, rather than appearing on the printed page of a score.
	Player_name string `xml:"player-name,omitempty" json:"player-name,omitempty"`

	Id *ID_MUSICXML `xml:"id,attr,omitempty" json:"id,omitempty"`
}

type Score_instrument struct {

	// The instrument-name element is typically used within a
	// software application, rather than appearing on the printed page of a score.
	Instrument_name string `xml:"instrument-name,omitempty" json:"instrument-name,omitempty"`

	// The optional instrument-abbreviation element is typically used
	// within a software application, rather than appearing on the printed page of
	// a score.
	Instrument_abbreviation string `xml:"instrument-abbreviation,omitempty" json:"instrument-abbreviation,omitempty"`

	Id *ID_MUSICXML `xml:"id,attr,omitempty" json:"id,omitempty"`
}

type Score_part struct {
	Identification *Identification `xml:"identification,omitempty" json:"identification,omitempty"`

	Part_link []*Part_link `xml:"part-link,omitempty" json:"part-link,omitempty"`

	Part_name *Part_name `xml:"part-name,omitempty" json:"part-name,omitempty"`

	Part_name_display *Name_display `xml:"part-name-display,omitempty" json:"part-name-display,omitempty"`

	Part_abbreviation *Part_name `xml:"part-abbreviation,omitempty" json:"part-abbreviation,omitempty"`

	Part_abbreviation_display *Name_display `xml:"part-abbreviation-display,omitempty" json:"part-abbreviation-display,omitempty"`

	// The group element allows the use of different versions of the
	// part for different purposes. Typical values include score, parts, sound, and
	// data. Ordering information can be derived from the ordering within a
	// MusicXML score or opus.
	Group []string `xml:"group,omitempty" json:"group,omitempty"`

	Score_instrument []*Score_instrument `xml:"score-instrument,omitempty" json:"score-instrument,omitempty"`

	Player []*Player `xml:"player,omitempty" json:"player,omitempty"`

	Id *ID_MUSICXML `xml:"id,attr,omitempty" json:"id,omitempty"`
}

type Virtual_instrument struct {

	// The virtual-library element indicates the virtual instrument
	// library name.
	Virtual_library string `xml:"virtual-library,omitempty" json:"virtual-library,omitempty"`

	// The virtual-name element indicates the library-specific name
	// for the virtual instrument.
	Virtual_name string `xml:"virtual-name,omitempty" json:"virtual-name,omitempty"`
}

type Work struct {

	// The work-number element specifies the number of a work, such
	// as its opus number.
	Work_number string `xml:"work-number,omitempty" json:"work-number,omitempty"`

	// The work-title element specifies the title of a work, not
	// including its opus or other work number.
	Work_title string `xml:"work-title,omitempty" json:"work-title,omitempty"`

	Opus *Opus `xml:"opus,omitempty" json:"opus,omitempty"`
}
