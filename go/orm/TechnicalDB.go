// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongmusicxml/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Technical_sql sql.NullBool
var dummy_Technical_time time.Duration
var dummy_Technical_sort sort.Float64Slice

// TechnicalAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model technicalAPI
type TechnicalAPI struct {
	gorm.Model

	models.Technical_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	TechnicalPointersEncoding TechnicalPointersEncoding
}

// TechnicalPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type TechnicalPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field Up_bow is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Up_bowID sql.NullInt64

	// field Down_bow is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Down_bowID sql.NullInt64

	// field Harmonic is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	HarmonicID sql.NullInt64

	// field Open_string is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Open_stringID sql.NullInt64

	// field Thumb_position is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Thumb_positionID sql.NullInt64

	// field Fingering is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	FingeringID sql.NullInt64

	// field Double_tongue is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Double_tongueID sql.NullInt64

	// field Triple_tongue is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Triple_tongueID sql.NullInt64

	// field Stopped is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	StoppedID sql.NullInt64

	// field Snap_pizzicato is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Snap_pizzicatoID sql.NullInt64

	// field Fret is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	FretID sql.NullInt64

	// field Hammer_on is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Hammer_onID sql.NullInt64

	// field Pull_off is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Pull_offID sql.NullInt64

	// field Bend is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	BendID sql.NullInt64

	// field Tap is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	TapID sql.NullInt64

	// field Heel is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	HeelID sql.NullInt64

	// field Toe is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	ToeID sql.NullInt64

	// field Fingernails is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	FingernailsID sql.NullInt64

	// field Hole is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	HoleID sql.NullInt64

	// field Arrow is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	ArrowID sql.NullInt64

	// field Handbell is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	HandbellID sql.NullInt64

	// field Brass_bend is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Brass_bendID sql.NullInt64

	// field Flip is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	FlipID sql.NullInt64

	// field Smear is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	SmearID sql.NullInt64

	// field Open is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	OpenID sql.NullInt64

	// field Half_muted is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Half_mutedID sql.NullInt64

	// field Harmon_mute is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	Harmon_muteID sql.NullInt64

	// field Golpe is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	GolpeID sql.NullInt64
}

// TechnicalDB describes a technical in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model technicalDB
type TechnicalDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field technicalDB.Name
	Name_Data sql.NullString

	// Declation for basic field technicalDB.Astring
	Astring_Data sql.NullString
	
	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	TechnicalPointersEncoding
}

// TechnicalDBs arrays technicalDBs
// swagger:response technicalDBsResponse
type TechnicalDBs []TechnicalDB

// TechnicalDBResponse provides response
// swagger:response technicalDBResponse
type TechnicalDBResponse struct {
	TechnicalDB
}

// TechnicalWOP is a Technical without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type TechnicalWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`

	Astring string `xlsx:"2"`
	// insertion for WOP pointer fields
}

var Technical_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
	"Astring",
}

type BackRepoTechnicalStruct struct {
	// stores TechnicalDB according to their gorm ID
	Map_TechnicalDBID_TechnicalDB map[uint]*TechnicalDB

	// stores TechnicalDB ID according to Technical address
	Map_TechnicalPtr_TechnicalDBID map[*models.Technical]uint

	// stores Technical according to their gorm ID
	Map_TechnicalDBID_TechnicalPtr map[uint]*models.Technical

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoTechnical *BackRepoTechnicalStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoTechnical.stage
	return
}

func (backRepoTechnical *BackRepoTechnicalStruct) GetDB() *gorm.DB {
	return backRepoTechnical.db
}

// GetTechnicalDBFromTechnicalPtr is a handy function to access the back repo instance from the stage instance
func (backRepoTechnical *BackRepoTechnicalStruct) GetTechnicalDBFromTechnicalPtr(technical *models.Technical) (technicalDB *TechnicalDB) {
	id := backRepoTechnical.Map_TechnicalPtr_TechnicalDBID[technical]
	technicalDB = backRepoTechnical.Map_TechnicalDBID_TechnicalDB[id]
	return
}

// BackRepoTechnical.CommitPhaseOne commits all staged instances of Technical to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoTechnical *BackRepoTechnicalStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for technical := range stage.Technicals {
		backRepoTechnical.CommitPhaseOneInstance(technical)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, technical := range backRepoTechnical.Map_TechnicalDBID_TechnicalPtr {
		if _, ok := stage.Technicals[technical]; !ok {
			backRepoTechnical.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoTechnical.CommitDeleteInstance commits deletion of Technical to the BackRepo
func (backRepoTechnical *BackRepoTechnicalStruct) CommitDeleteInstance(id uint) (Error error) {

	technical := backRepoTechnical.Map_TechnicalDBID_TechnicalPtr[id]

	// technical is not staged anymore, remove technicalDB
	technicalDB := backRepoTechnical.Map_TechnicalDBID_TechnicalDB[id]
	query := backRepoTechnical.db.Unscoped().Delete(&technicalDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	delete(backRepoTechnical.Map_TechnicalPtr_TechnicalDBID, technical)
	delete(backRepoTechnical.Map_TechnicalDBID_TechnicalPtr, id)
	delete(backRepoTechnical.Map_TechnicalDBID_TechnicalDB, id)

	return
}

// BackRepoTechnical.CommitPhaseOneInstance commits technical staged instances of Technical to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoTechnical *BackRepoTechnicalStruct) CommitPhaseOneInstance(technical *models.Technical) (Error error) {

	// check if the technical is not commited yet
	if _, ok := backRepoTechnical.Map_TechnicalPtr_TechnicalDBID[technical]; ok {
		return
	}

	// initiate technical
	var technicalDB TechnicalDB
	technicalDB.CopyBasicFieldsFromTechnical(technical)

	query := backRepoTechnical.db.Create(&technicalDB)
	if query.Error != nil {
		log.Fatal(query.Error)
	}

	// update stores
	backRepoTechnical.Map_TechnicalPtr_TechnicalDBID[technical] = technicalDB.ID
	backRepoTechnical.Map_TechnicalDBID_TechnicalPtr[technicalDB.ID] = technical
	backRepoTechnical.Map_TechnicalDBID_TechnicalDB[technicalDB.ID] = &technicalDB

	return
}

// BackRepoTechnical.CommitPhaseTwo commits all staged instances of Technical to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoTechnical *BackRepoTechnicalStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, technical := range backRepoTechnical.Map_TechnicalDBID_TechnicalPtr {
		backRepoTechnical.CommitPhaseTwoInstance(backRepo, idx, technical)
	}

	return
}

// BackRepoTechnical.CommitPhaseTwoInstance commits {{structname }} of models.Technical to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoTechnical *BackRepoTechnicalStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, technical *models.Technical) (Error error) {

	// fetch matching technicalDB
	if technicalDB, ok := backRepoTechnical.Map_TechnicalDBID_TechnicalDB[idx]; ok {

		technicalDB.CopyBasicFieldsFromTechnical(technical)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value technical.Up_bow translates to updating the technical.Up_bowID
		technicalDB.Up_bowID.Valid = true // allow for a 0 value (nil association)
		if technical.Up_bow != nil {
			if Up_bowId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Up_bow]; ok {
				technicalDB.Up_bowID.Int64 = int64(Up_bowId)
				technicalDB.Up_bowID.Valid = true
			}
		} else {
			technicalDB.Up_bowID.Int64 = 0
			technicalDB.Up_bowID.Valid = true
		}

		// commit pointer value technical.Down_bow translates to updating the technical.Down_bowID
		technicalDB.Down_bowID.Valid = true // allow for a 0 value (nil association)
		if technical.Down_bow != nil {
			if Down_bowId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Down_bow]; ok {
				technicalDB.Down_bowID.Int64 = int64(Down_bowId)
				technicalDB.Down_bowID.Valid = true
			}
		} else {
			technicalDB.Down_bowID.Int64 = 0
			technicalDB.Down_bowID.Valid = true
		}

		// commit pointer value technical.Harmonic translates to updating the technical.HarmonicID
		technicalDB.HarmonicID.Valid = true // allow for a 0 value (nil association)
		if technical.Harmonic != nil {
			if HarmonicId, ok := backRepo.BackRepoHarmonic.Map_HarmonicPtr_HarmonicDBID[technical.Harmonic]; ok {
				technicalDB.HarmonicID.Int64 = int64(HarmonicId)
				technicalDB.HarmonicID.Valid = true
			}
		} else {
			technicalDB.HarmonicID.Int64 = 0
			technicalDB.HarmonicID.Valid = true
		}

		// commit pointer value technical.Open_string translates to updating the technical.Open_stringID
		technicalDB.Open_stringID.Valid = true // allow for a 0 value (nil association)
		if technical.Open_string != nil {
			if Open_stringId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Open_string]; ok {
				technicalDB.Open_stringID.Int64 = int64(Open_stringId)
				technicalDB.Open_stringID.Valid = true
			}
		} else {
			technicalDB.Open_stringID.Int64 = 0
			technicalDB.Open_stringID.Valid = true
		}

		// commit pointer value technical.Thumb_position translates to updating the technical.Thumb_positionID
		technicalDB.Thumb_positionID.Valid = true // allow for a 0 value (nil association)
		if technical.Thumb_position != nil {
			if Thumb_positionId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Thumb_position]; ok {
				technicalDB.Thumb_positionID.Int64 = int64(Thumb_positionId)
				technicalDB.Thumb_positionID.Valid = true
			}
		} else {
			technicalDB.Thumb_positionID.Int64 = 0
			technicalDB.Thumb_positionID.Valid = true
		}

		// commit pointer value technical.Fingering translates to updating the technical.FingeringID
		technicalDB.FingeringID.Valid = true // allow for a 0 value (nil association)
		if technical.Fingering != nil {
			if FingeringId, ok := backRepo.BackRepoFingering.Map_FingeringPtr_FingeringDBID[technical.Fingering]; ok {
				technicalDB.FingeringID.Int64 = int64(FingeringId)
				technicalDB.FingeringID.Valid = true
			}
		} else {
			technicalDB.FingeringID.Int64 = 0
			technicalDB.FingeringID.Valid = true
		}

		// commit pointer value technical.Double_tongue translates to updating the technical.Double_tongueID
		technicalDB.Double_tongueID.Valid = true // allow for a 0 value (nil association)
		if technical.Double_tongue != nil {
			if Double_tongueId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Double_tongue]; ok {
				technicalDB.Double_tongueID.Int64 = int64(Double_tongueId)
				technicalDB.Double_tongueID.Valid = true
			}
		} else {
			technicalDB.Double_tongueID.Int64 = 0
			technicalDB.Double_tongueID.Valid = true
		}

		// commit pointer value technical.Triple_tongue translates to updating the technical.Triple_tongueID
		technicalDB.Triple_tongueID.Valid = true // allow for a 0 value (nil association)
		if technical.Triple_tongue != nil {
			if Triple_tongueId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Triple_tongue]; ok {
				technicalDB.Triple_tongueID.Int64 = int64(Triple_tongueId)
				technicalDB.Triple_tongueID.Valid = true
			}
		} else {
			technicalDB.Triple_tongueID.Int64 = 0
			technicalDB.Triple_tongueID.Valid = true
		}

		// commit pointer value technical.Stopped translates to updating the technical.StoppedID
		technicalDB.StoppedID.Valid = true // allow for a 0 value (nil association)
		if technical.Stopped != nil {
			if StoppedId, ok := backRepo.BackRepoEmpty_placement_smufl.Map_Empty_placement_smuflPtr_Empty_placement_smuflDBID[technical.Stopped]; ok {
				technicalDB.StoppedID.Int64 = int64(StoppedId)
				technicalDB.StoppedID.Valid = true
			}
		} else {
			technicalDB.StoppedID.Int64 = 0
			technicalDB.StoppedID.Valid = true
		}

		// commit pointer value technical.Snap_pizzicato translates to updating the technical.Snap_pizzicatoID
		technicalDB.Snap_pizzicatoID.Valid = true // allow for a 0 value (nil association)
		if technical.Snap_pizzicato != nil {
			if Snap_pizzicatoId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Snap_pizzicato]; ok {
				technicalDB.Snap_pizzicatoID.Int64 = int64(Snap_pizzicatoId)
				technicalDB.Snap_pizzicatoID.Valid = true
			}
		} else {
			technicalDB.Snap_pizzicatoID.Int64 = 0
			technicalDB.Snap_pizzicatoID.Valid = true
		}

		// commit pointer value technical.Fret translates to updating the technical.FretID
		technicalDB.FretID.Valid = true // allow for a 0 value (nil association)
		if technical.Fret != nil {
			if FretId, ok := backRepo.BackRepoFret.Map_FretPtr_FretDBID[technical.Fret]; ok {
				technicalDB.FretID.Int64 = int64(FretId)
				technicalDB.FretID.Valid = true
			}
		} else {
			technicalDB.FretID.Int64 = 0
			technicalDB.FretID.Valid = true
		}

		// commit pointer value technical.Hammer_on translates to updating the technical.Hammer_onID
		technicalDB.Hammer_onID.Valid = true // allow for a 0 value (nil association)
		if technical.Hammer_on != nil {
			if Hammer_onId, ok := backRepo.BackRepoHammer_on_pull_off.Map_Hammer_on_pull_offPtr_Hammer_on_pull_offDBID[technical.Hammer_on]; ok {
				technicalDB.Hammer_onID.Int64 = int64(Hammer_onId)
				technicalDB.Hammer_onID.Valid = true
			}
		} else {
			technicalDB.Hammer_onID.Int64 = 0
			technicalDB.Hammer_onID.Valid = true
		}

		// commit pointer value technical.Pull_off translates to updating the technical.Pull_offID
		technicalDB.Pull_offID.Valid = true // allow for a 0 value (nil association)
		if technical.Pull_off != nil {
			if Pull_offId, ok := backRepo.BackRepoHammer_on_pull_off.Map_Hammer_on_pull_offPtr_Hammer_on_pull_offDBID[technical.Pull_off]; ok {
				technicalDB.Pull_offID.Int64 = int64(Pull_offId)
				technicalDB.Pull_offID.Valid = true
			}
		} else {
			technicalDB.Pull_offID.Int64 = 0
			technicalDB.Pull_offID.Valid = true
		}

		// commit pointer value technical.Bend translates to updating the technical.BendID
		technicalDB.BendID.Valid = true // allow for a 0 value (nil association)
		if technical.Bend != nil {
			if BendId, ok := backRepo.BackRepoBend.Map_BendPtr_BendDBID[technical.Bend]; ok {
				technicalDB.BendID.Int64 = int64(BendId)
				technicalDB.BendID.Valid = true
			}
		} else {
			technicalDB.BendID.Int64 = 0
			technicalDB.BendID.Valid = true
		}

		// commit pointer value technical.Tap translates to updating the technical.TapID
		technicalDB.TapID.Valid = true // allow for a 0 value (nil association)
		if technical.Tap != nil {
			if TapId, ok := backRepo.BackRepoTap.Map_TapPtr_TapDBID[technical.Tap]; ok {
				technicalDB.TapID.Int64 = int64(TapId)
				technicalDB.TapID.Valid = true
			}
		} else {
			technicalDB.TapID.Int64 = 0
			technicalDB.TapID.Valid = true
		}

		// commit pointer value technical.Heel translates to updating the technical.HeelID
		technicalDB.HeelID.Valid = true // allow for a 0 value (nil association)
		if technical.Heel != nil {
			if HeelId, ok := backRepo.BackRepoHeel_toe.Map_Heel_toePtr_Heel_toeDBID[technical.Heel]; ok {
				technicalDB.HeelID.Int64 = int64(HeelId)
				technicalDB.HeelID.Valid = true
			}
		} else {
			technicalDB.HeelID.Int64 = 0
			technicalDB.HeelID.Valid = true
		}

		// commit pointer value technical.Toe translates to updating the technical.ToeID
		technicalDB.ToeID.Valid = true // allow for a 0 value (nil association)
		if technical.Toe != nil {
			if ToeId, ok := backRepo.BackRepoHeel_toe.Map_Heel_toePtr_Heel_toeDBID[technical.Toe]; ok {
				technicalDB.ToeID.Int64 = int64(ToeId)
				technicalDB.ToeID.Valid = true
			}
		} else {
			technicalDB.ToeID.Int64 = 0
			technicalDB.ToeID.Valid = true
		}

		// commit pointer value technical.Fingernails translates to updating the technical.FingernailsID
		technicalDB.FingernailsID.Valid = true // allow for a 0 value (nil association)
		if technical.Fingernails != nil {
			if FingernailsId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Fingernails]; ok {
				technicalDB.FingernailsID.Int64 = int64(FingernailsId)
				technicalDB.FingernailsID.Valid = true
			}
		} else {
			technicalDB.FingernailsID.Int64 = 0
			technicalDB.FingernailsID.Valid = true
		}

		// commit pointer value technical.Hole translates to updating the technical.HoleID
		technicalDB.HoleID.Valid = true // allow for a 0 value (nil association)
		if technical.Hole != nil {
			if HoleId, ok := backRepo.BackRepoHole.Map_HolePtr_HoleDBID[technical.Hole]; ok {
				technicalDB.HoleID.Int64 = int64(HoleId)
				technicalDB.HoleID.Valid = true
			}
		} else {
			technicalDB.HoleID.Int64 = 0
			technicalDB.HoleID.Valid = true
		}

		// commit pointer value technical.Arrow translates to updating the technical.ArrowID
		technicalDB.ArrowID.Valid = true // allow for a 0 value (nil association)
		if technical.Arrow != nil {
			if ArrowId, ok := backRepo.BackRepoArrow.Map_ArrowPtr_ArrowDBID[technical.Arrow]; ok {
				technicalDB.ArrowID.Int64 = int64(ArrowId)
				technicalDB.ArrowID.Valid = true
			}
		} else {
			technicalDB.ArrowID.Int64 = 0
			technicalDB.ArrowID.Valid = true
		}

		// commit pointer value technical.Handbell translates to updating the technical.HandbellID
		technicalDB.HandbellID.Valid = true // allow for a 0 value (nil association)
		if technical.Handbell != nil {
			if HandbellId, ok := backRepo.BackRepoHandbell.Map_HandbellPtr_HandbellDBID[technical.Handbell]; ok {
				technicalDB.HandbellID.Int64 = int64(HandbellId)
				technicalDB.HandbellID.Valid = true
			}
		} else {
			technicalDB.HandbellID.Int64 = 0
			technicalDB.HandbellID.Valid = true
		}

		// commit pointer value technical.Brass_bend translates to updating the technical.Brass_bendID
		technicalDB.Brass_bendID.Valid = true // allow for a 0 value (nil association)
		if technical.Brass_bend != nil {
			if Brass_bendId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Brass_bend]; ok {
				technicalDB.Brass_bendID.Int64 = int64(Brass_bendId)
				technicalDB.Brass_bendID.Valid = true
			}
		} else {
			technicalDB.Brass_bendID.Int64 = 0
			technicalDB.Brass_bendID.Valid = true
		}

		// commit pointer value technical.Flip translates to updating the technical.FlipID
		technicalDB.FlipID.Valid = true // allow for a 0 value (nil association)
		if technical.Flip != nil {
			if FlipId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Flip]; ok {
				technicalDB.FlipID.Int64 = int64(FlipId)
				technicalDB.FlipID.Valid = true
			}
		} else {
			technicalDB.FlipID.Int64 = 0
			technicalDB.FlipID.Valid = true
		}

		// commit pointer value technical.Smear translates to updating the technical.SmearID
		technicalDB.SmearID.Valid = true // allow for a 0 value (nil association)
		if technical.Smear != nil {
			if SmearId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Smear]; ok {
				technicalDB.SmearID.Int64 = int64(SmearId)
				technicalDB.SmearID.Valid = true
			}
		} else {
			technicalDB.SmearID.Int64 = 0
			technicalDB.SmearID.Valid = true
		}

		// commit pointer value technical.Open translates to updating the technical.OpenID
		technicalDB.OpenID.Valid = true // allow for a 0 value (nil association)
		if technical.Open != nil {
			if OpenId, ok := backRepo.BackRepoEmpty_placement_smufl.Map_Empty_placement_smuflPtr_Empty_placement_smuflDBID[technical.Open]; ok {
				technicalDB.OpenID.Int64 = int64(OpenId)
				technicalDB.OpenID.Valid = true
			}
		} else {
			technicalDB.OpenID.Int64 = 0
			technicalDB.OpenID.Valid = true
		}

		// commit pointer value technical.Half_muted translates to updating the technical.Half_mutedID
		technicalDB.Half_mutedID.Valid = true // allow for a 0 value (nil association)
		if technical.Half_muted != nil {
			if Half_mutedId, ok := backRepo.BackRepoEmpty_placement_smufl.Map_Empty_placement_smuflPtr_Empty_placement_smuflDBID[technical.Half_muted]; ok {
				technicalDB.Half_mutedID.Int64 = int64(Half_mutedId)
				technicalDB.Half_mutedID.Valid = true
			}
		} else {
			technicalDB.Half_mutedID.Int64 = 0
			technicalDB.Half_mutedID.Valid = true
		}

		// commit pointer value technical.Harmon_mute translates to updating the technical.Harmon_muteID
		technicalDB.Harmon_muteID.Valid = true // allow for a 0 value (nil association)
		if technical.Harmon_mute != nil {
			if Harmon_muteId, ok := backRepo.BackRepoHarmon_mute.Map_Harmon_mutePtr_Harmon_muteDBID[technical.Harmon_mute]; ok {
				technicalDB.Harmon_muteID.Int64 = int64(Harmon_muteId)
				technicalDB.Harmon_muteID.Valid = true
			}
		} else {
			technicalDB.Harmon_muteID.Int64 = 0
			technicalDB.Harmon_muteID.Valid = true
		}

		// commit pointer value technical.Golpe translates to updating the technical.GolpeID
		technicalDB.GolpeID.Valid = true // allow for a 0 value (nil association)
		if technical.Golpe != nil {
			if GolpeId, ok := backRepo.BackRepoEmpty_placement.Map_Empty_placementPtr_Empty_placementDBID[technical.Golpe]; ok {
				technicalDB.GolpeID.Int64 = int64(GolpeId)
				technicalDB.GolpeID.Valid = true
			}
		} else {
			technicalDB.GolpeID.Int64 = 0
			technicalDB.GolpeID.Valid = true
		}

		query := backRepoTechnical.db.Save(&technicalDB)
		if query.Error != nil {
			log.Fatalln(query.Error)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Technical intance %s", technical.Name))
		return err
	}

	return
}

// BackRepoTechnical.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoTechnical *BackRepoTechnicalStruct) CheckoutPhaseOne() (Error error) {

	technicalDBArray := make([]TechnicalDB, 0)
	query := backRepoTechnical.db.Find(&technicalDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	technicalInstancesToBeRemovedFromTheStage := make(map[*models.Technical]any)
	for key, value := range backRepoTechnical.stage.Technicals {
		technicalInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, technicalDB := range technicalDBArray {
		backRepoTechnical.CheckoutPhaseOneInstance(&technicalDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		technical, ok := backRepoTechnical.Map_TechnicalDBID_TechnicalPtr[technicalDB.ID]
		if ok {
			delete(technicalInstancesToBeRemovedFromTheStage, technical)
		}
	}

	// remove from stage and back repo's 3 maps all technicals that are not in the checkout
	for technical := range technicalInstancesToBeRemovedFromTheStage {
		technical.Unstage(backRepoTechnical.GetStage())

		// remove instance from the back repo 3 maps
		technicalID := backRepoTechnical.Map_TechnicalPtr_TechnicalDBID[technical]
		delete(backRepoTechnical.Map_TechnicalPtr_TechnicalDBID, technical)
		delete(backRepoTechnical.Map_TechnicalDBID_TechnicalDB, technicalID)
		delete(backRepoTechnical.Map_TechnicalDBID_TechnicalPtr, technicalID)
	}

	return
}

// CheckoutPhaseOneInstance takes a technicalDB that has been found in the DB, updates the backRepo and stages the
// models version of the technicalDB
func (backRepoTechnical *BackRepoTechnicalStruct) CheckoutPhaseOneInstance(technicalDB *TechnicalDB) (Error error) {

	technical, ok := backRepoTechnical.Map_TechnicalDBID_TechnicalPtr[technicalDB.ID]
	if !ok {
		technical = new(models.Technical)

		backRepoTechnical.Map_TechnicalDBID_TechnicalPtr[technicalDB.ID] = technical
		backRepoTechnical.Map_TechnicalPtr_TechnicalDBID[technical] = technicalDB.ID

		// append model store with the new element
		technical.Name = technicalDB.Name_Data.String
		technical.Stage(backRepoTechnical.GetStage())
	}
	technicalDB.CopyBasicFieldsToTechnical(technical)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	technical.Stage(backRepoTechnical.GetStage())

	// preserve pointer to technicalDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_TechnicalDBID_TechnicalDB)[technicalDB hold variable pointers
	technicalDB_Data := *technicalDB
	preservedPtrToTechnical := &technicalDB_Data
	backRepoTechnical.Map_TechnicalDBID_TechnicalDB[technicalDB.ID] = preservedPtrToTechnical

	return
}

// BackRepoTechnical.CheckoutPhaseTwo Checkouts all staged instances of Technical to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoTechnical *BackRepoTechnicalStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, technicalDB := range backRepoTechnical.Map_TechnicalDBID_TechnicalDB {
		backRepoTechnical.CheckoutPhaseTwoInstance(backRepo, technicalDB)
	}
	return
}

// BackRepoTechnical.CheckoutPhaseTwoInstance Checkouts staged instances of Technical to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoTechnical *BackRepoTechnicalStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, technicalDB *TechnicalDB) (Error error) {

	technical := backRepoTechnical.Map_TechnicalDBID_TechnicalPtr[technicalDB.ID]

	technicalDB.DecodePointers(backRepo, technical)

	return
}

func (technicalDB *TechnicalDB) DecodePointers(backRepo *BackRepoStruct, technical *models.Technical) {

	// insertion point for checkout of pointer encoding
	// Up_bow field
	technical.Up_bow = nil
	if technicalDB.Up_bowID.Int64 != 0 {
		technical.Up_bow = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.Up_bowID.Int64)]
	}
	// Down_bow field
	technical.Down_bow = nil
	if technicalDB.Down_bowID.Int64 != 0 {
		technical.Down_bow = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.Down_bowID.Int64)]
	}
	// Harmonic field
	technical.Harmonic = nil
	if technicalDB.HarmonicID.Int64 != 0 {
		technical.Harmonic = backRepo.BackRepoHarmonic.Map_HarmonicDBID_HarmonicPtr[uint(technicalDB.HarmonicID.Int64)]
	}
	// Open_string field
	technical.Open_string = nil
	if technicalDB.Open_stringID.Int64 != 0 {
		technical.Open_string = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.Open_stringID.Int64)]
	}
	// Thumb_position field
	technical.Thumb_position = nil
	if technicalDB.Thumb_positionID.Int64 != 0 {
		technical.Thumb_position = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.Thumb_positionID.Int64)]
	}
	// Fingering field
	technical.Fingering = nil
	if technicalDB.FingeringID.Int64 != 0 {
		technical.Fingering = backRepo.BackRepoFingering.Map_FingeringDBID_FingeringPtr[uint(technicalDB.FingeringID.Int64)]
	}
	// Double_tongue field
	technical.Double_tongue = nil
	if technicalDB.Double_tongueID.Int64 != 0 {
		technical.Double_tongue = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.Double_tongueID.Int64)]
	}
	// Triple_tongue field
	technical.Triple_tongue = nil
	if technicalDB.Triple_tongueID.Int64 != 0 {
		technical.Triple_tongue = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.Triple_tongueID.Int64)]
	}
	// Stopped field
	technical.Stopped = nil
	if technicalDB.StoppedID.Int64 != 0 {
		technical.Stopped = backRepo.BackRepoEmpty_placement_smufl.Map_Empty_placement_smuflDBID_Empty_placement_smuflPtr[uint(technicalDB.StoppedID.Int64)]
	}
	// Snap_pizzicato field
	technical.Snap_pizzicato = nil
	if technicalDB.Snap_pizzicatoID.Int64 != 0 {
		technical.Snap_pizzicato = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.Snap_pizzicatoID.Int64)]
	}
	// Fret field
	technical.Fret = nil
	if technicalDB.FretID.Int64 != 0 {
		technical.Fret = backRepo.BackRepoFret.Map_FretDBID_FretPtr[uint(technicalDB.FretID.Int64)]
	}
	// Hammer_on field
	technical.Hammer_on = nil
	if technicalDB.Hammer_onID.Int64 != 0 {
		technical.Hammer_on = backRepo.BackRepoHammer_on_pull_off.Map_Hammer_on_pull_offDBID_Hammer_on_pull_offPtr[uint(technicalDB.Hammer_onID.Int64)]
	}
	// Pull_off field
	technical.Pull_off = nil
	if technicalDB.Pull_offID.Int64 != 0 {
		technical.Pull_off = backRepo.BackRepoHammer_on_pull_off.Map_Hammer_on_pull_offDBID_Hammer_on_pull_offPtr[uint(technicalDB.Pull_offID.Int64)]
	}
	// Bend field
	technical.Bend = nil
	if technicalDB.BendID.Int64 != 0 {
		technical.Bend = backRepo.BackRepoBend.Map_BendDBID_BendPtr[uint(technicalDB.BendID.Int64)]
	}
	// Tap field
	technical.Tap = nil
	if technicalDB.TapID.Int64 != 0 {
		technical.Tap = backRepo.BackRepoTap.Map_TapDBID_TapPtr[uint(technicalDB.TapID.Int64)]
	}
	// Heel field
	technical.Heel = nil
	if technicalDB.HeelID.Int64 != 0 {
		technical.Heel = backRepo.BackRepoHeel_toe.Map_Heel_toeDBID_Heel_toePtr[uint(technicalDB.HeelID.Int64)]
	}
	// Toe field
	technical.Toe = nil
	if technicalDB.ToeID.Int64 != 0 {
		technical.Toe = backRepo.BackRepoHeel_toe.Map_Heel_toeDBID_Heel_toePtr[uint(technicalDB.ToeID.Int64)]
	}
	// Fingernails field
	technical.Fingernails = nil
	if technicalDB.FingernailsID.Int64 != 0 {
		technical.Fingernails = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.FingernailsID.Int64)]
	}
	// Hole field
	technical.Hole = nil
	if technicalDB.HoleID.Int64 != 0 {
		technical.Hole = backRepo.BackRepoHole.Map_HoleDBID_HolePtr[uint(technicalDB.HoleID.Int64)]
	}
	// Arrow field
	technical.Arrow = nil
	if technicalDB.ArrowID.Int64 != 0 {
		technical.Arrow = backRepo.BackRepoArrow.Map_ArrowDBID_ArrowPtr[uint(technicalDB.ArrowID.Int64)]
	}
	// Handbell field
	technical.Handbell = nil
	if technicalDB.HandbellID.Int64 != 0 {
		technical.Handbell = backRepo.BackRepoHandbell.Map_HandbellDBID_HandbellPtr[uint(technicalDB.HandbellID.Int64)]
	}
	// Brass_bend field
	technical.Brass_bend = nil
	if technicalDB.Brass_bendID.Int64 != 0 {
		technical.Brass_bend = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.Brass_bendID.Int64)]
	}
	// Flip field
	technical.Flip = nil
	if technicalDB.FlipID.Int64 != 0 {
		technical.Flip = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.FlipID.Int64)]
	}
	// Smear field
	technical.Smear = nil
	if technicalDB.SmearID.Int64 != 0 {
		technical.Smear = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.SmearID.Int64)]
	}
	// Open field
	technical.Open = nil
	if technicalDB.OpenID.Int64 != 0 {
		technical.Open = backRepo.BackRepoEmpty_placement_smufl.Map_Empty_placement_smuflDBID_Empty_placement_smuflPtr[uint(technicalDB.OpenID.Int64)]
	}
	// Half_muted field
	technical.Half_muted = nil
	if technicalDB.Half_mutedID.Int64 != 0 {
		technical.Half_muted = backRepo.BackRepoEmpty_placement_smufl.Map_Empty_placement_smuflDBID_Empty_placement_smuflPtr[uint(technicalDB.Half_mutedID.Int64)]
	}
	// Harmon_mute field
	technical.Harmon_mute = nil
	if technicalDB.Harmon_muteID.Int64 != 0 {
		technical.Harmon_mute = backRepo.BackRepoHarmon_mute.Map_Harmon_muteDBID_Harmon_mutePtr[uint(technicalDB.Harmon_muteID.Int64)]
	}
	// Golpe field
	technical.Golpe = nil
	if technicalDB.GolpeID.Int64 != 0 {
		technical.Golpe = backRepo.BackRepoEmpty_placement.Map_Empty_placementDBID_Empty_placementPtr[uint(technicalDB.GolpeID.Int64)]
	}
	return
}

// CommitTechnical allows commit of a single technical (if already staged)
func (backRepo *BackRepoStruct) CommitTechnical(technical *models.Technical) {
	backRepo.BackRepoTechnical.CommitPhaseOneInstance(technical)
	if id, ok := backRepo.BackRepoTechnical.Map_TechnicalPtr_TechnicalDBID[technical]; ok {
		backRepo.BackRepoTechnical.CommitPhaseTwoInstance(backRepo, id, technical)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitTechnical allows checkout of a single technical (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutTechnical(technical *models.Technical) {
	// check if the technical is staged
	if _, ok := backRepo.BackRepoTechnical.Map_TechnicalPtr_TechnicalDBID[technical]; ok {

		if id, ok := backRepo.BackRepoTechnical.Map_TechnicalPtr_TechnicalDBID[technical]; ok {
			var technicalDB TechnicalDB
			technicalDB.ID = id

			if err := backRepo.BackRepoTechnical.db.First(&technicalDB, id).Error; err != nil {
				log.Fatalln("CheckoutTechnical : Problem with getting object with id:", id)
			}
			backRepo.BackRepoTechnical.CheckoutPhaseOneInstance(&technicalDB)
			backRepo.BackRepoTechnical.CheckoutPhaseTwoInstance(backRepo, &technicalDB)
		}
	}
}

// CopyBasicFieldsFromTechnical
func (technicalDB *TechnicalDB) CopyBasicFieldsFromTechnical(technical *models.Technical) {
	// insertion point for fields commit

	technicalDB.Name_Data.String = technical.Name
	technicalDB.Name_Data.Valid = true

	technicalDB.Astring_Data.String = technical.Astring
	technicalDB.Astring_Data.Valid = true
}

// CopyBasicFieldsFromTechnical_WOP
func (technicalDB *TechnicalDB) CopyBasicFieldsFromTechnical_WOP(technical *models.Technical_WOP) {
	// insertion point for fields commit

	technicalDB.Name_Data.String = technical.Name
	technicalDB.Name_Data.Valid = true

	technicalDB.Astring_Data.String = technical.Astring
	technicalDB.Astring_Data.Valid = true
}

// CopyBasicFieldsFromTechnicalWOP
func (technicalDB *TechnicalDB) CopyBasicFieldsFromTechnicalWOP(technical *TechnicalWOP) {
	// insertion point for fields commit

	technicalDB.Name_Data.String = technical.Name
	technicalDB.Name_Data.Valid = true

	technicalDB.Astring_Data.String = technical.Astring
	technicalDB.Astring_Data.Valid = true
}

// CopyBasicFieldsToTechnical
func (technicalDB *TechnicalDB) CopyBasicFieldsToTechnical(technical *models.Technical) {
	// insertion point for checkout of basic fields (back repo to stage)
	technical.Name = technicalDB.Name_Data.String
	technical.Astring = technicalDB.Astring_Data.String
}

// CopyBasicFieldsToTechnical_WOP
func (technicalDB *TechnicalDB) CopyBasicFieldsToTechnical_WOP(technical *models.Technical_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	technical.Name = technicalDB.Name_Data.String
	technical.Astring = technicalDB.Astring_Data.String
}

// CopyBasicFieldsToTechnicalWOP
func (technicalDB *TechnicalDB) CopyBasicFieldsToTechnicalWOP(technical *TechnicalWOP) {
	technical.ID = int(technicalDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	technical.Name = technicalDB.Name_Data.String
	technical.Astring = technicalDB.Astring_Data.String
}

// Backup generates a json file from a slice of all TechnicalDB instances in the backrepo
func (backRepoTechnical *BackRepoTechnicalStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "TechnicalDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*TechnicalDB, 0)
	for _, technicalDB := range backRepoTechnical.Map_TechnicalDBID_TechnicalDB {
		forBackup = append(forBackup, technicalDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json Technical ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json Technical file", err.Error())
	}
}

// Backup generates a json file from a slice of all TechnicalDB instances in the backrepo
func (backRepoTechnical *BackRepoTechnicalStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*TechnicalDB, 0)
	for _, technicalDB := range backRepoTechnical.Map_TechnicalDBID_TechnicalDB {
		forBackup = append(forBackup, technicalDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("Technical")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&Technical_Fields, -1)
	for _, technicalDB := range forBackup {

		var technicalWOP TechnicalWOP
		technicalDB.CopyBasicFieldsToTechnicalWOP(&technicalWOP)

		row := sh.AddRow()
		row.WriteStruct(&technicalWOP, -1)
	}
}

// RestoreXL from the "Technical" sheet all TechnicalDB instances
func (backRepoTechnical *BackRepoTechnicalStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoTechnicalid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["Technical"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoTechnical.rowVisitorTechnical)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoTechnical *BackRepoTechnicalStruct) rowVisitorTechnical(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var technicalWOP TechnicalWOP
		row.ReadStruct(&technicalWOP)

		// add the unmarshalled struct to the stage
		technicalDB := new(TechnicalDB)
		technicalDB.CopyBasicFieldsFromTechnicalWOP(&technicalWOP)

		technicalDB_ID_atBackupTime := technicalDB.ID
		technicalDB.ID = 0
		query := backRepoTechnical.db.Create(technicalDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoTechnical.Map_TechnicalDBID_TechnicalDB[technicalDB.ID] = technicalDB
		BackRepoTechnicalid_atBckpTime_newID[technicalDB_ID_atBackupTime] = technicalDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "TechnicalDB.json" in dirPath that stores an array
// of TechnicalDB and stores it in the database
// the map BackRepoTechnicalid_atBckpTime_newID is updated accordingly
func (backRepoTechnical *BackRepoTechnicalStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoTechnicalid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "TechnicalDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json Technical file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*TechnicalDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_TechnicalDBID_TechnicalDB
	for _, technicalDB := range forRestore {

		technicalDB_ID_atBackupTime := technicalDB.ID
		technicalDB.ID = 0
		query := backRepoTechnical.db.Create(technicalDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
		backRepoTechnical.Map_TechnicalDBID_TechnicalDB[technicalDB.ID] = technicalDB
		BackRepoTechnicalid_atBckpTime_newID[technicalDB_ID_atBackupTime] = technicalDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json Technical file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Technical>id_atBckpTime_newID
// to compute new index
func (backRepoTechnical *BackRepoTechnicalStruct) RestorePhaseTwo() {

	for _, technicalDB := range backRepoTechnical.Map_TechnicalDBID_TechnicalDB {

		// next line of code is to avert unused variable compilation error
		_ = technicalDB

		// insertion point for reindexing pointers encoding
		// reindexing Up_bow field
		if technicalDB.Up_bowID.Int64 != 0 {
			technicalDB.Up_bowID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.Up_bowID.Int64)])
			technicalDB.Up_bowID.Valid = true
		}

		// reindexing Down_bow field
		if technicalDB.Down_bowID.Int64 != 0 {
			technicalDB.Down_bowID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.Down_bowID.Int64)])
			technicalDB.Down_bowID.Valid = true
		}

		// reindexing Harmonic field
		if technicalDB.HarmonicID.Int64 != 0 {
			technicalDB.HarmonicID.Int64 = int64(BackRepoHarmonicid_atBckpTime_newID[uint(technicalDB.HarmonicID.Int64)])
			technicalDB.HarmonicID.Valid = true
		}

		// reindexing Open_string field
		if technicalDB.Open_stringID.Int64 != 0 {
			technicalDB.Open_stringID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.Open_stringID.Int64)])
			technicalDB.Open_stringID.Valid = true
		}

		// reindexing Thumb_position field
		if technicalDB.Thumb_positionID.Int64 != 0 {
			technicalDB.Thumb_positionID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.Thumb_positionID.Int64)])
			technicalDB.Thumb_positionID.Valid = true
		}

		// reindexing Fingering field
		if technicalDB.FingeringID.Int64 != 0 {
			technicalDB.FingeringID.Int64 = int64(BackRepoFingeringid_atBckpTime_newID[uint(technicalDB.FingeringID.Int64)])
			technicalDB.FingeringID.Valid = true
		}

		// reindexing Double_tongue field
		if technicalDB.Double_tongueID.Int64 != 0 {
			technicalDB.Double_tongueID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.Double_tongueID.Int64)])
			technicalDB.Double_tongueID.Valid = true
		}

		// reindexing Triple_tongue field
		if technicalDB.Triple_tongueID.Int64 != 0 {
			technicalDB.Triple_tongueID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.Triple_tongueID.Int64)])
			technicalDB.Triple_tongueID.Valid = true
		}

		// reindexing Stopped field
		if technicalDB.StoppedID.Int64 != 0 {
			technicalDB.StoppedID.Int64 = int64(BackRepoEmpty_placement_smuflid_atBckpTime_newID[uint(technicalDB.StoppedID.Int64)])
			technicalDB.StoppedID.Valid = true
		}

		// reindexing Snap_pizzicato field
		if technicalDB.Snap_pizzicatoID.Int64 != 0 {
			technicalDB.Snap_pizzicatoID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.Snap_pizzicatoID.Int64)])
			technicalDB.Snap_pizzicatoID.Valid = true
		}

		// reindexing Fret field
		if technicalDB.FretID.Int64 != 0 {
			technicalDB.FretID.Int64 = int64(BackRepoFretid_atBckpTime_newID[uint(technicalDB.FretID.Int64)])
			technicalDB.FretID.Valid = true
		}

		// reindexing Hammer_on field
		if technicalDB.Hammer_onID.Int64 != 0 {
			technicalDB.Hammer_onID.Int64 = int64(BackRepoHammer_on_pull_offid_atBckpTime_newID[uint(technicalDB.Hammer_onID.Int64)])
			technicalDB.Hammer_onID.Valid = true
		}

		// reindexing Pull_off field
		if technicalDB.Pull_offID.Int64 != 0 {
			technicalDB.Pull_offID.Int64 = int64(BackRepoHammer_on_pull_offid_atBckpTime_newID[uint(technicalDB.Pull_offID.Int64)])
			technicalDB.Pull_offID.Valid = true
		}

		// reindexing Bend field
		if technicalDB.BendID.Int64 != 0 {
			technicalDB.BendID.Int64 = int64(BackRepoBendid_atBckpTime_newID[uint(technicalDB.BendID.Int64)])
			technicalDB.BendID.Valid = true
		}

		// reindexing Tap field
		if technicalDB.TapID.Int64 != 0 {
			technicalDB.TapID.Int64 = int64(BackRepoTapid_atBckpTime_newID[uint(technicalDB.TapID.Int64)])
			technicalDB.TapID.Valid = true
		}

		// reindexing Heel field
		if technicalDB.HeelID.Int64 != 0 {
			technicalDB.HeelID.Int64 = int64(BackRepoHeel_toeid_atBckpTime_newID[uint(technicalDB.HeelID.Int64)])
			technicalDB.HeelID.Valid = true
		}

		// reindexing Toe field
		if technicalDB.ToeID.Int64 != 0 {
			technicalDB.ToeID.Int64 = int64(BackRepoHeel_toeid_atBckpTime_newID[uint(technicalDB.ToeID.Int64)])
			technicalDB.ToeID.Valid = true
		}

		// reindexing Fingernails field
		if technicalDB.FingernailsID.Int64 != 0 {
			technicalDB.FingernailsID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.FingernailsID.Int64)])
			technicalDB.FingernailsID.Valid = true
		}

		// reindexing Hole field
		if technicalDB.HoleID.Int64 != 0 {
			technicalDB.HoleID.Int64 = int64(BackRepoHoleid_atBckpTime_newID[uint(technicalDB.HoleID.Int64)])
			technicalDB.HoleID.Valid = true
		}

		// reindexing Arrow field
		if technicalDB.ArrowID.Int64 != 0 {
			technicalDB.ArrowID.Int64 = int64(BackRepoArrowid_atBckpTime_newID[uint(technicalDB.ArrowID.Int64)])
			technicalDB.ArrowID.Valid = true
		}

		// reindexing Handbell field
		if technicalDB.HandbellID.Int64 != 0 {
			technicalDB.HandbellID.Int64 = int64(BackRepoHandbellid_atBckpTime_newID[uint(technicalDB.HandbellID.Int64)])
			technicalDB.HandbellID.Valid = true
		}

		// reindexing Brass_bend field
		if technicalDB.Brass_bendID.Int64 != 0 {
			technicalDB.Brass_bendID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.Brass_bendID.Int64)])
			technicalDB.Brass_bendID.Valid = true
		}

		// reindexing Flip field
		if technicalDB.FlipID.Int64 != 0 {
			technicalDB.FlipID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.FlipID.Int64)])
			technicalDB.FlipID.Valid = true
		}

		// reindexing Smear field
		if technicalDB.SmearID.Int64 != 0 {
			technicalDB.SmearID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.SmearID.Int64)])
			technicalDB.SmearID.Valid = true
		}

		// reindexing Open field
		if technicalDB.OpenID.Int64 != 0 {
			technicalDB.OpenID.Int64 = int64(BackRepoEmpty_placement_smuflid_atBckpTime_newID[uint(technicalDB.OpenID.Int64)])
			technicalDB.OpenID.Valid = true
		}

		// reindexing Half_muted field
		if technicalDB.Half_mutedID.Int64 != 0 {
			technicalDB.Half_mutedID.Int64 = int64(BackRepoEmpty_placement_smuflid_atBckpTime_newID[uint(technicalDB.Half_mutedID.Int64)])
			technicalDB.Half_mutedID.Valid = true
		}

		// reindexing Harmon_mute field
		if technicalDB.Harmon_muteID.Int64 != 0 {
			technicalDB.Harmon_muteID.Int64 = int64(BackRepoHarmon_muteid_atBckpTime_newID[uint(technicalDB.Harmon_muteID.Int64)])
			technicalDB.Harmon_muteID.Valid = true
		}

		// reindexing Golpe field
		if technicalDB.GolpeID.Int64 != 0 {
			technicalDB.GolpeID.Int64 = int64(BackRepoEmpty_placementid_atBckpTime_newID[uint(technicalDB.GolpeID.Int64)])
			technicalDB.GolpeID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoTechnical.db.Model(technicalDB).Updates(*technicalDB)
		if query.Error != nil {
			log.Fatal(query.Error)
		}
	}

}

// BackRepoTechnical.ResetReversePointers commits all staged instances of Technical to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoTechnical *BackRepoTechnicalStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, technical := range backRepoTechnical.Map_TechnicalDBID_TechnicalPtr {
		backRepoTechnical.ResetReversePointersInstance(backRepo, idx, technical)
	}

	return
}

func (backRepoTechnical *BackRepoTechnicalStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, technical *models.Technical) (Error error) {

	// fetch matching technicalDB
	if technicalDB, ok := backRepoTechnical.Map_TechnicalDBID_TechnicalDB[idx]; ok {
		_ = technicalDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoTechnicalid_atBckpTime_newID map[uint]uint
